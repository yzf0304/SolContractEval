{
    "contract_name": "BasicToken",
    "ground_truth": "contract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    uint256 totalSupply_;\n\n    /**\n    * @dev total number of tokens in exsitence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function msgSender() \n        public\n        view\n        returns (address)\n    {\n        return msg.sender;\n    }\n\n    function transfer(\n        address _to, \n        uint256 _value\n    ) \n        public \n        returns (bool) \n    {\n        require(_to != address(0));\n        require(_to != msg.sender);\n        require(_value <= balances[msg.sender]);\n        \n        _preValidateTransfer(msg.sender, _to, _value);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function _preValidateTransfer(\n        address _from, \n        address _to, \n        uint256 _value\n    ) \n        internal \n    {\n\n    }\n}",
    "function_sum": 5,
    "compiler_version": "0.4.25",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\n\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n// You task is to complete the smart contract BasicToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.25, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title BasicToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `ERC20` functions.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    uint256 totalSupply_;\n\n    /**\n     * @notice Returns the total token supply.\n     * @dev This function returns the total number of tokens in existence.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n    }\n\n    /**\n     * @notice Returns the address of the message sender.\n     * @dev This function is a utility function that returns the address of the message sender.\n     * @return The address of the message sender.\n     */\n    function msgSender() \n        public\n        view\n        returns (address)\n    {\n    }\n\n    /**\n     * @notice Transfers a specified amount of tokens from the message sender to a specified recipient.\n     * @dev This function transfers tokens from the message sender to a specified recipient. It ensures\n     * that the recipient is not the zero address, the recipient is not the sender, and the sender has\n     * sufficient balance. It also calls `_preValidateTransfer` for additional validation before\n     * updating the balances and emitting the `Transfer` event.\n     * @param _to The address of the recipient.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean value indicating whether the transfer was successful.\n     */\n    function transfer(\n        address _to, \n        uint256 _value\n    ) \n        public \n        returns (bool) \n    {}\n\n    /**\n     * @notice Returns the token balance of a specified address.\n     * @dev This function returns the token balance of a specified address.\n     * @param _owner The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {}\n\n    /**\n     * @dev Internal function to perform pre-validation before a transfer.\n     * @param _from The address of the token sender.\n     * @param _to The address of the token recipient.\n     * @param _value The amount of tokens to transfer.\n     */\n    function _preValidateTransfer(\n        address _from, \n        address _to, \n        uint256 _value\n    ) \n        internal \n    {}\n}\n"
}