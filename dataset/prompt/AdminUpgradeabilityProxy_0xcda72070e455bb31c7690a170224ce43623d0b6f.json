{
    "contract_name": "UpgradeabilityProxy",
    "ground_truth": "contract UpgradeabilityProxy is Proxy {\n\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n\n  event Upgraded(address indexed implementation);\n\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}",
    "function_sum": 3,
    "compiler_version": "0.6.8",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary Address {\n\n    function isContract(address account) internal view returns (bool) {\n\n        uint256 size;\n\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n\n            if (returndata.length > 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\nabstract contract Proxy {\n\n  fallback () payable external {\n    _fallback();\n  }\n\n  receive () payable external {\n    _fallback();\n  }\n\n  function _implementation() internal virtual view returns (address);\n\n  function _delegate(address implementation) internal {\n    assembly {\n\n      calldatacopy(0, 0, calldatasize())\n\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  function _willFallback() internal virtual {\n  }\n\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n\n\n\n// You task is to complete the smart contract UpgradeabilityProxy strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.6.8, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract serves as an upgradeable proxy, allowing the logic implementation of a contract to be updated.\n * @dev The contract uses the EIP-1967 standard for storing the implementation address. It provides functions to set and upgrade the implementation.\n */\ncontract UpgradeabilityProxy is Proxy {\n\n  /**\n   * @notice Initializes the proxy with an initial implementation and optionally calls a function on the implementation.\n   * @dev The constructor sets the initial implementation and, if provided, forwards the `_data` to the implementation.\n   * @param _logic The address of the initial implementation.\n   * @param _data Data to be passed to the initial implementation after it is set.\n   */\n  constructor(address _logic, bytes memory _data) public payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }  \n\n  /**\n   * @notice Emitted when the implementation is upgraded.\n   * @dev This event logs the new implementation address.\n   * @param implementation The address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @notice Internal constant for the storage slot used to store the implementation address.\n   * @dev This slot is used in the EIP-1967 standard for storing the implementation address.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @notice Returns the current implementation address.\n   * @dev This function reads the implementation address from the storage slot.\n   * @return impl The address of the current implementation.\n   */\n  function _implementation() internal override view returns (address impl) {\n  }\n\n  /**\n   * @notice Upgrades the implementation to a new address.\n   * @dev This function sets the new implementation and emits the `Upgraded` event.\n   * @param newImplementation The address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n  }\n\n  /**\n   * @notice Sets the implementation to a new address.\n   * @dev This function ensures the new implementation is a contract and updates the storage slot.\n   * @param newImplementation The address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n  }\n\n  /**\n   * @notice Fallback function to receive Ether.\n   * @dev This function allows the contract to receive Ether.\n   */\n  receive() external payable {}\n}\n"
}