{
    "contract_name": "ERC721A",
    "ground_truth": "contract ERC721A is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 private currentIndex = 0;\n\n    uint256 internal immutable collectionSize;\n    uint256 internal immutable maxBatchSize;\n    string private _name;\n    string private _symbol;\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) private _ownerships;\n    mapping(address => AddressData) private _addressData;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 maxBatchSize_,\n        uint256 collectionSize_\n    ) {\n        require(\n            collectionSize_ > 0,\n            \"ERC721A: collection must have a nonzero supply\"\n        );\n        require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n        _name = name_;\n        _symbol = symbol_;\n        maxBatchSize = maxBatchSize_;\n        collectionSize = collectionSize_;\n    }\n    function totalSupply() public view override returns (uint256) {\n        return currentIndex;\n    }\n    function tokenByIndex(uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(index < totalSupply(), \"ERC721A: global index out of bounds\");\n        return index;\n    }\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\n        uint256 numMintedSoFar = totalSupply();\n        uint256 tokenIdsIdx = 0;\n        address currOwnershipAddr = address(0);\n        for (uint256 i = 0; i < numMintedSoFar; i++) {\n            TokenOwnership memory ownership = _ownerships[i];\n            if (ownership.addr != address(0)) {\n                currOwnershipAddr = ownership.addr;\n            }\n            if (currOwnershipAddr == owner) {\n                if (tokenIdsIdx == index) {\n                    return i;\n                }\n                tokenIdsIdx++;\n            }\n        }\n        revert(\"ERC721A: unable to get token of owner by index\");\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721A: balance query for the zero address\"\n        );\n        return uint256(_addressData[owner].balance);\n    }\n\n    function _numberMinted(address owner) internal view returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721A: number minted query for the zero address\"\n        );\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    function ownershipOf(uint256 tokenId)\n        internal\n        view\n        returns (TokenOwnership memory)\n    {\n        require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\n\n        uint256 lowestTokenToCheck;\n        if (tokenId >= maxBatchSize) {\n            lowestTokenToCheck = tokenId - maxBatchSize + 1;\n        }\n\n        for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\n            TokenOwnership memory ownership = _ownerships[curr];\n            if (ownership.addr != address(0)) {\n                return ownership;\n            }\n        }\n\n        revert(\"ERC721A: unable to determine the owner of token\");\n    }\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n                : \"\";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        require(to != owner, \"ERC721A: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721A: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId, owner);\n    }\n    function getApproved(uint256 tokenId)\n        public\n        view\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721A: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override\n    {\n        require(operator != _msgSender(), \"ERC721A: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        _transfer(from, to, tokenId);\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721A: transfer to non ERC721Receiver implementer\"\n        );\n    }\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenId < currentIndex;\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        uint256 startTokenId = currentIndex;\n        require(to != address(0), \"ERC721A: mint to the zero address\");\n        require(!_exists(startTokenId), \"ERC721A: token already minted\");\n        require(quantity <= maxBatchSize, \"ERC721A: quantity to mint too high\");\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        AddressData memory addressData = _addressData[to];\n        _addressData[to] = AddressData(\n            addressData.balance + uint128(quantity),\n            addressData.numberMinted + uint128(quantity)\n        );\n        _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\n\n        uint256 updatedIndex = startTokenId;\n\n        for (uint256 i = 0; i < quantity; i++) {\n            emit Transfer(address(0), to, updatedIndex);\n            require(\n                _checkOnERC721Received(address(0), to, updatedIndex, _data),\n                \"ERC721A: transfer to non ERC721Receiver implementer\"\n            );\n            updatedIndex++;\n        }\n\n        currentIndex = updatedIndex;\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n            getApproved(tokenId) == _msgSender() ||\n            isApprovedForAll(prevOwnership.addr, _msgSender()));\n\n        require(\n            isApprovedOrOwner,\n            \"ERC721A: transfer caller is not owner nor approved\"\n        );\n\n        require(\n            prevOwnership.addr == from,\n            \"ERC721A: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721A: transfer to the zero address\");\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n        _approve(address(0), tokenId, prevOwnership.addr);\n\n        _addressData[from].balance -= 1;\n        _addressData[to].balance += 1;\n        _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));\n        // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n        uint256 nextTokenId = tokenId + 1;\n        if (_ownerships[nextTokenId].addr == address(0)) {\n            if (_exists(nextTokenId)) {\n                _ownerships[nextTokenId] = TokenOwnership(\n                    prevOwnership.addr,\n                    prevOwnership.startTimestamp\n                );\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    uint256 public nextOwnerToExplicitlySet = 0;\n    function _setOwnersExplicit(uint256 quantity) internal {\n        uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;\n        require(quantity > 0, \"quantity must be nonzero\");\n        uint256 endIndex = oldNextOwnerToSet + quantity - 1;\n        if (endIndex > collectionSize - 1) {\n            endIndex = collectionSize - 1;\n        }\n        require(_exists(endIndex), \"not enough minted yet for this cleanup\");\n        for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {\n            if (_ownerships[i].addr == address(0)) {\n                TokenOwnership memory ownership = ownershipOf(i);\n                _ownerships[i] = TokenOwnership(\n                    ownership.addr,\n                    ownership.startTimestamp\n                );\n            }\n        }\n        nextOwnerToExplicitlySet = endIndex + 1;\n    }\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721A: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}",
    "function_sum": 26,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-06-11\n*/\n// SPDX-License-Identifier: MIT\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Enumerable is IERC721 {\n    function totalSupply() external view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        returns (uint256);\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    function toString(uint256 value) internal pure returns (string memory) {\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n\n\n// You task is to complete the smart contract ERC721A strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ERC721A\n * @notice This contract implements the ERC721 standard with additional features for efficient batch minting and enumeration.\n * @dev This implementation is optimized for gas efficiency and supports a fixed collection size.\n */\ncontract ERC721A is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 private currentIndex = 0;\n\n    uint256 internal immutable collectionSize;\n    uint256 internal immutable maxBatchSize;\n    string private _name;\n    string private _symbol;\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) private _ownerships;\n    mapping(address => AddressData) private _addressData;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @notice Initializes the contract with the given name, symbol, maximum batch size, and collection size.\n     * @param name_ The name of the NFT collection.\n     * @param symbol_ The symbol of the NFT collection.\n     * @param maxBatchSize_ The maximum number of tokens that can be minted in a single transaction.\n     * @param collectionSize_ The total number of tokens in the collection.\n     * @dev The collection size must be greater than zero, and the max batch size must be greater than zero.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 maxBatchSize_,\n        uint256 collectionSize_\n    ) {\n        require(\n            collectionSize_ > 0,\n            \"ERC721A: collection must have a nonzero supply\"\n        );\n        require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n        _name = name_;\n        _symbol = symbol_;\n        maxBatchSize = maxBatchSize_;\n        collectionSize = collectionSize_;\n    }\n\n    /**\n     * @notice Returns the total number of tokens minted so far.\n     * @return The total supply of tokens.\n     * @dev The total supply is equal to the current index.\n     */\n    function totalSupply() public view override returns (uint256) {}\n\n    /**\n     * @notice Returns the token ID at a given index.\n     * @param index A valid index within the total supply.\n     * @return The token ID at the given index.\n     * @dev The index must be less than the total supply.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {}\n\n    /**\n     * @notice Returns the token ID owned by an owner at a given index.\n     * @param owner The address of the owner.\n     * @param index A valid index within the owner's balance.\n     * @return The token ID at the given index.\n     * @dev The index must be less than the owner's balance.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {}\n\n    /**\n     * @notice Checks if the contract implements a given interface.\n     * @param interfaceId The interface identifier to check.\n     * @return True if the interface is supported, false otherwise.\n     * @dev Supports IERC721, IERC721Metadata, and IERC721Enumerable interfaces.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {}\n\n    /**\n     * @notice Returns the number of tokens owned by an address.\n     * @param owner The address to query the balance of.\n     * @return The balance of the given address.\n     * @dev The owner cannot be the zero address.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {}\n\n    /**\n     * @notice Returns the number of tokens minted by an address.\n     * @param owner The address to query the number of minted tokens for.\n     * @return The number of tokens minted by the given address.\n     * @dev The owner cannot be the zero address.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {}\n\n    /**\n     * @notice Returns the ownership information for a given token ID.\n     * @param tokenId The token ID to query.\n     * @return The ownership information for the given token ID.\n     * @dev The token ID must exist.\n     */\n    function ownershipOf(uint256 tokenId)\n        internal\n        view\n        returns (TokenOwnership memory)\n    {}\n\n    /**\n     * @notice Returns the owner of a given token ID.\n     * @param tokenId The token ID to query.\n     * @return The owner of the given token ID.\n     * @dev The token ID must exist.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {}\n\n    /**\n     * @notice Returns the name of the NFT collection.\n     * @return The name of the NFT collection.\n     */\n    function name() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the symbol of the NFT collection.\n     * @return The symbol of the NFT collection.\n     */\n    function symbol() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the URI for a given token ID.\n     * @param tokenId The token ID to query.\n     * @return The URI for the given token ID.\n     * @dev The token ID must exist.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {}\n\n    /**\n     * @notice Returns the base URI for the NFT collection.\n     * @return The base URI for the NFT collection.\n     * @dev This function can be overridden to provide a custom base URI.\n     */\n    function _baseURI() internal view virtual returns (string memory) {}\n\n    /**\n     * @notice Approves another address to transfer the given token ID.\n     * @param to The address to approve.\n     * @param tokenId The token ID to approve.\n     * @dev The caller must be the owner or approved for all.\n     */\n    function approve(address to, uint256 tokenId) public override {}\n\n    /**\n     * @notice Returns the approved address for a given token ID.\n     * @param tokenId The token ID to query.\n     * @return The approved address for the given token ID.\n     * @dev The token ID must exist.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        override\n        returns (address)\n    {}\n\n    /**\n     * @notice Sets or unsets the approval for all tokens from the caller to the operator.\n     * @param operator The address to set the approval for.\n     * @param approved True to set the approval, false to unset it.\n     * @dev The operator cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override\n    {}\n\n    /**\n     * @notice Checks if an operator is approved for all tokens from an owner.\n     * @param owner The address of the owner.\n     * @param operator The address of the operator.\n     * @return True if the operator is approved for all, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {}\n\n    /**\n     * @notice Transfers a token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @dev The caller must be the owner or approved for the token.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {}\n\n    /**\n     * @notice Safely transfers a token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @dev The caller must be the owner or approved for the token.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {}\n\n    /**\n     * @notice Safely transfers a token from one address to another with additional data.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @param _data Additional data to send along with the transfer.\n     * @dev The caller must be the owner or approved for the token.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {}\n\n    /**\n     * @notice Checks if a token ID exists.\n     * @param tokenId The token ID to check.\n     * @return True if the token ID exists, false otherwise.\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {}\n\n    /**\n     * @notice Mints a specified quantity of tokens to a given address.\n     * @param to The address to mint the tokens to.\n     * @param quantity The number of tokens to mint.\n     * @dev The recipient cannot be the zero address, and the quantity must be within the max batch size.\n     */\n    function _safeMint(address to, uint256 quantity) internal {}\n\n    /**\n     * @dev Safely mints multiple NFTs to a recipient with ERC721A compliance.\n     * @param to Recipient address\n     * @param quantity Number of tokens to mint\n     * @param _data Optional data to pass to receiver\n     * @dev Requirements:\n     *   - Recipient cannot be zero address\n     *   - Starting token ID must not exist\n     *   - Quantity must not exceed max batch size\n     * @dev Emits Transfer events for each minted token\n     * @dev Performs safety checks via _checkOnERC721Received\n     * @dev Updates:\n     *   - Token ownership records\n     *   - Recipient address data (balance & mint count)\n     *   - Current token index\n     * @dev Calls hooks:\n     *   - _beforeTokenTransfers, _afterTokenTransfers\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {}\n\n    /**\n     * @dev Transfers ownership of an NFT from one address to another.\n     * @param from Current owner address\n     * @param to New owner address\n     * @param tokenId ID of the token to transfer\n     * @dev Requirements:\n     *   - Caller must be owner or approved operator\n     *   - `from` must be current owner\n     *   - `to` cannot be zero address\n     * @dev Updates:\n     *   - Ownership records for the token\n     *   - Balances of both addresses\n     *   - Maintains next token ID linkage for efficient lookups\n     * @dev Emits Transfer event\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {}\n\n    /**\n     * @notice Sets the approval for a given token ID.\n     * @param to The address to approve.\n     * @param tokenId The token ID to approve.\n     * @param owner The owner of the token.\n     * @dev Emits an Approval event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {}\n\n    uint256 public nextOwnerToExplicitlySet = 0;\n\n    /**\n     * @notice Explicitly sets the ownership for a range of token IDs.\n     * @param quantity The number of token IDs to set.\n     * @dev The quantity must be greater than zero and within the collection size.\n     */\n    function _setOwnersExplicit(uint256 quantity) internal {}\n\n    /**\n     * @notice Checks if a receiver is an ERC721Receiver and calls onERC721Received.\n     * @param from The address sending the token.\n     * @param to The address receiving the token.\n     * @param tokenId The token ID being transferred.\n     * @param _data Additional data to send along with the transfer.\n     * @return True if the receiver is an ERC721Receiver, false otherwise.\n     * @dev Reverts if the receiver is a contract but does not implement the ERC721Receiver interface.\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {}\n\n    /**\n     * @notice Hook called before a token transfer.\n     * @param from The address sending the token.\n     * @param to The address receiving the token.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens being transferred.\n     * @dev This hook can be overridden to perform additional checks or actions.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @notice Hook called after a token transfer.\n     * @param from The address sending the token.\n     * @param to The address receiving the token.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens being transferred.\n     * @dev This hook can be overridden to perform additional checks or actions.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"
}