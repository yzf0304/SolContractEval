{
    "contract_name": "AtomicSwap",
    "ground_truth": "contract AtomicSwap is ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    enum State { Empty, Initiated, Redeemed, Refunded }\n\n    struct Swap {\n        bytes32 hashedSecret;\n        bytes32 secret;\n        address contractAddr;\n        address participant;\n        address payable initiator;\n        uint refundTimestamp;\n        uint countdown;\n        uint value;\n        uint payoff;\n        bool active;\n        State state;\n    }\n    \n    event Initiated(\n        bytes32 indexed _hashedSecret,\n        address indexed _contract,\n        address indexed _participant,\n        address _initiator,\n        uint _refundTimestamp,\n        uint _countdown,\n        uint _value,\n        uint _payoff,\n        bool _active\n    );\n    event Added(\n        bytes32 indexed _hashedSecret,\n        address _sender,\n        uint _value  \n    );\n    event Activated(\n        bytes32 indexed _hashedSecret\n    );\n    event Redeemed(\n        bytes32 indexed _hashedSecret,\n        bytes32 _secret\n    );\n    event Refunded(\n        bytes32 indexed _hashedSecret\n    );\n\n    mapping(bytes32 => Swap) public swaps;\n\n    modifier onlyByInitiator(bytes32 _hashedSecret) {\n        require(msg.sender == swaps[_hashedSecret].initiator, \"sender is not the initiator\");\n        _;\n    }\n\n    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint _refundTimestamp, uint _countdown) {\n        require(_participant != address(0), \"invalid participant address\");\n        require(swaps[_hashedSecret].state == State.Empty, \"swap for this hash is initiated\");\n        require(block.timestamp <= _refundTimestamp, \"invalid refundTimestamp\");\n        require(_countdown < _refundTimestamp, \"invalid countdown\");\n        _;\n    }\n    \n    modifier isInitiated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].state == State.Initiated, \"swap for this hash is empty or spent\");\n        _;\n    }\n\n    modifier isAddable(bytes32 _hashedSecret) {\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\n        _;\n    }\n        \n    modifier isActivated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].active, \"swap is not active\");\n        _;\n    }    \n    \n    modifier isNotActivated(bytes32 _hashedSecret) {\n        require(!swaps[_hashedSecret].active, \"swap is active\");\n        _;\n    }\n\n    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\n        require(sha256(abi.encodePacked(sha256(abi.encodePacked(_secret)))) == _hashedSecret, \"secret is not correct\");\n        _;\n    }\n\n    modifier isRefundable(bytes32 _hashedSecret) {\n        require(block.timestamp > swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has not come\");\n        _;\n    }\n\n    function initiate (bytes32 _hashedSecret, address _contract, address _participant, uint _refundTimestamp, uint _countdown, uint _value, uint _payoff, bool _active)\n        public nonReentrant isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)\n    {\n        IERC20(_contract).safeTransferFrom(msg.sender, address(this), _value);\n\n        swaps[_hashedSecret].value = _value.sub(_payoff);\n        swaps[_hashedSecret].hashedSecret = _hashedSecret;\n        swaps[_hashedSecret].contractAddr = _contract;\n        swaps[_hashedSecret].participant = _participant;\n        swaps[_hashedSecret].initiator = msg.sender;\n        swaps[_hashedSecret].refundTimestamp = _refundTimestamp;\n        swaps[_hashedSecret].countdown = _countdown;\n        swaps[_hashedSecret].payoff = _payoff;\n        swaps[_hashedSecret].active = _active;\n        swaps[_hashedSecret].state = State.Initiated;\n\n        emit Initiated(\n            _hashedSecret,\n            _contract,\n            _participant,\n            msg.sender,\n            _refundTimestamp,\n            _countdown,\n            _value.sub(_payoff),\n            _payoff,\n            _active\n        );\n    }\n    \n    function add (bytes32 _hashedSecret, uint _value)\n        public nonReentrant isInitiated(_hashedSecret) isAddable(_hashedSecret)    \n    {\n        IERC20(swaps[_hashedSecret].contractAddr).safeTransferFrom(msg.sender, address(this), _value);\n        \n        swaps[_hashedSecret].value = swaps[_hashedSecret].value.add(_value);\n\n        emit Added(\n            _hashedSecret,\n            msg.sender,\n            swaps[_hashedSecret].value\n        );\n    }\n    \n    function activate (bytes32 _hashedSecret)\n        public nonReentrant isInitiated(_hashedSecret) isNotActivated(_hashedSecret) onlyByInitiator(_hashedSecret)\n    {\n        swaps[_hashedSecret].active = true;\n\n        emit Activated(\n            _hashedSecret\n        );\n    }\n\n    function redeem(bytes32 _hashedSecret, bytes32 _secret) \n        public nonReentrant isInitiated(_hashedSecret) isActivated(_hashedSecret) isRedeemable(_hashedSecret, _secret) \n    {\n        swaps[_hashedSecret].secret = _secret;\n        swaps[_hashedSecret].state = State.Redeemed;\n\n        if (block.timestamp > swaps[_hashedSecret].refundTimestamp.sub(swaps[_hashedSecret].countdown)) {\n            \n            IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value);\n            \n            if(swaps[_hashedSecret].payoff > 0) {\n                IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(msg.sender, swaps[_hashedSecret].payoff);\n            }\n        }\n        else {\n            IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\n        }\n        \n        emit Redeemed(\n            _hashedSecret,\n            _secret\n        );\n        \n        delete swaps[_hashedSecret];\n    }\n\n    function refund(bytes32 _hashedSecret)\n        public nonReentrant isInitiated(_hashedSecret) isRefundable(_hashedSecret) \n    {\n        swaps[_hashedSecret].state = State.Refunded;\n\n        IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].initiator, swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\n\n        emit Refunded(\n            _hashedSecret\n        );\n        \n        delete swaps[_hashedSecret];\n    }\n}",
    "function_sum": 3,
    "compiler_version": "0.5.16",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-08-25\n*/\n// From file: openzeppelin-contracts/contracts/math/SafeMath.sol\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n}\n\n// File: openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n// File: openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\n\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        _notEntered = true;\n    }\n\n    modifier nonReentrant() {\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n}\n\n\n\n// You task is to complete the smart contract AtomicSwap strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.16, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title AtomicSwap\n * @author [Your Name]\n * @notice This contract facilitates atomic swaps between two parties using a hashed secret.\n * @dev Implements non-reentrancy guard and uses SafeMath and SafeERC20 for secure arithmetic and token operations.\n */\ncontract AtomicSwap is ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    enum State { Empty, Initiated, Redeemed, Refunded }\n\n    struct Swap {\n        bytes32 hashedSecret;\n        bytes32 secret;\n        address contractAddr;\n        address participant;\n        address payable initiator;\n        uint refundTimestamp;\n        uint countdown;\n        uint value;\n        uint payoff;\n        bool active;\n        State state;\n    }\n    \n    event Initiated(\n        bytes32 indexed _hashedSecret,\n        address indexed _contract,\n        address indexed _participant,\n        address _initiator,\n        uint _refundTimestamp,\n        uint _countdown,\n        uint _value,\n        uint _payoff,\n        bool _active\n    );\n    event Added(\n        bytes32 indexed _hashedSecret,\n        address _sender,\n        uint _value  \n    );\n    event Activated(\n        bytes32 indexed _hashedSecret\n    );\n    event Redeemed(\n        bytes32 indexed _hashedSecret,\n        bytes32 _secret\n    );\n    event Refunded(\n        bytes32 indexed _hashedSecret\n    );\n\n    mapping(bytes32 => Swap) public swaps;\n\n    /**\n     * @notice Modifier to ensure the function can only be called by the initiator of the swap.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier onlyByInitiator(bytes32 _hashedSecret) {\n        require(msg.sender == swaps[_hashedSecret].initiator, \"sender is not the initiator\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the swap can be initiated.\n     * @param _hashedSecret The hashed secret of the swap.\n     * @param _participant The address of the participant.\n     * @param _refundTimestamp The timestamp after which the swap can be refunded.\n     * @param _countdown The countdown period before the refund timestamp.\n     */\n    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint _refundTimestamp, uint _countdown) {\n        require(_participant != address(0), \"invalid participant address\");\n        require(swaps[_hashedSecret].state == State.Empty, \"swap for this hash is initiated\");\n        require(block.timestamp <= _refundTimestamp, \"invalid refundTimestamp\");\n        require(_countdown < _refundTimestamp, \"invalid countdown\");\n        _;\n    }\n    \n    /**\n     * @notice Modifier to ensure the swap has been initiated.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier isInitiated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].state == State.Initiated, \"swap for this hash is empty or spent\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the swap can be added to.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier isAddable(bytes32 _hashedSecret) {\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\n        _;\n    }\n        \n    /**\n     * @notice Modifier to ensure the swap is activated.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier isActivated(bytes32 _hashedSecret) {\n        require(swaps[_hashedSecret].active, \"swap is not active\");\n        _;\n    }    \n    \n    /**\n     * @notice Modifier to ensure the swap is not activated.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier isNotActivated(bytes32 _hashedSecret) {\n        require(!swaps[_hashedSecret].active, \"swap is active\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the swap can be redeemed.\n     * @param _hashedSecret The hashed secret of the swap.\n     * @param _secret The secret to redeem the swap.\n     */\n    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\n        require(sha256(abi.encodePacked(sha256(abi.encodePacked(_secret)))) == _hashedSecret, \"secret is not correct\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the swap can be refunded.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    modifier isRefundable(bytes32 _hashedSecret) {\n        require(block.timestamp > swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has not come\");\n        _;\n    }\n\n    /**\n     * @notice Initiates a new atomic swap.\n     * @param _hashedSecret The hashed secret of the swap.\n     * @param _contract The address of the ERC20 token contract.\n     * @param _participant The address of the participant.\n     * @param _refundTimestamp The timestamp after which the swap can be refunded.\n     * @param _countdown The countdown period before the refund timestamp.\n     * @param _value The total value of the swap.\n     * @param _payoff The payoff amount.\n     * @param _active Whether the swap is active.\n     */\n    function initiate (bytes32 _hashedSecret, address _contract, address _participant, uint _refundTimestamp, uint _countdown, uint _value, uint _payoff, bool _active)\n        public nonReentrant isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)\n    {}\n\n    /**\n     * @notice Adds more value to an existing swap.\n     * @param _hashedSecret The hashed secret of the swap.\n     * @param _value The additional value to add.\n     */\n    function add (bytes32 _hashedSecret, uint _value)\n        public nonReentrant isInitiated(_hashedSecret) isAddable(_hashedSecret)    \n    {}\n\n    /**\n     * @notice Activates an initiated swap.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    function activate (bytes32 _hashedSecret)\n        public nonReentrant isInitiated(_hashedSecret) isNotActivated(_hashedSecret) onlyByInitiator(_hashedSecret)\n    {}\n\n    /**\n     * @dev Redeems a swap by revealing the secret and transferring funds.\n     * @param _hashedSecret Hashed secret used to identify the swap\n     * @param _secret Actual secret to validate the redemption\n     * @dev Requirements:\n     *   - Swap must be initialized (isInitiated)\n     *   - Swap must be activated (isActivated)\n     *   - Swap must be redeemable with provided secret (isRedeemable)\n     * @dev Behavior:\n     *   - Records the secret and marks swap as redeemed\n     *   - Transfers funds based on refund timing:\n     *     - If past refund window: transfers base value to participant and payoff to msg.sender\n     *     - Otherwise: transfers combined value+payoff to participant\n     *   - Emits Redeemed event\n     *   - Clears swap data\n     * @dev Security:\n     *   - Uses nonReentrant modifier to prevent reentrancy attacks\n     */\n    function redeem(bytes32 _hashedSecret, bytes32 _secret) \n        public nonReentrant isInitiated(_hashedSecret) isActivated(_hashedSecret) isRedeemable(_hashedSecret, _secret) \n    {}\n\n    /**\n     * @notice Refunds the swap if the refund timestamp has passed.\n     * @param _hashedSecret The hashed secret of the swap.\n     */\n    function refund(bytes32 _hashedSecret)\n        public nonReentrant isInitiated(_hashedSecret) isRefundable(_hashedSecret) \n    {}\n}\n"
}