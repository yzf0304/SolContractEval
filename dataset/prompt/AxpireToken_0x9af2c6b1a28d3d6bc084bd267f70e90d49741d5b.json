{
    "contract_name": "AxpireToken",
    "ground_truth": "contract AxpireToken is ERC223,ERC20 {\n\n\n\n    uint256 initialSupply= 350000000 * 10**8;\n\n    string tokenName=\"aXpire Token\";\n\n    string tokenSymbol=\"AXP\";\n\n    uint8 decimalUnits=8;\n\n\n\n    //Constructor\n\n    function AxpireToken() public\n\n    ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol)\n\n    {\n\n        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;\n\n        //Assigning total no of tokens\n\n        balances[owner] = initialSupply;\n\n        totalSupply = initialSupply;\n\n    }\n\n\n\n\n\n    function transfer(address to, uint256 value, bytes data) public returns (bool success) {\n\n\n\n        bool status = transferInternal(msg.sender, to, value, data);\n\n\n\n        return status;\n\n    }\n\n\n\n    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {\n\n\n\n        bool status = transferInternal(msg.sender, to, value, data, true, customFallback);\n\n\n\n        return status;\n\n    }\n\n\n\n    // rollback changes to transferInternal for transferFrom\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n\n\n        if (allowed[_from][msg.sender] < _value) {\n\n            return false;\n\n        }\n\n\n\n        bool _success = super.transferInternal(_from, _to, _value);\n\n\n\n        if (_success) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n\n\n        return _success;\n\n    }\n\n\n\n    function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {\n\n        return transferInternal(from, to, value, data, false, \"\");\n\n    }\n\n\n\n    function transferInternal(\n\n    address from,\n\n    address to,\n\n    uint256 value,\n\n    bytes data,\n\n    bool useCustomFallback,\n\n    string customFallback\n\n    )\n\n    internal returns (bool success)\n\n    {\n\n        bool status = super.transferInternal(from, to, value);\n\n\n\n        if (status) {\n\n            if (isContract(to)) {\n\n                ContractReceiver receiver = ContractReceiver(to);\n\n\n\n                if (useCustomFallback) {\n\n                    // solhint-disable-next-line avoid-call-value\n\n                    require(receiver.call.value(0)(bytes4(keccak256(customFallback)), from, value, data) == true);\n\n                } else {\n\n                    receiver.tokenFallback(from, value, data);\n\n                }\n\n            }\n\n\n\n            Transfer(from, to, value, data);\n\n        }\n\n\n\n        return status;\n\n    }\n\n\n\n    function transferInternal(address from, address to, uint256 value) internal returns (bool success) {\n\n\n\n        bytes memory data;\n\n\n\n        return transferInternal(from, to, value, data, false, \"\");\n\n    }\n\n\n\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n\n    function isContract(address _addr) private returns (bool) {\n\n        uint length;\n\n        assembly {\n\n        //retrieve the size of the code on target address, this needs assembly\n\n        length := extcodesize(_addr)\n\n        }\n\n        return (length > 0);\n\n    }\n\n\n\n}",
    "function_sum": 7,
    "compiler_version": "0.4.20",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-02-01\n\n*/\n//Owner Contract-For Defining Owner and Transferring Ownership\n\ncontract Ownable {\n\n    address public owner;\n\n\n\n    function Ownable() public {\n\n        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        owner = newOwner;\n\n    }\n\n\n\n}\n\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n        uint256 c = a * b;\n\n        assert(a == 0 || c / a == b);\n\n        return c;\n\n    }\n\n\n\n    function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n        uint256 c = a / b;\n\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n\n    }\n\n\n\n    function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n        assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n        uint256 c = a + b;\n\n        assert(c >= a);\n\n        return c;\n\n    }\n\n}\n\ncontract TokenRecipient {\n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n\n}\n\n//Token Format\n\ncontract ERC20 is Ownable {\n\n    using SafeMath for uint256;\n\n    //Public Variables of the token\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    uint256 public totalSupply;\n\n\n\n\n\n    mapping (address => uint256) public balances;\n\n\n\n    mapping (address => mapping (address => uint256)) public allowed;\n\n\n\n    /* This generates a public event on the blockchain that will notify clients */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n\n\n    //Constructor\n\n    function ERC20(\n\n    uint256 _initialSupply,\n\n    string _tokenName,\n\n    uint8 _decimalUnits,\n\n    string _tokenSymbol\n\n    ) public\n\n    {\n\n\n\n        balances[0x2e1977127F682723C778bBcac576A4aF2c0e790d] = _initialSupply;\n\n        totalSupply = _initialSupply;\n\n        decimals = _decimalUnits;\n\n        symbol = _tokenSymbol;\n\n        name = _tokenName;\n\n    }\n\n\n\n    /* public methods */\n\n    function transfer(address _to, uint256 _value) public  returns (bool) {\n\n\n\n\n\n        bool status = transferInternal(msg.sender, _to, _value);\n\n\n\n        require(status == true);\n\n\n\n        return true;\n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n\n\n\n\n        allowed[msg.sender][_spender] = _value;\n\n\n\n        Approval(msg.sender, _spender, _value);\n\n\n\n        return true;\n\n    }\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n\n\n\n\n\n        TokenRecipient spender = TokenRecipient(_spender);\n\n\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n\n\n\n\n        if (allowed[_from][msg.sender] < _value) {\n\n            return false;\n\n        }\n\n\n\n        bool _success = transferInternal(_from, _to, _value);\n\n\n\n        if (_success) {\n\n            allowed[_from][msg.sender] -= _value;\n\n        }\n\n\n\n        return _success;\n\n    }\n\n\n\n    /*constant functions*/\n\n    function totalSupply() public constant returns (uint256) {\n\n        return totalSupply;\n\n    }\n\n\n\n    function balanceOf(address _address) public constant returns (uint256 balance) {\n\n        return balances[_address];\n\n    }\n\n\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\n        return allowed[_owner][_spender];\n\n    }\n\n\n\n    /* internal functions*/\n\n    function setBalance(address _holder, uint256 _amount) internal {\n\n        balances[_holder] = _amount;\n\n    }\n\n\n\n    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {\n\n\n\n        if (_value == 0) {\n\n            Transfer(_from, _to, _value);\n\n\n\n            return true;\n\n        }\n\n\n\n        if (balances[_from] < _value) {\n\n            return false;\n\n        }\n\n\n\n        setBalance(_from, balances[_from].sub(_value));\n\n        setBalance(_to, balances[_to].add(_value));\n\n\n\n        Transfer(_from, _to, _value);\n\n\n\n        return true;\n\n    }\n\n}\n\ncontract ERC223 {\n\n    event Transfer(address indexed from, address indexed to, uint value, bytes  data);\n\n    function transfer(address to, uint value, bytes data) public returns (bool ok);\n\n    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);\n\n}\n\ncontract ContractReceiver {\n\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n\n}\n\n\n\n// You task is to complete the smart contract AxpireToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.20, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice The AxpireToken contract is an implementation of the ERC20 and ERC223 standards, designed to create a token with the specified initial supply, name, symbol, and decimals.\n * @dev This contract extends the functionality of ERC20 and ERC223 by adding additional transfer methods and handling for contract recipients.\n */\ncontract AxpireToken is ERC223, ERC20 {\n\n    uint256 initialSupply = 350000000 * 10**8;\n    string tokenName = \"aXpire Token\";\n    string tokenSymbol = \"AXP\";\n    uint8 decimalUnits = 8;\n\n    //Constructor\n    function AxpireToken() public\n    ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol)\n    {\n        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;\n        //Assigning total no of tokens\n        balances[owner] = initialSupply;\n        totalSupply = initialSupply;\n    }\n\n    /**\n     * @notice Transfers a specified amount of tokens to a recipient address, including additional data.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @param data Additional data to send along with the transfer.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transfer(address to, uint256 value, bytes data) public returns (bool success) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens to a recipient address, including additional data and a custom fallback function.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @param data Additional data to send along with the transfer.\n     * @param customFallback The custom fallback function to use if the recipient is a contract.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from one address to another, using the allowance mechanism.\n     * @param _from The address from which the tokens will be transferred.\n     * @param _to The address to which the tokens will be transferred.\n     * @param _value The amount of tokens to transfer.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @dev Internal function to handle the transfer of tokens, including additional data.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @param data Additional data to send along with the transfer.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {}\n\n    /**\n     * @dev Internal function to handle the transfer of tokens, including additional data and a custom fallback function.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @param data Additional data to send along with the transfer.\n     * @param useCustomFallback A boolean indicating whether to use a custom fallback function.\n     * @param customFallback The custom fallback function to use if the recipient is a contract.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value,\n        bytes data,\n        bool useCustomFallback,\n        string customFallback\n    ) internal returns (bool success) {}\n\n    /**\n     * @dev Internal function to handle the transfer of tokens without additional data.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @return success A boolean indicating whether the transfer was successful.\n     */\n    function transferInternal(address from, address to, uint256 value) internal returns (bool success) {}\n\n    /**\n     * @dev Checks if the given address is a contract by checking the code size.\n     * @param _addr The address to check.\n     * @return A boolean indicating whether the address is a contract.\n     */\n    function isContract(address _addr) private returns (bool) {}\n}\n"
}