{
    "contract_name": "BITOToken",
    "ground_truth": "contract BITOToken is ERC20Interface {\n  using SafeMath for uint;\n\n  // State variables\n  string public symbol = 'BITO';\n  string public name = 'BITO Coin';\n  uint public decimals = 8;\n  address public owner;\n  uint public totalSupply = 210000000 * (10 **8);\n  bool public emergencyFreeze;\n  \n  // mappings\n  mapping (address => uint) balances;\n  mapping (address => mapping (address => uint) ) allowed;\n  mapping (address => bool) frozen;\n  \n\n  // constructor\n  function BITOToken () public {\n    owner = msg.sender;\n    balances[owner] = totalSupply;\n  }\n\n  // events\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n  event Burn(address indexed from, uint256 amount);\n  event Freezed(address targetAddress, bool frozen);\n  event EmerygencyFreezed(bool emergencyFreezeStatus);\n  \n\n\n  // Modifiers\n  modifier onlyOwner {\n    require(msg.sender == owner);\n     _;\n  }\n\n  modifier unfreezed(address _account) { \n    require(!frozen[_account]);\n    _;  \n  }\n  \n  modifier noEmergencyFreeze() { \n    require(!emergencyFreeze);\n    _; \n  }\n  \n\n\n  // functions\n\n  // ------------------------------------------------------------------------\n  // Transfer Token\n  // ------------------------------------------------------------------------\n  function transfer(address _to, uint _value) unfreezed(_to) noEmergencyFreeze() public returns (bool success) {\n    require(_to != 0x0);\n    require(balances[msg.sender] >= _value);\n   /*  require(!frozenAccount[_from]); \n    require(!frozenAccount[_to]);  \n    require(!emergencyFreeze);   */ \n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  // ------------------------------------------------------------------------\n  // Approve others to spend on your behalf\n  // ------------------------------------------------------------------------\n  function approve(address _spender, uint _value) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {\n    //require(balances[msg.sender] >= _value);\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  // ------------------------------------------------------------------------\n  // Approve and call : If approve returns true, it calls receiveApproval method of contract\n  // ------------------------------------------------------------------------\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success)\n    {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n  // ------------------------------------------------------------------------\n  // Transferred approved amount from other's account\n  // ------------------------------------------------------------------------\n  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) noEmergencyFreeze() public returns (bool success) {\n    require(_value <= allowed[_from][msg.sender]);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n\n  // ------------------------------------------------------------------------\n  // Burn (Destroy tokens)\n  // ------------------------------------------------------------------------\n  function burn(uint256 _value) public returns (bool success) {\n    require(balances[msg.sender] >= _value);\n    balances[msg.sender] -= _value;\n    totalSupply -= _value;\n    emit Burn(msg.sender, _value);\n    return true;\n  }\n\n  // ------------------------------------------------------------------------\n  //               ONLYOWNER METHODS                             \n  // ------------------------------------------------------------------------\n\n\n  // ------------------------------------------------------------------------\n  // Transfer Ownership\n  // ------------------------------------------------------------------------\n  function transferOwnership(address _newOwner) public onlyOwner {\n    require(_newOwner != address(0));\n    owner = _newOwner;\n    emit OwnershipTransferred(owner, _newOwner);\n  }\n\n  // ------------------------------------------------------------------------\n  // Freeze account - onlyOwner\n  // ------------------------------------------------------------------------\n  function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {\n    require(_target != 0x0);\n    frozen[_target] = _freeze;\n    emit Freezed(_target, _freeze);\n    return true;\n  }\n\n  // ------------------------------------------------------------------------\n  // Emerygency freeze - onlyOwner\n  // ------------------------------------------------------------------------\n  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {\n    emergencyFreeze = _freeze;\n    emit EmerygencyFreezed(_freeze);\n    return true;\n  }\n  \n\n  // ------------------------------------------------------------------------\n  //               CONSTANT METHODS\n  // ------------------------------------------------------------------------\n\n\n  // ------------------------------------------------------------------------\n  // Check Allowance : Constant\n  // ------------------------------------------------------------------------\n  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {\n    return allowed[_tokenOwner][_spender];\n  }\n\n  // ------------------------------------------------------------------------\n  // Check Balance : Constant\n  // ------------------------------------------------------------------------\n  function balanceOf(address _tokenOwner) public constant returns (uint balance) {\n    return balances[_tokenOwner];\n  }\n\n  // ------------------------------------------------------------------------\n  // Total supply : Constant\n  // ------------------------------------------------------------------------\n  function totalSupply() public constant returns (uint) {\n    return totalSupply;\n  }\n\n  // ------------------------------------------------------------------------\n  // Get Freeze Status : Constant\n  // ------------------------------------------------------------------------\n  function isFreezed(address _targetAddress) public constant returns (bool) {\n    return frozen[_targetAddress]; \n  }\n\n\n\n  // ------------------------------------------------------------------------\n  // Prevents contract from accepting ETH\n  // ------------------------------------------------------------------------\n  function () public payable {\n    revert();\n  }\n\n  // ------------------------------------------------------------------------\n  // Owner can transfer out any accidentally sent ERC20 tokens\n  // ------------------------------------------------------------------------\n  function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {\n      return ERC20Interface(_tokenAddress).transfer(owner, _value);\n  }\n}",
    "function_sum": 13,
    "compiler_version": "0.4.21",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// source : https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\n\n\n// You task is to complete the smart contract BITOToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.21, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title BITOToken\n * @dev This contract implements the ERC20 token standard with additional features such as freezing accounts, emergency freeze, and burning tokens.\n * @notice BITOToken is a custom ERC20 token with the symbol 'BITO' and name 'BITO Coin'. It includes functionalities for transferring, approving, and burning tokens, as well as owner-only functions to manage the contract.\n */\ncontract BITOToken is ERC20Interface {\n  using SafeMath for uint;\n\n  // State variables\n  string public symbol = 'BITO';\n  string public name = 'BITO Coin';\n  uint public decimals = 8;\n  address public owner;\n  uint public totalSupply = 210000000 * (10 **8);\n  bool public emergencyFreeze;\n  \n  // mappings\n  mapping (address => uint) balances;\n  mapping (address => mapping (address => uint) ) allowed;\n  mapping (address => bool) frozen;\n  \n\n  /**\n   * @dev Initializes the contract and assigns the total supply to the contract owner.\n   * @notice The constructor sets the contract owner and assigns the total supply of tokens to the owner.\n   */\n  function BITOToken () public {\n    owner = msg.sender;\n    balances[owner] = totalSupply;\n  }\n\n  // events\n  event OwnershipTransferred(address indexed _from, address indexed _to);\n  event Burn(address indexed from, uint256 amount);\n  event Freezed(address targetAddress, bool frozen);\n  event EmerygencyFreezed(bool emergencyFreezeStatus);\n  \n\n\n  // Modifiers\n  /**\n   * @dev Modifier to ensure that only the contract owner can call the function.\n   * @notice Ensures that the function can only be called by the contract owner.\n   */\n  modifier onlyOwner {\n    require(msg.sender == owner);\n     _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the account is not frozen.\n   * @notice Ensures that the function can only be called if the specified account is not frozen.\n   */\n  modifier unfreezed(address _account) { \n    require(!frozen[_account]);\n    _;  \n  }\n  \n  /**\n   * @dev Modifier to ensure that the emergency freeze is not active.\n   * @notice Ensures that the function can only be called if the emergency freeze is not active.\n   */\n  modifier noEmergencyFreeze() { \n    require(!emergencyFreeze);\n    _; \n  }\n  \n\n\n  // functions\n\n  // ------------------------------------------------------------------------\n  // Transfer Token\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Transfers tokens from the sender's account to another account.\n   * @notice Transfers a specified amount of tokens from the sender's account to the recipient's account.\n   * @param _to The address of the recipient.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating whether the transfer was successful.\n   */\n  function transfer(address _to, uint _value) unfreezed(_to) noEmergencyFreeze() public returns (bool success) {}\n\n  // ------------------------------------------------------------------------\n  // Approve others to spend on your behalf\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Approves a spender to withdraw a certain amount of tokens from the caller's account.\n   * @notice Allows a specified address to withdraw a certain amount of tokens from the caller's account.\n   * @param _spender The address of the spender.\n   * @param _value The amount of tokens to approve.\n   * @return A boolean indicating whether the approval was successful.\n   */\n  function approve(address _spender, uint _value) unfreezed(_spender) unfreezed(msg.sender) noEmergencyFreeze() public returns (bool success) {}\n\n  // ------------------------------------------------------------------------\n  // Approve and call : If approve returns true, it calls receiveApproval method of contract\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Approves a spender to withdraw a certain amount of tokens and calls the `receiveApproval` method on the spender's contract.\n   * @notice Approves a specified address to withdraw a certain amount of tokens and calls the `receiveApproval` method on the spender's contract.\n   * @param _spender The address of the spender.\n   * @param _value The amount of tokens to approve.\n   * @param _extraData Additional data to pass to the `receiveApproval` method.\n   * @return A boolean indicating whether the approval and call were successful.\n   */\n  function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {}\n\n  // ------------------------------------------------------------------------\n  // Transferred approved amount from other's account\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Transfers tokens from one account to another, using the allowance mechanism.\n   * @notice Transfers a specified amount of tokens from one account to another, using the allowance mechanism.\n   * @param _from The address of the token holder.\n   * @param _to The address of the recipient.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating whether the transfer was successful.\n   */\n  function transferFrom(address _from, address _to, uint _value) unfreezed(_to) unfreezed(_from) noEmergencyFreeze() public returns (bool success) {}\n\n  // ------------------------------------------------------------------------\n  // Burn (Destroy tokens)\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Burns (destroys) a specified amount of tokens from the caller's account.\n   * @notice Burns (destroys) a specified amount of tokens from the caller's account.\n   * @param _value The amount of tokens to burn.\n   * @return A boolean indicating whether the burn was successful.\n   */\n  function burn(uint256 _value) public returns (bool success) {}\n\n  // ------------------------------------------------------------------------\n  //               ONLYOWNER METHODS                             \n  // ------------------------------------------------------------------------\n\n\n  // ------------------------------------------------------------------------\n  // Transfer Ownership\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Transfers ownership of the contract to a new address.\n   * @notice Transfers ownership of the contract to a new address.\n   * @param _newOwner The address of the new owner.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {}\n\n  // ------------------------------------------------------------------------\n  // Freeze account - onlyOwner\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Freezes or unfreezes a specified account.\n   * @notice Freezes or unfreezes a specified account.\n   * @param _target The address of the account to freeze or unfreeze.\n   * @param _freeze A boolean indicating whether to freeze or unfreeze the account.\n   * @return A boolean indicating whether the operation was successful.\n   */\n  function freezeAccount (address _target, bool _freeze) public onlyOwner returns(bool res) {}\n\n  // ------------------------------------------------------------------------\n  // Emerygency freeze - onlyOwner\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Activates or deactivates the emergency freeze for all accounts.\n   * @notice Activates or deactivates the emergency freeze for all accounts.\n   * @param _freeze A boolean indicating whether to activate or deactivate the emergency freeze.\n   * @return A boolean indicating whether the operation was successful.\n   */\n  function emergencyFreezeAllAccounts (bool _freeze) public onlyOwner returns(bool res) {}\n  \n\n  // ------------------------------------------------------------------------\n  //               CONSTANT METHODS\n  // ------------------------------------------------------------------------\n\n\n  // ------------------------------------------------------------------------\n  // Check Allowance : Constant\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Returns the remaining allowance of a spender for a token owner.\n   * @notice Returns the remaining allowance of a spender for a token owner.\n   * @param _tokenOwner The address of the token owner.\n   * @param _spender The address of the spender.\n   * @return The remaining allowance.\n   */\n  function allowance(address _tokenOwner, address _spender) public constant returns (uint remaining) {}\n\n  // ------------------------------------------------------------------------\n  // Check Balance : Constant\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Returns the balance of a specified account.\n   * @notice Returns the balance of a specified account.\n   * @param _tokenOwner The address of the account.\n   * @return The balance of the account.\n   */\n  function balanceOf(address _tokenOwner) public constant returns (uint balance) {}\n\n  // ------------------------------------------------------------------------\n  // Total supply : Constant\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Returns the total supply of tokens.\n   * @notice Returns the total supply of tokens.\n   * @return The total supply of tokens.\n   */\n  function totalSupply() public constant returns (uint) {}\n\n  // ------------------------------------------------------------------------\n  // Get Freeze Status : Constant\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Returns the freeze status of a specified account.\n   * @notice Returns the freeze status of a specified account.\n   * @param _targetAddress The address of the account.\n   * @return A boolean indicating whether the account is frozen.\n   */\n  function isFreezed(address _targetAddress) public constant returns (bool) {}\n\n  // ------------------------------------------------------------------------\n  // Prevents contract from accepting ETH\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Reverts any ETH sent to the contract.\n   * @notice Reverts any ETH sent to the contract.\n   */\n  function () public payable {\n  }\n\n  // ------------------------------------------------------------------------\n  // Owner can transfer out any accidentally sent ERC20 tokens\n  // ------------------------------------------------------------------------\n  /**\n   * @dev Transfers any accidentally sent ERC20 tokens to the owner.\n   * @notice Transfers any accidentally sent ERC20 tokens to the owner.\n   * @param _tokenAddress The address of the ERC20 token.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating whether the transfer was successful.\n   */\n  function transferAnyERC20Token(address _tokenAddress, uint _value) public onlyOwner returns (bool success) {}\n}\n"
}