{
    "contract_name": "BOTS",
    "ground_truth": "contract BOTS is ERC20(\"Bot Ocean\", \"BOTS\") {\n    function mint(\n        address _to, \n        uint256 _amount\n    ) \n        public \n        onlyOwner \n    {\n        _mint(_to, _amount);\n    }\n    \n    function burn(\n        address _from, \n        uint256 _amount\n    ) \n        public \n        onlyOwner \n    {\n        _burn(_from, _amount);\n    }\n    \n    function setName(\n        string memory _newName\n    ) \n        public \n        onlyOwner \n    {\n       _name = _newName;\n    } \n    \n    function setSymbol(\n        string memory _newSymbol\n    ) \n        public \n        onlyOwner \n    {\n       _symbol = _newSymbol;\n    } \n    \n    function setWebsite(\n        string memory _newWebsite\n    ) \n        public \n        onlyOwner \n    {\n       _website = _newWebsite;\n    }\n    \n    function tokenFallback(\n        address _from, \n        uint256 _value, \n        bytes memory _data\n    ) \n        public \n    {\n        revert();\n    }\n    \n    function takeOut(\n        IERC20 _token, \n        uint256 _amount\n    ) \n        external \n        onlyOwner \n    {\n        _token.transfer(owner, _amount);\n    }\n}",
    "function_sum": 7,
    "compiler_version": "0.7.3",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-02-07\n*/\n/**\n *Submitted for verification at Etherscan.io on 2020-10-12\n*/\n\nabstract contract Context {\n    function _msgSender() \n        internal\n        view \n        virtual\n        returns (address payable) \n    {\n        return msg.sender;\n    }\n\n    function _msgData() \n        internal\n        view \n        virtual \n        returns (bytes memory) \n    {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function add(\n        uint256 a, \n        uint256 b\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(\n        uint256 a, \n        uint256 b\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a, \n        uint256 b, \n        string memory errorMessage\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(\n        uint256 a, \n        uint256 b\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(\n        uint256 a, \n        uint256 b\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a, \n        uint256 b, \n        string memory errorMessage\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(\n        uint256 a, \n        uint256 b\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a, \n        uint256 b, \n        string memory errorMessage\n    ) \n        internal \n        pure \n        returns (uint256) \n    {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\nabstract contract Ownable is Context {\n    address public owner;\n    address public pendingOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner, \n        address indexed newOwner\n    );\n\n    constructor () {\n        address msgSender = _msgSender();\n        owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    modifier onlyOwner() {\n        require(owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function transferOwnership(\n        address newOwner\n    ) \n        onlyOwner \n        external \n    {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        pendingOwner = newOwner;\n     }\n    \n     function claimOwnership() \n        external \n    {\n        require(_msgSender() == pendingOwner);\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n     }\n}\n\nabstract contract Pausable is Ownable {\n    event Pause();\n    event Unpause();\n\n    bool public paused = true;\n\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function pause() \n        onlyOwner \n        whenNotPaused \n        external \n    {\n        paused = true;\n        emit Pause();\n    }\n\n    function unpause()\n        onlyOwner \n        whenPaused \n        external \n    {\n        paused = false;\n        emit Unpause();\n    }\n}\n\nabstract contract Whitelist is Pausable {\n    mapping(address => bool) public whitelist;\n    mapping(address => bool) public blacklist;\n\n    modifier isWhitelisted() {\n        require(whitelist[_msgSender()]);\n        _;\n    }\n  \n    modifier isBlacklisted() {\n        require(blacklist[_msgSender()]);\n        _;\n    }\n\n    function addWhitelist(\n        address account\n    ) \n        public \n        onlyOwner \n    {\n        whitelist[account] = true;\n    }\n    \n    function removeWhitelist(\n        address account\n    ) \n        public \n        onlyOwner \n    {\n        whitelist[account] = false;\n    }\n\n    function addBlacklist(\n        address account\n    ) \n        public \n        onlyOwner \n    {\n        blacklist[account] = true;\n    }\n\n    function removeBlacklist(\n        address account\n    ) \n        public \n        onlyOwner \n    {\n        blacklist[account] = false;\n    }\n}\n\nabstract contract ERC20 is Whitelist, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n    string internal _website;\n    uint8 private _decimals;\n\n    constructor (\n        string memory name, \n        string memory symbol\n    ) {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    function name() \n        public \n        view \n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol() \n        public \n        view \n        returns (string memory) \n    {\n        return _symbol;\n    }\n    \n    function website() \n        public \n        view \n        returns (string memory) \n    {\n        return _website;\n    }\n\n    function decimals() \n        public \n        view \n        returns (uint8) \n    {\n        return _decimals;\n    }\n\n    function totalSupply() \n        public \n        view \n        override \n        returns (uint256) \n    {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) \n        public \n        view \n        override \n        returns (uint256) \n    {\n        return _balances[account];\n    }\n\n    function transfer(\n        address recipient, \n        uint256 amount\n    ) \n        public \n        virtual \n        override \n        returns (bool) \n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    \n    function allowance(\n        address owner, \n        address spender\n    ) \n        public \n        view \n        virtual \n        override \n        returns (uint256) \n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender, \n        uint256 amount\n    ) \n        public \n        virtual \n        override \n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender, \n        address recipient, \n        uint256 amount\n    ) \n        public \n        virtual \n        override \n        returns (bool) \n    {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender, \n        uint256 addedValue\n    ) \n        public \n        virtual \n        returns (bool) \n    {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender, \n        uint256 subtractedValue\n    ) \n        public \n        virtual \n        returns (bool) \n    {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function _transfer(\n        address sender, \n        address recipient, \n        uint256 amount\n    ) \n        canTransfer\n        internal \n        virtual \n    {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(\n        address account, \n        uint256 amount\n    ) \n        internal \n        virtual \n    {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(\n        address account, \n        uint256 amount\n    ) \n        internal \n        virtual \n    {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner, \n        address spender, \n        uint256 amount\n    ) \n        internal \n        virtual \n    {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    modifier canTransfer() \n    {\n        address msgSender = _msgSender();\n        require(whitelist[msgSender] || !paused);\n        require(!blacklist[msgSender]);\n        _;\n    }\n\n    function _setupDecimals(\n        uint8 decimals_\n    ) \n        internal \n    {\n        _decimals = decimals_;\n    }\n\n    function _beforeTokenTransfer(\n        address from, \n        address to, \n        uint256 amount\n    ) \n        internal \n        virtual \n    { \n        \n    }\n}\n\n\n\n// You task is to complete the smart contract BOTS strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.7.3, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title BOTS Token Contract\n * @notice This contract implements a basic ERC20 token with additional functionalities for the owner.\n * @dev The contract extends the OpenZeppelin ERC20 implementation and includes methods for minting, burning, and updating token metadata.\n */\ncontract BOTS is ERC20(\"Bot Ocean\", \"BOTS\") {\n    /**\n     * @notice Mints new tokens to a specified address.\n     * @dev Only the contract owner can call this function. It mints `_amount` of tokens to `_to`.\n     * @param _to The address to which the tokens will be minted.\n     * @param _amount The amount of tokens to mint.\n     */\n    function mint(\n        address _to, \n        uint256 _amount\n    ) \n        public \n        onlyOwner \n    {}\n\n    /**\n     * @notice Burns a specified amount of tokens from a given address.\n     * @dev Only the contract owner can call this function. It burns `_amount` of tokens from `_from`.\n     * @param _from The address from which the tokens will be burned.\n     * @param _amount The amount of tokens to burn.\n     */\n    function burn(\n        address _from, \n        uint256 _amount\n    ) \n        public \n        onlyOwner \n    {}\n\n    /**\n     * @notice Sets a new name for the token.\n     * @dev Only the contract owner can call this function. It updates the token's name to `_newName`.\n     * @param _newName The new name for the token.\n     */\n    function setName(\n        string memory _newName\n    ) \n        public \n        onlyOwner \n    {}\n\n    /**\n     * @notice Sets a new symbol for the token.\n     * @dev Only the contract owner can call this function. It updates the token's symbol to `_newSymbol`.\n     * @param _newSymbol The new symbol for the token.\n     */\n    function setSymbol(\n        string memory _newSymbol\n    ) \n        public \n        onlyOwner \n    {}\n\n    /**\n     * @notice Sets a new website for the token.\n     * @dev Only the contract owner can call this function. It updates the token's website to `_newWebsite`.\n     * @param _newWebsite The new website for the token.\n     */\n    function setWebsite(\n        string memory _newWebsite\n    ) \n        public \n        onlyOwner \n    {}\n\n    /**\n     * @notice A fallback function for receiving tokens.\n     * @dev This function is intended to handle incoming token transfers but currently reverts any calls.\n     * @param _from The address from which the tokens are sent.\n     * @param _value The amount of tokens being sent.\n     * @param _data Additional data passed with the transfer.\n     */\n    function tokenFallback(\n        address _from, \n        uint256 _value, \n        bytes memory _data\n    ) \n        public \n    {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw a specified amount of another ERC20 token from this contract.\n     * @dev Only the contract owner can call this function. It transfers `_amount` of `_token` to the owner.\n     * @param _token The ERC20 token to withdraw.\n     * @param _amount The amount of the token to withdraw.\n     */\n    function takeOut(\n        IERC20 _token, \n        uint256 _amount\n    ) \n        external \n        onlyOwner \n    {}\n}\n"
}