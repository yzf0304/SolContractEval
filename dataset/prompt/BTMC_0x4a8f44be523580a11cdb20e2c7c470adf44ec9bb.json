{
    "contract_name": "BTMC",
    "ground_truth": "contract BTMC is ERC20,Ownable,Pausable{\n\tusing SafeMath for uint256;\n\n\t//the base info of the token\n\tstring public constant name=\"MinerCoin\";\n\tstring public constant symbol=\"BTMC\";\n\tstring public constant version = \"1.0\";\n\tuint256 public constant decimals = 18;\n\n\t//1\u4ebf\u56e2\u961f\u6301\u6709\n\tuint256 public constant INIT_SUPPLY=100000000*10**decimals;\n\n\t//\u6316\u77ff5\u4ebf\uff08\u4ee3\u5e01\u9636\u6bb5\u5148\u4e0d\u751f\u6210\uff09\n\tuint256 public constant MINING_SUPPLY=500000000*10**decimals;\n\n\n\t//\u516c\u52df2\u4ebf\n\tuint256 public constant MAX_FUNDING_SUPPLY=200000000*10**decimals;\n\n\t//\u56e2\u961f\u9501\u5b9a2\u4ebf\n\tuint256 public constant TEAM_KEEPING=200000000*10**decimals;\t\n\n\t//\u603b\u53d1\u884c10\u4ebf\n\tuint256 public constant MAX_SUPPLY=INIT_SUPPLY+MINING_SUPPLY+MAX_FUNDING_SUPPLY+TEAM_KEEPING;\n\n\t//\u516c\u52df\u53c2\u6570\n\t//\u5df2\u7ecf\u516c\u52df\u91cf\n\tuint256 public totalFundingSupply;\n\tuint256 public startTime;\n\tuint256 public endTime;\n\tuint256 public rate;\n\n\t//\u56e2\u961f\u6bcf\u6b21\u89e3\u7981\n\tuint256 public constant TEAM_UNFREEZE=40000000*10**decimals;\n\tbool public hasOneStepWithdraw;\n\tbool public hasTwoStepWithdraw;\n\tbool public hasThreeStepWithdraw;\n\tbool public hasFourStepWithdraw;\n\tbool public hasFiveStepWithdraw;\n\n\n\t \n\t//ERC20\u7684\u4f59\u989d\n    mapping(address => uint256) balances;\n\tmapping (address => mapping (address => uint256)) allowed;\n\t\n\tfunction BTMC(){\n\t\ttotalSupply=INIT_SUPPLY;\n\t\tbalances[msg.sender] = INIT_SUPPLY;\n\t\tTransfer(0x0, msg.sender, INIT_SUPPLY);\n\t\ttotalFundingSupply = 0;\n\t\n\t\t//20180423 235959\n\t\tstartTime=1524499199;\n\t\t//20180515 000000\n\t\tendTime=1526313600;\n\t\trate=5000;\n\n\t\thasOneStepWithdraw=false;\n\t\thasTwoStepWithdraw=false;\n\t\thasThreeStepWithdraw=false;\n\t\thasFourStepWithdraw=false;\n\t\thasFiveStepWithdraw=false;\n\n\n\n\n\t}\n\n\tevent CreateBTMC(address indexed _to, uint256 _value);\n\n\n\tmodifier notReachTotalSupply(uint256 _value,uint256 _rate){\n\t\tassert(MAX_SUPPLY>=totalSupply.add(_value.mul(_rate)));\n\t\t_;\n\t}\n\n\tmodifier notReachFundingSupply(uint256 _value,uint256 _rate){\n\t\tassert(MAX_FUNDING_SUPPLY>=totalFundingSupply.add(_value.mul(_rate)));\n\t\t_;\n\t}\n\tmodifier assertFalse(bool withdrawStatus){\n\t\tassert(!withdrawStatus);\n\t\t_;\n\t}\n\n\tmodifier notBeforeTime(uint256 targetTime){\n\t\tassert(now>targetTime);\n\t\t_;\n\t}\n\n\tmodifier notAfterTime(uint256 targetTime){\n\t\tassert(now<=targetTime);\n\t\t_;\n\t}\n\n\n\t//owner\u6709\u6743\u9650\u63d0\u53d6\u8d26\u6237\u4e2d\u7684eth\n\tfunction etherProceeds() external\n\t\tonlyOwner\n\n\t{\n\t\tif(!msg.sender.send(this.balance)) revert();\n\t}\n\n\n\t//\u4ee3\u5e01\u5206\u53d1\u51fd\u6570\uff0c\u5185\u90e8\u4f7f\u7528\n\tfunction processFunding(address receiver,uint256 _value,uint256 _rate)  internal\n\t\tnotReachTotalSupply(_value,_rate)\n\t{\n\t\tuint256 amount=_value.mul(_rate);\n\t\ttotalSupply=totalSupply.add(amount);\n\t\tbalances[receiver] +=amount;\n\t\tCreateBTMC(receiver,amount);\n\t\tTransfer(0x0, receiver, amount);\n\t}\n\n\tfunction funding (address receiver,uint256 _value,uint256 _rate) whenNotPaused internal \n\t\tnotReachFundingSupply(_value,_rate)\n\t{\n\t\tprocessFunding(receiver,_value,_rate);\n\t\tuint256 amount=_value.mul(_rate);\n\t\ttotalFundingSupply = totalFundingSupply.add(amount);\n\t}\n\t\n\n\tfunction () payable external\n\t\tnotBeforeTime(startTime)\n\t\tnotAfterTime(endTime)\n\t{\n\t\t\tfunding(msg.sender,msg.value,rate);\n\t}\n\n\n\t//20200423 000000\u53ef\u63d0\n\tfunction withdrawForOneStep() external\n\t\tonlyOwner\n\t\tassertFalse(hasOneStepWithdraw)\n\t\tnotBeforeTime(1587571200)\n\t{\n\t\tprocessFunding(msg.sender,TEAM_UNFREEZE,1);\n\t\t//\u6807\u8bb0\u56e2\u961f\u5df2\u63d0\u73b0\n\t\thasOneStepWithdraw = true;\n\t}\n\n\t//20201023 000000\n\tfunction withdrawForTwoStep() external\n\t\tonlyOwner\n\t\tassertFalse(hasTwoStepWithdraw)\n\t\tnotBeforeTime(1603382400)\n\t{\n\t\tprocessFunding(msg.sender,TEAM_UNFREEZE,1);\n\t\t//\u6807\u8bb0\u56e2\u961f\u5df2\u63d0\u73b0\n\t\thasTwoStepWithdraw = true;\n\t}\n\n\t//20210423 000000\n\tfunction withdrawForThreeStep() external\n\t\tonlyOwner\n\t\tassertFalse(hasThreeStepWithdraw)\n\t\tnotBeforeTime(1619107200)\n\t{\n\t\tprocessFunding(msg.sender,TEAM_UNFREEZE,1);\n\t\t//\u6807\u8bb0\u56e2\u961f\u5df2\u63d0\u73b0\n\t\thasThreeStepWithdraw = true;\n\t}\n\n\t//20211023 000000\n\tfunction withdrawForFourStep() external\n\t\tonlyOwner\n\t\tassertFalse(hasFourStepWithdraw)\n\t\tnotBeforeTime(1634918400)\n\t{\n\t\tprocessFunding(msg.sender,TEAM_UNFREEZE,1);\n\t\t//\u6807\u8bb0\u56e2\u961f\u5df2\u63d0\u73b0\n\t\thasFourStepWithdraw = true;\n\t}\n\n\t//20220423 000000\n\tfunction withdrawForFiveStep() external\n\t\tonlyOwner\n\t\tassertFalse(hasFiveStepWithdraw)\n\t\tnotBeforeTime(1650643200)\n\t{\n\t\tprocessFunding(msg.sender,TEAM_UNFREEZE,1);\n\t\t//\u6807\u8bb0\u56e2\u961f\u5df2\u63d0\u73b0\n\t\thasFiveStepWithdraw = true;\n\t}\t\t\t\n\n\n  \tfunction transfer(address _to, uint256 _value) whenNotPaused public  returns (bool)\n \t{\n\t\trequire(_to != address(0));\n\t\t// SafeMath.sub will throw if there is not enough balance.\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tTransfer(msg.sender, _to, _value);\n\t\treturn true;\n  \t}\n\n  \tfunction balanceOf(address _owner) public constant returns (uint256 balance) \n  \t{\n\t\treturn balances[_owner];\n  \t}\n\n\n  \tfunction transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) \n  \t{\n\t\trequire(_to != address(0));\n\t\tuint256 _allowance = allowed[_from][msg.sender];\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n\t\tTransfer(_from, _to, _value);\n\t\treturn true;\n  \t}\n\n  \tfunction approve(address _spender, uint256 _value) whenNotPaused public returns (bool) \n  \t{\n\t\tallowed[msg.sender][_spender] = _value;\n\t\tApproval(msg.sender, _spender, _value);\n\t\treturn true;\n  \t}\n\n  \tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) \n  \t{\n\t\treturn allowed[_owner][_spender];\n  \t}\n\n\n\tfunction setupFundingRate(uint256 _rate) external\n\t\tonlyOwner\n\t{\n\t\trate=_rate;\n\t}\n\n    function setupFundingTime(uint256 _startTime,uint256 _endTime) external\n        onlyOwner\n    {\n\t\tstartTime=_startTime;\n\t\tendTime=_endTime;\n    }\n\t  \n}",
    "function_sum": 14,
    "compiler_version": "0.4.22",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n\n\n// You task is to complete the smart contract BTMC strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.22, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice BTMC is a token contract that implements ERC20, Ownable, and Pausable functionalities. \n * It includes features for token distribution, team token vesting, and funding.\n * @dev The contract is designed to manage the initial supply, mining, public funding, and team vesting of tokens.\n */\ncontract BTMC is ERC20, Ownable, Pausable {\n    using SafeMath for uint256;\n\n    // Base information of the token\n    string public constant name = \"MinerCoin\";\n    string public constant symbol = \"BTMC\";\n    string public constant version = \"1.0\";\n    uint256 public constant decimals = 18;\n\n    // Initial supply for the team\n    uint256 public constant INIT_SUPPLY = 100000000 * 10**decimals;\n\n    // Mining supply (not generated in the initial phase)\n    uint256 public constant MINING_SUPPLY = 500000000 * 10**decimals;\n\n    // Maximum supply for public funding\n    uint256 public constant MAX_FUNDING_SUPPLY = 200000000 * 10**decimals;\n\n    // Team keeping supply\n    uint256 public constant TEAM_KEEPING = 200000000 * 10**decimals;\n\n    // Total maximum supply\n    uint256 public constant MAX_SUPPLY = INIT_SUPPLY + MINING_SUPPLY + MAX_FUNDING_SUPPLY + TEAM_KEEPING;\n\n    // Public funding parameters\n    uint256 public totalFundingSupply;\n    uint256 public startTime;\n    uint256 public endTime;\n    uint256 public rate;\n\n    // Team unfreezing parameters\n    uint256 public constant TEAM_UNFREEZE = 40000000 * 10**decimals;\n    bool public hasOneStepWithdraw;\n    bool public hasTwoStepWithdraw;\n    bool public hasThreeStepWithdraw;\n    bool public hasFourStepWithdraw;\n    bool public hasFiveStepWithdraw;\n\n    // ERC20 balances\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    /**\n     * @notice Constructor initializes the token with the initial supply and sets up the public funding parameters.\n     * @dev Sets the initial supply, balances, and funding parameters.\n     */\n    function BTMC() {\n        totalSupply = INIT_SUPPLY;\n        balances[msg.sender] = INIT_SUPPLY;\n        Transfer(0x0, msg.sender, INIT_SUPPLY);\n        totalFundingSupply = 0;\n        startTime = 1524499199; // 2018-04-23 23:59:59\n        endTime = 1526313600;   // 2018-05-15 00:00:00\n        rate = 5000;\n        hasOneStepWithdraw = false;\n        hasTwoStepWithdraw = false;\n        hasThreeStepWithdraw = false;\n        hasFourStepWithdraw = false;\n        hasFiveStepWithdraw = false;\n    }\n\n    event CreateBTMC(address indexed _to, uint256 _value);\n\n    /**\n     * @dev Modifier to ensure the total supply does not exceed the maximum supply.\n     */\n    modifier notReachTotalSupply(uint256 _value, uint256 _rate) {\n        assert(MAX_SUPPLY >= totalSupply.add(_value.mul(_rate)));\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the total funding supply does not exceed the maximum funding supply.\n     */\n    modifier notReachFundingSupply(uint256 _value, uint256 _rate) {\n        assert(MAX_FUNDING_SUPPLY >= totalFundingSupply.add(_value.mul(_rate)));\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure a boolean status is false.\n     */\n    modifier assertFalse(bool withdrawStatus) {\n        assert(!withdrawStatus);\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the current time is after a target time.\n     */\n    modifier notBeforeTime(uint256 targetTime) {\n        assert(now > targetTime);\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the current time is before or equal to a target time.\n     */\n    modifier notAfterTime(uint256 targetTime) {\n        assert(now <= targetTime);\n        _;\n    }\n\n    /**\n     * @notice Allows the owner to withdraw ETH from the contract.\n     * @dev Only the owner can call this function.\n     */\n    function etherProceeds() external onlyOwner {\n    }\n\n    /**\n     * @notice Internal function to process token funding.\n     * @dev Ensures the total supply does not exceed the maximum supply.\n     */\n    function processFunding(address receiver, uint256 _value, uint256 _rate) internal notReachTotalSupply(_value, _rate) {\n    }\n\n    /**\n     * @notice Internal function to handle public funding.\n     * @dev Ensures the total funding supply does not exceed the maximum funding supply.\n     */\n    function funding(address receiver, uint256 _value, uint256 _rate) whenNotPaused internal notReachFundingSupply(_value, _rate) {\n    }\n\n    /**\n     * @notice Fallback function to handle ETH payments during the funding period.\n     * @dev Ensures the current time is within the funding period.\n     */\n    function () payable external notBeforeTime(startTime) notAfterTime(endTime) {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the first step of team tokens.\n     * @dev Ensures the current time is after the specified date and the withdrawal has not been done.\n     */\n    function withdrawForOneStep() external onlyOwner assertFalse(hasOneStepWithdraw) notBeforeTime(1587571200) {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the second step of team tokens.\n     * @dev Ensures the current time is after the specified date and the withdrawal has not been done.\n     */\n    function withdrawForTwoStep() external onlyOwner assertFalse(hasTwoStepWithdraw) notBeforeTime(1603382400) {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the third step of team tokens.\n     * @dev Ensures the current time is after the specified date and the withdrawal has not been done.\n     */\n    function withdrawForThreeStep() external onlyOwner assertFalse(hasThreeStepWithdraw) notBeforeTime(1619107200) {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the fourth step of team tokens.\n     * @dev Ensures the current time is after the specified date and the withdrawal has not been done.\n     */\n    function withdrawForFourStep() external onlyOwner assertFalse(hasFourStepWithdraw) notBeforeTime(1634918400) {\n    }\n\n    /**\n     * @notice Allows the owner to withdraw the fifth step of team tokens.\n     * @dev Ensures the current time is after the specified date and the withdrawal has not been done.\n     */\n    function withdrawForFiveStep() external onlyOwner assertFalse(hasFiveStepWithdraw) notBeforeTime(1650643200) {\n    }\n\n    /**\n     * @notice Transfers tokens from the sender to the recipient.\n     * @dev Ensures the transfer is valid and updates the balances.\n     */\n    function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) {\n    }\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @dev Returns the token balance of the given address.\n     */\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n    }\n\n    /**\n     * @notice Transfers tokens from one address to another using an allowance.\n     * @dev Ensures the transfer is valid and updates the balances and allowances.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) {\n    }\n\n    /**\n     * @notice Approves an address to spend a certain amount of tokens on behalf of the owner.\n     * @dev Sets the allowance for the spender.\n     */\n    function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) {\n    }\n\n    /**\n     * @notice Returns the remaining allowance of a spender for a given owner.\n     * @dev Returns the remaining allowance.\n     */\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    }\n\n    /**\n     * @notice Allows the owner to set the funding rate.\n     * @dev Only the owner can call this function.\n     */\n    function setupFundingRate(uint256 _rate) external onlyOwner {\n    }\n\n    /**\n     * @notice Allows the owner to set the funding start and end times.\n     * @dev Only the owner can call this function.\n     */\n    function setupFundingTime(uint256 _startTime, uint256 _endTime) external onlyOwner {\n    }\n}\n"
}