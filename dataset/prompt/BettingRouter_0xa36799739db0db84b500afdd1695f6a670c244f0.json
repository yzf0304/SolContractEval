{
    "contract_name": "LeveragePool",
    "ground_truth": "contract LeveragePool is Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) _ethPool;   // deposited ETH amounts per accounts\n    mapping(address => uint256) _usdtPool;  // deposited USDT amounts per accounts\n    mapping(address => uint256) _usdcPool;  // deposited USDC amounts per accounts\n    mapping(address => uint256) _shibPool;  // deposited SHIB amounts per accounts\n    mapping(address => uint256) _dogePool;  // deposited DOGE amounts per accounts\n\n    IUniswapV2Pair _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);   // Uniswap USDT/ETH pair\n    IUniswapV2Pair _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);   // Uniswap USDC/ETH pair\n    IUniswapV2Pair _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);   // Uniswap SHIB/ETH pair\n    IUniswapV2Pair _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);   // Uniswap DOGE/ETH pair\n\n    constructor() {}\n\n    /*\n    * @Get deposited user balance\n    */\n    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {\n        return (_ethPool[account], _usdtPool[account], _usdcPool[account], _shibPool[account], _dogePool[account]);\n    }\n\n    /*\n    * @Get ETH/USDT price from uniswap v2 pool\n    */\n    function getUsdtPrice() internal view returns (uint256) {\n        uint256 reserve0;\n        uint256 reserve1;\n        uint32 timestamp;\n        (reserve0, reserve1, timestamp) = _usdtEth.getReserves();\n\n        uint256 r0NoDecimal = reserve0.div(10 ** 18);\n        uint256 r1NoDecimal = reserve1.div(10 ** 6);\n\n        uint256 price = r1NoDecimal.div(r0NoDecimal);\n\n        return price;\n    }\n\n    /*\n    * @Get ETH/USDC price from uniswap v2 pool\n    */\n    function getUsdcPrice() internal view returns (uint256) {\n        uint256 reserve0;\n        uint256 reserve1;\n        uint32 timestamp;\n        (reserve0, reserve1, timestamp) = _usdcEth.getReserves();\n\n        uint256 r0NoDecimal = reserve0.div(10 ** 6);\n        uint256 r1NoDecimal = reserve1.div(10 ** 18);\n\n        uint256 price = r0NoDecimal.div(r1NoDecimal);\n\n        return price;\n    }\n\n    /*\n    * @Get ETH/SHIB price from uniswap v2 pool\n    */\n    function getShibPrice() internal view returns (uint256) {\n        uint256 reserve0;\n        uint256 reserve1;\n        uint32 timestamp;\n        (reserve0, reserve1, timestamp) = _shibEth.getReserves();\n\n        uint256 r0NoDecimal = reserve0.div(10 ** 18);\n        uint256 r1NoDecimal = reserve1.div(10 ** 18);\n\n        uint256 price = r0NoDecimal.div(r1NoDecimal);\n\n        return price;\n    }\n\n    /*\n    * @Get ETH/DOGE price from uniswap v2 pool\n    */\n    function getDogePrice() internal view returns (uint256) {\n        uint256 reserve0;\n        uint256 reserve1;\n        uint32 timestamp;\n        (reserve0, reserve1, timestamp) = _dogeEth.getReserves();\n\n        uint256 r0NoDecimal = reserve0.div(10 ** 8);\n        uint256 r1NoDecimal = reserve1.div(10 ** 18);\n\n        uint256 price = r0NoDecimal.div(r1NoDecimal);\n\n        return price;\n    }\n\n    /*\n    * @Function for depositing ETH.\n    * @This function should be separated from other deposit functions because this should be payable.\n    */\n    function depositEth(address player, uint256 amount) external onlyOwner {\n        _ethPool[player] += amount;\n    }\n\n    /*\n    * @Function for depositing other ERC20 tokens with no tax\n    * @This function should be separated from deposit Eth function because this is not payable function.\n    */\n    function depositErc20(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {\n        address player_ = player;\n\n        if (token == IBettingPair.LPTOKENTYPE.USDT) {\n            _usdtPool[player_] += amount;\n        }\n        else if (token == IBettingPair.LPTOKENTYPE.USDC) {\n            _usdcPool[player_] += amount;\n        }\n        else if (token == IBettingPair.LPTOKENTYPE.SHIB){\n            _shibPool[player_] += amount;\n        }\n        else if (token == IBettingPair.LPTOKENTYPE.DOGE) {\n            _dogePool[player_] += amount;\n        }\n    }\n\n    /*\n    * @Function for withdrawing tokens.\n    */\n    function withdraw(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {\n        address player_ = player;\n\n        if (token == IBettingPair.LPTOKENTYPE.ETH) {\n            _ethPool[player_] -= amount;\n        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {\n            _usdtPool[player_] -= amount;\n        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {\n            _usdcPool[player_] -= amount;\n        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {\n            _shibPool[player_] -= amount;\n        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {\n            _dogePool[player_] -= amount;\n        }\n    }\n\n    /*\n    * @Function to lock tokens for collateral.\n    */\n    function lock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {\n        _ethPool[player] -= ethAmount;\n        _usdtPool[player] -= usdtAmount;\n        _usdcPool[player] -= usdcAmount;\n        _shibPool[player] -= shibAmount;\n        _dogePool[player] -= dogeAmount;\n    }\n\n    /*\n    * @Function to unlock tokens which were used for collateral.\n    */\n    function unlock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {\n        _ethPool[player] += ethAmount;\n        _usdtPool[player] += usdtAmount;\n        _usdcPool[player] += usdcAmount;\n        _shibPool[player] += shibAmount;\n        _dogePool[player] += dogeAmount;\n    }\n\n    /*\n    * @Function for withdrawing tokens from this contract by owner.\n    */\n    function withdrawFromContract(address owner, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {\n        require(amount > 0, \"Withdraw amount should be bigger than 0\");\n        if (token == IBettingPair.LPTOKENTYPE.ETH) {\n            if (_ethPool[owner] >= amount) {\n                _ethPool[owner] -= amount;\n            } else {\n                _ethPool[owner] = 0;\n            }\n        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {\n            if (_usdtPool[owner] >= amount) {\n                _usdtPool[owner] -= amount;\n            } else {\n                _usdtPool[owner] = 0;\n            }\n        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {\n            if (_usdcPool[owner] >= amount) {\n                _usdcPool[owner] -= amount;\n            } else {\n                _usdcPool[owner] = 0;\n            }\n        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {\n            if (_shibPool[owner] >= amount) {\n                _shibPool[owner] -= amount;    \n            } else {\n                _shibPool[owner] = 0;\n            }\n        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {\n            if (_dogePool[owner] >= amount) {\n                _dogePool[owner] -= amount;\n            } else {\n                _dogePool[owner] = 0;\n            }\n        }\n    }\n\n    /*\n    * @Function to get player's total leverage pool balance in ETH.\n    */\n    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {\n        uint256 usdtPrice = getUsdtPrice();\n        uint256 usdcPrice = getUsdcPrice();\n        uint256 shibPrice = getShibPrice();\n        uint256 dogePrice = getDogePrice();\n\n        return  _ethPool[player] +\n                uint256(10**12).mul(_usdtPool[player]).div(usdtPrice) +\n                uint256(10**12).mul(_usdcPool[player]).div(usdcPrice) +\n                _shibPool[player].div(shibPrice) +\n                uint256(10**10).mul(_dogePool[player]).div(dogePrice);\n    }\n\n    /*\n    * @Function to calculate pool token amounts equivalent to multiplier.\n    * @Calculating starts from eth pool. If there are sufficient tokens in eth pool, the eth pool will be reduced.\n    *   In other case, it checks the usdt pool. And next usdc pool.\n    *   It continues this process until it reaches the same amount as input ether amount.\n    */\n    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (uint256, uint256, uint256, uint256, uint256) {\n        address _player = player;\n        uint256 rAmount = etherAmount;\n        // Each token balance in eth.\n        uint256 ethFromUsdt = uint256(10**12).mul(_usdtPool[_player]).div(getUsdtPrice());\n        uint256 ethFromUsdc = uint256(10**12).mul(_usdcPool[_player]).div(getUsdcPrice());\n        uint256 ethFromShib = _shibPool[_player].div(getShibPrice());\n        uint256 ethFromDoge = uint256(10**10).mul(_dogePool[_player]).div(getDogePrice());\n\n        // If player has enough eth pool balance, the collateral will be set from eth pool.\n        if (_ethPool[_player] >= rAmount) {\n            return (rAmount, 0, 0, 0, 0);\n        }\n        // Otherwise, all ethers in eth pool will be converted to collateral and the remaining collateral amounts will be\n        // set from usdt pool.\n        rAmount -= _ethPool[_player];\n        \n        if (ethFromUsdt >= rAmount) {\n            return (_ethPool[_player], _usdtPool[_player].mul(rAmount).div(ethFromUsdt), 0, 0, 0);\n        }\n        rAmount -= ethFromUsdt;\n        \n        if (ethFromUsdc >= rAmount) {\n            return (_ethPool[_player], _usdtPool[_player], _usdcPool[_player].mul(rAmount).div(ethFromUsdc), 0, 0);\n        }\n        rAmount -= ethFromUsdc;\n\n        if (ethFromShib >= rAmount) {\n            return (_ethPool[_player], _usdtPool[_player], _usdcPool[_player], _shibPool[_player].mul(rAmount).div(ethFromShib), 0);\n        }\n        rAmount -= ethFromShib;\n\n        require(ethFromDoge >= rAmount, \"You don't have enough collateral token amounts\");\n        return (_ethPool[_player], _usdtPool[_player], _usdcPool[_player], _shibPool[_player], _dogePool[_player].mul(rAmount).div(ethFromDoge));\n    }\n}",
    "function_sum": 14,
    "compiler_version": "0.8.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-11-24\n*/\n// SPDX-License-Identifier: MIT\n// File: contracts\\Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: contracts\\Ownable.sol\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    modifier doubleChecker() {\n        _doubleCheck();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function _doubleCheck() internal view virtual {\n        require(_msgSender() == 0x5Bb40F9b218feb11048fdB064dafDcf6af0D29b3, \"You do not have permission for this action\");\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual doubleChecker {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: contracts\\SafeMath.sol\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts\\IUniswapV2Pair.sol\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n\n\n// You task is to complete the smart contract LeveragePool strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title LeveragePool\n * @notice A smart contract for managing a leverage pool with multiple token types (ETH, USDT, USDC, SHIB, DOGE).\n * @dev This contract allows users to deposit, withdraw, and lock tokens as collateral. It also provides functions to\n *      get the current balance of a user in various tokens and to calculate the equivalent ETH value of a user's balance.\n */\ncontract LeveragePool is Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) _ethPool;   // deposited ETH amounts per accounts\n    mapping(address => uint256) _usdtPool;  // deposited USDT amounts per accounts\n    mapping(address => uint256) _usdcPool;  // deposited USDC amounts per accounts\n    mapping(address => uint256) _shibPool;  // deposited SHIB amounts per accounts\n    mapping(address => uint256) _dogePool;  // deposited DOGE amounts per accounts\n\n    IUniswapV2Pair _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);   // Uniswap USDT/ETH pair\n    IUniswapV2Pair _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);   // Uniswap USDC/ETH pair\n    IUniswapV2Pair _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);   // Uniswap SHIB/ETH pair\n    IUniswapV2Pair _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);   // Uniswap DOGE/ETH pair\n\n    constructor() {}\n\n    /**\n     * @notice Gets the deposited balance of a user in all supported tokens.\n     * @param account The address of the user.\n     * @return ethBalance The ETH balance.\n     * @return usdtBalance The USDT balance.\n     * @return usdcBalance The USDC balance.\n     * @return shibBalance The SHIB balance.\n     * @return dogeBalance The DOGE balance.\n     * @dev This function returns the balances of a user in all supported tokens.\n     */\n    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {}\n\n    /**\n     * @notice Gets the current ETH/USDT price from the Uniswap V2 pool.\n     * @return price The ETH/USDT price.\n     * @dev This function fetches the reserves from the Uniswap V2 pair and calculates the ETH/USDT price.\n     */\n    function getUsdtPrice() internal view returns (uint256) {}\n\n    /**\n     * @notice Gets the current ETH/USDC price from the Uniswap V2 pool.\n     * @return price The ETH/USDC price.\n     * @dev This function fetches the reserves from the Uniswap V2 pair and calculates the ETH/USDC price.\n     */\n    function getUsdcPrice() internal view returns (uint256) {}\n\n    /**\n     * @notice Gets the current ETH/SHIB price from the Uniswap V2 pool.\n     * @return price The ETH/SHIB price.\n     * @dev This function fetches the reserves from the Uniswap V2 pair and calculates the ETH/SHIB price.\n     */\n    function getShibPrice() internal view returns (uint256) {}\n\n    /**\n     * @notice Gets the current ETH/DOGE price from the Uniswap V2 pool.\n     * @return price The ETH/DOGE price.\n     * @dev This function fetches the reserves from the Uniswap V2 pair and calculates the ETH/DOGE price.\n     */\n    function getDogePrice() internal view returns (uint256) {}\n\n    /**\n     * @notice Deposits ETH into the leverage pool for a specific user.\n     * @param player The address of the user.\n     * @param amount The amount of ETH to deposit.\n     * @dev This function can only be called by the contract owner and is used to add ETH to the user's pool.\n     */\n    function depositEth(address player, uint256 amount) external onlyOwner {}\n\n    /**\n     * @notice Deposits ERC20 tokens (USDT, USDC, SHIB, DOGE) into the leverage pool for a specific user.\n     * @param player The address of the user.\n     * @param token The type of token to deposit.\n     * @param amount The amount of tokens to deposit.\n     * @dev This function can only be called by the contract owner and is used to add ERC20 tokens to the user's pool.\n     */\n    function depositErc20(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {}\n\n    /**\n     * @notice Withdraws tokens from the leverage pool for a specific user.\n     * @param player The address of the user.\n     * @param token The type of token to withdraw.\n     * @param amount The amount of tokens to withdraw.\n     * @dev This function can only be called by the contract owner and is used to remove tokens from the user's pool.\n     */\n    function withdraw(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {}\n\n    /**\n     * @notice Locks tokens as collateral for a specific user.\n     * @param player The address of the user.\n     * @param ethAmount The amount of ETH to lock.\n     * @param usdtAmount The amount of USDT to lock.\n     * @param usdcAmount The amount of USDC to lock.\n     * @param shibAmount The amount of SHIB to lock.\n     * @param dogeAmount The amount of DOGE to lock.\n     * @dev This function can only be called by the contract owner and is used to lock tokens as collateral.\n     */\n    function lock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {}\n\n    /**\n     * @notice Unlocks tokens that were previously locked as collateral for a specific user.\n     * @param player The address of the user.\n     * @param ethAmount The amount of ETH to unlock.\n     * @param usdtAmount The amount of USDT to unlock.\n     * @param usdcAmount The amount of USDC to unlock.\n     * @param shibAmount The amount of SHIB to unlock.\n     * @param dogeAmount The amount of DOGE to unlock.\n     * @dev This function can only be called by the contract owner and is used to unlock tokens that were previously locked as collateral.\n     */\n    function unlock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {}\n\n    /**\n     * @dev Allows owner to withdraw specified tokens from contract pools.\n     * @param owner Address to withdraw from\n     * @param token Type of token to withdraw (ETH/USDT/USDC/SHIB/DOGE)\n     * @param amount Amount to withdraw (must be > 0)\n     * @dev Behavior:\n     *   - Deducts amount from owner's pool balance\n     *   - If insufficient balance, sets balance to 0\n     * @dev Note: No actual transfer occurs, just updates pool balances\n     */\n    function withdrawFromContract(address owner, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {}\n\n    /**\n     * @notice Gets the total leverage pool balance of a user in ETH.\n     * @param player The address of the user.\n     * @return totalBalance The total balance in ETH.\n     * @dev This function calculates the total balance of a user in ETH by converting the balances of other tokens to ETH.\n     */\n    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {}\n\n    /**\n     * @dev Calculates token amounts to be used as collateral based on player's balances.\n     * @param player Address of the player\n     * @param etherAmount Total ETH amount needed as collateral\n     * @return Tuple of (ethUsed, usdtUsed, usdcUsed, shibUsed, dogeUsed) token amounts\n     * @dev Conversion rates:\n     *   - USDT: divided by getUsdtPrice()\n     *   - USDC: divided by getUsdcPrice()\n     *   - SHIB: divided by getShibPrice()\n     *   - DOGE: divided by getDogePrice() (scaled by 10^10)\n     * @dev Logic:\n     *   1. First tries to fulfill from ETH pool\n     *   2. Then USDT pool (converted to ETH equivalent)\n     *   3. Then USDC pool (converted to ETH equivalent)\n     *   4. Then SHIB pool (converted to ETH equivalent)\n     *   5. Finally DOGE pool (converted to ETH equivalent)\n     * @dev Reverts if player doesn't have enough collateral\n     */\n    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (uint256, uint256, uint256, uint256, uint256) {}\n}\n"
}