{
    "contract_name": "BotMinting",
    "ground_truth": "contract BotMinting is BotAuction {\n\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\n\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n    uint256 public constant GEN0_STARTING_PRICE = 10 finney;\n\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n\n    uint256 public promoCreatedCount;\n\n    uint256 public gen0CreatedCount;\n\n\n\n    function createPromoBot(uint256 _genes, address _owner) external onlyCOO {\n\n        address botOwner = _owner;\n\n        if (botOwner == address(0)) {\n\n            botOwner = cooAddress;\n\n        }\n\n        require(promoCreatedCount < PROMO_CREATION_LIMIT);\n\n\n\n        promoCreatedCount++;\n\n        _createBot(0, 0, 0, _genes, botOwner);\n\n    }\n\n\n\n    function createGen0Auction(uint256 _genes) external onlyCOO {\n\n        require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n\n\n\n        uint256 botId = _createBot(0, 0, 0, _genes, address(this));\n\n        _approve(botId, saleAuction);\n\n\n\n        saleAuction.createAuction(\n\n            botId,\n\n            _computeNextGen0Price(),\n\n            0,\n\n            GEN0_AUCTION_DURATION,\n\n            address(this)\n\n        );\n\n\n\n        gen0CreatedCount++;\n\n    }\n\n\n\n    function _computeNextGen0Price() internal view returns (uint256) {\n\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\n\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice + (avePrice / 2);\n\n        if (nextPrice < GEN0_STARTING_PRICE) {\n\n            nextPrice = GEN0_STARTING_PRICE;\n\n        }\n\n        return nextPrice;\n\n    }\n\n}",
    "function_sum": 3,
    "compiler_version": "0.4.20",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract ERC721 {\n\n    function totalSupply() public view returns (uint256 total);\n\n    function balanceOf(address _owner) public view returns (uint256 balance);\n\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n\n    function approve(address _to, uint256 _tokenId) external;\n\n    function transfer(address _to, uint256 _tokenId) external;\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    event Transfer(address from, address to, uint256 tokenId);\n\n    event Approval(address owner, address approved, uint256 tokenId);\n\n}\n\ncontract GeneScienceInterface {\n\n    function isGeneScience() public pure returns (bool);\n\n    function mixGenes(uint256 genes1, uint256 genes2, uint256 targetBlock) public returns (uint256);\n\n}\n\ncontract BotAccessControl {\n\n    event ContractUpgrade(address newContract);\n\n    address public ceoAddress;\n\n    address public cfoAddress;\n\n    address public cooAddress;\n\n    bool public paused = false;\n\n\n\n    modifier onlyCEO() {\n\n        require(msg.sender == ceoAddress);\n\n        _;\n\n    }\n\n\n\n    modifier onlyCFO() {\n\n        require(msg.sender == cfoAddress);\n\n        _;\n\n    }\n\n\n\n    modifier onlyCOO() {\n\n        require(msg.sender == cooAddress);\n\n        _;\n\n    }\n\n\n\n    modifier onlyCLevel() {\n\n        require(\n\n            msg.sender == cooAddress ||\n\n            msg.sender == ceoAddress ||\n\n            msg.sender == cfoAddress\n\n        );\n\n        _;\n\n    }\n\n\n\n    function setCEO(address _newCEO) external onlyCEO {\n\n        require(_newCEO != address(0));\n\n\n\n        ceoAddress = _newCEO;\n\n    }\n\n\n\n    function setCFO(address _newCFO) external onlyCEO {\n\n        require(_newCFO != address(0));\n\n\n\n        cfoAddress = _newCFO;\n\n    }\n\n\n\n    function setCOO(address _newCOO) external onlyCEO {\n\n        require(_newCOO != address(0));\n\n\n\n        cooAddress = _newCOO;\n\n    }\n\n\n\n    modifier whenNotPaused() {\n\n        require(!paused);\n\n        _;\n\n    }\n\n\n\n    modifier whenPaused {\n\n        require(paused);\n\n        _;\n\n    }\n\n\n\n    function pause() external onlyCLevel whenNotPaused {\n\n        paused = true;\n\n    }\n\n\n\n    function unpause() public onlyCEO whenPaused {\n\n        paused = false;\n\n    }\n\n}\n\ncontract BotBase is BotAccessControl {\n\n    event Birth(\n\n      address owner,\n\n      uint256 botId,\n\n      uint256 matronId,\n\n      uint256 sireId,\n\n      uint256 genes,\n\n      uint256 birthTime\n\n    );\n\n\n\n    event Transfer(address from, address to, uint256 tokenId);\n\n\n\n    struct Bot {\n\n        uint256 genes;\n\n        uint64 birthTime;\n\n        uint64 cooldownEndBlock;\n\n        uint32 matronId;\n\n        uint32 sireId;\n\n        uint32 siringWithId;\n\n        uint16 cooldownIndex;\n\n        uint16 generation;\n\n    }\n\n\n\n    uint32[14] public cooldowns = [\n\n        uint32(1 minutes),\n\n        uint32(2 minutes),\n\n        uint32(5 minutes),\n\n        uint32(10 minutes),\n\n        uint32(30 minutes),\n\n        uint32(1 hours),\n\n        uint32(2 hours),\n\n        uint32(4 hours),\n\n        uint32(8 hours),\n\n        uint32(16 hours),\n\n        uint32(1 days),\n\n        uint32(2 days),\n\n        uint32(4 days),\n\n        uint32(7 days)\n\n    ];\n\n\n\n    uint256 public secondsPerBlock = 15;\n\n\n\n    Bot[] bots;\n\n\n\n    mapping (uint256 => address) public botIndexToOwner;\n\n    mapping (address => uint256) ownershipTokenCount;\n\n    mapping (uint256 => address) public botIndexToApproved;\n\n    mapping (uint256 => address) public sireAllowedToAddress;\n\n    uint32 public destroyedBots;\n\n    SaleClockAuction public saleAuction;\n\n    SiringClockAuction public siringAuction;\n\n\n\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n\n        if (_to == address(0)) {\n\n            delete botIndexToOwner[_tokenId];\n\n        } else {\n\n            ownershipTokenCount[_to]++;\n\n            botIndexToOwner[_tokenId] = _to;\n\n        }\n\n        if (_from != address(0)) {\n\n            ownershipTokenCount[_from]--;\n\n            delete sireAllowedToAddress[_tokenId];\n\n            delete botIndexToApproved[_tokenId];\n\n        }\n\n        Transfer(_from, _to, _tokenId);\n\n    }\n\n\n\n    function _createBot(\n\n        uint256 _matronId,\n\n        uint256 _sireId,\n\n        uint256 _generation,\n\n        uint256 _genes,\n\n        address _owner\n\n    )\n\n        internal\n\n        returns (uint)\n\n    {\n\n        require(_matronId == uint256(uint32(_matronId)));\n\n        require(_sireId == uint256(uint32(_sireId)));\n\n        require(_generation == uint256(uint16(_generation)));\n\n\n\n        uint16 cooldownIndex = uint16(_generation / 2);\n\n        if (cooldownIndex > 13) {\n\n            cooldownIndex = 13;\n\n        }\n\n\n\n        Bot memory _bot = Bot({\n\n            genes: _genes,\n\n            birthTime: uint64(now),\n\n            cooldownEndBlock: 0,\n\n            matronId: uint32(_matronId),\n\n            sireId: uint32(_sireId),\n\n            siringWithId: 0,\n\n            cooldownIndex: cooldownIndex,\n\n            generation: uint16(_generation)\n\n        });\n\n        uint256 newBotId = bots.push(_bot) - 1;\n\n\n\n        require(newBotId == uint256(uint32(newBotId)));\n\n\n\n        Birth(\n\n            _owner,\n\n            newBotId,\n\n            uint256(_bot.matronId),\n\n            uint256(_bot.sireId),\n\n            _bot.genes,\n\n            uint256(_bot.birthTime)\n\n       );\n\n\n\n        _transfer(0, _owner, newBotId);\n\n\n\n        return newBotId;\n\n    }\n\n\n\n    function _destroyBot(uint256 _botId) internal {\n\n        require(_botId > 0);\n\n        address from = botIndexToOwner[_botId];\n\n        require(from != address(0));\n\n        destroyedBots++;\n\n        _transfer(from, 0, _botId);\n\n    }\n\n\n\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\n\n        require(secs < cooldowns[0]);\n\n        secondsPerBlock = secs;\n\n    }\n\n}\n\ncontract BotExtension is BotBase {\n\n    event Lock(uint256 botId, uint16 mask);\n\n    mapping (address => bool) extensions;\n\n    mapping (uint256 => uint16) locks;\n\n    uint16 constant LOCK_BREEDING = 1;\n\n    uint16 constant LOCK_TRANSFER = 2;\n\n    uint16 constant LOCK_ALL = LOCK_BREEDING | LOCK_TRANSFER;\n\n\n\n    function addExtension(address _contract) external onlyCEO {\n\n        extensions[_contract] = true;\n\n    }\n\n\n\n    function removeExtension(address _contract) external onlyCEO {\n\n        delete extensions[_contract];\n\n    }\n\n\n\n    modifier onlyExtension() {\n\n        require(extensions[msg.sender] == true);\n\n        _;\n\n    }\n\n\n\n    function extCreateBot(\n\n        uint256 _matronId,\n\n        uint256 _sireId,\n\n        uint256 _generation,\n\n        uint256 _genes,\n\n        address _owner\n\n    )\n\n        public\n\n        onlyExtension\n\n        returns (uint)\n\n    {\n\n        return _createBot(_matronId, _sireId, _generation, _genes, _owner);\n\n    }\n\n\n\n    function extDestroyBot(uint256 _botId)\n\n        public\n\n        onlyExtension\n\n    {\n\n        require(locks[_botId] == 0);\n\n\n\n        _destroyBot(_botId);\n\n    }\n\n\n\n    function extLockBot(uint256 _botId, uint16 _mask)\n\n        public\n\n        onlyExtension\n\n    {\n\n        _lockBot(_botId, _mask);\n\n    }\n\n\n\n    function _lockBot(uint256 _botId, uint16 _mask)\n\n        internal\n\n    {\n\n        require(_mask > 0);\n\n\n\n        uint16 mask = locks[_botId];\n\n        require(mask & _mask == 0);\n\n\n\n        if (_mask & LOCK_BREEDING > 0) {\n\n            Bot storage bot = bots[_botId];\n\n            require(bot.siringWithId == 0);\n\n        }\n\n\n\n        if (_mask & LOCK_TRANSFER > 0) {\n\n            address owner = botIndexToOwner[_botId];\n\n            require(owner != address(saleAuction));\n\n            require(owner != address(siringAuction));\n\n        }\n\n\n\n        mask |= _mask;\n\n\n\n        locks[_botId] = mask;\n\n\n\n        Lock(_botId, mask);\n\n    }\n\n\n\n    function extUnlockBot(uint256 _botId, uint16 _mask)\n\n        public\n\n        onlyExtension\n\n        returns (uint16)\n\n    {\n\n        _unlockBot(_botId, _mask);\n\n    }\n\n\n\n    function _unlockBot(uint256 _botId, uint16 _mask)\n\n        internal\n\n    {\n\n        require(_mask > 0);\n\n\n\n        uint16 mask = locks[_botId];\n\n        require(mask & _mask == _mask);\n\n        mask ^= _mask;\n\n\n\n        locks[_botId] = mask;\n\n\n\n        Lock(_botId, mask);\n\n    }\n\n\n\n    function extGetLock(uint256 _botId)\n\n        public\n\n        view\n\n        onlyExtension\n\n        returns (uint16)\n\n    {\n\n        return locks[_botId];\n\n    }\n\n}\n\ncontract BotOwnership is BotExtension, ERC721 {\n\n    string public constant name = \"CryptoBots\";\n\n    string public constant symbol = \"CBT\";\n\n\n\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n\n        return botIndexToOwner[_tokenId] == _claimant;\n\n    }\n\n\n\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n\n        return botIndexToApproved[_tokenId] == _claimant;\n\n    }\n\n\n\n    function _approve(uint256 _tokenId, address _approved) internal {\n\n        botIndexToApproved[_tokenId] = _approved;\n\n    }\n\n\n\n    function balanceOf(address _owner) public view returns (uint256 count) {\n\n        return ownershipTokenCount[_owner];\n\n    }\n\n\n\n    function transfer(\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_to != address(0));\n\n        require(_to != address(this));\n\n        require(_to != address(saleAuction));\n\n        require(_to != address(siringAuction));\n\n        require(_owns(msg.sender, _tokenId));\n\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\n\n        _transfer(msg.sender, _to, _tokenId);\n\n    }\n\n\n\n    function approve(\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_owns(msg.sender, _tokenId));\n\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\n\n        _approve(_tokenId, _to);\n\n        Approval(msg.sender, _to, _tokenId);\n\n    }\n\n\n\n    function transferFrom(\n\n        address _from,\n\n        address _to,\n\n        uint256 _tokenId\n\n    )\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_to != address(0));\n\n        require(_to != address(this));\n\n        require(_approvedFor(msg.sender, _tokenId));\n\n        require(_owns(_from, _tokenId));\n\n        require(locks[_tokenId] & LOCK_TRANSFER == 0);\n\n        _transfer(_from, _to, _tokenId);\n\n    }\n\n\n\n    function totalSupply() public view returns (uint) {\n\n        return bots.length - destroyedBots;\n\n    }\n\n\n\n    function ownerOf(uint256 _tokenId)\n\n        external\n\n        view\n\n        returns (address owner)\n\n    {\n\n        owner = botIndexToOwner[_tokenId];\n\n        require(owner != address(0));\n\n    }\n\n\n\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n\n        uint256 tokenCount = balanceOf(_owner);\n\n\n\n        if (tokenCount == 0) {\n\n            return new uint256[](0);\n\n        } else {\n\n            uint256[] memory result = new uint256[](tokenCount);\n\n            uint256 totalBots = bots.length - 1;\n\n            uint256 resultIndex = 0;\n\n            uint256 botId;\n\n            for (botId = 0; botId <= totalBots; botId++) {\n\n                if (botIndexToOwner[botId] == _owner) {\n\n                    result[resultIndex] = botId;\n\n                    resultIndex++;\n\n                }\n\n            }\n\n\n\n            return result;\n\n        }\n\n    }\n\n}\n\ncontract BotBreeding is BotOwnership {\n\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\n\n    uint256 public autoBirthFee = 2 finney;\n\n    uint256 public pregnantBots;\n\n    GeneScienceInterface public geneScience;\n\n\n\n    function setGeneScienceAddress(address _address) external onlyCEO {\n\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n\n        require(candidateContract.isGeneScience());\n\n        geneScience = candidateContract;\n\n    }\n\n\n\n    function _isReadyToBreed(uint256 _botId, Bot _bot) internal view returns (bool) {\n\n        return\n\n            (_bot.siringWithId == 0) &&\n\n            (_bot.cooldownEndBlock <= uint64(block.number)) &&\n\n            (locks[_botId] & LOCK_BREEDING == 0);\n\n    }\n\n\n\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns (bool) {\n\n        address matronOwner = botIndexToOwner[_matronId];\n\n        address sireOwner = botIndexToOwner[_sireId];\n\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\n\n    }\n\n\n\n    function _triggerCooldown(Bot storage _bot) internal {\n\n        _bot.cooldownEndBlock = uint64((cooldowns[_bot.cooldownIndex]/secondsPerBlock) + block.number);\n\n        if (_bot.cooldownIndex < 13) {\n\n            _bot.cooldownIndex += 1;\n\n        }\n\n    }\n\n\n\n    function approveSiring(address _addr, uint256 _sireId)\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_owns(msg.sender, _sireId));\n\n        sireAllowedToAddress[_sireId] = _addr;\n\n    }\n\n\n\n    function setAutoBirthFee(uint256 val) external onlyCOO {\n\n        autoBirthFee = val;\n\n    }\n\n\n\n    function _isReadyToGiveBirth(Bot _matron) private view returns (bool) {\n\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\n\n    }\n\n\n\n    function isReadyToBreed(uint256 _botId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        Bot storage bot = bots[_botId];\n\n        return _botId > 0 && _isReadyToBreed(_botId, bot);\n\n    }\n\n\n\n    function isPregnant(uint256 _botId)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return _botId > 0 && bots[_botId].siringWithId != 0;\n\n    }\n\n\n\n    function _isValidMatingPair(\n\n        Bot storage _matron,\n\n        uint256 _matronId,\n\n        Bot storage _sire,\n\n        uint256 _sireId\n\n    )\n\n        private\n\n        view\n\n        returns(bool)\n\n    {\n\n        if (_matronId == _sireId) {\n\n            return false;\n\n        }\n\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\n\n            return false;\n\n        }\n\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\n\n            return false;\n\n        }\n\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\n\n            return true;\n\n        }\n\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\n\n            return false;\n\n        }\n\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\n\n            return false;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\n\n        internal\n\n        view\n\n        returns (bool)\n\n    {\n\n        Bot storage matron = bots[_matronId];\n\n        Bot storage sire = bots[_sireId];\n\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\n\n    }\n\n\n\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\n\n        external\n\n        view\n\n        returns(bool)\n\n    {\n\n        require(_matronId > 0);\n\n        require(_sireId > 0);\n\n        Bot storage matron = bots[_matronId];\n\n        Bot storage sire = bots[_sireId];\n\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\n\n            _isSiringPermitted(_sireId, _matronId);\n\n    }\n\n\n\n    function _breedWith(uint256 _matronId, uint256 _sireId) internal {\n\n        Bot storage sire = bots[_sireId];\n\n        Bot storage matron = bots[_matronId];\n\n        matron.siringWithId = uint32(_sireId);\n\n        _triggerCooldown(sire);\n\n        _triggerCooldown(matron);\n\n        delete sireAllowedToAddress[_matronId];\n\n        delete sireAllowedToAddress[_sireId];\n\n        pregnantBots++;\n\n        Pregnant(botIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\n\n    }\n\n\n\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\n\n        external\n\n        payable\n\n        whenNotPaused\n\n    {\n\n        require(msg.value >= autoBirthFee);\n\n        require(_owns(msg.sender, _matronId));\n\n        require(_isSiringPermitted(_sireId, _matronId));\n\n        Bot storage matron = bots[_matronId];\n\n        require(_isReadyToBreed(_matronId, matron));\n\n        Bot storage sire = bots[_sireId];\n\n        require(_isReadyToBreed(_sireId, sire));\n\n        require(_isValidMatingPair(\n\n            matron,\n\n            _matronId,\n\n            sire,\n\n            _sireId\n\n        ));\n\n        _breedWith(_matronId, _sireId);\n\n    }\n\n\n\n    function giveBirth(uint256 _matronId)\n\n        external\n\n        whenNotPaused\n\n        returns(uint256)\n\n    {\n\n        Bot storage matron = bots[_matronId];\n\n        require(matron.birthTime != 0);\n\n        require(_isReadyToGiveBirth(matron));\n\n        uint256 sireId = matron.siringWithId;\n\n        Bot storage sire = bots[sireId];\n\n        uint16 parentGen = matron.generation;\n\n        if (sire.generation > matron.generation) {\n\n            parentGen = sire.generation;\n\n        }\n\n        uint256 childGenes = geneScience.mixGenes(matron.genes, sire.genes, matron.cooldownEndBlock - 1);\n\n        address owner = botIndexToOwner[_matronId];\n\n        uint256 botId = _createBot(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        delete matron.siringWithId;\n\n        pregnantBots--;\n\n        msg.sender.send(autoBirthFee);\n\n        return botId;\n\n    }\n\n}\n\ncontract SiringClockAuction is ClockAuction {\n\n    bool public isSiringClockAuction = true;\n\n\n\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public\n\n        ClockAuction(_nftAddr, _cut) {}\n\n\n\n    function createAuction(\n\n        uint256 _tokenId,\n\n        uint256 _startingPrice,\n\n        uint256 _endingPrice,\n\n        uint256 _duration,\n\n        address _seller\n\n    )\n\n        external\n\n    {\n\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n\n        _escrow(_seller, _tokenId);\n\n        Auction memory auction = Auction(\n\n            _seller,\n\n            uint128(_startingPrice),\n\n            uint128(_endingPrice),\n\n            uint64(_duration),\n\n            uint64(now)\n\n        );\n\n        _addAuction(_tokenId, auction);\n\n    }\n\n\n\n    function bid(uint256 _tokenId)\n\n        external\n\n        payable\n\n    {\n\n        require(msg.sender == address(nonFungibleContract));\n\n        address seller = tokenIdToAuction[_tokenId].seller;\n\n        _bid(_tokenId, msg.value);\n\n        _transfer(seller, _tokenId);\n\n    }\n\n\n\n}\n\ncontract SaleClockAuction is ClockAuction {\n\n    bool public isSaleClockAuction = true;\n\n    uint256 public gen0SaleCount;\n\n    uint256[5] public lastGen0SalePrices;\n\n\n\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public\n\n        ClockAuction(_nftAddr, _cut) {}\n\n\n\n    function createAuction(\n\n        uint256 _tokenId,\n\n        uint256 _startingPrice,\n\n        uint256 _endingPrice,\n\n        uint256 _duration,\n\n        address _seller\n\n    )\n\n        external\n\n    {\n\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n\n        _escrow(_seller, _tokenId);\n\n        Auction memory auction = Auction(\n\n            _seller,\n\n            uint128(_startingPrice),\n\n            uint128(_endingPrice),\n\n            uint64(_duration),\n\n            uint64(now)\n\n        );\n\n        _addAuction(_tokenId, auction);\n\n    }\n\n\n\n    function bid(uint256 _tokenId)\n\n        external\n\n        payable\n\n    {\n\n        address seller = tokenIdToAuction[_tokenId].seller;\n\n        uint256 price = _bid(_tokenId, msg.value);\n\n        _transfer(msg.sender, _tokenId);\n\n        if (seller == address(nonFungibleContract)) {\n\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\n\n            gen0SaleCount++;\n\n        }\n\n    }\n\n\n\n    function averageGen0SalePrice() external view returns (uint256) {\n\n        uint256 sum = 0;\n\n        for (uint256 i = 0; i < 5; i++) {\n\n            sum += lastGen0SalePrices[i];\n\n        }\n\n        return sum / 5;\n\n    }\n\n\n\n}\n\ncontract BotAuction is BotBreeding {\n\n    function setSaleAuctionAddress(address _address) external onlyCEO {\n\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        require(candidateContract.isSaleClockAuction());\n\n        saleAuction = candidateContract;\n\n    }\n\n\n\n    function setSiringAuctionAddress(address _address) external onlyCEO {\n\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\n\n        require(candidateContract.isSiringClockAuction());\n\n        siringAuction = candidateContract;\n\n    }\n\n\n\n    function createSaleAuction(\n\n        uint256 _botId,\n\n        uint256 _startingPrice,\n\n        uint256 _endingPrice,\n\n        uint256 _duration\n\n    )\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_owns(msg.sender, _botId));\n\n        require(!isPregnant(_botId));\n\n        _approve(_botId, saleAuction);\n\n        saleAuction.createAuction(\n\n            _botId,\n\n            _startingPrice,\n\n            _endingPrice,\n\n            _duration,\n\n            msg.sender\n\n        );\n\n    }\n\n\n\n    function createSiringAuction(\n\n        uint256 _botId,\n\n        uint256 _startingPrice,\n\n        uint256 _endingPrice,\n\n        uint256 _duration\n\n    )\n\n        external\n\n        whenNotPaused\n\n    {\n\n        require(_owns(msg.sender, _botId));\n\n        require(isReadyToBreed(_botId));\n\n        _approve(_botId, siringAuction);\n\n        siringAuction.createAuction(\n\n            _botId,\n\n            _startingPrice,\n\n            _endingPrice,\n\n            _duration,\n\n            msg.sender\n\n        );\n\n    }\n\n\n\n    function bidOnSiringAuction(\n\n        uint256 _sireId,\n\n        uint256 _matronId\n\n    )\n\n        external\n\n        payable\n\n        whenNotPaused\n\n    {\n\n        require(_owns(msg.sender, _matronId));\n\n        require(isReadyToBreed(_matronId));\n\n        require(_canBreedWithViaAuction(_matronId, _sireId));\n\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\n\n        require(msg.value >= currentPrice + autoBirthFee);\n\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n\n        _breedWith(uint32(_matronId), uint32(_sireId));\n\n    }\n\n\n\n    function withdrawAuctionBalances() external onlyCLevel {\n\n        saleAuction.withdrawBalance();\n\n        siringAuction.withdrawBalance();\n\n    }\n\n}\n\n\n\n// You task is to complete the smart contract BotMinting strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.20, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract is responsible for minting and auctioning bots. It extends the BotAuction contract.\n * @dev The contract handles the creation of promo and Gen0 bots, and manages their limits and auction prices.\n */\ncontract BotMinting is BotAuction {\n\n    uint256 public constant PROMO_CREATION_LIMIT = 5000;\n\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n    uint256 public constant GEN0_STARTING_PRICE = 10 finney;\n\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n\n    uint256 public promoCreatedCount;\n\n    uint256 public gen0CreatedCount;\n\n    /**\n     * @notice Creates a promo bot with the specified genes and assigns it to an owner.\n     * @dev Only the COO can call this function. The bot owner defaults to the COO if not specified.\n     * @param _genes The genetic makeup of the bot.\n     * @param _owner The address of the owner of the new bot.\n     */\n    function createPromoBot(uint256 _genes, address _owner) external onlyCOO {\n        {}\n    }\n\n    /**\n     * @notice Creates a Gen0 bot with the specified genes and starts an auction for it.\n     * @dev Only the COO can call this function. The bot is initially owned by the contract and then put up for auction.\n     * @param _genes The genetic makeup of the bot.\n     */\n    function createGen0Auction(uint256 _genes) external onlyCOO {\n        {}\n    }\n\n    /**\n     * @notice Computes the next price for a Gen0 bot based on the average sale price.\n     * @dev The price is calculated as the average sale price plus half of the average sale price. If the computed price is below the starting price, it defaults to the starting price.\n     * @return The next price for a Gen0 bot.\n     */\n    function _computeNextGen0Price() internal view returns (uint256) {\n        {}\n    }\n}\n"
}