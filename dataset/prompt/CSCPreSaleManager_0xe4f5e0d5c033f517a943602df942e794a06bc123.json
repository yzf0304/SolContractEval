{
    "contract_name": "OperationalControl",
    "ground_truth": "contract OperationalControl {\n    // Facilitates access & control for the game.\n    // Roles:\n    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)\n    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n\n    /// @dev Emited when contract is upgraded\n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public gameManagerPrimary;\n    address public gameManagerSecondary;\n    address public bankManager;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\n    bool public error = false;\n\n    /// @dev Operation modifiers for limiting access\n    modifier onlyGameManager() {\n        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);\n        _;\n    }\n\n    modifier onlyBanker() {\n        require(msg.sender == bankManager);\n        _;\n    }\n\n    modifier anyOperator() {\n        require(\n            msg.sender == gameManagerPrimary ||\n            msg.sender == gameManagerSecondary ||\n            msg.sender == bankManager\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the GM.\n    function setPrimaryGameManager(address _newGM) external onlyGameManager {\n        require(_newGM != address(0));\n\n        gameManagerPrimary = _newGM;\n    }\n\n    /// @dev Assigns a new address to act as the GM.\n    function setSecondaryGameManager(address _newGM) external onlyGameManager {\n        require(_newGM != address(0));\n\n        gameManagerSecondary = _newGM;\n    }\n\n    /// @dev Assigns a new address to act as the Banker.\n    function setBanker(address _newBK) external onlyGameManager {\n        require(_newBK != address(0));\n\n        bankManager = _newBK;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused {\n        require(paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract has Error\n    modifier whenError {\n        require(error);\n        _;\n    }\n\n    /// @dev Called by any Operator role to pause the contract.\n    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\n    function pause() external onlyGameManager whenNotPaused {\n        paused = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n    /// @notice This is public rather than external so it can be called by derived contracts. \n    function unpause() public onlyGameManager whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n    /// @notice This is public rather than external so it can be called by derived contracts. \n    function hasError() public onlyGameManager whenPaused {\n        error = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\n    /// @notice This is public rather than external so it can be called by derived contracts. \n    function noError() public onlyGameManager whenPaused {\n        error = false;\n    }\n}",
    "function_sum": 7,
    "compiler_version": "0.4.21",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n\n\n// You task is to complete the smart contract OperationalControl strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.21, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title OperationalControl\n * @notice This contract facilitates access and control for a game, with defined roles for Game Managers and Banker.\n *         The Game Managers (Primary/Secondary) have universal control over all game elements but cannot withdraw funds.\n *         The Banker can withdraw funds and adjust fees or prices.\n * @dev The contract includes pausable and error handling functionalities to manage the state of the game.\n */\ncontract OperationalControl {\n    // Facilitates access & control for the game.\n    // Roles:\n    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)\n    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\n\n    /// @dev Emitted when the contract is upgraded.\n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each role.\n    address public gameManagerPrimary;\n    address public gameManagerSecondary;\n    address public bankManager;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked.\n    bool public paused = false;\n\n    // @dev Keeps track whether the contract errored out. When that is true, most actions are blocked, and a refund can be claimed.\n    bool public error = false;\n\n    /// @dev Operation modifiers for limiting access.\n    modifier onlyGameManager() {\n        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);\n        _;\n    }\n\n    modifier onlyBanker() {\n        require(msg.sender == bankManager);\n        _;\n    }\n\n    modifier anyOperator() {\n        require(\n            msg.sender == gameManagerPrimary ||\n            msg.sender == gameManagerSecondary ||\n            msg.sender == bankManager\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the primary Game Manager.\n    function setPrimaryGameManager(address _newGM) external onlyGameManager {}\n\n    /// @dev Assigns a new address to act as the secondary Game Manager.\n    function setSecondaryGameManager(address _newGM) external onlyGameManager {}\n\n    /// @dev Assigns a new address to act as the Banker.\n    function setBanker(address _newBK) external onlyGameManager {}\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract is not paused.\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract is paused.\n    modifier whenPaused {\n        require(paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract has an error.\n    modifier whenError {\n        require(error);\n        _;\n    }\n\n    /// @dev Called by any Operator role to pause the contract. Used only if a bug or exploit is discovered to limit losses or damage.\n    function pause() external onlyGameManager whenNotPaused {}\n\n    /// @dev Unpauses the smart contract. Can only be called by the Game Manager.\n    /// @notice This is public rather than external so it can be called by derived contracts.\n    function unpause() public onlyGameManager whenPaused {}\n\n    /// @dev Sets the contract to an error state. Can only be called by the Game Manager.\n    /// @notice This is public rather than external so it can be called by derived contracts.\n    function hasError() public onlyGameManager whenPaused {}\n\n    /// @dev Clears the contract's error state. Can only be called by the Game Manager.\n    /// @notice This is public rather than external so it can be called by derived contracts.\n    function noError() public onlyGameManager whenPaused {}\n}\n"
}