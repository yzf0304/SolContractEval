{
    "contract_name": "CZRLocker",
    "ground_truth": "contract CZRLocker is owned {\n\n    \n\n    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);\n\n    event RemoveLock(address addr, uint index);\n\n    event Unlock(address addr, uint index, uint unlockAmount);\n\n\n\n    address public tokenAddr;\n\n    address public unlocker;\n\n    \n\n    struct LockedCZR {\n\n        uint startLockTime;\n\n        uint lockMonth;\n\n        uint lockedAmount;\n\n        uint unlockedAmount;\n\n    }\n\n    \n\n    mapping(address => LockedCZR[]) public lockedCZRMap;\n\n    \n\n    function CZRLocker(address _tokenAddr, address _unlocker) public {\n\n        tokenAddr = _tokenAddr;\n\n        unlocker = _unlocker;\n\n    }\n\n\n\n    /// @notice remove CZR lock (only set all field to 0)\n\n    /// @param addr address to remove lock\n\n    /// @param index index to remove\n\n    function removeCZRLock(address addr, uint index) onlyOwner public {\n\n        LockedCZR[] storage lockArr = lockedCZRMap[addr];\n\n        require(lockArr.length > 0 && index < lockArr.length);\n\n    \n\n        delete lockArr[index];      //delete just set all feilds to zero value, not remove item out of array;\n\n        RemoveLock(addr, index);\n\n    }\n\n    \n\n    /// @notice add CZR lock\n\n    /// @param addr address to add lock\n\n    /// @param startLockTime start lock time, 0 for now\n\n    /// @param amount CZR amount\n\n    /// @param lockMonth months to lock\n\n    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public {\n\n        require(amount > 0);\n\n        if (startLockTime == 0)\n\n            startLockTime = now;\n\n        lockedCZRMap[addr].push(LockedCZR(startLockTime, lockMonth, amount, 0));\n\n        uint index = lockedCZRMap[addr].length - 1;\n\n        AddLock(addr, index, startLockTime, lockMonth, amount);\n\n    }\n\n    \n\n    /// @notice unlock CZR\n\n    /// @param addr address to unlock\n\n    /// @param limit max unlock number\n\n    function unlockCZR(address addr, uint limit) public {\n\n        require(msg.sender == owner || msg.sender == unlocker);\n\n        \n\n        LockedCZR[] storage lockArr = lockedCZRMap[addr];\n\n        require(lockArr.length > 0);\n\n        token t = token(tokenAddr);\n\n        \n\n        uint num = 0;\n\n        for (uint i = 0; i < lockArr.length; i++) {\n\n            var lock = lockArr[i];\n\n            if (lock.lockedAmount > 0) {\n\n                uint time = now - lock.startLockTime;\n\n                uint month = time / 30 days;\n\n                \n\n                if (month == 0) \n\n                    continue;\n\n\n\n                uint unlockAmount;\n\n                if (month >= lock.lockMonth)\n\n                    unlockAmount = lock.lockedAmount;\n\n                else\n\n                    unlockAmount = (lock.lockedAmount + lock.unlockedAmount) * month / lock.lockMonth - lock.unlockedAmount;\n\n                        \n\n                if (unlockAmount == 0) \n\n                    continue;\n\n                    \n\n                lock.unlockedAmount += unlockAmount;\n\n                lock.lockedAmount -= unlockAmount;\n\n                        \n\n                t.transferFrom(owner, addr, unlockAmount);\n\n                Unlock(addr, i, unlockAmount);\n\n                \n\n                num++;\n\n                if (limit > 0 && num == limit)\n\n                    break;\n\n            }\n\n        }\n\n        \n\n        require(num > 0);\n\n    }\n\n    \n\n    /// @notice withdraw eth\n\n    /// @param to Address to receive the eth\n\n    /// @param value the amount of eth it will receive\n\n    function withdrawEth(address to, uint256 value) onlyOwner public {\n\n        to.transfer(value);\n\n    }\n\n    \n\n    /// record total received eth and check whether goal completed\n\n    function() payable public {\n\n    }\n\n}",
    "function_sum": 5,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-01-24\n\n*/\n\ncontract owned {\n\n    address public owner;\n\n\n\n    function owned() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        owner = newOwner;\n\n    }\n\n}\n\ninterface token { function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); }\n\n\n\n// You task is to complete the smart contract CZRLocker strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice A smart contract to manage and control the locking and unlocking of CZR tokens.\n * @dev This contract allows the owner to add, remove, and unlock CZR token locks. It also includes functionality to withdraw ETH.\n */\ncontract CZRLocker is owned {\n\n    /**\n     * @notice Emitted when a new lock is added.\n     * @param addr The address for which the lock is added.\n     * @param index The index of the lock.\n     * @param startLockTime The time when the lock starts.\n     * @param lockMonth The duration of the lock in months.\n     * @param lockedAmount The amount of CZR tokens that are locked.\n     */\n    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);\n\n    /**\n     * @notice Emitted when a lock is removed.\n     * @param addr The address for which the lock is removed.\n     * @param index The index of the lock.\n     */\n    event RemoveLock(address addr, uint index);\n\n    /**\n     * @notice Emitted when a lock is unlocked.\n     * @param addr The address for which the lock is unlocked.\n     * @param index The index of the lock.\n     * @param unlockAmount The amount of CZR tokens that are unlocked.\n     */\n    event Unlock(address addr, uint index, uint unlockAmount);\n\n    /**\n     * @notice The address of the CZR token.\n     */\n    address public tokenAddr;\n\n    /**\n     * @notice The address of the unlocker.\n     */\n    address public unlocker;\n\n    /**\n     * @dev Structure to store the details of a locked CZR.\n     */\n    struct LockedCZR {\n        uint startLockTime;\n        uint lockMonth;\n        uint lockedAmount;\n        uint unlockedAmount;\n    }\n\n    /**\n     * @dev Mapping from an address to an array of its locked CZR details.\n     */\n    mapping(address => LockedCZR[]) public lockedCZRMap;\n\n    /**\n     * @notice Constructor to initialize the contract with the token address and unlocker address.\n     * @param _tokenAddr The address of the CZR token.\n     * @param _unlocker The address of the unlocker.\n     */\n    function CZRLocker(address _tokenAddr, address _unlocker) public {\n        tokenAddr = _tokenAddr;\n        unlocker = _unlocker;\n    }\n\n    /**\n     * @notice Removes a CZR lock by setting all fields to zero.\n     * @param addr The address for which the lock is to be removed.\n     * @param index The index of the lock to be removed.\n     */\n    function removeCZRLock(address addr, uint index) onlyOwner public {\n    }\n\n    /**\n     * @notice Adds a new CZR lock.\n     * @param addr The address for which the lock is to be added.\n     * @param startLockTime The time when the lock starts (0 for now).\n     * @param amount The amount of CZR tokens to be locked.\n     * @param lockMonth The duration of the lock in months.\n     */\n    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public {\n    }\n\n    /**\n     * @dev Unlocks CZR tokens for a user based on lock duration.\n     * @param addr Address of the user whose tokens are being unlocked\n     * @param limit Maximum number of locks to process (0 for unlimited)\n     * @dev Requirements:\n     *   - Only callable by contract owner or unlocker\n     *   - User must have existing locked CZR records\n     * @dev Behavior:\n     *   - Calculates unlockable amount for each lock based on time passed\n     *   - Processes up to 'limit' locks if specified\n     *   - Transfers unlocked tokens to user's address\n     *   - Emits Unlock event for each processed lock\n     * @dev Notes:\n     *   - Locks are processed in order (oldest first)\n     *   - Monthly unlocking schedule is enforced\n     *   - Requires sufficient token balance in contract\n     * @dev Returns:\n     *   - Number of locks processed (implicit via require check)\n     */\n    function unlockCZR(address addr, uint limit) public {\n    }\n\n    /**\n     * @notice Withdraws ETH to a specified address.\n     * @param to The address to receive the ETH.\n     * @param value The amount of ETH to be transferred.\n     */\n    function withdrawEth(address to, uint256 value) onlyOwner public {\n    }\n\n    /**\n     * @notice Fallback function to receive ETH.\n     */\n    function() payable public {\n    }\n}\n"
}