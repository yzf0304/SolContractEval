{
    "contract_name": "Crowdsale",
    "ground_truth": "contract Crowdsale is Ownable{\n\n  using SafeMath for uint256;\n\n\n\n  // The token being sold\n\n  DragonToken public token;\n\n  \n\n  // The address of token reserves\n\n  address public tokenReserve;\n\n\n\n  // start and end timestamps where investments are allowed (both inclusive)\n\n  uint256 public startTime;\n\n  uint256 public endTime;\n\n\n\n  // address where funds are collected\n\n  address public wallet;\n\n\n\n  // token rate in wei\n\n  uint256 public rate;\n\n\n\n  // amount of raised money in wei\n\n  uint256 public weiRaised;\n\n  \n\n  uint256 public tokensSold;\n\n\n\n  /**\n\n   * event for token purchase logging\n\n   * @param purchaser who paid for the tokens\n\n   * @param beneficiary who got the tokens\n\n   * @param value weis paid for purchase\n\n   * @param amount amount of tokens purchased\n\n   * @param releaseTime tokens unlock time\n\n   */\n\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 releaseTime);\n\n  \n\n  /**\n\n   * event upon endTime updated\n\n   */\n\n  event EndTimeUpdated();\n\n  \n\n  /**\n\n   * Dragon token price updated\n\n   */\n\n  event DragonPriceUpdated();\n\n  \n\n  /**\n\n   * event for token releasing\n\n   * @param holder who is releasing his tokens\n\n   */\n\n  event TokenReleased(address indexed holder, uint256 amount);\n\n\n\n\n\n  function Crowdsale() public {\n\n  \n\n    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e; // overriding owner\n\n    startTime = now;\n\n    endTime = 1521187200;\n\n    rate = 5000000000000000; // price in wei\n\n    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;\n\n    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);\n\n    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;\n\n  }\n\n\n\n  // fallback function can be used to buy tokens\n\n  function () external payable {\n\n    buyTokens(msg.sender);\n\n  }\n\n\n\n  // low level token purchase function\n\n  function buyTokens(address beneficiary) public payable {\n\n    require(beneficiary != address(0));\n\n    require(validPurchase());\n\n\n\n    uint256 weiAmount = msg.value;\n\n\n\n    // calculate token amount to be created\n\n    uint256 tokens = getTokenAmount(weiAmount);\n\n\n\n    // update state\n\n    weiRaised = weiRaised.add(weiAmount);\n\n    tokensSold = tokensSold.add(tokens);\n\n\n\n    uint256 lockedFor = assignTokens(beneficiary, tokens);\n\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, lockedFor);\n\n\n\n    forwardFunds();\n\n  }\n\n\n\n  // @return true if crowdsale event has ended\n\n  function hasEnded() public view returns (bool) {\n\n    return now > endTime;\n\n  }\n\n\n\n  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {\n\n    uint256 amount = weiAmount.div(rate);\n\n    return amount.mul(100000000); // multiply with decimals\n\n  }\n\n\n\n  // send ether to the fund collection wallet\n\n  function forwardFunds() internal {\n\n    wallet.transfer(msg.value);\n\n  }\n\n\n\n  // @return true if the transaction can buy tokens\n\n  function validPurchase() internal view returns (bool) {\n\n    bool withinPeriod = now >= startTime && now <= endTime;\n\n    bool nonZeroPurchase = msg.value != 0;\n\n    return withinPeriod && nonZeroPurchase;\n\n  }\n\n\n\n  function updateEndTime(uint256 newTime) onlyOwner external {\n\n    require(newTime > startTime);\n\n    endTime = newTime;\n\n    EndTimeUpdated();\n\n  }\n\n  \n\n  function updateDragonPrice(uint256 weiAmount) onlyOwner external {\n\n    require(weiAmount > 0);\n\n    rate = weiAmount;\n\n    DragonPriceUpdated();\n\n  }\n\n  \n\n  mapping(address => uint256) balances;\n\n  mapping(address => uint256) releaseTime;\n\n  function assignTokens(address beneficiary, uint256 amount) private returns(uint256 lockedFor){\n\n      lockedFor = now + 45 days;\n\n      balances[beneficiary] = balances[beneficiary].add(amount);\n\n      releaseTime[beneficiary] = lockedFor;\n\n  }\n\n  \n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n  \n\n\n\n  function unlockTime(address _owner) public view returns (uint256 time) {\n\n    return releaseTime[_owner];\n\n  }\n\n\n\n  /**\n\n   * @notice Transfers tokens held by timelock to beneficiary.\n\n   */\n\n  function releaseDragonTokens() public {\n\n    require(now >= releaseTime[msg.sender]);\n\n    \n\n    uint256 amount = balances[msg.sender];\n\n    require(amount > 0);\n\n    \n\n    balances[msg.sender] = 0;\n\n    if(!token.transferFrom(tokenReserve,msg.sender,amount)){\n\n        revert();\n\n    }\n\n\n\n    TokenReleased(msg.sender,amount);\n\n  }\n\n  \n\n}",
    "function_sum": 12,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-02-14\n\n*/\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n    \n\n  /**\n\n  * @dev Multiplies two numbers, throws on overflow.\n\n  */\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Integer division of two numbers, truncating the quotient.\n\n  */\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  /**\n\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\n  */\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  /**\n\n  * @dev Adds two numbers, throws on overflow.\n\n  */\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\ncontract DragonToken{\n\n  function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\n\n}\n\n\n\n// You task is to complete the smart contract Crowdsale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Crowdsale\n * @author [Your Name]\n * @notice This contract is designed to facilitate a token crowdsale, allowing users to purchase tokens with Ether.\n * The sale has a defined start and end time, and the rate of token to Ether can be adjusted by the owner.\n * Tokens are locked for a period after purchase before they can be released.\n * @dev Inherits from Ownable, which provides basic authorization control functions.\n */\ncontract Crowdsale is Ownable {\n\n  using SafeMath for uint256;\n\n  /**\n   * @notice The token being sold in the crowdsale.\n   */\n  DragonToken public token;\n\n  /**\n   * @notice The address of the token reserves.\n   */\n  address public tokenReserve;\n\n  /**\n   * @notice The start and end timestamps where investments are allowed (both inclusive).\n   */\n  uint256 public startTime;\n  uint256 public endTime;\n\n  /**\n   * @notice The address where funds are collected.\n   */\n  address public wallet;\n\n  /**\n   * @notice The token rate in wei.\n   */\n  uint256 public rate;\n\n  /**\n   * @notice The amount of raised money in wei.\n   */\n  uint256 public weiRaised;\n\n  /**\n   * @notice The total amount of tokens sold during the crowdsale.\n   */\n  uint256 public tokensSold;\n\n  /**\n   * @dev Event for logging token purchases.\n   * @param purchaser The address that paid for the tokens.\n   * @param beneficiary The address that received the tokens.\n   * @param value The amount of wei paid for the purchase.\n   * @param amount The amount of tokens purchased.\n   * @param releaseTime The timestamp when the tokens will be unlocked.\n   */\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 releaseTime);\n\n  /**\n   * @dev Event for logging updates to the end time of the crowdsale.\n   */\n  event EndTimeUpdated();\n\n  /**\n   * @dev Event for logging updates to the token price.\n   */\n  event DragonPriceUpdated();\n\n  /**\n   * @dev Event for logging the release of tokens.\n   * @param holder The address releasing the tokens.\n   * @param amount The amount of tokens released.\n   */\n  event TokenReleased(address indexed holder, uint256 amount);\n\n  function Crowdsale() public {\n    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e; // overriding owner\n    startTime = now;\n    endTime = 1521187200;\n    rate = 5000000000000000; // price in wei\n    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;\n    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);\n    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;\n  }\n\n  /**\n   * @notice Fallback function allows users to buy tokens by sending Ether directly to the contract.\n   */\n  function () external payable {\n  }\n\n  /**\n   * @notice Allows users to buy tokens.\n   * @param beneficiary The address that will receive the tokens.\n   */\n  function buyTokens(address beneficiary) public payable {}\n\n  /**\n   * @notice Checks if the crowdsale has ended.\n   * @return A boolean indicating whether the crowdsale has ended.\n   */\n  function hasEnded() public view returns (bool) {}\n\n  /**\n   * @dev Calculates the amount of tokens to be created based on the wei amount.\n   * @param weiAmount The amount of wei sent by the user.\n   * @return The amount of tokens to be created.\n   */\n  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {}\n\n  /**\n   * @dev Transfers the funds to the collection wallet.\n   */\n  function forwardFunds() internal {}\n\n  /**\n   * @dev Checks if the current transaction is a valid purchase.\n   * @return A boolean indicating whether the purchase is valid.\n   */\n  function validPurchase() internal view returns (bool) {}\n\n  /**\n   * @notice Updates the end time of the crowdsale.\n   * @param newTime The new end time.\n   */\n  function updateEndTime(uint256 newTime) onlyOwner external {}\n\n  /**\n   * @notice Updates the price of the token in wei.\n   * @param weiAmount The new price in wei.\n   */\n  function updateDragonPrice(uint256 weiAmount) onlyOwner external {}\n\n  mapping(address => uint256) balances;\n  mapping(address => uint256) releaseTime;\n\n  /**\n   * @dev Assigns tokens to the beneficiary and sets the release time.\n   * @param beneficiary The address receiving the tokens.\n   * @param amount The amount of tokens to assign.\n   * @return The timestamp when the tokens will be unlocked.\n   */\n  function assignTokens(address beneficiary, uint256 amount) private returns(uint256 lockedFor) {}\n\n  /**\n   * @notice Gets the balance of the specified address.\n   * @param _owner The address to query the balance of.\n   * @return The balance of the specified address.\n   */\n  function balanceOf(address _owner) public view returns (uint256 balance) {}\n\n  /**\n   * @notice Gets the unlock time for the specified address.\n   * @param _owner The address to query the unlock time of.\n   * @return The unlock time for the specified address.\n   */\n  function unlockTime(address _owner) public view returns (uint256 time) {}\n\n  /**\n   * @notice Releases the tokens held by timelock to the beneficiary.\n   */\n  function releaseDragonTokens() public {}\n}\n"
}