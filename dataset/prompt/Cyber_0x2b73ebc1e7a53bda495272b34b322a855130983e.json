{
    "contract_name": "Cyber",
    "ground_truth": "contract Cyber is ERC721Omni {\n\n    string private _baseURI = \"ipfs://QmS84uLAUvGLverNnvyU8YhsHKJi6E3WnfvuD7qmRmBos2/\";\n    uint256 private constant maximumSupply = 6600;\n    uint256 public publicMintedCap = 1980;\n\n    uint256 public totalSupply;\n    uint256 public publicMinted;\n    uint256 public gasForLzReceive = 350000;\n    bool public depreciatedMint;\n    bool public publicStatus;\n    bool public huntlistStatus;\n    bytes32 public merkleRoot = 0xd6fbbe52742f9b344f0cec438e6e560e182c4aec6a42bbf8e944f227632ba0b3;\n\n    constructor(address _lzEndpoint) ERC721Omni(\"Cyber\", \"Hunters\") { \n        endpoint = ILayerZeroEndpoint(_lzEndpoint); \n    }\n\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"Contract Caller\");\n        _;\n    }\n\n    function donate() external payable {\n        // thank you friend!\n    }\n\n    function traverseChains(uint16 _chainId, uint tokenId) public payable {\n        require(msg.sender == ownerOf(tokenId), \"You must own the token to traverse\");\n        require(trustedRemoteLookup[_chainId].length > 0, \"This chain is currently unavailable for travel\");\n\n        _burn(tokenId);\n        totalSupply--;\n\n        bytes memory payload = abi.encode(msg.sender, tokenId);\n        uint16 version = 1;\n        bytes memory adapterParams = abi.encodePacked(version, gasForLzReceive);\n\n        (uint messageFee, ) = endpoint.estimateFees(_chainId, address(this), payload, false, adapterParams);\n        \n        require(msg.value >= messageFee, \"msg.value cannot cover messageFee. Requires additional gas\");\n\n        endpoint.send{value: msg.value}(\n            _chainId,                           // Endpoint chainId\n            trustedRemoteLookup[_chainId],      // Endpoint contract\n            payload,                            // Encoded bytes\n            payable(msg.sender),                // Excess fund destination address\n            address(0x0),                       // Unused\n            adapterParams                       // Transaction Parameters \n        );\n    }\n\n    function _LzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) override internal {\n        (address toAddr, uint tokenId) = abi.decode(_payload, (address, uint));\n        _mint(toAddr, tokenId);\n        totalSupply++;\n    }\n\n    function publicMint() external callerIsUser {\n        require(publicStatus, \"Public mint not active\");\n        require(totalSupply < maximumSupply, \"Will exceed maximum supply\");\n\n        unchecked {\n            require(publicMinted++ < publicMintedCap, \"Public supply depleted\");\n            _mint(msg.sender, totalSupply++);\n        }\n   }\n\n   function huntlistMint(bytes32[] calldata _proof) external callerIsUser {\n       require(huntlistStatus, \"Huntlist mint not active\");\n        require(verifyProof(_proof, merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Not on Huntlist\");\n        uint256 temporarySupply = totalSupply;\n        unchecked {\n            require(temporarySupply + 1 < maximumSupply, \"Will exceed max supply\");\n            require(_addressData[msg.sender].huntlistMinted == 0, \"Insufficient Mints Remaining\");\n            _addressData[msg.sender].huntlistMinted += uint128(2);\n        }\n        _mint(msg.sender, temporarySupply++);\n        _mint(msg.sender, temporarySupply++);\n        totalSupply = temporarySupply;\n   }\n\n   function verifyProof(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        bytes32 computedHash = leaf;\n\n        uint256 iterations = proof.length;\n        for (uint256 i; i < iterations; ) {\n            bytes32 proofElement = proof[i++];\n\n            if (computedHash <= proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n\n        }\n        return computedHash == root;\n    }\n\n    function burnHunter(uint256 tokenId) external {\n       require(depreciatedMint, \"Mint is still active.\");\n       require(msg.sender == ownerOf(tokenId) || isApprovedForAll[ownerOf(tokenId)][msg.sender] || msg.sender == getApproved[tokenId], \"Lacks Permissions\");\n       _burn(tokenId);\n       totalSupply--;\n   }\n\n   function setPublicState(bool _state) external onlyOwner {\n       require(!depreciatedMint, \"Mint is depreciated.\");\n       publicStatus = _state;\n   }\n\n   function setHuntlistState(bool _state) external onlyOwner {\n       require(!depreciatedMint, \"Mint is depreciated.\");\n       huntlistStatus = _state;\n   }\n\n   function setPublicMintSupply(uint256 _supply) external onlyOwner {\n       require(!depreciatedMint, \"Mint is depreciated.\");\n       require(_supply > publicMintedCap, \"Cannot reduce mint supply\");\n       require(_supply <= maximumSupply, \"Cannot exceed maximum supply\");\n       publicMintedCap = _supply;\n   }\n\n  function setRoot(bytes32 _newROOT) external onlyOwner {\n        merkleRoot = _newROOT;\n    }\n\n  function depreciateMint() external onlyOwner {\n      require(!depreciatedMint, \"Mint is already depreciated.\");\n      delete publicStatus;\n      delete huntlistStatus;\n      depreciatedMint = true;\n      address deployer = msg.sender;\n      uint256 timestamp = block.timestamp;\n\n        for (uint256 i; i < 66; ){\n            _ownerOf[i].tokenHolder = deployer;\n            _ownerOf[i].timestampHolder = uint96(timestamp);\n            unchecked {\n                emit Transfer(address(0), deployer, i++);\n            }\n        }\n\n        unchecked {\n            _addressData[deployer].balance += 66;\n            totalSupply += 66;\n        }\n  }\n\n  function setBaseURI(string memory _newURI) external onlyOwner {\n      _baseURI = _newURI;\n  }\n\n  function setGasForDestinationLzReceive(uint _newGasValue) external onlyOwner {\n      gasForLzReceive = _newGasValue;\n  }\n\n  function setLzEndpoint(address _lzEndpoint) external onlyOwner {\n      endpoint = ILayerZeroEndpoint(_lzEndpoint);\n  }\n\n  function baseURI() override public view returns (string memory) {\n      return _baseURI;\n  }\n\n  function withdrawDonations() external onlyOwner {\n      uint256 currentBalance = address(this).balance;\n      (bool sent, ) = address(msg.sender).call{value: currentBalance}('');\n      require(sent, \"Transfer Error\");    \n  }\n\n}",
    "function_sum": 17,
    "compiler_version": "0.8.14",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-06-12\n*/\n// SPDX-License-Identifier: MIT\n// Made with love by Mai\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n\nabstract contract ERC721Omni {\n    using Address for address;\n    using Strings for uint256;\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    string public name;\n    string public symbol;\n    address public owner;\n    ILayerZeroEndpoint internal endpoint;\n\n    struct FailedMessages {\n        uint payloadLength;\n        bytes32 payloadHash;\n    }\n\n    struct addressData {\n        uint128 balance;\n        uint128 huntlistMinted;\n    }\n\n    struct tokenData {\n        address tokenHolder;\n        uint96 timestampHolder;//Maybe if you guys like your hunters we can do cool stuff with this\n    }\n\n    mapping(uint256 => tokenData) internal _ownerOf;\n    mapping(address => addressData) internal _addressData;\n\n    mapping(uint16 => mapping(bytes => mapping(uint => FailedMessages))) public failedMessages;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint256 => address) public getApproved;\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n        _transferOwnership(msg.sender);\n    }\n\n    function ownerOf(uint256 id) public view virtual returns (address) {\n        require(_ownerOf[id].tokenHolder != address(0), \"Nonexistent Token\");\n        return _ownerOf[id].tokenHolder;\n    }\n\n    function balanceOf(address _owner) public view virtual returns (uint256) {\n        require(_owner != address(0), \"Zero Address\");\n        return _addressData[_owner].balance;\n    }\n\n    function durationTimestamp(uint256 tokenId) public view virtual returns (uint256) {\n        return _ownerOf[tokenId].timestampHolder;\n    }\n\n    function huntlistMinted(address _owner) public view virtual returns (uint256) {\n        require(_owner != address(0), \"Zero Address\");\n        return _addressData[_owner].huntlistMinted;\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(from == _ownerOf[tokenId].tokenHolder, \"Non Owner\");\n        require(to != address(0), \"Zero Address\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[tokenId],\n            \"Lacks Permissions\"\n        );\n\n        unchecked {\n            _addressData[from].balance--;\n            _addressData[to].balance++;\n        }\n\n        _ownerOf[tokenId].tokenHolder = to;\n        _ownerOf[tokenId].timestampHolder = uint96(block.timestamp);\n        delete getApproved[tokenId];\n        emit Transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        transferFrom(from, to, tokenId);\n\n        require(to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"Unsafe Transfer\"\n        );\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public {\n        transferFrom(from, to, tokenId);\n\n        require(to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, tokenId, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"Unsafe Transfer\"\n        );\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        isApprovedForAll[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function approve(address spender, uint256 tokenId) public {\n        address _owner = _ownerOf[tokenId].tokenHolder;\n        require(msg.sender == _owner || isApprovedForAll[_owner][msg.sender], \"Lacks Permissions\");\n\n        getApproved[tokenId] = spender;\n        emit Approval(_owner, spender, tokenId);\n    }\n\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"Zero Address\");\n        require(_ownerOf[tokenId].tokenHolder == address(0), \"Already Exists\");\n\n        unchecked {\n            _addressData[to].balance++;\n        }\n\n        _ownerOf[tokenId].tokenHolder = to;\n        _ownerOf[tokenId].timestampHolder = uint96(block.timestamp);\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal {\n        _mint(to, tokenId);\n\n        require(to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), tokenId, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"Unsafe Mint\"\n        );\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal {\n        _mint(to, tokenId);\n\n        require(to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), tokenId, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"Unsafe Mint\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal {\n        address _owner = _ownerOf[tokenId].tokenHolder;\n        require(_owner != address(0), \"Nonexistent Token\");\n\n        unchecked {\n            _addressData[_owner].balance--;\n        }\n\n        delete _ownerOf[tokenId];\n        delete getApproved[tokenId];\n\n        emit Transfer(_owner, address(0), tokenId);\n    }\n\n    function baseURI() public view virtual returns (string memory) {\n        return '';\n    }\n\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\n        require(_ownerOf[tokenId].tokenHolder != address(0), \"Nonexistent Token\");\n        string memory _baseURI = baseURI();\n        return bytes(_baseURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenId.toString())) : '';\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 ||\n            interfaceId == 0x80ac58cd ||\n            interfaceId == 0x5b5e139f;\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) external {\n        require(msg.sender == address(endpoint)); \n        require(_srcAddress.length == trustedRemoteLookup[_srcChainId].length && keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]), \n            \"NonblockingReceiver: invalid source sending contract\");\n\n        try this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {\n        } catch {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = FailedMessages(_payload.length, keccak256(_payload));\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);\n        }\n    }\n\n    function onLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) public {\n        require(msg.sender == address(this), \"NonblockingReceiver: caller must be Bridge.\");\n        _LzReceive( _srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _LzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) virtual internal;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _txParam) internal {\n        endpoint.send{value: msg.value}(_dstChainId, trustedRemoteLookup[_dstChainId], _payload, _refundAddress, _zroPaymentAddress, _txParam);\n    }\n\n    function retryMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes calldata _payload) external payable {\n        FailedMessages storage failedMsg = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(failedMsg.payloadHash != bytes32(0), \"NonblockingReceiver: no stored message\");\n        require(_payload.length == failedMsg.payloadLength && keccak256(_payload) == failedMsg.payloadHash, \"LayerZero: invalid payload\");\n        failedMsg.payloadLength = 0;\n        failedMsg.payloadHash = bytes32(0);\n        this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function setTrustedRemote(uint16 _chainId, bytes calldata _trustedRemote) external onlyOwner {\n        trustedRemoteLookup[_chainId] = _trustedRemote;\n    }\n\n    function renounceOwnership() public onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner == address(0)) revert NewOwnerAddressZero();\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal {\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    modifier onlyOwner() {\n        if (owner != msg.sender) revert CallerNotOwner();\n        _;\n    }\n\n}\n\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n\n\n\n// You task is to complete the smart contract Cyber strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.14, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Cyber\n * @author [Your Name]\n * @notice The Cyber contract is an ERC721 token contract that allows for minting, burning, and traversing tokens across different chains using LayerZero.\n * @dev This contract extends the ERC721Omni contract to include additional functionality such as public minting, huntlist minting, and chain traversal.\n */\ncontract Cyber is ERC721Omni {\n\n    string private _baseURI = \"ipfs://QmS84uLAUvGLverNnvyU8YhsHKJi6E3WnfvuD7qmRmBos2/\";\n    uint256 private constant maximumSupply = 6600;\n    uint256 public publicMintedCap = 1980;\n\n    uint256 public totalSupply;\n    uint256 public publicMinted;\n    uint256 public gasForLzReceive = 350000;\n    bool public depreciatedMint;\n    bool public publicStatus;\n    bool public huntlistStatus;\n    bytes32 public merkleRoot = 0xd6fbbe52742f9b344f0cec438e6e560e182c4aec6a42bbf8e944f227632ba0b3;\n\n    constructor(address _lzEndpoint) ERC721Omni(\"Cyber\", \"Hunters\") { \n        endpoint = ILayerZeroEndpoint(_lzEndpoint); \n    }\n\n    /**\n     * @dev Modifier to ensure that the caller is a user (not a contract).\n     */\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"Contract Caller\");\n        _;\n    }\n\n    /**\n     * @notice Allows users to donate to the contract.\n     * @dev This function accepts ETH donations.\n     */\n    function donate() external payable {}\n\n    /**\n     * @dev Allows token owner to traverse to another chain via LayerZero.\n     * @param _chainId Destination chain ID\n     * @param tokenId ID of the token to traverse\n     * @dev Requirements:\n     *   - Caller must be the token owner\n     *   - Destination chain must be available in trustedRemoteLookup\n     * @dev Behavior:\n     *   - Burns the token (removes from supply)\n     *   - Encodes payload with sender and token ID\n     *   - Estimates message fees for cross-chain transfer\n     *   - Validates msg.value covers the fees\n     *   - Sends cross-chain message via LayerZero endpoint\n     * @dev Notes:\n     *   - Uses adapterParams for gas configuration\n     *   - Excess funds are returned to msg.sender\n     *   - Requires LayerZero endpoint setup\n     */\n    function traverseChains(uint16 _chainId, uint tokenId) public payable {}\n\n    /**\n     * @notice Internal function to handle the reception of tokens from another chain.\n     * @dev This function is called by the LayerZero endpoint when a token is received from another chain.\n     * @param _srcChainId The ID of the source chain.\n     * @param _srcAddress The address of the sender on the source chain.\n     * @param _nonce The nonce of the message.\n     * @param _payload The payload containing the recipient address and token ID.\n     */\n    function _LzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) override internal {}\n\n    /**\n     * @notice Allows users to mint a token during the public mint phase.\n     * @dev This function mints a new token to the caller's address if the public mint is active and within the supply limits.\n     */\n    function publicMint() external callerIsUser {}\n\n    /**\n     * @notice Allows users to mint tokens if they are on the huntlist.\n     * @dev This function mints two tokens to the caller's address if they are on the huntlist and the huntlist mint is active.\n     * @param _proof The Merkle proof to verify the caller's inclusion in the huntlist.\n     */\n    function huntlistMint(bytes32[] calldata _proof) external callerIsUser {}\n\n    /**\n     * @notice Verifies a Merkle proof against the root.\n     * @dev This function checks if the provided proof and leaf match the Merkle root.\n     * @param proof The Merkle proof.\n     * @param root The Merkle root.\n     * @param leaf The leaf to be verified.\n     * @return A boolean indicating whether the proof is valid.\n     */\n    function verifyProof(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {}\n\n    /**\n     * @notice Allows the owner of a token to burn it.\n     * @dev This function burns the specified token and decreases the total supply.\n     * @param tokenId The ID of the token to be burned.\n     */\n    function burnHunter(uint256 tokenId) external {}\n\n    /**\n     * @notice Sets the state of the public mint.\n     * @dev This function can only be called by the contract owner and sets the public mint status.\n     * @param _state The new state of the public mint.\n     */\n    function setPublicState(bool _state) external onlyOwner {}\n\n    /**\n     * @notice Sets the state of the huntlist mint.\n     * @dev This function can only be called by the contract owner and sets the huntlist mint status.\n     * @param _state The new state of the huntlist mint.\n     */\n    function setHuntlistState(bool _state) external onlyOwner {}\n\n    /**\n     * @notice Sets the cap for the public mint supply.\n     * @dev This function can only be called by the contract owner and sets the maximum number of tokens that can be minted during the public mint phase.\n     * @param _supply The new cap for the public mint supply.\n     */\n    function setPublicMintSupply(uint256 _supply) external onlyOwner {}\n\n    /**\n     * @notice Sets the Merkle root for the huntlist.\n     * @dev This function can only be called by the contract owner and updates the Merkle root used for verifying the huntlist.\n     * @param _newROOT The new Merkle root.\n     */\n    function setRoot(bytes32 _newROOT) external onlyOwner {}\n\n    /**\n     * @notice Depreciates the mint and mints remaining tokens to the deployer.\n     * @dev This function can only be called by the contract owner and deprecates the mint, mints 66 tokens to the deployer, and sets the mint status.\n     */\n    function depreciateMint() external onlyOwner {}\n\n    /**\n     * @notice Sets the base URI for the token metadata.\n     * @dev This function can only be called by the contract owner and updates the base URI used for token metadata.\n     * @param _newURI The new base URI.\n     */\n    function setBaseURI(string memory _newURI) external onlyOwner {}\n\n    /**\n     * @notice Sets the gas amount for the LayerZero receive function.\n     * @dev This function can only be called by the contract owner and updates the gas amount for the LayerZero receive function.\n     * @param _newGasValue The new gas value.\n     */\n    function setGasForDestinationLzReceive(uint _newGasValue) external onlyOwner {}\n\n    /**\n     * @notice Sets the LayerZero endpoint address.\n     * @dev This function can only be called by the contract owner and updates the LayerZero endpoint address.\n     * @param _lzEndpoint The new LayerZero endpoint address.\n     */\n    function setLzEndpoint(address _lzEndpoint) external onlyOwner {}\n\n    /**\n     * @notice Returns the base URI for the token metadata.\n     * @dev This function is overridden to return the base URI for the token metadata.\n     * @return The base URI.\n     */\n    function baseURI() override public view returns (string memory) {}\n\n    /**\n     * @notice Allows the contract owner to withdraw all ETH from the contract.\n     * @dev This function can only be called by the contract owner and transfers the contract's balance to the owner.\n     */\n    function withdrawDonations() external onlyOwner {}\n\n}\n"
}