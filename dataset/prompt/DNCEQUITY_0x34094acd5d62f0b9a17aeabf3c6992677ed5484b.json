{
    "contract_name": "DNCEQUITY",
    "ground_truth": "contract DNCEQUITY is ERC223BasicToken{\n\taddress admin;\n\tstring public name = \"DinarCoin\";\n    string public symbol = \"DNC\";\n    uint public decimals = 18;\n\tmapping (address => bool) public mintable;\n\n\tevent Minted(address indexed recipient, uint256 value);\n\tevent Burned(address indexed user, uint256 value);\n\n\tfunction DNCEQUITY() {\n\t\tadmin = msg.sender;\n\t}\n\n\tmodifier onlyadmin { if (msg.sender == admin) _; }\n\n\tfunction changeAdmin(address _newAdminAddr) onlyadmin {\n\t\tadmin = _newAdminAddr;\n\t}\n\n\tfunction createNewMintableUser (address newAddr) onlyadmin {\n\t\tif(balances[newAddr] == 0)  \n    \t\tmintable[newAddr] = true;\n\t}\n\t\n\tfunction deleteMintable (address addr) onlyadmin {\n\t    mintable[addr] = false;\n\t}\n\t\n\tfunction adminTransfer(address from, address to, uint256 value) onlyadmin {\n        if(mintable[from] == true) {\n    \t    balances[from] = balances[from].sub(value);\n    \t    balances[to] = balances[to].add(value);\n    \t    Transfer(from, to, value);\n        }\n\t}\n\t\n\tfunction mintNewDNC(address user, uint256 quantity) onlyadmin {\n\t    uint256 correctedQuantity = quantity * (10**(decimals-1));\n        if(mintable[user] == true) {\n            totalSupply = totalSupply.add(correctedQuantity);\n            balances[user] = balances[user].add(correctedQuantity);\n            Transfer(0, user, correctedQuantity);\n            Minted(user, correctedQuantity);\n        }   \n\t}\n\t\n\tfunction burnDNC(address user, uint256 quantity) onlyadmin {\n\t    uint256 correctedQuantity = quantity * (10**(decimals-1));\n\t    if(mintable[user] == true) {\n            balances[user] = balances[user].sub(correctedQuantity);\n            totalSupply = totalSupply.sub(correctedQuantity);\n            Transfer(user, 0, correctedQuantity);\n            Burned(user, correctedQuantity);\n\t    }\n\t}\n}",
    "function_sum": 7,
    "compiler_version": "0.4.21",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract DNCAsset {\n    uint256 public totalSupply = 0;\n    //function balanceOf(address who) constant returns (uint);\n    //function transfer(address _to, uint _value) returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n}\n\ncontract DNCReceivingContract {\n    function tokenFallback(address _from, uint _value, bytes _data);\n}\n\n/* SafeMath for checking eror*/\n\nlibrary SafeMath {\n    \n  function mul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n  function div(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n\n\n}\n\ncontract ERC223BasicToken is DNCAsset{\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    function transfer(address _to, uint _value) returns (bool success) {\n        uint codeLength;\n        bytes memory empty;\n\n        assembly {\n            // Retrieve the size of the code on target address, this needs assembly .\n            codeLength := extcodesize(_to)\n        }\n        \n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        if(codeLength>0) {\n            DNCReceivingContract receiver = DNCReceivingContract(_to);\n            receiver.tokenFallback(msg.sender, _value, empty);\n        }\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint balance) {\n        return balances[_owner];\n    }\n}\n\n\n\n// You task is to complete the smart contract DNCEQUITY strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.21, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title DNCEQUITY\n * @notice This contract implements a basic token following the ERC223 standard with additional functionalities like minting, burning, and admin-controlled transfers.\n * @dev The contract includes an admin role for managing mintable users, transferring tokens, and minting/burning tokens. The decimals are fixed at 18.\n */\ncontract DNCEQUITY is ERC223BasicToken {\n    address admin;\n    string public name = \"DinarCoin\";\n    string public symbol = \"DNC\";\n    uint public decimals = 18;\n    mapping (address => bool) public mintable;\n\n    event Minted(address indexed recipient, uint256 value);\n    event Burned(address indexed user, uint256 value);\n\n    /**\n     * @notice Initializes the contract and sets the admin to the contract deployer.\n     * @dev The admin is set to the address that deploys the contract.\n     */\n    function DNCEQUITY() {\n        admin = msg.sender;\n    }\n\n    /**\n     * @notice Modifier to restrict access to only the admin.\n     * @dev Ensures that the function can only be called by the admin.\n     */\n    modifier onlyadmin { if (msg.sender == admin) _; }\n\n    /**\n     * @notice Allows the current admin to change the admin to a new address.\n     * @dev Only the current admin can call this function.\n     * @param _newAdminAddr The address of the new admin.\n     */\n    function changeAdmin(address _newAdminAddr) onlyadmin {}\n\n    /**\n     * @notice Allows the admin to create a new mintable user.\n     * @dev Only the admin can call this function. The user must not have any existing balance.\n     * @param newAddr The address of the new mintable user.\n     */\n    function createNewMintableUser(address newAddr) onlyadmin {}\n\n    /**\n     * @notice Allows the admin to remove the mintable status from a user.\n     * @dev Only the admin can call this function.\n     * @param addr The address of the user to remove mintable status from.\n     */\n    function deleteMintable(address addr) onlyadmin {}\n\n    /**\n     * @notice Allows the admin to transfer tokens from one address to another.\n     * @dev Only the admin can call this function. The `from` address must be mintable.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param value The amount of tokens to transfer.\n     */\n    function adminTransfer(address from, address to, uint256 value) onlyadmin {}\n\n    /**\n     * @notice Allows the admin to mint new tokens to a specified user.\n     * @dev Only the admin can call this function. The user must be mintable.\n     * @param user The address of the user to receive the new tokens.\n     * @param quantity The amount of tokens to mint.\n     */\n    function mintNewDNC(address user, uint256 quantity) onlyadmin {}\n\n    /**\n     * @notice Allows the admin to burn tokens from a specified user.\n     * @dev Only the admin can call this function. The user must be mintable.\n     * @param user The address of the user to burn tokens from.\n     * @param quantity The amount of tokens to burn.\n     */\n    function burnDNC(address user, uint256 quantity) onlyadmin {}\n}\n"
}