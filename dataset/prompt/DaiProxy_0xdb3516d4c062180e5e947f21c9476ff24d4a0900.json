{
    "contract_name": "DaiProxy",
    "ground_truth": "contract DaiProxy {\n    string public constant version = \"0511\";\n\n    // --- Owner ---\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event SetOwner(address owner);\n\n    function setOwner(address _owner) public onlyOwner {\n        owner = _owner;\n        emit SetOwner(_owner);\n    }\n\n    // --- State ---\n    enum State { Ready, Running, Killed }\n\n    State public state = State.Ready;\n\n    modifier notStarted {\n        require(state == State.Ready);\n        _;\n    }\n\n    modifier notPaused {\n        require(state == State.Running);\n        _;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    function add(uint a, uint b) private pure returns (uint) {\n        require(a <= uint(-1) - b);\n        return a + b;\n    }\n\n    function sub(uint a, uint b) private pure returns (uint) {\n        require(a >= b);\n        return a - b;\n    }\n\n    function mul(uint a, uint b) private pure returns (uint) {\n        require(b == 0 || a <= uint(-1) / b);\n        return a * b;\n    }\n\n    function div(uint a, uint b) private pure returns (uint) {\n        require(b != 0);\n        return a / b;\n    }\n\n    function ceil(uint a, uint b) private pure returns (uint) {\n        require(b != 0);\n\n        uint r = a / b;\n        return a > r * b ? r + 1 : r;\n    }\n\n    function muldiv(uint a, uint b, uint c) private pure returns (uint) {\n        uint safe = 1 << (256 - 32);  // 2.696e67\n        uint mask = (1 << 32) - 1;\n\n        require(c != 0 && c < safe);\n\n        if (b == 0) return 0;\n        if (a < b) (a, b) = (b, a);\n        \n        uint p = a / c;\n        uint r = a % c;\n\n        uint res = 0;\n\n        while (true) {  // most 8 times\n            uint v = b & mask;\n            res = add(res, add(mul(p, v), r * v / c));\n\n            b >>= 32;\n            if (b == 0) break;\n\n            require(p < safe);\n\n            p <<= 32;\n            r <<= 32;\n\n            p = add(p, r / c);\n            r %= c;\n        }\n\n        return res;\n    }\n\n    // --- Contracts & Constructor ---\n    DaiLike public Dai;\n    JoinLike public Join;\n    PotLike public Pot;\n    VatLike public Vat;\n\n    ReserveLike public Reserve;\n\n    WrappedDaiLike public EDai;\n    WrappedDaiLike public ODai;\n\n    event SetReserve(address reserve);\n\n    constructor(address dai, address join, address pot, address vat, address eDai, address oDai) public {\n        owner = msg.sender;\n\n        Dai = DaiLike(dai);\n        Join = JoinLike(join);\n        Pot = PotLike(pot);\n        Vat = VatLike(vat);\n\n        EDai = WrappedDaiLike(eDai);\n        ODai = WrappedDaiLike(oDai);\n\n        require(address(Join.dai()) == dai);\n        require(address(Join.vat()) == vat);\n        require(address(Pot.vat()) == vat);\n\n        Vat.hope(pot);  // Pot.join\n        Vat.hope(join);  // Join.exit\n\n        require(Dai.approve(join, uint(-1)));  // Join.join -> dai.burn\n    }\n\n    function setReserve(address reserve) public onlyOwner {\n        require(EDai.approve(address(Reserve), 0));\n        require(ODai.approve(address(Reserve), 0));\n\n        Reserve = ReserveLike(reserve);\n\n        EDai.setReserve(reserve);\n        ODai.setReserve(reserve);\n\n        // approve for Reserve.depositToken\n        require(EDai.approve(reserve, uint(-1)));\n        require(ODai.approve(reserve, uint(-1)));\n\n        emit SetReserve(reserve);\n    }\n\n    modifier onlyEDai {\n        require(msg.sender == address(EDai));\n        _;\n    }\n\n    modifier onlyODai {\n        require(msg.sender == address(ODai));\n        _;\n    }\n\n    // --- Integration ---\n    function chi() private returns (uint) {\n        return now > Pot.rho() ? Pot.drip() : Pot.chi();\n    }\n\n    function joinDai(uint dai) private {\n        require(Dai.transferFrom(msg.sender, address(this), dai));\n        Join.join(address(this), dai);\n\n        uint vat = Vat.dai(address(this));\n        Pot.join(div(vat, chi()));\n    }\n\n    function exitDai(address to, uint dai) private {\n        uint vat = Vat.dai(address(this));\n        uint req = mul(dai, ONE);\n\n        if (req > vat) {\n            uint pot = ceil(req - vat, chi());\n            Pot.exit(pot);\n        }\n\n        Join.exit(to, dai);\n    }\n\n    function mintODai(address to, uint dai) private returns (uint) {\n        uint wad = dai;\n\n        if (ODai.totalSupply() != 0) {\n            uint pie = Pot.pie(address(this));\n            uint vat = Vat.dai(address(this));\n\n            // \uae30\uc874 rad\n            uint rad = sub(add(mul(pie, chi()), vat), mul(EDai.totalSupply(), ONE));\n\n            // rad : supply = dai * ONE : wad\n            wad = muldiv(ODai.totalSupply(), mul(dai, ONE), rad);\n        }\n\n        joinDai(dai);\n        ODai.mint(to, wad);\n        return wad;\n    }\n\n    function depositEDai(string memory toChain, uint dai, bytes memory to) public notPaused {\n        require(dai > 0);\n\n        joinDai(dai);\n\n        EDai.mint(address(this), dai);\n        Reserve.depositToken(address(EDai), toChain, to, dai);\n    }\n\n    function depositODai(string memory toChain, uint dai, bytes memory to) public notPaused {\n        require(dai > 0);\n\n        uint wad = mintODai(address(this), dai);\n        Reserve.depositToken(address(ODai), toChain, to, wad);\n    }\n\n    function swapFromEDai(address from, address to, uint dai) private {\n        EDai.burn(from, dai);\n        exitDai(to, dai);\n    }\n\n    function swapFromODai(address from, address to, uint wad) private {\n        uint pie = Pot.pie(address(this));\n        uint vat = Vat.dai(address(this));\n\n        // \uae30\uc874 rad\n        uint rad = sub(add(mul(pie, chi()), vat), mul(EDai.totalSupply(), ONE));\n\n        // rad : supply = dai * ONE : wad\n        uint dai = muldiv(rad, wad, mul(ODai.totalSupply(), ONE));\n\n        ODai.burn(from, wad);\n        exitDai(to, dai);\n    }\n\n    function withdrawEDai(address to, uint dai) public onlyEDai notPaused {\n        require(dai > 0);\n\n        swapFromEDai(address(Reserve), to, dai);\n    }\n\n    function withdrawODai(address to, uint wad) public onlyODai notPaused {\n        require(wad > 0);\n\n        swapFromODai(address(Reserve), to, wad);\n    }\n\n    function swapToEDai(uint dai) public notPaused {\n        require(dai > 0);\n\n        joinDai(dai);\n        EDai.mint(msg.sender, dai);\n    }\n\n    function swapToODai(uint dai) public notPaused {\n        require(dai > 0);\n\n        mintODai(msg.sender, dai);\n    }\n\n    function swapFromEDai(uint dai) public notPaused {\n        require(dai > 0);\n\n        swapFromEDai(msg.sender, msg.sender, dai);\n    }\n\n    function swapFromODai(uint wad) public notPaused {\n        require(wad > 0);\n\n        swapFromODai(msg.sender, msg.sender, wad);\n    }\n\n    // --- Migration ---\n    DaiProxy public NewProxy;\n\n    event SetNewProxy(address proxy);\n    event StartProxy(address prev);\n    event KillProxy(address next, bool mig);\n\n    modifier onlyNewProxy {\n        require(msg.sender == address(NewProxy));\n        _;\n    }\n\n\n    function setNewProxy(address proxy) public onlyOwner {\n        NewProxy = DaiProxy(proxy);\n        emit SetNewProxy(proxy);\n    }\n\n\n    function killProxy(address to) public notPaused onlyOwner {\n        state = State.Killed;\n\n        chi();\n\n        Pot.exit(Pot.pie(address(this)));\n        Join.exit(to, Vat.dai(address(this)) / ONE);\n\n        emit KillProxy(to, false);\n    }\n\n\n    function migrateProxy() public notPaused onlyNewProxy {\n        state = State.Killed;\n\n        EDai.setProxy(address(NewProxy));\n        ODai.setProxy(address(NewProxy));\n\n        chi();\n\n        Pot.exit(Pot.pie(address(this)));\n        Vat.move(address(this), address(NewProxy), Vat.dai(address(this)));\n\n        emit KillProxy(address(NewProxy), true);\n    }\n\n\n    function startProxy(address oldProxy) public notStarted onlyOwner {\n        state = State.Running;\n\n        if (oldProxy != address(0)) {\n            DaiProxy(oldProxy).migrateProxy();\n\n            uint vat = Vat.dai(address(this));\n            Pot.join(div(vat, chi()));\n        }\n\n        emit StartProxy(oldProxy);\n    }\n}",
    "function_sum": 26,
    "compiler_version": "0.5.12",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-05-24\n*/\n\ncontract ReserveLike {\n    function depositToken(address, string memory, bytes memory, uint) public;\n}\n\ncontract WrappedDaiLike {\n    function setProxy(address) public;\n    function setReserve(address) public;\n\n    uint public totalSupply;\n    function approve(address, uint) public returns (bool);\n\n    function mint(address, uint) public;\n    function burn(address, uint) public;\n}\n\ncontract DaiLike {\n    function approve(address, uint) public returns (bool);\n    function transferFrom(address, address, uint) public returns (bool);\n}\n\ncontract JoinLike {\n    VatLike public vat;\n    DaiLike public dai;\n\n    function join(address, uint) public;\n    function exit(address, uint) public;\n}\n\ncontract PotLike {\n    mapping(address => uint) public pie;\n    uint public chi;\n\n    VatLike public vat;\n    uint public rho;\n\n    function drip() public returns (uint);\n\n    function join(uint) public;\n    function exit(uint) public;\n}\n\ncontract VatLike {\n    mapping(address => uint) public dai;\n\n    function hope(address) public;\n    function move(address, address, uint) public;\n}\n\n\n\n// You task is to complete the smart contract DaiProxy strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.12, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title DaiProxy\n * @notice A proxy contract for managing DAI and its wrapped versions, including deposit, withdrawal, and migration functionalities.\n * @dev This contract handles the lifecycle of DAI and its wrapped versions (eDai and oDai) with various state transitions and mathematical operations.\n */\ncontract DaiProxy {\n    string public constant version = \"0511\";\n\n    // --- Owner ---\n    address public owner;\n\n    /**\n     * @notice Modifier to restrict function calls to the owner of the contract.\n     * @dev Ensures that only the owner can execute the function.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @notice Event emitted when the owner is set.\n     * @param owner The new owner's address.\n     */\n    event SetOwner(address owner);\n\n    /**\n     * @notice Sets a new owner for the contract.\n     * @param _owner The address of the new owner.\n     * @dev Only the current owner can set a new owner.\n     */\n    function setOwner(address _owner) public onlyOwner {\n    }\n\n    // --- State ---\n    enum State { Ready, Running, Killed }\n\n    State public state = State.Ready;\n\n    /**\n     * @notice Modifier to ensure the function can only be called when the state is Ready.\n     * @dev Ensures that the function is not called after the contract has started.\n     */\n    modifier notStarted {\n        require(state == State.Ready);\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the function can only be called when the state is Running.\n     * @dev Ensures that the function is not called when the contract is paused or killed.\n     */\n    modifier notPaused {\n        require(state == State.Running);\n        _;\n    }\n\n    // --- Math ---\n    uint constant ONE = 10 ** 27;\n\n    /**\n     * @notice Adds two unsigned integers, ensuring no overflow.\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The sum of the two integers.\n     * @dev Ensures that the sum does not overflow.\n     */\n    function add(uint a, uint b) private pure returns (uint) {}\n\n    /**\n     * @notice Subtracts one unsigned integer from another, ensuring no underflow.\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The difference between the two integers.\n     * @dev Ensures that the subtraction does not underflow.\n     */\n    function sub(uint a, uint b) private pure returns (uint) {}\n\n    /**\n     * @notice Multiplies two unsigned integers, ensuring no overflow.\n     * @param a The first integer.\n     * @param b The second integer.\n     * @return The product of the two integers.\n     * @dev Ensures that the multiplication does not overflow.\n     */\n    function mul(uint a, uint b) private pure returns (uint) {}\n\n    /**\n     * @notice Divides one unsigned integer by another, ensuring no division by zero.\n     * @param a The numerator.\n     * @param b The denominator.\n     * @return The quotient of the division.\n     * @dev Ensures that the denominator is not zero.\n     */\n    function div(uint a, uint b) private pure returns (uint) {}\n\n    /**\n     * @notice Calculates the ceiling of the division of two unsigned integers.\n     * @param a The numerator.\n     * @param b The denominator.\n     * @return The ceiling of the division.\n     * @dev Ensures that the denominator is not zero.\n     */\n    function ceil(uint a, uint b) private pure returns (uint) {}\n\n    /**\n     * @notice Performs a multiplication followed by a division, ensuring no overflow or division by zero.\n     * @param a The first integer.\n     * @param b The second integer.\n     * @param c The divisor.\n     * @return The result of the multiplication and division.\n     * @dev Ensures that the divisor is not zero and the multiplication does not overflow.\n     */\n    function muldiv(uint a, uint b, uint c) private pure returns (uint) {}\n\n    // --- Contracts & Constructor ---\n    DaiLike public Dai;\n    JoinLike public Join;\n    PotLike public Pot;\n    VatLike public Vat;\n\n    ReserveLike public Reserve;\n\n    WrappedDaiLike public EDai;\n    WrappedDaiLike public ODai;\n\n    /**\n     * @notice Event emitted when the reserve is set.\n     * @param reserve The address of the new reserve.\n     */\n    event SetReserve(address reserve);\n\n    /**\n     * @notice Initializes the contract with the necessary addresses.\n     * @param dai The address of the DAI token.\n     * @param join The address of the Join contract.\n     * @param pot The address of the Pot contract.\n     * @param vat The address of the Vat contract.\n     * @param eDai The address of the eDai token.\n     * @param oDai The address of the oDai token.\n     * @dev Sets up the initial state and approvals for the contract.\n     */\n    constructor(address dai, address join, address pot, address vat, address eDai, address oDai) public {\n        owner = msg.sender;\n\n        Dai = DaiLike(dai);\n        Join = JoinLike(join);\n        Pot = PotLike(pot);\n        Vat = VatLike(vat);\n\n        EDai = WrappedDaiLike(eDai);\n        ODai = WrappedDaiLike(oDai);\n\n        require(address(Join.dai()) == dai);\n        require(address(Join.vat()) == vat);\n        require(address(Pot.vat()) == vat);\n\n        Vat.hope(pot);  // Pot.join\n        Vat.hope(join);  // Join.exit\n\n        require(Dai.approve(join, uint(-1)));  // Join.join -> dai.burn\n    }\n\n    /**\n     * @notice Sets the reserve contract.\n     * @param reserve The address of the new reserve.\n     * @dev Only the owner can set the reserve. Approves the reserve for eDai and oDai.\n     */\n    function setReserve(address reserve) public onlyOwner {\n    }\n\n    /**\n     * @notice Modifier to restrict function calls to the eDai contract.\n     * @dev Ensures that only the eDai contract can execute the function.\n     */\n    modifier onlyEDai {\n        require(msg.sender == address(EDai));\n        _;\n    }\n\n    /**\n     * @notice Modifier to restrict function calls to the oDai contract.\n     * @dev Ensures that only the oDai contract can execute the function.\n     */\n    modifier onlyODai {\n        require(msg.sender == address(ODai));\n        _;\n    }\n\n    // --- Integration ---\n    /**\n     * @notice Returns the current chi value from the Pot contract.\n     * @return The chi value.\n     * @dev Updates the chi value if necessary.\n     */\n    function chi() private returns (uint) {}\n\n    /**\n     * @notice Joins DAI into the system.\n     * @param dai The amount of DAI to join.\n     * @dev Transfers DAI from the sender, joins it, and updates the Pot.\n     */\n    function joinDai(uint dai) private {}\n\n    /**\n     * @notice Exits DAI from the system.\n     * @param to The address to send the DAI to.\n     * @param dai The amount of DAI to exit.\n     * @dev Exits DAI from the Pot and sends it to the specified address.\n     */\n    function exitDai(address to, uint dai) private {}\n\n    /**\n     * @notice Mints oDai for a given amount of DAI.\n     * @param to The address to mint the oDai to.\n     * @param dai The amount of DAI to mint oDai for.\n     * @return The amount of oDai minted.\n     * @dev Joins DAI, calculates the oDai amount, and mints it.\n     */\n    function mintODai(address to, uint dai) private returns (uint) {}\n\n    /**\n     * @notice Deposits eDai to the reserve.\n     * @param toChain The destination chain.\n     * @param dai The amount of DAI to deposit.\n     * @param to The recipient address on the destination chain.\n     * @dev Joins DAI, mints eDai, and deposits it to the reserve.\n     */\n    function depositEDai(string memory toChain, uint dai, bytes memory to) public notPaused {}\n\n    /**\n     * @notice Deposits oDai to the reserve.\n     * @param toChain The destination chain.\n     * @param dai The amount of DAI to deposit.\n     * @param to The recipient address on the destination chain.\n     * @dev Mints oDai, joins DAI, and deposits it to the reserve.\n     */\n    function depositODai(string memory toChain, uint dai, bytes memory to) public notPaused {}\n\n    /**\n     * @notice Swaps eDai for DAI.\n     * @param from The address to burn eDai from.\n     * @param to The address to send DAI to.\n     * @param dai The amount of DAI to swap.\n     * @dev Burns eDai and exits DAI to the specified address.\n     */\n    function swapFromEDai(address from, address to, uint dai) private {}\n\n    /**\n     * @notice Swaps oDai for DAI.\n     * @param from The address to burn oDai from.\n     * @param to The address to send DAI to.\n     * @param wad The amount of oDai to swap.\n     * @dev Burns oDai, calculates the DAI amount, and exits DAI to the specified address.\n     */\n    function swapFromODai(address from, address to, uint wad) private {}\n\n    /**\n     * @notice Withdraws eDai from the reserve.\n     * @param to The address to send the DAI to.\n     * @param dai The amount of DAI to withdraw.\n     * @dev Swaps eDai for DAI and sends it to the specified address.\n     */\n    function withdrawEDai(address to, uint dai) public onlyEDai notPaused {}\n\n    /**\n     * @notice Withdraws oDai from the reserve.\n     * @param to The address to send the DAI to.\n     * @param wad The amount of oDai to withdraw.\n     * @dev Swaps oDai for DAI and sends it to the specified address.\n     */\n    function withdrawODai(address to, uint wad) public onlyODai notPaused {}\n\n    /**\n     * @notice Swaps DAI for eDai.\n     * @param dai The amount of DAI to swap.\n     * @dev Joins DAI, mints eDai, and sends it to the sender.\n     */\n    function swapToEDai(uint dai) public notPaused {}\n\n    /**\n     * @notice Swaps DAI for oDai.\n     * @param dai The amount of DAI to swap.\n     * @dev Mints oDai for the specified DAI amount.\n     */\n    function swapToODai(uint dai) public notPaused {}\n\n    /**\n     * @notice Swaps eDai for DAI.\n     * @param dai The amount of DAI to swap.\n     * @dev Swaps eDai for DAI and sends it to the sender.\n     */\n    function swapFromEDai(uint dai) public notPaused {}\n\n    /**\n     * @notice Swaps oDai for DAI.\n     * @param wad The amount of oDai to swap.\n     * @dev Swaps oDai for DAI and sends it to the sender.\n     */\n    function swapFromODai(uint wad) public notPaused {}\n\n    // --- Migration ---\n    DaiProxy public NewProxy;\n\n    /**\n     * @notice Event emitted when a new proxy is set.\n     * @param proxy The address of the new proxy.\n     */\n    event SetNewProxy(address proxy);\n\n    /**\n     * @notice Event emitted when the proxy is started.\n     * @param prev The address of the previous proxy.\n     */\n    event StartProxy(address prev);\n\n    /**\n     * @notice Event emitted when the proxy is killed.\n     * @param next The address of the next proxy.\n     * @param mig Whether the migration was successful.\n     */\n    event KillProxy(address next, bool mig);\n\n    /**\n     * @notice Modifier to restrict function calls to the new proxy contract.\n     * @dev Ensures that only the new proxy can execute the function.\n     */\n    modifier onlyNewProxy {\n        require(msg.sender == address(NewProxy));\n        _;\n    }\n\n    /**\n     * @notice Sets a new proxy contract.\n     * @param proxy The address of the new proxy.\n     * @dev Only the owner can set a new proxy.\n     */\n    function setNewProxy(address proxy) public onlyOwner {\n    }\n\n    /**\n     * @notice Kills the proxy and transfers remaining DAI to the specified address.\n     * @param to The address to transfer the remaining DAI to.\n     * @dev Only the owner can kill the proxy. Exits all DAI from the Pot and sends it to the specified address.\n     */\n    function killProxy(address to) public notPaused onlyOwner {}\n\n    /**\n     * @notice Migrates the proxy to a new proxy.\n     * @dev Only the new proxy can migrate. Transfers DAI and sets the new proxy for eDai and oDai.\n     */\n    function migrateProxy() public notPaused onlyNewProxy {}\n\n    /**\n     * @notice Starts the proxy, optionally migrating from an old proxy.\n     * @param oldProxy The address of the old proxy.\n     * @dev Only the owner can start the proxy. Joins any remaining DAI from the old proxy.\n     */\n    function startProxy(address oldProxy) public notStarted onlyOwner {}\n}\n"
}