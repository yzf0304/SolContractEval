{
    "contract_name": "ESSENTIA_ERC20",
    "ground_truth": "contract ESSENTIA_ERC20 is Ownable {\n\n    using SafeMath for uint256;\n\n\n    mapping (address => uint256) public balances;\n\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n    // Public variables for the ESSENTIA ERC20 ESS token contract\n    string public constant standard = \"ESSENTIA erc20 and Genesis\";\n    uint256 public constant decimals = 18;   // hardcoded to be a constant\n    string public name = \"ESSENTIA\";\n    string public symbol = \"ESS\";\n    uint256 public totalSupply;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n        // SafeMath.sub will throw if there is not enough balance.\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n\n\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n\n        balances[_to] = balances[_to].add(_value);\n\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n}",
    "function_sum": 8,
    "compiler_version": "0.4.24",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/*\n\n    Copyright 2018, Angelo A. M. & Vicent Nos & Mireia Puig\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*/\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() internal {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external ;\n}\n\n\n\n// You task is to complete the smart contract ESSENTIA_ERC20 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.24, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ESSENTIA_ERC20\n * @notice This contract implements the ERC20 standard for the ESSENTIA token (ESS).\n * @dev The contract is based on the OpenZeppelin Ownable contract, which provides basic authorization control.\n */\ncontract ESSENTIA_ERC20 is Ownable {\n\n    using SafeMath for uint256;\n\n    // Mapping of addresses to their respective token balances\n    mapping (address => uint256) public balances;\n\n    // Mapping of allowances for spending tokens\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    // Public variables for the ESSENTIA ERC20 ESS token contract\n    string public constant standard = \"ESSENTIA erc20 and Genesis\";\n    uint256 public constant decimals = 18;   // hardcoded to be a constant\n    string public name = \"ESSENTIA\";\n    string public symbol = \"ESS\";\n    uint256 public totalSupply;\n\n    // Event to notify when tokens are transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // Event to notify when an allowance is set\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @param _owner The address to query the balance of.\n     * @return The balance of the specified address.\n     * @dev This function is used to check the balance of an address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {}\n\n    /**\n     * @notice Transfers `_value` amount of tokens from the caller's account to `_to`.\n     * @param _to The recipient address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function ensures that the sender has enough balance and emits a `Transfer` event.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool) {}\n\n    /**\n     * @notice Transfers `_value` amount of tokens from `_from` to `_to` using the allowance mechanism.\n     * @param _from The address to transfer tokens from.\n     * @param _to The recipient address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function checks the allowance and the balance of `_from` and emits a `Transfer` event.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {}\n\n    /**\n     * @notice Approves `_spender` to spend `_value` amount of tokens on behalf of the caller.\n     * @param _spender The address that will spend the tokens.\n     * @param _value The amount of tokens to approve.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function sets the allowance and emits an `Approval` event.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {}\n\n    /**\n     * @notice Returns the remaining number of tokens that `_spender` is allowed to spend on behalf of `_owner`.\n     * @param _owner The address of the token owner.\n     * @param _spender The address of the spender.\n     * @return The remaining allowance.\n     * @dev This function is used to check the current allowance.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {}\n\n    /**\n     * @notice Increases the allowance granted to `_spender` by adding `_addedValue`.\n     * @param _spender The address that will spend the tokens.\n     * @param _addedValue The amount to increase the allowance by.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function updates the allowance and emits an `Approval` event.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {}\n\n    /**\n     * @notice Decreases the allowance granted to `_spender` by subtracting `_subtractedValue`.\n     * @param _spender The address that will spend the tokens.\n     * @param _subtractedValue The amount to decrease the allowance by.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function updates the allowance and emits an `Approval` event. If the new allowance is less than 0, it is set to 0.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {}\n\n    /**\n     * @notice Approves `_spender` to spend `_value` amount of tokens and then calls a function on `_spender` with additional data.\n     * @param _spender The address that will spend the tokens.\n     * @param _value The amount of tokens to approve.\n     * @param _extraData Additional data to pass to the `receiveApproval` function.\n     * @return A boolean indicating whether the operation was successful.\n     * @dev This function combines the `approve` and `receiveApproval` calls in a single transaction.\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {}\n}\n"
}