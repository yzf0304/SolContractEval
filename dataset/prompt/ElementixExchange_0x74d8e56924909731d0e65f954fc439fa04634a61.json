{
    "contract_name": "ProxyRegistry",
    "ground_truth": "contract ProxyRegistry is Ownable {\n\n    /* DelegateProxy implementation contract. Must be initialized. */\n    address public delegateProxyImplementation;\n\n    /* Authenticated proxies by user. */\n    mapping(address => OwnableDelegateProxy) public proxies;\n\n    /* Contracts pending access. */\n    mapping(address => uint256) public pending;\n\n    /* Contracts allowed to call those proxies. */\n    mapping(address => bool) public contracts;\n\n    /* Delay period for adding an authenticated contract.\n       This mitigates a particular class of potential attack on the Elementix DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the ELT supply (votes in the DAO),\n       a malicious but rational attacker could buy half the Elementix and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given one weeks, if that happened, users would have\n       plenty of time to notice and transfer their assets.\n    */\n    uint256 public DELAY_PERIOD = 7 days;\n\n    // event\n    event RegisterProxy(address indexed sender, address proxyAddr);\n    event AuthenticationOperation(address indexed addr, bool opt);\n\n    /**\n     * Start the process to enable access for specified contract. Subject to delay period.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address to which to grant permissions\n     */\n    function startGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        require(!contracts[addr] && pending[addr] == 0);\n        pending[addr] = block.timestamp;\n    }\n\n    /**\n     * End the process to nable access for specified contract after delay period has passed.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address to which to grant permissions\n     */\n    function endGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < block.timestamp));\n        pending[addr] = 0;\n        contracts[addr] = true;\n        emit AuthenticationOperation(addr, true);\n    }\n\n    /**\n     * Revoke access for specified contract. Can be done instantly.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address of which to revoke permissions\n     */    \n    function revokeAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        contracts[addr] = false;\n        emit AuthenticationOperation(addr, false);\n    }\n\n    /**\n     * Register a proxy contract with this registry\n     *\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\n     * @return proxy New AuthenticatedProxy contract\n     */\n    function registerProxy()\n        public\n        returns (OwnableDelegateProxy proxy)\n    {\n        require(address(proxies[msg.sender]) == address(0),\"dup register\");\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", msg.sender, address(this)));\n        proxies[msg.sender] = proxy;\n        emit RegisterProxy(msg.sender, address(proxy));\n        return proxy;\n    }\n\n}",
    "function_sum": 4,
    "compiler_version": "0.8.4",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n// File: dependencies/openzeppelin/contracts/utils/Context.sol\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n// File: dependencies/openzeppelin/contracts/access/Ownable.sol\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\n\n\n// You task is to complete the smart contract ProxyRegistry strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.4, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ProxyRegistry\n * @notice A registry for managing proxy contracts and their permissions.\n * @dev This contract allows the owner to grant and revoke access to specific contracts, and users to register their own proxy contracts.\n */\ncontract ProxyRegistry is Ownable {\n\n    /* DelegateProxy implementation contract. Must be initialized. */\n    address public delegateProxyImplementation;\n\n    /* Authenticated proxies by user. */\n    mapping(address => OwnableDelegateProxy) public proxies;\n\n    /* Contracts pending access. */\n    mapping(address => uint256) public pending;\n\n    /* Contracts allowed to call those proxies. */\n    mapping(address => bool) public contracts;\n\n    /* Delay period for adding an authenticated contract.\n       This mitigates a particular class of potential attack on the Elementix DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the ELT supply (votes in the DAO),\n       a malicious but rational attacker could buy half the Elementix and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given one weeks, if that happened, users would have\n       plenty of time to notice and transfer their assets.\n    */\n    uint256 public DELAY_PERIOD = 7 days;\n\n    // event\n    event RegisterProxy(address indexed sender, address proxyAddr);\n    event AuthenticationOperation(address indexed addr, bool opt);\n\n    /**\n     * @notice Start the process to enable access for a specified contract. Subject to a delay period.\n     * @dev Only the owner of the ProxyRegistry can call this function.\n     * @param addr Address to which to grant permissions\n     */\n    function startGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {}\n\n    /**\n     * @notice End the process to enable access for a specified contract after the delay period has passed.\n     * @dev Only the owner of the ProxyRegistry can call this function.\n     * @param addr Address to which to grant permissions\n     */\n    function endGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {}\n\n    /**\n     * @notice Revoke access for a specified contract. Can be done instantly.\n     * @dev Only the owner of the ProxyRegistry can call this function.\n     * @param addr Address of which to revoke permissions\n     */\n    function revokeAuthentication (address addr)\n        public\n        onlyOwner\n    {}\n\n    /**\n     * @notice Register a proxy contract with this registry.\n     * @dev Must be called by the user for whom the proxy is being created. Creates a new AuthenticatedProxy.\n     * @return proxy New AuthenticatedProxy contract\n     */\n    function registerProxy()\n        public\n        returns (OwnableDelegateProxy proxy)\n    {}\n}\n"
}