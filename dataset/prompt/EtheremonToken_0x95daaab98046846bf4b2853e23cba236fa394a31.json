{
    "contract_name": "TokenERC20",
    "ground_truth": "contract TokenERC20 {\n\n    uint256 public totalSupply;\n\n\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Burn(address indexed from, uint256 value);\n\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n\n        Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n\n    }\n\n\n\n    function transfer(address _to, uint256 _value) public {\n\n        _transfer(msg.sender, _to, _value);\n\n    }\n\n\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require(_value <= allowance[_from][msg.sender]);\n\n        allowance[_from][msg.sender] -= _value;\n\n        _transfer(_from, _to, _value);\n\n        return true; \n\n    }\n\n\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        allowance[msg.sender][_spender] = _value;\n\n        return true;\n\n    }\n\n\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n\n        TokenRecipient spender = TokenRecipient(_spender);\n\n        if (approve(_spender, _value)) {\n\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n\n        }\n\n    }\n\n\n\n    function burn(uint256 _value) public returns (bool success) {\n\n        require(balanceOf[msg.sender] >= _value);\n\n        balanceOf[msg.sender] -= _value;\n\n        totalSupply -= _value;\n\n        Burn(msg.sender, _value);\n\n        return true;\n\n    }\n\n\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\n        require(balanceOf[_from] >= _value);\n\n        require(_value <= allowance[_from][msg.sender]);\n\n        balanceOf[_from] -= _value;\n\n        allowance[_from][msg.sender] -= _value;\n\n        totalSupply -= _value;\n\n        Burn(_from, _value);\n\n        return true;\n\n    }\n\n}",
    "function_sum": 7,
    "compiler_version": "0.4.19",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ninterface TokenRecipient { \n\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; \n\n}\n\n\n\n// You task is to complete the smart contract TokenERC20 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.19, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice A simple ERC20 token contract.\n * @dev This contract implements the basic functionalities of an ERC20 token, including transfer, approve, and burn.\n */\ncontract TokenERC20 {\n\n    uint256 public totalSupply;\n\n    /**\n     * @notice A mapping to keep track of the balance of each address.\n     * @dev This mapping stores the amount of tokens held by each address.\n     */\n    mapping (address => uint256) public balanceOf;\n\n    /**\n     * @notice A mapping to keep track of the allowance for a specific spender.\n     * @dev This mapping stores the amount of tokens that a specific address is allowed to spend on behalf of another address.\n     */\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /**\n     * @notice Event triggered when tokens are transferred from one address to another.\n     * @dev This event logs the sender, recipient, and the amount of tokens transferred.\n     * @param _from The address from which the tokens are sent.\n     * @param _to The address to which the tokens are sent.\n     * @param _value The amount of tokens transferred.\n     */\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * @notice Event triggered when tokens are burned (destroyed).\n     * @dev This event logs the address that burned the tokens and the amount of tokens burned.\n     * @param _from The address that burned the tokens.\n     * @param _value The amount of tokens burned.\n     */\n    event Burn(address indexed _from, uint256 _value);\n\n    /**\n     * @dev Internal function to transfer tokens between two addresses.\n     * @param _from The address from which the tokens are sent.\n     * @param _to The address to which the tokens are sent.\n     * @param _value The amount of tokens to be transferred.\n     */\n    function _transfer(address _from, address _to, uint _value) internal {}\n\n    /**\n     * @notice Transfers tokens from the message sender to another address.\n     * @dev This function calls the internal `_transfer` function to perform the transfer.\n     * @param _to The address to which the tokens are sent.\n     * @param _value The amount of tokens to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public {}\n\n    /**\n     * @notice Transfers tokens from one address to another, using the allowance mechanism.\n     * @dev This function ensures that the spender has enough allowance to transfer the specified amount of tokens.\n     * @param _from The address from which the tokens are sent.\n     * @param _to The address to which the tokens are sent.\n     * @param _value The amount of tokens to be transferred.\n     * @return success True if the transfer was successful.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Approves a spender to transfer a specified amount of tokens on behalf of the message sender.\n     * @dev This function sets the allowance for the specified spender.\n     * @param _spender The address that will be allowed to spend the tokens.\n     * @param _value The amount of tokens that the spender is allowed to spend.\n     * @return success True if the approval was successful.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Approves a spender to transfer a specified amount of tokens and calls a callback function on the spender.\n     * @dev This function sets the allowance and then calls a callback function on the spender with additional data.\n     * @param _spender The address that will be allowed to spend the tokens.\n     * @param _value The amount of tokens that the spender is allowed to spend.\n     * @param _extraData Additional data to be passed to the callback function.\n     * @return success True if the approval and callback were successful.\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {}\n\n    /**\n     * @notice Burns (destroys) a specified amount of tokens from the message sender's balance.\n     * @dev This function reduces the total supply and the message sender's balance by the specified amount.\n     * @param _value The amount of tokens to be burned.\n     * @return success True if the burn was successful.\n     */\n    function burn(uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Burns (destroys) a specified amount of tokens from another address, using the allowance mechanism.\n     * @dev This function reduces the total supply and the specified address's balance by the specified amount, and also reduces the allowance.\n     * @param _from The address from which the tokens are burned.\n     * @param _value The amount of tokens to be burned.\n     * @return success True if the burn was successful.\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {}\n}\n"
}