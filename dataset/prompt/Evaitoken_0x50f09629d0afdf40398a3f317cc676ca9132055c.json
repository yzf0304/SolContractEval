{
    "contract_name": "Evaitoken",
    "ground_truth": "contract Evaitoken is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public initialSupply;\n    uint256 public _totalSupply;\n    address public owner;\n    uint256 public totalProfit;\n    uint256 public profit;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    mapping(uint256 => uint256) internal token;\n\n    constructor() public {\n        name = \"EVAI.IO\";\n        symbol = \"EVAI\";\n        decimals = 8;\n        _totalSupply = 1000000000 * 10**uint256(decimals);\n        initialSupply = _totalSupply;\n        balances[msg.sender] = _totalSupply;\n        owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function totalSupply() external view override returns (uint256) {\n        return safeSub(_totalSupply, balances[address(0)]);\n    }\n\n    function balanceOf(address tokenOwner)\n        external\n        view\n        override\n        returns (uint256 getBalance)\n    {\n        return balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender)\n        external\n        view\n        override\n        returns (uint256 remaining)\n    {\n        return allowed[tokenOwner][spender];\n    }\n\n    function approve(address spender, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transfer(address to, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        require(to != address(0));\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external override returns (bool success) {\n        require(to != address(0));\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n\n    function buy(address to, uint256 tokens)\n        external\n        override\n        returns (bool success)\n    {\n        require(to != address(0));\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function operationProfit(uint256 _profit)\n        external\n        override\n        returns (bool success)\n    {\n        require(owner == msg.sender, \"This is not owner\");\n        profit = _profit;\n        totalProfit = safeAdd(totalProfit, profit);\n        emit Profit(msg.sender, profit, totalProfit);\n        return true;\n    }\n\n    function burn(uint256 tokens) external override returns (bool success) {\n        require(owner == msg.sender, \"This is not owner\");\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        _totalSupply = safeSub(_totalSupply, tokens);\n        emit Burn(msg.sender, address(0), tokens);\n        return true;\n    }\n}",
    "function_sum": 9,
    "compiler_version": "0.6.10",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-06-06\n*/\n/**\n *Submitted for verification at Etherscan.io on 2020-07-21\n */\n// SPDX-License-Identifier: MIT\n//--------------------------------------\n//  EVAI contract\n//\n// Symbol      : EVAI\n// Name        : EVAI.IO\n// Total supply: 1000000000\n// Decimals    : 8\n//--------------------------------------\n\nabstract contract ERC20Interface {\n    function totalSupply() external view virtual returns (uint256);\n\n    function balanceOf(address tokenOwner)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function allowance(address tokenOwner, address spender)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function transfer(address to, uint256 tokens)\n        external\n        virtual\n        returns (bool);\n\n    function approve(address spender, uint256 tokens)\n        external\n        virtual\n        returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokens\n    ) external virtual returns (bool);\n\n    function burn(uint256 tokens) external virtual returns (bool success);\n\n    function buy(address to, uint256 tokens) external virtual returns (bool);\n\n    function operationProfit(uint256 _profit) external virtual returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(\n        address indexed tokenOwner,\n        address indexed spender,\n        uint256 tokens\n    );\n    event Burn(address from, address, uint256 value);\n    event Profit(address from, uint256 profit, uint256 totalProfit);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\n\ncontract SafeMath {\n    function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        c = a - b;\n        return c;\n    }\n}\n\n\n\n// You task is to complete the smart contract Evaitoken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.6.10, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Evaitoken\n * @notice This contract implements the ERC20 token standard with additional functionalities like profit tracking and token burning.\n * @dev The contract uses SafeMath for arithmetic operations to prevent overflows and underflows.\n */\ncontract Evaitoken is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public initialSupply;\n    uint256 public _totalSupply;\n    address public owner;\n    uint256 public totalProfit;\n    uint256 public profit;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    mapping(uint256 => uint256) internal token;\n\n    /**\n     * @notice Initializes the contract with the initial supply of tokens and sets the owner.\n     * @dev The constructor sets the token's name, symbol, decimals, and initial supply. It also assigns the entire initial supply to the contract deployer.\n     */\n    constructor() public {\n        name = \"EVAI.IO\";\n        symbol = \"EVAI\";\n        decimals = 8;\n        _totalSupply = 1000000000 * 10**uint256(decimals);\n        initialSupply = _totalSupply;\n        balances[msg.sender] = _totalSupply;\n        owner = msg.sender;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    /**\n     * @notice Returns the total supply of tokens, excluding any tokens sent to the zero address.\n     * @dev This function calculates the total supply by subtracting the balance of the zero address from the `_totalSupply`.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() external view override returns (uint256) {}\n\n    /**\n     * @notice Returns the balance of a specific token holder.\n     * @dev This function retrieves the balance of the specified `tokenOwner` from the `balances` mapping.\n     * @param tokenOwner The address of the token holder.\n     * @return getBalance The balance of the token holder.\n     */\n    function balanceOf(address tokenOwner) external view override returns (uint256 getBalance) {}\n\n    /**\n     * @notice Returns the amount of tokens that an owner allowed to a spender.\n     * @dev This function retrieves the allowance set by `tokenOwner` for `spender` from the `allowed` mapping.\n     * @param tokenOwner The address of the token owner.\n     * @param spender The address of the spender.\n     * @return remaining The remaining allowance.\n     */\n    function allowance(address tokenOwner, address spender) external view override returns (uint256 remaining) {}\n\n    /**\n     * @notice Sets the amount of tokens that an owner allows to a spender.\n     * @dev This function updates the `allowed` mapping and emits an `Approval` event.\n     * @param spender The address of the spender.\n     * @param tokens The number of tokens to approve.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 tokens) external override returns (bool success) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from the message sender to another address.\n     * @dev This function updates the `balances` mapping and emits a `Transfer` event.\n     * @param to The address to transfer tokens to.\n     * @param tokens The number of tokens to transfer.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address to, uint256 tokens) external override returns (bool success) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from one address to another, using the allowance mechanism.\n     * @dev This function updates the `balances` and `allowed` mappings and emits a `Transfer` event.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param tokens The number of tokens to transfer.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(address from, address to, uint256 tokens) external override returns (bool success) {}\n\n    /**\n     * @notice Allows the purchase of tokens and transfers them to a specified address.\n     * @dev This function updates the `balances` mapping and emits a `Transfer` event.\n     * @param to The address to transfer tokens to.\n     * @param tokens The number of tokens to transfer.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function buy(address to, uint256 tokens) external override returns (bool success) {}\n\n    /**\n     * @notice Updates the profit and total profit of the contract.\n     * @dev This function can only be called by the contract owner and updates the `profit` and `totalProfit` variables.\n     * @param _profit The amount of profit to add.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function operationProfit(uint256 _profit) external override returns (bool success) {}\n\n    /**\n     * @notice Burns a specified amount of tokens from the owner's balance.\n     * @dev This function can only be called by the contract owner and updates the `balances` and `_totalSupply` variables.\n     * @param tokens The number of tokens to burn.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function burn(uint256 tokens) external override returns (bool success) {}\n\n    /**\n     * @notice Fallback function to receive Ether.\n     * @dev This function is used to receive Ether, but it does not perform any action in this contract.\n     */\n    receive() external payable {}\n}\n"
}