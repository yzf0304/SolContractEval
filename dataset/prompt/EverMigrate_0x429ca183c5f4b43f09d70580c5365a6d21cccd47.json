{
    "contract_name": "EverMigrate",
    "ground_truth": "contract EverMigrate is IEverMigrate, Context, Ownable {\n    using SafeMath for uint256;\n\n    struct TokenDetails {\n        address sourceToken;\n        address targetToken;\n        address devAddress;\n        uint256 ratio;\n        bool isPresent;\n    }\n\n    struct Transaction {\n        uint256 amount;\n        uint256 timestamp;\n        uint32 txnId;\n    }\n\n    mapping (address => TokenDetails) private _tokenList;\n    address[] private _allTokens;\n\n    \n    uint32 private _txnId = 0;\n    mapping (address => mapping (address => Transaction[])) private _userTxns;\n\n    constructor() {\n\n    }\n\n    function addTokenDetails(\n        address sourceToken,\n        address targetToken,\n        address devAddress,\n        uint256 ratio) external onlyOwner {\n        _tokenList[sourceToken] = TokenDetails(sourceToken, targetToken, devAddress, ratio, true);\n        _allTokens.push(sourceToken);\n\n        emit TokenAdded(sourceToken, targetToken, ratio);\n    }\n\n    function migrateTokens(address sourceToken, address toAddress, uint256 amount) \n        external {\n        require(amount > 0, \"Amount should be greater than Zero\");\n        require(toAddress != address(0), \"ERC20: transfer to the zero address is not allowed\");\n        require(supportsToken(sourceToken), \"Unsupported sourceToken\");\n\n        TokenDetails memory tokenDetails = _tokenList[sourceToken];\n        uint256 amountOut = amount\n            .mul(10**IERC20(tokenDetails.targetToken).decimals())\n            .div(10**IERC20(tokenDetails.sourceToken).decimals())\n            .div(tokenDetails.ratio);\n\n        IERC20(tokenDetails.sourceToken).transferFrom(_msgSender(), tokenDetails.devAddress, amount);\n        IERC20(tokenDetails.targetToken).transfer(toAddress, amountOut);\n\n        Transaction[] storage userTxns = _userTxns[sourceToken][_msgSender()];\n        userTxns.push(\n            Transaction({\n                amount: amount,\n                timestamp: block.timestamp,\n                txnId: _txnId\n            })\n        );\n        _userTxns[sourceToken][_msgSender()] = userTxns;\n\n        _txnId = _txnId + 1;\n\n        emit TokensMigrated(tokenDetails.sourceToken, tokenDetails.targetToken, amount, amountOut);\n    }\n\n    function userTransactionsLength(address sourceToken, address userAddress) \n        external view returns (uint256) {\n        return _userTxns[sourceToken][userAddress].length;\n    }\n\n    function userTransaction(address sourceToken, address userAddress, uint256 position)\n        external view returns (uint256, uint256, uint32) {\n        Transaction storage txn = _userTxns[sourceToken][userAddress][position];\n        \n        return (txn.amount, txn.timestamp, txn.txnId);\n    }\n    \n    function returnTokens(address sourceToken, address toAddress, uint256 amount)\n        external onlyOwner {\n        require(amount > 0, \"Amount should be greater than Zero\");\n        require(toAddress != address(0), \"ERC20: transfer to the zero address is not allowed\");\n        require(supportsToken(sourceToken), \"Unsupported sourceToken\");\n\n        TokenDetails memory tokenDetails = _tokenList[sourceToken];\n        IERC20(tokenDetails.targetToken).transfer(toAddress, amount);\n\n        emit TokensReturned(tokenDetails.targetToken, toAddress, amount);\n    }\n    \n    function tokenMigrateDetails(address sourceToken) \n        external \n        view \n    returns (address targetToken, uint256 ratio) {\n        require(supportsToken(sourceToken), \"Unsupported sourceToken\");\n        \n        TokenDetails storage details = _tokenList[sourceToken];\n\n        targetToken = details.targetToken;\n        ratio = details.ratio;\n    }\n\n    function allSupportedTokens() external view returns (address[] memory supportedTokens) {\n        return _allTokens;\n    }\n\n    function allSupportedTokensLength() external view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function supportsToken(address sourceToken) public view returns(bool) {\n        if (_tokenList[sourceToken].isPresent) return true;\n\n        return false;\n    }\n}",
    "function_sum": 9,
    "compiler_version": "0.8.8",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-02-17\n*/\n// SPDX-License-Identifier: MIT\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n    function decimals() external pure returns (uint8);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }   \n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface IEverMigrate {\n    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external;\n    function returnTokens(address sourceToken, address toAddress, uint256 amount) external;\n    function tokenMigrateDetails(address sourceToken) external view returns (address targetToken, uint256 ratio);\n    function allSupportedTokens() external view returns (address[] memory);\n    function allSupportedTokensLength() external view returns (uint256);\n    function supportsToken(address sourceToken) external view returns(bool);\n    \n    event TokenAdded(address fromToken, address toToken, uint256 ratio);\n    event TokensMigrated(address fromToken, address toToken, uint256 amountIn, uint256 amountOut);\n    event TokensReturned(address token, address toAddress, uint256 amount);\n}\n\n\n\n// You task is to complete the smart contract EverMigrate strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.8, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title EverMigrate\n * @notice A contract for migrating tokens from a source token to a target token, with support for tracking user transactions.\n * @dev The contract allows the owner to add token pairs and migrate tokens. It also provides functions to retrieve transaction details and supported tokens.\n */\ncontract EverMigrate is IEverMigrate, Context, Ownable {\n    using SafeMath for uint256;\n\n    struct TokenDetails {\n        address sourceToken;\n        address targetToken;\n        address devAddress;\n        uint256 ratio;\n        bool isPresent;\n    }\n\n    struct Transaction {\n        uint256 amount;\n        uint256 timestamp;\n        uint32 txnId;\n    }\n\n    mapping (address => TokenDetails) private _tokenList;\n    address[] private _allTokens;\n\n    uint32 private _txnId = 0;\n    mapping (address => mapping (address => Transaction[])) private _userTxns;\n\n    constructor() {\n\n    }\n\n    /**\n     * @notice Adds a new token pair to the migration list.\n     * @param sourceToken The address of the source token.\n     * @param targetToken The address of the target token.\n     * @param devAddress The address where the source tokens will be sent.\n     * @param ratio The conversion ratio between the source and target tokens.\n     * @dev Only the contract owner can call this function.\n     */\n    function addTokenDetails(\n        address sourceToken,\n        address targetToken,\n        address devAddress,\n        uint256 ratio\n    ) external onlyOwner {}\n\n    /**\n     * @notice Migrates tokens from the source token to the target token.\n     * @param sourceToken The address of the source token.\n     * @param toAddress The recipient address for the target tokens.\n     * @param amount The amount of source tokens to migrate.\n     * @dev The function checks if the source token is supported, transfers the source tokens to the dev address, and sends the converted target tokens to the recipient.\n     */\n    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {}\n\n    /**\n     * @notice Returns the number of transactions for a specific user and source token.\n     * @param sourceToken The address of the source token.\n     * @param userAddress The address of the user.\n     * @return The number of transactions.\n     * @dev This function is used to get the length of the transaction history for a user.\n     */\n    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {}\n\n    /**\n     * @notice Returns the details of a specific transaction for a user and source token.\n     * @param sourceToken The address of the source token.\n     * @param userAddress The address of the user.\n     * @param position The index of the transaction in the user's transaction history.\n     * @return The amount, timestamp, and transaction ID of the transaction.\n     * @dev This function is used to get the details of a specific transaction.\n     */\n    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {}\n\n    /**\n     * @notice Returns tokens to a specified address.\n     * @param sourceToken The address of the source token.\n     * @param toAddress The recipient address for the returned tokens.\n     * @param amount The amount of tokens to return.\n     * @dev Only the contract owner can call this function. The function checks if the source token is supported and transfers the target tokens to the recipient.\n     */\n    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {}\n\n    /**\n     * @notice Returns the migration details for a specific source token.\n     * @param sourceToken The address of the source token.\n     * @return The target token address and the conversion ratio.\n     * @dev This function is used to get the migration details for a specific source token.\n     */\n    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {}\n\n    /**\n     * @notice Returns an array of all supported source tokens.\n     * @return An array of supported source token addresses.\n     * @dev This function is used to get a list of all supported source tokens.\n     */\n    function allSupportedTokens() external view returns (address[] memory) {}\n\n    /**\n     * @notice Returns the number of supported source tokens.\n     * @return The number of supported source tokens.\n     * @dev This function is used to get the count of all supported source tokens.\n     */\n    function allSupportedTokensLength() external view returns (uint256) {}\n\n    /**\n     * @notice Checks if a specific source token is supported.\n     * @param sourceToken The address of the source token.\n     * @return True if the token is supported, false otherwise.\n     * @dev This function is used to check if a specific source token is supported.\n     */\n    function supportsToken(address sourceToken) public view returns (bool) {}\n}\n"
}