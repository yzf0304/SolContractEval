{
    "contract_name": "FORMLESS",
    "ground_truth": "contract FORMLESS is Ownable, ERC721A, ReentrancyGuard {\n    using Strings for uint256;\n\n\n  uint256 public MAX_PER_Transtion = 1; // maximam amount that user can mint per transaction\n  uint256 public MAX_PER_Address = 1;\n\n  uint256 public  PRICE = 0.069 ether; //\n\n  uint256 private TotalCollectionSize_ = 500; // total number of nfts\n  uint256 private constant MaxMintPerBatch_ = 1; //max mint per trx\n \n  mapping(address => bool) private whitelistedAddressesForMint;\n\n\n\n\n\n  string private _baseTokenURI;\n\n\n  uint public status = 0; //0 - sale pause, 1 - whitelist sale, 2 - public sale\n\n  constructor() ERC721A(\"FORMLESS\",\"FORMLESS\", MaxMintPerBatch_, TotalCollectionSize_) {\n   \n   \n\n    \n    _baseTokenURI= \"https://gateway.pinata.cloud/ipfs/QmWT2u6UEeXJs5MWcSTQhHFyYC9wKevQNjXC4J3k67ymtQ/\";\n\n\n  }\n\n  modifier callerIsUser() {\n    require(tx.origin == msg.sender, \"The caller is another contract\");\n    _;\n  }\n\nfunction mint(uint256 quantity) external payable callerIsUser {\n    if(status == 1){\n    require(whitelistedAddressesForMint[msg.sender], \"You are not White Listed For Mint\");\n    require(totalSupply() + quantity <= TotalCollectionSize_, \"Reached max supply\");\n    require(quantity == 1, \"1 NFT per Mint\");\n    require(numberMinted(msg.sender) < 1  , \"Already minted\" );\n    require(msg.value >= PRICE * quantity, \"Not enough ETH in your wallet\");\n    _safeMint(msg.sender, 1);\n    }\n    else{\n    require(status == 2, \"Public Sale is not Active\");\n    require(quantity > 0,\"Mint Quantity should be more than 0\");\n    require(quantity <= MAX_PER_Transtion,\"Max 1 NFTs can be minted in a Trx\");\n    require(totalSupply() + quantity <= TotalCollectionSize_, \"Reached max supply\");\n    require(numberMinted(msg.sender) + quantity <= MAX_PER_Address, \"Can't mint this much\" );\n    require(msg.value >= PRICE * quantity, \"Not enough ETH in your wallet\");\n    _safeMint(msg.sender, quantity);  \n    }\n    }\n\n   function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId),\"ERC721Metadata: URI query for nonexistent token\");\n \n    string memory baseURI = _baseURI();\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, tokenId.toString(),\".json\"))\n        : \"\";\n    } \n\n\n  function isWhitelistedForMint(address _user) public view returns (bool) {\n    return whitelistedAddressesForMint[_user];\n  }\n\n  \n  function addNewWhitelistUserForMint(address[] calldata _users) public onlyOwner {\n    // [\"\",\"\",\"\"]\n    for(uint i=0;i<_users.length;i++)\n        whitelistedAddressesForMint[_users[i]] = true;\n  }\n  \n\n\n  function setBaseURI(string memory baseURI) external onlyOwner {\n    _baseTokenURI = baseURI;\n  }\n  function _baseURI() internal view virtual override returns (string memory) {\n    return _baseTokenURI;\n  }\n  function numberMinted(address owner) public view returns (uint256) {\n    return _numberMinted(owner);\n  }\n  function getOwnershipData(uint256 tokenId)\n    external\n    view\n    returns (TokenOwnership memory)\n  {\n    return ownershipOf(tokenId);\n  }\n\n  function withdrawMoney() external onlyOwner nonReentrant {\n    (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n    require(success, \"Transfer failed.\");\n  }\n\n  function changeMAX_PER_Address(uint256 q) external onlyOwner\n  {\n      MAX_PER_Address = q;\n  }\n\n  function reserve(address _address, uint256 quantity) public onlyOwner {\n  require(quantity > 0,\"Quantity should be more than 0\");\n  require(totalSupply() + quantity <= TotalCollectionSize_, \"Reached max supply\");\n  _safeMint(_address, quantity);\n  }\n\n\n\n  function changeMintPrice(uint256 _newPrice) external onlyOwner\n  {\n      PRICE = _newPrice;\n  }\n\n  function changeCollectionSize(uint256 _collectionSize) external onlyOwner\n  {\n      TotalCollectionSize_ = _collectionSize;\n  }\n\n  function changeMAX_PER_Transtion(uint256 q) external onlyOwner\n  {\n      MAX_PER_Transtion = q;\n  }\n \n  function giveaway(address a, uint q)public onlyOwner{\n    require(totalSupply() + q <= TotalCollectionSize_, \"Reached max supply\");\n    require(q <= MAX_PER_Transtion, \"Can't exceed more than 10\");\n    _safeMint(a, q);\n  }\n\n\n  function setStatus(uint256 s)external onlyOwner{\n      status = s;\n      if(s==1){\n          PRICE=0.069 ether;\n      }\n      else{\n          PRICE=0.099 ether;\n      }\n}\n\n  function getStatus()public view returns(uint){\n\t\treturn status;\n      \n  }\n  \n  function getcollectionSize()public view returns(uint){\n      return TotalCollectionSize_;\n  }\n  \n}",
    "function_sum": 18,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-08-14\n*/\n// SPDX-License-Identifier: MIT\n\nabstract contract ReentrancyGuard { \n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n   _status = _ENTERED;\n\n        _;\n        _status = _NOT_ENTERED;\n    }\n}\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n \n    function toString(uint256 value) internal pure returns (string memory) { \n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n \n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n \n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n \n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n \n    function owner() public view virtual returns (address) {\n        return _owner;\n    } \n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n \n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n \n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n \n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nlibrary Address { \n    function isContract(address account) internal view returns (bool) { \n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    } \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    } \n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n \n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n \n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    } \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n \n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n \n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n \n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n \n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else { \n            if (returndata.length > 0) { \n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IERC721Receiver { \n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC165 { \n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 { \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ninterface IERC721 is IERC165 { \n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); \n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); \n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved); \n    function balanceOf(address owner) external view returns (uint256 balance); \n    function ownerOf(uint256 tokenId) external view returns (address owner); \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external; \n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external; \n    function approve(address to, uint256 tokenId) external;\n \n    function getApproved(uint256 tokenId) external view returns (address operator); \n    function setApprovalForAll(address operator, bool _approved) external; \n    function isApprovedForAll(address owner, address operator) external view returns (bool); \n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Enumerable is IERC721 { \n    function totalSupply() external view returns (uint256); \n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId); \n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\ninterface IERC721Metadata is IERC721 { \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract ERC721A is\n  Context,\n  ERC165,\n  IERC721,\n  IERC721Metadata,\n  IERC721Enumerable\n{\n  using Address for address;\n  using Strings for uint256;\n\n  struct TokenOwnership {\n    address addr;\n    uint64 startTimestamp;\n  }\n\n  struct AddressData {\n    uint128 balance;\n    uint128 numberMinted;\n  }\n\n  uint256 private currentIndex = 1;\n\n  uint256 internal immutable collectionSize;\n  uint256 internal immutable maxBatchSize; \n  string private _name; \n  string private _symbol; \n  mapping(uint256 => TokenOwnership) private _ownerships; \n  mapping(address => AddressData) private _addressData; \n  mapping(uint256 => address) private _tokenApprovals; \n  mapping(address => mapping(address => bool)) private _operatorApprovals; \n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint256 maxBatchSize_,\n    uint256 collectionSize_\n  ) {\n    require(\n      collectionSize_ > 0,\n      \"ERC721A: collection must have a nonzero supply\"\n    );\n    require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n    _name = name_;\n    _symbol = symbol_;\n    maxBatchSize = maxBatchSize_;\n    collectionSize = collectionSize_;\n  } \n  function totalSupply() public view override returns (uint256) {\n    return currentIndex-1;\n  } \n  function tokenByIndex(uint256 index) public view override returns (uint256) {\n    require(index < totalSupply(), \"ERC721A: global index out of bounds\");\n    return index;\n  } \n  function tokenOfOwnerByIndex(address owner, uint256 index)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\n    uint256 numMintedSoFar = totalSupply();\n    uint256 tokenIdsIdx = 0;\n    address currOwnershipAddr = address(0);\n    for (uint256 i = 0; i < numMintedSoFar; i++) {\n      TokenOwnership memory ownership = _ownerships[i];\n      if (ownership.addr != address(0)) {\n        currOwnershipAddr = ownership.addr;\n      }\n      if (currOwnershipAddr == owner) {\n        if (tokenIdsIdx == index) {\n          return i;\n        }\n        tokenIdsIdx++;\n      }\n    }\n    revert(\"ERC721A: unable to get token of owner by index\");\n  } \n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IERC721).interfaceId ||\n      interfaceId == type(IERC721Metadata).interfaceId ||\n      interfaceId == type(IERC721Enumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  } \n  function balanceOf(address owner) public view override returns (uint256) {\n    require(owner != address(0), \"ERC721A: balance query for the zero address\");\n    return uint256(_addressData[owner].balance);\n  }\n\n  function _numberMinted(address owner) internal view returns (uint256) {\n    require(\n      owner != address(0),\n      \"ERC721A: number minted query for the zero address\"\n    );\n    return uint256(_addressData[owner].numberMinted);\n  }\n\n  function ownershipOf(uint256 tokenId)\n    internal\n    view\n    returns (TokenOwnership memory)\n  {\n    require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\n\n    uint256 lowestTokenToCheck;\n    if (tokenId >= maxBatchSize) {\n      lowestTokenToCheck = tokenId - maxBatchSize + 1;\n    }\n\n    for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\n      TokenOwnership memory ownership = _ownerships[curr];\n      if (ownership.addr != address(0)) {\n        return ownership;\n      }\n    }\n\n    revert(\"ERC721A: unable to determine the owner of token\");\n  } \n  function ownerOf(uint256 tokenId) public view override returns (address) {\n    return ownershipOf(tokenId).addr;\n  } \n  function name() public view virtual override returns (string memory) {\n    return _name;\n  } \n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  } \n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory baseURI = _baseURI();\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, tokenId.toString(),_getUriExtension()))\n        : \"\";\n  } \n  function _baseURI() internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  function _getUriExtension() internal view virtual returns (string memory) {\n    return \"\";\n  }\n \n  function approve(address to, uint256 tokenId) public override {\n    address owner = ERC721A.ownerOf(tokenId);\n    require(to != owner, \"ERC721A: approval to current owner\");\n\n    require(\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n      \"ERC721A: approve caller is not owner nor approved for all\"\n    );\n\n    _approve(to, tokenId, owner);\n  } \n  function getApproved(uint256 tokenId) public view override returns (address) {\n    require(_exists(tokenId), \"ERC721A: approved query for nonexistent token\");\n\n    return _tokenApprovals[tokenId];\n  } \n  function setApprovalForAll(address operator, bool approved) public override {\n    require(operator != _msgSender(), \"ERC721A: approve to caller\");\n\n    _operatorApprovals[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }\n \n  function isApprovedForAll(address owner, address operator)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n \n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public override {\n    _transfer(from, to, tokenId);\n  } \n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  } \n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) public override {\n    _transfer(from, to, tokenId);\n    require(\n      _checkOnERC721Received(from, to, tokenId, _data),\n      \"ERC721A: transfer to non ERC721Receiver implementer\"\n    );\n  } \n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return tokenId < currentIndex;\n  }\n\n  function _safeMint(address to, uint256 quantity) internal {\n    _safeMint(to, quantity, \"\");\n  } \n  function _safeMint(\n    address to,\n    uint256 quantity,\n    bytes memory _data\n  ) internal {\n    uint256 startTokenId = currentIndex;\n    require(to != address(0), \"ERC721A: mint to the zero address\"); \n    require(!_exists(startTokenId), \"ERC721A: token already minted\");\n    require(quantity <= maxBatchSize, \"ERC721A: quantity to mint too high\");\n\n    _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n    AddressData memory addressData = _addressData[to];\n    _addressData[to] = AddressData(\n      addressData.balance + uint128(quantity),\n      addressData.numberMinted + uint128(quantity)\n    );\n    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\n\n    uint256 updatedIndex = startTokenId;\n\n    for (uint256 i = 0; i < quantity; i++) {\n      emit Transfer(address(0), to, updatedIndex);\n      require(\n        _checkOnERC721Received(address(0), to, updatedIndex, _data),\n        \"ERC721A: transfer to non ERC721Receiver implementer\"\n      );\n      updatedIndex++;\n    }\n\n    currentIndex = updatedIndex;\n    _afterTokenTransfers(address(0), to, startTokenId, quantity);\n  } \n  function _transfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) private {\n    TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n    bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n      getApproved(tokenId) == _msgSender() ||\n      isApprovedForAll(prevOwnership.addr, _msgSender()));\n\n    require(\n      isApprovedOrOwner,\n      \"ERC721A: transfer caller is not owner nor approved\"\n    );\n\n    require(\n      prevOwnership.addr == from,\n      \"ERC721A: transfer from incorrect owner\"\n    );\n    require(to != address(0), \"ERC721A: transfer to the zero address\");\n\n    _beforeTokenTransfers(from, to, tokenId, 1); \n    _approve(address(0), tokenId, prevOwnership.addr);\n\n    _addressData[from].balance -= 1;\n    _addressData[to].balance += 1;\n    _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp)); \n    uint256 nextTokenId = tokenId + 1;\n    if (_ownerships[nextTokenId].addr == address(0)) {\n      if (_exists(nextTokenId)) {\n        _ownerships[nextTokenId] = TokenOwnership(\n          prevOwnership.addr,\n          prevOwnership.startTimestamp\n        );\n      }\n    }\n\n    emit Transfer(from, to, tokenId);\n    _afterTokenTransfers(from, to, tokenId, 1);\n  } \n  function _approve(\n    address to,\n    uint256 tokenId,\n    address owner\n  ) private {\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  uint256 public nextOwnerToExplicitlySet = 0; \n  function _setOwnersExplicit(uint256 quantity) internal {\n    uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;\n    require(quantity > 0, \"quantity must be nonzero\");\n    uint256 endIndex = oldNextOwnerToSet + quantity - 1;\n    if (endIndex > collectionSize - 1) {\n      endIndex = collectionSize - 1;\n    } \n    require(_exists(endIndex), \"not enough minted yet for this cleanup\");\n    for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {\n      if (_ownerships[i].addr == address(0)) {\n        TokenOwnership memory ownership = ownershipOf(i);\n        _ownerships[i] = TokenOwnership(\n          ownership.addr,\n          ownership.startTimestamp\n        );\n      }\n    }\n    nextOwnerToExplicitlySet = endIndex + 1;\n  } \n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (to.isContract()) {\n      try\n        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\n      returns (bytes4 retval) {\n        return retval == IERC721Receiver(to).onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721A: transfer to non ERC721Receiver implementer\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  } \n  function _beforeTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {} \n  function _afterTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {}\n}\n\n\n\n// You task is to complete the smart contract FORMLESS strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title FORMLESS NFT Contract\n * @author [Your Name]\n * @notice This contract allows for the creation, minting, and management of a collection of NFTs.\n * @dev The contract uses ERC721A for efficient batch minting, ReentrancyGuard to prevent reentrancy attacks, and Ownable for access control.\n */\ncontract FORMLESS is Ownable, ERC721A, ReentrancyGuard {\n    using Strings for uint256;\n\n    /**\n     * @notice Maximum number of NFTs that can be minted in a single transaction.\n     * @dev This value can be updated by the contract owner.\n     */\n    uint256 public MAX_PER_Transtion = 1; // maximam amount that user can mint per transaction\n\n    /**\n     * @notice Maximum number of NFTs that can be minted by a single address.\n     * @dev This value can be updated by the contract owner.\n     */\n    uint256 public MAX_PER_Address = 1;\n\n    /**\n     * @notice Price for minting one NFT.\n     * @dev This value can be updated by the contract owner.\n     */\n    uint256 public PRICE = 0.069 ether;\n\n    /**\n     * @notice Total number of NFTs in the collection.\n     * @dev This value can be updated by the contract owner.\n     */\n    uint256 private TotalCollectionSize_ = 500; // total number of nfts\n\n    /**\n     * @notice Maximum number of NFTs that can be minted in a single batch.\n     * @dev This value is constant and cannot be changed.\n     */\n    uint256 private constant MaxMintPerBatch_ = 1; //max mint per trx\n\n    /**\n     * @notice Mapping to track whitelisted addresses for minting.\n     * @dev Only whitelisted addresses can mint during the whitelist sale.\n     */\n    mapping(address => bool) private whitelistedAddressesForMint;\n\n    /**\n     * @notice Base URI for the NFT metadata.\n     * @dev This value can be updated by the contract owner.\n     */\n    string private _baseTokenURI;\n\n    /**\n     * @notice Status of the sale: 0 - paused, 1 - whitelist sale, 2 - public sale.\n     * @dev This value can be updated by the contract owner.\n     */\n    uint public status = 0; //0 - sale pause, 1 - whitelist sale, 2 - public sale\n\n    /**\n     * @notice Constructor to initialize the contract with initial values.\n     * @dev Sets the base URI and initializes the ERC721A contract.\n     */\n    constructor() ERC721A(\"FORMLESS\",\"FORMLESS\", MaxMintPerBatch_, TotalCollectionSize_) {\n        _baseTokenURI= \"https://gateway.pinata.cloud/ipfs/QmWT2u6UEeXJs5MWcSTQhHFyYC9wKevQNjXC4J3k67ymtQ/\";\n    }\n\n    /**\n     * @notice Modifier to ensure the caller is not another contract.\n     * @dev Prevents other contracts from calling certain functions.\n     */\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract\");\n        _;\n    }\n\n    /**\n     * @notice Allows users to mint NFTs.\n     * @dev Different rules apply depending on the current sale status (whitelist or public).\n     * @param quantity The number of NFTs to mint.\n     */\n    function mint(uint256 quantity) external payable callerIsUser {}\n\n    /**\n     * @notice Returns the token URI for a given token ID.\n     * @dev Ensures the token exists before returning the URI.\n     * @param tokenId The ID of the token.\n     * @return The token URI.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Checks if an address is whitelisted for minting.\n     * @dev Used to determine if an address can mint during the whitelist sale.\n     * @param _user The address to check.\n     * @return True if the address is whitelisted, false otherwise.\n     */\n    function isWhitelistedForMint(address _user) public view returns (bool) {}\n\n    /**\n     * @notice Adds new addresses to the whitelist for minting.\n     * @dev Only the contract owner can call this function.\n     * @param _users Array of addresses to add to the whitelist.\n     */\n    function addNewWhitelistUserForMint(address[] calldata _users) public onlyOwner {}\n\n    /**\n     * @notice Sets the base URI for the NFT metadata.\n     * @dev Only the contract owner can call this function.\n     * @param baseURI The new base URI.\n     */\n    function setBaseURI(string memory baseURI) external onlyOwner {}\n\n    /**\n     * @notice Returns the base URI for the NFT metadata.\n     * @dev Used internally to construct the full token URI.\n     * @return The base URI.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the number of NFTs minted by a specific address.\n     * @dev Used to enforce minting limits.\n     * @param owner The address to check.\n     * @return The number of NFTs minted by the address.\n     */\n    function numberMinted(address owner) public view returns (uint256) {}\n\n    /**\n     * @notice Returns the ownership data for a given token ID.\n     * @dev Used to get detailed ownership information.\n     * @param tokenId The ID of the token.\n     * @return The ownership data.\n     */\n    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {}\n\n    /**\n     * @notice Allows the contract owner to withdraw funds from the contract.\n     * @dev Uses nonReentrant to prevent reentrancy attacks.\n     */\n    function withdrawMoney() external onlyOwner nonReentrant {}\n\n    /**\n     * @notice Changes the maximum number of NFTs that can be minted by a single address.\n     * @dev Only the contract owner can call this function.\n     * @param q The new maximum number of NFTs.\n     */\n    function changeMAX_PER_Address(uint256 q) external onlyOwner {}\n\n    /**\n     * @notice Reserves a number of NFTs for a specific address.\n     * @dev Only the contract owner can call this function.\n     * @param _address The address to reserve NFTs for.\n     * @param quantity The number of NFTs to reserve.\n     */\n    function reserve(address _address, uint256 quantity) public onlyOwner {}\n\n    /**\n     * @notice Changes the price for minting one NFT.\n     * @dev Only the contract owner can call this function.\n     * @param _newPrice The new price for minting one NFT.\n     */\n    function changeMintPrice(uint256 _newPrice) external onlyOwner {}\n\n    /**\n     * @notice Changes the total size of the NFT collection.\n     * @dev Only the contract owner can call this function.\n     * @param _collectionSize The new total size of the collection.\n     */\n    function changeCollectionSize(uint256 _collectionSize) external onlyOwner {}\n\n    /**\n     * @notice Changes the maximum number of NFTs that can be minted in a single transaction.\n     * @dev Only the contract owner can call this function.\n     * @param q The new maximum number of NFTs.\n     */\n    function changeMAX_PER_Transtion(uint256 q) external onlyOwner {}\n\n    /**\n     * @notice Allows the contract owner to give away NFTs to a specific address.\n     * @dev Only the contract owner can call this function.\n     * @param a The address to give NFTs to.\n     * @param q The number of NFTs to give away.\n     */\n    function giveaway(address a, uint q) public onlyOwner {}\n\n    /**\n     * @notice Changes the status of the sale.\n     * @dev Only the contract owner can call this function.\n     * @param s The new status (0 - paused, 1 - whitelist sale, 2 - public sale).\n     */\n    function setStatus(uint256 s) external onlyOwner {}\n\n    /**\n     * @notice Returns the current status of the sale.\n     * @dev Used to check if the sale is paused, in whitelist mode, or open to the public.\n     * @return The current status.\n     */\n    function getStatus() public view returns (uint) {}\n\n    /**\n     * @notice Returns the total size of the NFT collection.\n     * @dev Used to check the total number of NFTs in the collection.\n     * @return The total size of the collection.\n     */\n    function getcollectionSize() public view returns (uint) {}\n}\n"
}