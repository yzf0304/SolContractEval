{
    "contract_name": "CrowdSale",
    "ground_truth": "contract CrowdSale is Ownable {\n\n\n\n    // ERC20 Token\n\n    ERC20 public token;\n\n\n\n    // address where receives funds\n\n    address public beneficiary;\n\n    // address where provides tokens\n\n    address public tokenHolder;\n\n\n\n    // how many token units per wei\n\n    uint public rate;\n\n\n\n    // amount of goal in wei\n\n    uint public amountGoal;\n\n\n\n    // amount of current raised money in wei\n\n    uint public amountRaised;\n\n\n\n    // amount of tokens issued\n\n    uint public amountTokenIssued;\n\n\n\n    // Important Time\n\n    uint public startTime;\n\n    uint public endTime;\n\n\n\n    // Stages Info\n\n    struct Stage {\n\n        uint duration;      // Duration in second of current stage\n\n        uint rate;          // 100 = 100%\n\n    }\n\n    Stage[] public icoStages;\n\n    Stage[] public lockStages;\n\n\n\n\n\n    // Purchaser Info\n\n    struct PurchaserInfo {\n\n        uint amountEtherSpent;\n\n        uint amountTokenTaken;\n\n        uint[] lockedToken;\n\n    }\n\n    mapping(address => PurchaserInfo) public purchasers;\n\n\n\n    address[] public purchaserList;\n\n\n\n\n\n    // ----- Events -----\n\n    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);\n\n    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);\n\n    event FundingWithdrawn(address beneficiaryAddress, uint value);\n\n    event UnlockToken(address purchaser, uint amountUnlockedTokens);\n\n\n\n\n\n    // ----- Modifiers -----\n\n    modifier afterEnded {\n\n        require(isEnded());\n\n        _;\n\n    }\n\n\n\n    modifier onlyOpenTime {\n\n        require(isStarted());\n\n        require(!isEnded());\n\n        _;\n\n    }\n\n\n\n\n\n    // ----- Functions -----\n\n    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {\n\n        require(beneficiaryAddr != address(0));\n\n        require(tokenHolderAddr != address(0));\n\n        require(tokenAddr != address(0));\n\n        require(tokenRate > 0);\n\n\n\n        beneficiary = beneficiaryAddr;\n\n        tokenHolder = tokenHolderAddr;\n\n        token = ERC20(tokenAddr);\n\n        rate = tokenRate;\n\n\n\n        _initStages();\n\n    }\n\n\n\n    function _initStages() internal;   //Need override\n\n\n\n    function getTokenAddress() public view returns(address) {\n\n        return token;\n\n    }\n\n\n\n    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {\n\n        if(stageIdx >= purchasers[_purchaser].lockedToken.length) {\n\n            return 0;\n\n        }\n\n        return purchasers[_purchaser].lockedToken[stageIdx];\n\n    }\n\n\n\n    function canTokenUnlocked(uint stageIndex) public view returns(bool) {\n\n        if(0 <= stageIndex && stageIndex < lockStages.length){\n\n            uint stageEndTime = endTime;\n\n            for(uint i = 0; i <= stageIndex; i++) {\n\n                stageEndTime += lockStages[i].duration;\n\n            }//for\n\n            return now > stageEndTime;\n\n        }\n\n        return false;\n\n    }\n\n\n\n    function isStarted() public view returns(bool) {\n\n        return 0 < startTime && startTime <= now;\n\n    }\n\n\n\n    function isReachedGoal() public view returns(bool) {\n\n        return amountRaised >= amountGoal;\n\n    }\n\n\n\n    function isEnded() public view returns(bool) {\n\n        return now > endTime || isReachedGoal();\n\n    }\n\n\n\n    function getCurrentStage() public view returns(int) {\n\n        int stageIdx = -1;\n\n        uint stageEndTime = startTime;\n\n        for(uint i = 0; i < icoStages.length; i++) {\n\n            stageEndTime += icoStages[i].duration;\n\n            if (now <= stageEndTime) {\n\n                stageIdx = int(i);\n\n                break;\n\n            }\n\n        }\n\n        return stageIdx;\n\n    }\n\n\n\n    function getRemainingTimeInSecond() public view returns(uint) {\n\n        if(endTime == 0)\n\n            return 0;\n\n        return endTime - now;\n\n    }\n\n\n\n    function _addPurchaser(address purchaser) internal {\n\n        require(purchaser != address(0));\n\n\n\n//        for (uint i = 0; i < purchaserList.length; i++) {\n\n//            if (purchaser == purchaserList[i]){\n\n//                return;\n\n//            }\n\n//        }\n\n        purchaserList.push(purchaser);\n\n    }\n\n\n\n    function start(uint fundingGoalInEther) public onlyOwner {\n\n        require(!isStarted());\n\n        require(fundingGoalInEther > 0);\n\n        amountGoal = fundingGoalInEther * 1 ether;\n\n\n\n        startTime = now;\n\n\n\n        uint duration = 0;\n\n        for(uint i = 0; i < icoStages.length; i++){\n\n            duration += icoStages[i].duration;\n\n        }\n\n\n\n        endTime = startTime + duration;\n\n    }\n\n\n\n    function stop() public onlyOwner {\n\n        require(isStarted());\n\n        endTime = now;\n\n    }\n\n\n\n    function () payable public onlyOpenTime {\n\n        require(msg.value > 0);\n\n\n\n        uint amount = msg.value;\n\n        var (buyTokenCount, bonusTokenCount) = _getTokenCount(amount);\n\n\n\n        PurchaserInfo storage pi = purchasers[msg.sender];\n\n        pi.amountEtherSpent += amount;\n\n        pi.amountTokenTaken += buyTokenCount;\n\n\n\n        if (pi.lockedToken.length == 0) {\n\n            pi.lockedToken = new uint[](lockStages.length);\n\n        }\n\n\n\n        for(uint i = 0; i < lockStages.length; i++) {\n\n            Stage storage stage = lockStages[i];\n\n            pi.lockedToken[i] += stage.rate * bonusTokenCount / 100;\n\n        }\n\n\n\n\n\n        amountRaised += amount;\n\n        amountTokenIssued += buyTokenCount;\n\n\n\n        token.transferFrom(tokenHolder, msg.sender, buyTokenCount);\n\n        TokenPurchase(msg.sender, amount, buyTokenCount, bonusTokenCount);\n\n\n\n        _addPurchaser(msg.sender);\n\n\n\n        if(isReachedGoal()){\n\n            endTime = now;\n\n        }\n\n    }\n\n\n\n    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {\n\n        buyTokenCount = amountInWei * rate;\n\n\n\n        int stageIdx = getCurrentStage();\n\n        assert(stageIdx >= 0 && uint(stageIdx) < icoStages.length);\n\n        bonusTokenCount = buyTokenCount * icoStages[uint(stageIdx)].rate / 100;\n\n    }\n\n\n\n\n\n    function safeWithdrawal() public onlyOwner {\n\n        require(beneficiary != address(0));\n\n        beneficiary.transfer(amountRaised);\n\n        FundingWithdrawn(beneficiary, amountRaised);\n\n    }\n\n\n\n    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {\n\n        require(0 <= purchaserStartIdx && purchaserStartIdx < purchaserEndIdx && purchaserEndIdx <= purchaserList.length);\n\n        require(canTokenUnlocked(stageIndex));\n\n\n\n        for (uint j = purchaserStartIdx; j < purchaserEndIdx; j++) {\n\n            address purchaser = purchaserList[j];\n\n            if(purchaser != address(0)){\n\n                PurchaserInfo storage pi = purchasers[purchaser];\n\n                uint unlockedToken = pi.lockedToken[stageIndex];\n\n                if (unlockedToken > 0) {\n\n                    pi.lockedToken[stageIndex] = 0;\n\n                    pi.amountTokenTaken += unlockedToken;\n\n\n\n                    amountTokenIssued += unlockedToken;\n\n\n\n                    token.transferFrom(tokenHolder, purchaser, unlockedToken);\n\n                    UnlockToken(purchaser, unlockedToken);\n\n                }\n\n            }\n\n        }//for\n\n\n\n    }\n\n\n\n}",
    "function_sum": 15,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2017-12-27\n\n*/\n\ncontract ERC20 {\n\n\n\n    uint256 public totalSupply;\n\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\n    function balanceOf(address who) public view returns (uint256);\n\n    function transfer(address to, uint256 value) public returns (bool);\n\n\n\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n\n\n}\n\n//////////////////////////////////////////////////\n\ncontract Ownable {\n\n    address public owner;\n\n\n\n    event OwnerChanged(address oldOwner, address newOwner);\n\n\n\n    function Ownable() public {\n\n        owner = msg.sender;\n\n    }\n\n\n\n    modifier onlyOwner {\n\n        require(msg.sender == owner);\n\n        _;\n\n    }\n\n\n\n    function transferOwnership(address newOwner) onlyOwner public {\n\n        require(newOwner != owner && newOwner != address(0x0));\n\n        address oldOwner = owner;\n\n        owner = newOwner;\n\n        OwnerChanged(oldOwner, newOwner);\n\n    }\n\n}\n\n\n\n// You task is to complete the smart contract CrowdSale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title CrowdSale\n * @dev This contract is designed to manage a crowd sale for an ERC20 token.\n * It allows users to purchase tokens with Ether, and the funds are collected in a beneficiary address.\n * The contract also supports different stages with varying rates and bonus tokens, and it manages the locking and unlocking of bonus tokens.\n * @notice This contract should be used to conduct a crowd sale for an ERC20 token, allowing for staged bonuses and token locking.\n */\ncontract CrowdSale is Ownable {\n\n    // ERC20 Token\n    ERC20 public token;\n\n    // Address where funds are received\n    address public beneficiary;\n    // Address that provides tokens\n    address public tokenHolder;\n\n    // Rate of token units per wei\n    uint public rate;\n    // Goal amount in wei\n    uint public amountGoal;\n    // Current amount of raised money in wei\n    uint public amountRaised;\n    // Amount of tokens issued\n    uint public amountTokenIssued;\n\n    // Important Time\n    uint public startTime;\n    uint public endTime;\n\n    // Stages Info\n    struct Stage {\n        uint duration;      // Duration in seconds of the current stage\n        uint rate;          // Bonus rate (100 = 100%)\n    }\n    Stage[] public icoStages;\n    Stage[] public lockStages;\n\n    // Purchaser Info\n    struct PurchaserInfo {\n        uint amountEtherSpent;\n        uint amountTokenTaken;\n        uint[] lockedToken;\n    }\n    mapping(address => PurchaserInfo) public purchasers;\n    address[] public purchaserList;\n\n    // ----- Events -----\n    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);\n    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);\n    event FundingWithdrawn(address beneficiaryAddress, uint value);\n    event UnlockToken(address purchaser, uint amountUnlockedTokens);\n\n    // ----- Modifiers -----\n    /**\n     * @dev Modifier to allow function calls only after the crowd sale has ended.\n     */\n    modifier afterEnded {\n        require(isEnded());\n        _;\n    }\n\n    /**\n     * @dev Modifier to allow function calls only during the open time of the crowd sale.\n     */\n    modifier onlyOpenTime {\n        require(isStarted());\n        require(!isEnded());\n        _;\n    }\n\n    // ----- Functions -----\n\n    /**\n     * @notice Initializes the CrowdSale contract with the provided parameters.\n     * @param beneficiaryAddr The address where the funds will be sent.\n     * @param tokenHolderAddr The address that holds the tokens to be sold.\n     * @param tokenAddr The address of the ERC20 token contract.\n     * @param tokenRate The rate of tokens per wei.\n     * @dev Requires valid addresses and a positive token rate.\n     */\n    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {\n        require(beneficiaryAddr != address(0));\n        require(tokenHolderAddr != address(0));\n        require(tokenAddr != address(0));\n        require(tokenRate > 0);\n\n        beneficiary = beneficiaryAddr;\n        tokenHolder = tokenHolderAddr;\n        token = ERC20(tokenAddr);\n        rate = tokenRate;\n\n        _initStages();\n    }\n\n    /**\n     * @dev Initializes the stages for the crowd sale. This function needs to be overridden.\n     */\n    function _initStages() internal;\n\n    /**\n     * @notice Returns the address of the ERC20 token contract.\n     * @return The address of the token contract.\n     */\n    function getTokenAddress() public view returns(address) {}\n\n    /**\n     * @notice Returns the amount of locked tokens for a specific purchaser at a given stage index.\n     * @param _purchaser The address of the purchaser.\n     * @param stageIdx The index of the stage.\n     * @return The amount of locked tokens.\n     */\n    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {}\n\n    /**\n     * @notice Checks if tokens can be unlocked at a specific stage index.\n     * @param stageIndex The index of the stage.\n     * @return True if tokens can be unlocked, otherwise false.\n     */\n    function canTokenUnlocked(uint stageIndex) public view returns(bool) {}\n\n    /**\n     * @notice Checks if the crowd sale has started.\n     * @return True if the crowd sale has started, otherwise false.\n     */\n    function isStarted() public view returns(bool) {}\n\n    /**\n     * @notice Checks if the goal amount has been reached.\n     * @return True if the goal amount has been reached, otherwise false.\n     */\n    function isReachedGoal() public view returns(bool) {}\n\n    /**\n     * @notice Checks if the crowd sale has ended.\n     * @return True if the crowd sale has ended, otherwise false.\n     */\n    function isEnded() public view returns(bool) {}\n\n    /**\n     * @notice Returns the current stage index.\n     * @return The current stage index.\n     */\n    function getCurrentStage() public view returns(int) {}\n\n    /**\n     * @notice Returns the remaining time in seconds until the end of the crowd sale.\n     * @return The remaining time in seconds.\n     */\n    function getRemainingTimeInSecond() public view returns(uint) {}\n\n    /**\n     * @dev Adds a new purchaser to the list.\n     * @param purchaser The address of the purchaser.\n     */\n    function _addPurchaser(address purchaser) internal {}\n\n    /**\n     * @notice Starts the crowd sale with a specified funding goal.\n     * @param fundingGoalInEther The funding goal in ether.\n     * @dev Only the owner can call this function, and the crowd sale must not have started yet.\n     */\n    function start(uint fundingGoalInEther) public onlyOwner {}\n\n    /**\n     * @notice Stops the crowd sale.\n     * @dev Only the owner can call this function, and the crowd sale must have started.\n     */\n    function stop() public onlyOwner {}\n\n    /**\n     * @notice Allows users to purchase tokens by sending Ether.\n     * @dev Only callable during the open time of the crowd sale.\n     */\n    function () payable public onlyOpenTime {}\n\n    /**\n     * @dev Calculates the number of tokens to be bought and the bonus tokens.\n     * @param amountInWei The amount of Ether sent.\n     * @return The number of tokens to be bought and the bonus tokens.\n     */\n    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {}\n\n    /**\n     * @notice Allows the owner to withdraw the collected funds.\n     * @dev Only the owner can call this function.\n     */\n    function safeWithdrawal() public onlyOwner {}\n\n    /**\n     * @dev Unlocks bonus tokens for a range of purchasers in a specific stage.\n     * @param stageIndex Index of the stage for which tokens are being unlocked\n     * @param purchaserStartIdx Starting index in purchaserList (inclusive)\n     * @param purchaserEndIdx Ending index in purchaserList (exclusive)\n     * @dev Requirements:\n     *   - Must be called after the event has ended\n     *   - Only callable by the contract owner\n     *   - Valid purchaser index range must be provided\n     *   - Tokens must be unlockable for the specified stage\n     * @dev Behavior:\n     *   - Iterates through purchasers in the specified range\n     *   - Unlocks bonus tokens for each valid purchaser\n     *   - Updates purchaser and contract state:\n     *     - Clears locked tokens for the stage\n     *     - Tracks total tokens taken by purchaser\n     *     - Updates total tokens issued\n     *     - Transfers tokens to purchaser\n     *     - Emits UnlockToken event\n     * @dev Notes:\n     *   - Purchaser list is assumed to be maintained elsewhere\n     *   - Token transfer uses tokenHolder as source\n     *   - Requires sufficient token balance in tokenHolder\n     */\n    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {}\n}\n"
}