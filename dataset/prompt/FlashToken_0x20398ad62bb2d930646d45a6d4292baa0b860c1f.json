{
    "contract_name": "FlashToken",
    "ground_truth": "contract FlashToken is IERC20 {\n    using SafeMath for uint256;\n\n    // bytes32 private constant EIP712DOMAIN_HASH =\n    // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    // bytes32 private constant NAME_HASH = keccak256(\"FLASH\")\n    bytes32 private constant NAME_HASH = 0x345b72c36b14f1cee01efb8ac4b299dc7b8d873e28b4796034548a3d371a4d2f;\n\n    // bytes32 private constant VERSION_HASH = keccak256(\"2\")\n    bytes32 private constant VERSION_HASH = 0xad7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a5;\n\n    // bytes32 public constant PERMIT_TYPEHASH =\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    // keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    string public constant name = \"Flashstake\";\n    string public constant symbol = \"FLASH\";\n    uint8 public constant decimals = 18;\n\n    address public constant FLASH_PROTOCOL = 0x15EB0c763581329C921C8398556EcFf85Cc48275;\n    address public constant FLASH_CLAIM = 0xf2319b6D2aB252d8D80D8CEC34DaF0079222A624;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n    modifier onlyMinter {\n        require(msg.sender == FLASH_PROTOCOL || msg.sender == FLASH_CLAIM, \"FlashToken:: NOT_MINTER\");\n        _;\n    }\n\n    constructor() {\n        // BlockZero Labs: Foundation Fund\n        _mint(0x842f8f6fB524996d0b660621DA895166E1ceA691, 1200746000000000000000000);\n        _mint(0x0945d9033147F27aDDFd3e7532ECD2100cb91032, 1000000000000000000000000);\n    }\n\n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeparator(), encodeData));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(recoveredAddress != address(0) && recoveredAddress == signer, \"FlashToken:: INVALID_SIGNATURE\");\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        require(to != address(this) && to != address(0), \"FlashToken:: RECEIVER_IS_TOKEN_OR_ZERO\");\n\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function getChainId() public pure returns (uint256 chainId) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n    }\n\n    function getDomainSeparator() public view returns (bytes32) {\n        return keccak256(abi.encode(EIP712DOMAIN_HASH, NAME_HASH, VERSION_HASH, getChainId(), address(this)));\n    }\n\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != uint256(-1)) {\n            // Allowance is implicitly checked with SafeMath's underflow protection\n            allowance[from][msg.sender] = fromAllowance.sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"FlashToken:: AUTH_EXPIRED\");\n\n        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner], deadline));\n        nonces[owner] = nonces[owner].add(1);\n        _validateSignedData(owner, encodeData, v, r, s);\n\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp > validAfter, \"FlashToken:: AUTH_NOT_YET_VALID\");\n        require(block.timestamp < validBefore, \"FlashToken:: AUTH_EXPIRED\");\n        require(!authorizationState[from][nonce], \"FlashToken:: AUTH_ALREADY_USED\");\n\n        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        emit AuthorizationUsed(from, nonce);\n\n        _transfer(from, to, value);\n    }\n}",
    "function_sum": 14,
    "compiler_version": "0.7.4",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-03-31\n*/\n// SPDX-License-Identifier: MIT\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"MATH:ADD_OVERFLOW\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"MATH:SUB_UNDERFLOW\");\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n\n\n\n// You task is to complete the smart contract FlashToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.7.4, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title FlashToken\n * @notice A token contract implementing the ERC20 standard with additional features such as minting, burning, and advanced authorization.\n * @dev This contract includes functionalities for permit (ERC-2612) and transfer with authorization (ERC-3009).\n */\ncontract FlashToken is IERC20 {\n    using SafeMath for uint256;\n\n    // EIP-712 Domain Separator constants\n    bytes32 private constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    bytes32 private constant NAME_HASH = 0x345b72c36b14f1cee01efb8ac4b299dc7b8d873e28b4796034548a3d371a4d2f;\n    bytes32 private constant VERSION_HASH = 0xad7c5bef027816a800da1736444fb58a807ef4c9603b7848673f7e3a68eb14a5;\n\n    // Typehashes for EIP-712 signatures\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n    // Token metadata\n    string public constant name = \"Flashstake\";\n    string public constant symbol = \"FLASH\";\n    uint8 public constant decimals = 18;\n\n    // Minter addresses\n    address public constant FLASH_PROTOCOL = 0x15EB0c763581329C921C8398556EcFf85Cc48275;\n    address public constant FLASH_CLAIM = 0xf2319b6D2aB252d8D80D8CEC34DaF0079222A624;\n\n    // Total supply and balances\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // ERC-2612, ERC-3009 state\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n    // Events\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n    // Modifier to restrict functions to only minter addresses\n    modifier onlyMinter {\n        require(msg.sender == FLASH_PROTOCOL || msg.sender == FLASH_CLAIM, \"FlashToken:: NOT_MINTER\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract and mints initial tokens to specified addresses.\n     */\n    constructor() {\n        // BlockZero Labs: Foundation Fund\n        _mint(0x842f8f6fB524996d0b660621DA895166E1ceA691, 1200746000000000000000000);\n        _mint(0x0945d9033147F27aDDFd3e7532ECD2100cb91032, 1000000000000000000000000);\n    }\n\n    /**\n     * @notice Validates the signed data using EIP-712.\n     * @dev Checks if the recovered signer matches the provided signer and disallows address(0).\n     * @param signer The address of the signer.\n     * @param encodeData The encoded data to be signed.\n     * @param v The v component of the signature.\n     * @param r The r component of the signature.\n     * @param s The s component of the signature.\n     */\n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {}\n\n    /**\n     * @notice Mints new tokens to a specified address.\n     * @dev Increases the total supply and the recipient's balance.\n     * @param to The address to receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     */\n    function _mint(address to, uint256 value) internal {}\n\n    /**\n     * @notice Burns tokens from a specified address.\n     * @dev Decreases the total supply and the sender's balance.\n     * @param from The address to burn tokens from.\n     * @param value The amount of tokens to burn.\n     */\n    function _burn(address from, uint256 value) internal {}\n\n    /**\n     * @notice Sets the allowance for a spender.\n     * @dev Updates the allowance and emits an Approval event.\n     * @param owner The address of the token owner.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens to approve.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {}\n\n    /**\n     * @notice Transfers tokens from one address to another.\n     * @dev Ensures the receiver is not the zero address or the contract itself, updates balances, and emits a Transfer event.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param value The amount of tokens to transfer.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {}\n\n    /**\n     * @notice Returns the current chain ID.\n     * @return chainId The current chain ID.\n     */\n    function getChainId() public pure returns (uint256 chainId) {}\n\n    /**\n     * @notice Returns the domain separator used in EIP-712 signatures.\n     * @return The domain separator.\n     */\n    function getDomainSeparator() public view returns (bytes32) {}\n\n    /**\n     * @notice Mints new tokens to a specified address.\n     * @dev Only callable by the minter addresses.\n     * @param to The address to receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return True on success.\n     */\n    function mint(address to, uint256 value) external onlyMinter returns (bool) {}\n\n    /**\n     * @notice Burns tokens from the caller's account.\n     * @param value The amount of tokens to burn.\n     * @return True on success.\n     */\n    function burn(uint256 value) external returns (bool) {}\n\n    /**\n     * @notice Approves a spender to transfer a certain amount of tokens on behalf of the caller.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens to approve.\n     * @return True on success.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {}\n\n    /**\n     * @notice Transfers tokens from the caller's account to another address.\n     * @param to The address to transfer tokens to.\n     * @param value The amount of tokens to transfer.\n     * @return True on success.\n     */\n    function transfer(address to, uint256 value) external override returns (bool) {}\n\n    /**\n     * @notice Transfers tokens from one address to another, using the caller's allowance.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param value The amount of tokens to transfer.\n     * @return True on success.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {}\n\n    /**\n     * @notice Sets the allowance for a spender using a signed message.\n     * @param owner The address of the token owner.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens to approve.\n     * @param deadline The deadline for the operation.\n     * @param v The v component of the signature.\n     * @param r The r component of the signature.\n     * @param s The s component of the signature.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {}\n\n    /**\n     * @notice Transfers tokens with authorization using a signed message.\n     * @param from The address to transfer tokens from.\n     * @param to The address to transfer tokens to.\n     * @param value The amount of tokens to transfer.\n     * @param validAfter The timestamp after which the authorization is valid.\n     * @param validBefore The timestamp before which the authorization is valid.\n     * @param nonce The nonce for the authorization.\n     * @param v The v component of the signature.\n     * @param r The r component of the signature.\n     * @param s The s component of the signature.\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {}\n}\n"
}