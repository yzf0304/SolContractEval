{
    "contract_name": "GCUToken",
    "ground_truth": "contract GCUToken is ERC223Interface {\n    using SafeMath for uint256;\n\n    /* Contract Constants */\n    string public constant _name = \"Global Currency Unit\";\n    string public constant _symbol = \"GCU\";\n    uint8 public constant _decimals = 18;\n\n    /* Contract Variables */\n    address public owner;\n    uint256 public totalSupply_;\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping (address => uint256)) public allowed;\n\n    /*88 888 888 000*/\n    /* Constructor initializes the owner's balance and the supply  */\n    constructor (uint256 _amount, address _initialWallet) {\n        owner = _initialWallet;\n        totalSupply_ = _amount * (uint256(10) ** _decimals);\n        balances[_initialWallet] = totalSupply_;\n\n        emit Transfer(0x0, _initialWallet, totalSupply_);\n    }\n\n    /* ERC20 Events */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed to, uint256 value);\n\n    /* ERC223 Events */\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Returns balance of the `_owner`.\n     *\n     * @param _address   The address whose balance will be returned.\n     * @return balance Balance of the `_owner`.\n     */\n    function balanceOf(address _address) view returns (uint256 balance) {\n        return balances[_address];\n    }\n\n    /**\n     * @dev Transfer the specified amount of tokens to the specified address.\n     *      This function works the same with the previous one\n     *      but doesn't contain `_data` param.\n     *      Added due to backwards compatibility reasons.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     */\n    function transfer(address _to, uint _value) returns (bool success) {\n        if (balances[msg.sender] >= _value\n        && _value > 0\n        && balances[_to] + _value > balances[_to]) {\n            bytes memory empty;\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, empty);\n            } else {\n                return transferToAddress(_to, _value, empty);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Withdraws to address _to form the address _from up to the amount _value */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_from] >= _value\n        && allowed[_from][msg.sender] >= _value\n        && _value > 0\n        && balances[_to] + _value > balances[_to]) {\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Allows _spender to withdraw the _allowance amount form sender */\n    function approve(address _spender, uint256 _allowance) returns (bool success) {\n        allowed[msg.sender][_spender] = _allowance;\n        Approval(msg.sender, _spender, _allowance);\n        return true;\n    }\n\n    /* Checks how much _spender can withdraw from _owner */\n    function allowance(address _owner, address _spender) view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    /* ERC223 Functions */\n    /* Get the contract constant _name */\n    function name() view returns (string name) {\n        return _name;\n    }\n\n    /* Get the contract constant _symbol */\n    function symbol() view returns (string symbol) {\n        return _symbol;\n    }\n\n    /* Get the contract constant _decimals */\n    function decimals() view returns (uint8 decimals) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Transfer the specified amount of tokens to the specified address.\n     *      Invokes the `tokenFallback` function if the recipient is a contract.\n     *      The token transfer fails if the recipient is a contract\n     *      but does not implement the `tokenFallback` function\n     *      or the fallback function to receive funds.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     * @param _data  Transaction metadata.\n     */\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n        if (balances[msg.sender] >= _value\n        && _value > 0\n        && balances[_to] + _value > balances[_to]) {\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, _data);\n            } else {\n                return transferToAddress(_to, _value, _data);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Transfer function when _to represents a regular address */\n    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Transfer function when _to represents a contract address, with the caveat\n    that the contract needs to implement the tokenFallback function in order to receive tokens */\n    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        ContractReceiver receiver = ContractReceiver(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Infers if whether _address is a contract based on the presence of bytecode */\n    function isContract(address _address) internal returns (bool is_contract) {\n        uint length;\n        if (_address == 0) return false;\n        assembly {\n        length := extcodesize(_address)\n        }\n        if(length > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Stops any attempt to send Ether to this contract */\n    function () {\n        revert();\n        //throw;\n    }\n}",
    "function_sum": 13,
    "compiler_version": "0.4.26",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract ERC223Interface {\n    uint public totalSupply_;\n    function balanceOf(address who) view returns (uint);\n    function transfer(address to, uint value) returns (bool);\n    function transfer(address to, uint value, bytes data)  returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\n\n/**\n * @dev Standard ERC223 function that will handle incoming token transfers.\n *\n * param _from  Token sender address.\n * param _value Amount of tokens.\n * param _data  Transaction metadata.\n */\n\ncontract ContractReceiver {\n    function tokenFallback(address _from, uint _value, bytes _data) {\n        _from;\n        _value;\n        _data;\n    }\n}\n\n\n\n// You task is to complete the smart contract GCUToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.26, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title GCUToken\n * @dev This contract implements the ERC20 and ERC223 token standards.\n * It includes functionalities for transferring tokens, approving token transfers,\n * and handling token transfers to contracts that implement the `tokenFallback` function.\n */\ncontract GCUToken is ERC223Interface {\n    using SafeMath for uint256;\n\n    /* Contract Constants */\n    string public constant _name = \"Global Currency Unit\";\n    string public constant _symbol = \"GCU\";\n    uint8 public constant _decimals = 18;\n\n    /* Contract Variables */\n    address public owner;\n    uint256 public totalSupply_;\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping (address => uint256)) public allowed;\n\n    /*88 888 888 000*/\n    /* Constructor initializes the owner's balance and the supply  */\n    constructor (uint256 _amount, address _initialWallet) {\n        owner = _initialWallet;\n        totalSupply_ = _amount * (uint256(10) ** _decimals);\n        balances[_initialWallet] = totalSupply_;\n\n        emit Transfer(0x0, _initialWallet, totalSupply_);\n    }\n\n    /* ERC20 Events */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed from, address indexed to, uint256 value);\n\n    /* ERC223 Events */\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n\n    /**\n     * @notice Returns the total number of tokens in existence.\n     * @dev This function returns the total supply of tokens.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() public view returns (uint256) {}\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @dev This function returns the balance of the `_address`.\n     * @param _address The address whose balance will be returned.\n     * @return The balance of the `_address`.\n     */\n    function balanceOf(address _address) view returns (uint256 balance) {}\n\n    /**\n     * @notice Transfers the specified amount of tokens to the specified address.\n     * @dev This function transfers `_value` tokens from the sender to `_to`.\n     * If `_to` is a contract, it invokes the `tokenFallback` function.\n     * @param _to The receiver address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating if the transfer was successful.\n     */\n    function transfer(address _to, uint _value) returns (bool success) {}\n\n    /**\n     * @notice Transfers the specified amount of tokens from one address to another.\n     * @dev This function transfers `_value` tokens from `_from` to `_to` on behalf of the sender.\n     * @param _from The address to transfer tokens from.\n     * @param _to The address to transfer tokens to.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating if the transfer was successful.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /**\n     * @notice Approves the specified address to spend a certain amount of tokens on behalf of the sender.\n     * @dev This function sets the allowance for `_spender` to spend `_allowance` tokens on behalf of the sender.\n     * @param _spender The address that will be approved to spend tokens.\n     * @param _allowance The amount of tokens that can be spent.\n     * @return A boolean indicating if the approval was successful.\n     */\n    function approve(address _spender, uint256 _allowance) returns (bool success) {}\n\n    /**\n     * @notice Returns the remaining allowance for a spender.\n     * @dev This function returns the remaining allowance for `_spender` to spend on behalf of `_owner`.\n     * @param _owner The address that set the allowance.\n     * @param _spender The address that can spend the tokens.\n     * @return The remaining allowance.\n     */\n    function allowance(address _owner, address _spender) view returns (uint256 remaining) {}\n\n    /**\n     * @notice Returns the name of the token.\n     * @dev This function returns the token name.\n     * @return The name of the token.\n     */\n    function name() view returns (string name) {}\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @dev This function returns the token symbol.\n     * @return The symbol of the token.\n     */\n    function symbol() view returns (string symbol) {}\n\n    /**\n     * @notice Returns the number of decimals used by the token.\n     * @dev This function returns the number of decimals.\n     * @return The number of decimals.\n     */\n    function decimals() view returns (uint8 decimals) {}\n\n    /**\n     * @notice Transfers the specified amount of tokens to the specified address with additional data.\n     * @dev This function transfers `_value` tokens from the sender to `_to` and passes `_data` to the recipient.\n     * If `_to` is a contract, it invokes the `tokenFallback` function.\n     * @param _to The receiver address.\n     * @param _value The amount of tokens to transfer.\n     * @param _data Additional data to pass to the recipient.\n     * @return A boolean indicating if the transfer was successful.\n     */\n    function transfer(address _to, uint _value, bytes _data) returns (bool success) {}\n\n    /**\n     * @dev Internal function to transfer tokens to a regular address.\n     * @param _to The receiver address.\n     * @param _value The amount of tokens to transfer.\n     * @param _data Additional data to pass to the recipient.\n     * @return A boolean indicating if the transfer was successful.\n     */\n    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {}\n\n    /**\n     * @dev Internal function to transfer tokens to a contract address.\n     * @param _to The receiver address.\n     * @param _value The amount of tokens to transfer.\n     * @param _data Additional data to pass to the recipient.\n     * @return A boolean indicating if the transfer was successful.\n     */\n    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {}\n\n    /**\n     * @dev Checks if the given address is a contract.\n     * @param _address The address to check.\n     * @return A boolean indicating if the address is a contract.\n     */\n    function isContract(address _address) internal returns (bool is_contract) {}\n\n    /**\n     * @dev Prevents any attempt to send Ether to this contract.\n     */\n    function () {\n    }\n}\n"
}