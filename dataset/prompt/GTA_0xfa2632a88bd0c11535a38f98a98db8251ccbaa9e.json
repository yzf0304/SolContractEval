{
    "contract_name": "StandardToken",
    "ground_truth": "contract StandardToken is ERC20 {\n\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n\n\n\n\n\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n\n\n  function approve(address _spender, uint256 _value) returns (bool) {\n\n\n\n    // To change the approve amount you first have to reduce the addresses`\n\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n    //  already 0 to mitigate the race condition described here:\n\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n}",
    "function_sum": 3,
    "compiler_version": "0.4.16",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract ERC20 {\n\n    uint256 public totalSupply;\n\n    function balanceOf(address who) constant returns (uint256);\n\n\n\n    function transfer(address to, uint256 value) returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    function allowance(address owner, address spender) constant returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value) returns (bool);\n\n\n\n    function approve(address spender, uint256 value) returns (bool);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\n\n\n// You task is to complete the smart contract StandardToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.16, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title StandardToken\n * @dev Implementation of the basic standard token with ERC20 functionality.\n * @notice This contract provides a basic implementation of an ERC20 token, including balance tracking and allowance management.\n */\ncontract StandardToken is ERC20 {\n\n    using SafeMath for uint256;\n\n    mapping(address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @param _owner The address to query the balance of.\n     * @return The balance of the specified address.\n     * @dev This function is used to check the balance of a specific address.\n     */\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n    }\n\n    /**\n     * @notice Approves the specified address to spend a certain amount of tokens on behalf of the message sender.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return True if the approval was successful.\n     * @dev To change the approve amount, you first have to reduce the addresses' allowance to zero by calling `approve(_spender, 0)` if it is not already 0 to mitigate the race condition described here: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     */\n    function approve(address _spender, uint256 _value) returns (bool) {\n    }\n\n    /**\n     * @notice Returns the remaining number of tokens that `_spender` is allowed to spend on behalf of `_owner`.\n     * @param _owner The address of the token owner.\n     * @param _spender The address of the spender.\n     * @return The remaining allowance for the spender.\n     * @dev This function is used to check the remaining allowance for a specific spender.\n     */\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    }\n}\n"
}