{
    "contract_name": "HalloweenMinter",
    "ground_truth": "contract HalloweenMinter is Ownable {\n\n    address public constant withdrawAddress = 0xdEcf4B112d4120B6998e5020a6B4819E490F7db6;\n    iNFTCollection public NFTCollection = iNFTCollection(0x2d3C8D1A84cA778A3bba0F4fC389330AB96AF3Be); \n\n    constructor(){\n        pause(false);\n        setMintCount(false);\n    }\n\n\n    uint256 public cost = 0;\n    uint256 public maxSupply = 5000;\n    uint256 public maxMintAmountPerTransaction = 3;\n    uint256 public publicSaleMaxMintAmountPerAddress = 300;\n    bool public paused = true;\n    bool public onlyWhitelisted = true;\n    bool public mintCount = true;\n    mapping(address => uint256) public whitelistMintedAmount;\n    mapping(address => uint256) public publicSaleMintedAmount;\n    bytes32 public constant AIRDROP_ROLE = keccak256(\"AIRDROP_ROLE\");\n\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract.\");\n        _;\n    }\n \n    //mint with merkle tree\n    bytes32 public merkleRoot;\n    function mint(uint256 _mintAmount , uint256 _maxMintAmount , bytes32[] calldata _merkleProof) public payable callerIsUser{\n        require(!paused, \"the contract is paused\");\n        require(0 < _mintAmount, \"need to mint at least 1 NFT\");\n        require(_mintAmount <= maxMintAmountPerTransaction, \"max mint amount per session exceeded\");\n        require(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\n        require(cost * _mintAmount <= msg.value, \"insufficient funds\");\n        if(onlyWhitelisted == true) {\n            bytes32 leaf = keccak256( abi.encodePacked(msg.sender, _maxMintAmount) );\n            require(MerkleProof.verify(_merkleProof, merkleRoot, leaf), \"user is not whitelisted\");\n            if(mintCount == true){\n                require(_mintAmount <= _maxMintAmount - whitelistMintedAmount[msg.sender] , \"max NFT per address exceeded\");\n                whitelistMintedAmount[msg.sender] += _mintAmount;\n            }\n        }else{\n            if(mintCount == true){\n                require(_mintAmount <= publicSaleMaxMintAmountPerAddress - publicSaleMintedAmount[msg.sender] , \"max NFT per address exceeded\");\n                publicSaleMintedAmount[msg.sender] += _mintAmount;\n            }\n        }\n        NFTCollection.externalMint( msg.sender , _mintAmount );\n    }\n\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner() {\n        maxSupply = _maxSupply;\n    }    \n\n    function totalSupply() public view returns(uint256){\n        return NFTCollection.totalSupply();\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setPublicSaleMaxMintAmountPerAddress(uint256 _publicSaleMaxMintAmountPerAddress) public onlyOwner() {\n        publicSaleMaxMintAmountPerAddress = _publicSaleMaxMintAmountPerAddress;\n    }\n\n    function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }\n\n    function setOnlyWhitelisted(bool _state) public onlyOwner {\n        onlyWhitelisted = _state;\n    }\n\n    function setMaxMintAmountPerTransaction(uint256 _maxMintAmountPerTransaction) public onlyOwner {\n        maxMintAmountPerTransaction = _maxMintAmountPerTransaction;\n    }\n  \n    function pause(bool _state) public onlyOwner {\n        paused = _state;\n    }\n\n    function setMintCount(bool _state) public onlyOwner {\n        mintCount = _state;\n    }\n\n\n\n\n\n    //onlyowner\n    function setNFTCollection(address _address) public onlyOwner() {\n        NFTCollection = iNFTCollection(_address);\n    }\n\n    function withdraw() public onlyOwner {\n        (bool os, ) = payable(withdrawAddress).call{value: address(this).balance}('');\n        require(os);\n    }\n\n\n\n}",
    "function_sum": 12,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-10-31\n*/\n// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\n\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/access/Ownable.sol\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// File: minter.sol\n// Copyright (c) 2022 Keisuke OHNO\n/*\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n*/\n\ninterface iNFTCollection {\n    function externalMint(address _address , uint256 _amount) external payable ;\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address address_) external view returns (uint256);\n    function ownerOf(uint256 tokenId_) external view returns (address);\n    function tokensOfOwner(address _address) external view returns (uint256[] memory);\n}\n\n\n\n// You task is to complete the smart contract HalloweenMinter strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title HalloweenMinter\n * @notice This contract allows users to mint NFTs with specific conditions, including a whitelist and public sale.\n * @dev The contract is Ownable, which means only the owner can modify certain parameters such as the cost, supply, and minting rules.\n */\ncontract HalloweenMinter is Ownable {\n\n    address public constant withdrawAddress = 0xdEcf4B112d4120B6998e5020a6B4819E490F7db6;\n    iNFTCollection public NFTCollection = iNFTCollection(0x2d3C8D1A84cA778A3bba0F4fC389330AB96AF3Be); \n\n    constructor(){\n        pause(false);\n        setMintCount(false);\n    }\n\n    uint256 public cost = 0;\n    uint256 public maxSupply = 5000;\n    uint256 public maxMintAmountPerTransaction = 3;\n    uint256 public publicSaleMaxMintAmountPerAddress = 300;\n    bool public paused = true;\n    bool public onlyWhitelisted = true;\n    bool public mintCount = true;\n    mapping(address => uint256) public whitelistMintedAmount;\n    mapping(address => uint256) public publicSaleMintedAmount;\n    bytes32 public constant AIRDROP_ROLE = keccak256(\"AIRDROP_ROLE\");\n\n    /**\n     * @notice Modifier to ensure that the function caller is an external user, not another contract.\n     * @dev This modifier helps prevent reentrancy attacks and ensures that the function is called by an EOA.\n     */\n    modifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract.\");\n        _;\n    }\n \n    bytes32 public merkleRoot;\n    /**\n     * @notice Allows users to mint NFTs, with optional whitelisting and mint count restrictions.\n     * @dev Users must provide a merkle proof if the contract is in the whitelist phase. The function checks various conditions before allowing the mint.\n     * @param _mintAmount The number of NFTs to mint.\n     * @param _maxMintAmount The maximum number of NFTs allowed for the user.\n     * @param _merkleProof The merkle proof to verify the user's whitelist status.\n     */\n    function mint(uint256 _mintAmount , uint256 _maxMintAmount , bytes32[] calldata _merkleProof) public payable callerIsUser {}\n\n    /**\n     * @notice Sets the maximum supply of NFTs.\n     * @dev Only the contract owner can call this function.\n     * @param _maxSupply The new maximum supply of NFTs.\n     */\n    function setMaxSupply(uint256 _maxSupply) public onlyOwner {}\n\n    /**\n     * @notice Returns the total supply of NFTs.\n     * @dev This function queries the NFT collection contract for the total supply.\n     * @return The total supply of NFTs.\n     */\n    function totalSupply() public view returns(uint256) {}\n\n    /**\n     * @notice Sets the merkle root for the whitelist.\n     * @dev Only the contract owner can call this function.\n     * @param _merkleRoot The new merkle root for the whitelist.\n     */\n    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {}\n\n    /**\n     * @notice Sets the maximum number of NFTs that can be minted per address during the public sale.\n     * @dev Only the contract owner can call this function.\n     * @param _publicSaleMaxMintAmountPerAddress The new maximum number of NFTs per address.\n     */\n    function setPublicSaleMaxMintAmountPerAddress(uint256 _publicSaleMaxMintAmountPerAddress) public onlyOwner {}\n\n    /**\n     * @notice Sets the cost of minting one NFT.\n     * @dev Only the contract owner can call this function.\n     * @param _newCost The new cost of minting one NFT.\n     */\n    function setCost(uint256 _newCost) public onlyOwner {}\n\n    /**\n     * @notice Toggles whether only whitelisted addresses can mint NFTs.\n     * @dev Only the contract owner can call this function.\n     * @param _state The new state (true for only whitelisted, false for open to all).\n     */\n    function setOnlyWhitelisted(bool _state) public onlyOwner {}\n\n    /**\n     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.\n     * @dev Only the contract owner can call this function.\n     * @param _maxMintAmountPerTransaction The new maximum number of NFTs per transaction.\n     */\n    function setMaxMintAmountPerTransaction(uint256 _maxMintAmountPerTransaction) public onlyOwner {}\n\n    /**\n     * @notice Pauses or unpauses the contract.\n     * @dev Only the contract owner can call this function.\n     * @param _state The new state (true for paused, false for unpaused).\n     */\n    function pause(bool _state) public onlyOwner {}\n\n    /**\n     * @notice Toggles whether the mint count should be enforced.\n     * @dev Only the contract owner can call this function.\n     * @param _state The new state (true for enforcing mint count, false for not enforcing).\n     */\n    function setMintCount(bool _state) public onlyOwner {}\n\n    /**\n     * @notice Sets the address of the NFT collection contract.\n     * @dev Only the contract owner can call this function.\n     * @param _address The new address of the NFT collection contract.\n     */\n    function setNFTCollection(address _address) public onlyOwner {}\n\n    /**\n     * @notice Withdraws the contract's balance to the specified withdrawal address.\n     * @dev Only the contract owner can call this function.\n     */\n    function withdraw() public onlyOwner {}\n\n}\n"
}