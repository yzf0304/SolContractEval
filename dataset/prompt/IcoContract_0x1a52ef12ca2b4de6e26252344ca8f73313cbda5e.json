{
    "contract_name": "Bonus",
    "ground_truth": "contract Bonus is IcoPhase, Ownable {\n\n\tusing SafeMath for uint256;\n\n\n\n\t//decimals of tokens\n\n\tuint256 constant decimals = 18;\n\n\n\n\t//enable/disable\n\n\tbool public isBonus;\n\n\n\n\t//storage\n\n\tmapping(address => uint256) public bonusAccountBalances;\n\n\tmapping(uint256 => address) public bonusAccountIndex;\n\n\tuint256 public bonusAccountCount;\n\n\n\n\tfunction Bonus() public {\n\n\t\tisBonus = true;\n\n\t}\n\n\n\n\t/**\n\n\t * Enable bonus\n\n\t */\n\n\tfunction enableBonus() public onlyOwner returns (bool)\n\n\t{\n\n\t\trequire(!isBonus);\n\n\t\tisBonus=true;\n\n\t\treturn true;\n\n\t}\n\n\n\n\t/**\n\n\t * Disable bonus\n\n\t */\n\n\tfunction disableBonus() public onlyOwner returns (bool)\n\n\t{\n\n\t\trequire(isBonus);\n\n\t\tisBonus=false;\n\n\t\treturn true;\n\n\t}\n\n\n\n\t/**\n\n\t * Get bonus percent by time\n\n\t */\n\n\tfunction getBonusByTime() public constant returns(uint256) {\n\n\t\tuint256 bonus = 0;\n\n\n\n\t\tif(now>=phasePresale_From && now<phasePresale_To){\n\n\t\t\tbonus = 10;\n\n\t\t} else if (now>=phasePublicSale1_From && now<phasePublicSale1_To) {\n\n\t\t\tbonus = 6;\n\n\t\t} else if (now>=phasePublicSale2_From && now<phasePublicSale2_To) {\n\n\t\t\tbonus = 3;\n\n\t\t} else if (now>=phasePublicSale3_From && now<phasePublicSale3_To) {\n\n\t\t\tbonus = 1;\n\n\t\t}\n\n\n\n\t\treturn bonus;\n\n\t}\n\n\n\n\t/**\n\n\t * Get bonus by eth\n\n\t * @param _value - eth to convert to bonus\n\n\t */\n\n\tfunction getBonusByETH(uint256 _value) public constant returns(uint256) {\n\n\t\tuint256 bonus = 0;\n\n\n\n\t\tif(now>=phasePresale_From && now<phasePresale_To){\n\n\t\t\tif(_value>=400*10**decimals){\n\n\t\t\t\tbonus=_value.mul(10).div(100);\n\n\t\t\t} else if(_value>=300*10**decimals){\n\n\t\t\t\tbonus=_value.mul(5).div(100);\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t\treturn bonus;\n\n\t}\n\n\n\n\t/**\n\n\t * Get bonus balance of an account\n\n\t * @param _owner - the address to get bonus of\n\n\t */\n\n\tfunction balanceBonusOf(address _owner) public constant returns (uint256 balance)\n\n\t{\n\n\t\treturn bonusAccountBalances[_owner];\n\n\t}\n\n\n\n\t/**\n\n\t * Get bonus balance of an account\n\n\t */\n\n\tfunction payBonusToAddress(address _address) public onlyOwner returns (bool success);\n\n}",
    "function_sum": 6,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-01-30\n\n*/\n/**\n\n * @title SafeMath\n\n * @dev Math operations with safety checks that throw on error\n\n */\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint256 c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n/**\n\n * Store config of phase ICO\n\n */\n\ncontract IcoPhase {\n\n  uint256 public constant phasePresale_From = 1517493600;//14h 01/02/2018 GMT\n\n  uint256 public constant phasePresale_To = 1518703200;//14h 15/02/2018 GMT\n\n\n\n  uint256 public constant phasePublicSale1_From = 1520690400;//14h 10/03/2018 GMT\n\n  uint256 public constant phasePublicSale1_To = 1521122400;//14h 15/03/2018 GMT\n\n\n\n  uint256 public constant phasePublicSale2_From = 1521122400;//14h 15/03/2018 GMT\n\n  uint256 public constant phasePublicSale2_To = 1521554400;//14h 20/03/2018 GMT\n\n\n\n  uint256 public constant phasePublicSale3_From = 1521554400;//14h 20/03/2018 GMT\n\n  uint256 public constant phasePublicSale3_To = 1521986400;//14h 25/03/2018 GMT\n\n}\n\n\n\n// You task is to complete the smart contract Bonus strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract manages the bonus distribution for an ICO, allowing the owner to enable or disable bonuses,\n *         calculate bonuses based on time and ETH amount, and manage bonus balances for participants.\n * @dev This contract inherits from IcoPhase and Ownable. It uses SafeMath for arithmetic operations.\n */\ncontract Bonus is IcoPhase, Ownable {\n\n\tusing SafeMath for uint256;\n\n\t//decimals of tokens\n\tuint256 constant decimals = 18;\n\n\t//enable/disable\n\tbool public isBonus;\n\n\t//storage\n\tmapping(address => uint256) public bonusAccountBalances;\n\tmapping(uint256 => address) public bonusAccountIndex;\n\tuint256 public bonusAccountCount;\n\n\t/**\n\t * @notice Initializes the contract with bonuses enabled.\n\t * @dev Constructor sets the initial state of the contract.\n\t */\n\tfunction Bonus() public {\n\t\tisBonus = true;\n\t}\n\n\t/**\n\t * @notice Enables the bonus system.\n\t * @dev Can only be called by the contract owner and when bonuses are currently disabled.\n\t * @return A boolean indicating the success of the operation.\n\t */\n\tfunction enableBonus() public onlyOwner returns (bool) {}\n\n\t/**\n\t * @notice Disables the bonus system.\n\t * @dev Can only be called by the contract owner and when bonuses are currently enabled.\n\t * @return A boolean indicating the success of the operation.\n\t */\n\tfunction disableBonus() public onlyOwner returns (bool) {}\n\n\t/**\n\t * @notice Gets the bonus percentage based on the current time.\n\t * @dev Checks the current time against predefined phases and returns the corresponding bonus percentage.\n\t * @return The bonus percentage as a uint256.\n\t */\n\tfunction getBonusByTime() public constant returns(uint256) {}\n\n\t/**\n\t * @notice Calculates the bonus amount based on the provided ETH value.\n\t * @dev Determines the bonus amount based on the current phase and the provided ETH value.\n\t * @param _value The amount of ETH to convert to a bonus.\n\t * @return The bonus amount as a uint256.\n\t */\n\tfunction getBonusByETH(uint256 _value) public constant returns(uint256) {}\n\n\t/**\n\t * @notice Returns the bonus balance of a specific account.\n\t * @dev Fetches the bonus balance from the storage mapping.\n\t * @param _owner The address of the account to check the bonus balance for.\n\t * @return The bonus balance as a uint256.\n\t */\n\tfunction balanceBonusOf(address _owner) public constant returns (uint256 balance) {}\n\n\t/**\n\t * @notice Pays a bonus to a specified address.\n\t * @dev Only the contract owner can call this function. The actual implementation of paying the bonus should be defined.\n\t * @param _address The address to which the bonus will be paid.\n\t * @return A boolean indicating the success of the operation.\n\t */\n\tfunction payBonusToAddress(address _address) public onlyOwner returns (bool success) {}\n\n\t/**\n\t * @notice Fallback function to receive Ether.\n\t * @dev This function allows the contract to receive Ether.\n\t */\n\treceive() external payable {}\n}\n"
}