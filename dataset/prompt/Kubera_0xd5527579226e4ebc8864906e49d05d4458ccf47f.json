{
    "contract_name": "Kubera",
    "ground_truth": "contract Kubera is SafeMath {\n\n    /* Public variables of the token */\n\n    string public standard = 'ERC20';\n\n    string public name = 'Kubera token';\n\n    string public symbol = 'KBR';\n\n    uint8 public decimals = 0;\n\n    uint256 public totalSupply;\n\n    address public owner;\n\n    uint public tokensSoldToInvestors = 0;\n\n    uint public maxGoalInICO = 2100000000;\n\n    /* From this time on tokens may be transfered (after ICO 23h59 10/11/2017)*/\n\n    uint256 public startTime = 1510325999;\n\n    /* Tells if tokens have been burned already */\n\n    bool burned;\n\n    bool hasICOStarted;\n\n    /* This wallet will hold tokens after ICO*/\n\n    address tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;\n\n    /* This creates an array with all balances */\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n\n\n\n    /* This generates a public event on the blockchain that will notify clients */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event TransferToReferral(address indexed referralAddress, uint256 value);\n\n    event Approval(address indexed Owner, address indexed spender, uint256 value);\n\n    event Burned(uint amount);\n\n\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n\n    function Kubera() {\n\n        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;\n\n        // Give the owner all initial tokens\n\n        balanceOf[owner] = 2205000000;\n\n        // Update total supply\n\n        totalSupply      = 2205000000;\n\n    }\n\n\n\n    /* Send some of your tokens to a given address */\n\n    function transfer(address _to, uint256 _value) returns(bool success) {\n\n        //check if the crowdsale is already over\n\n        if (now < startTime) {\n\n            revert();\n\n        }\n\n\n\n        //prevent owner transfer all tokens immediately after ICO ended\n\n        if (msg.sender == owner && !burned) {\n\n            burn();\n\n            return;\n\n        }\n\n\n\n        // Subtract from the sender\n\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);\n\n        // Add the same to the recipient\n\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n\n        // Notify anyone listening that this transfer took place\n\n        Transfer(msg.sender, _to, _value);\n\n\n\n        return true;\n\n    }\n\n\n\n\n\n    /* Allow another contract or person to spend some tokens in your behalf */\n\n    function approve(address _spender, uint256 _value) returns(bool success) {\n\n        if( now < startTime && hasICOStarted) { // during ICO only allow execute this function one time\n\n            revert();\n\n        }\n\n        hasICOStarted = true;\n\n        allowance[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n\n\n        return true;\n\n    }\n\n\n\n    /* A contract or  person attempts to get the tokens of somebody else.\n\n    *  This is only allowed if the token holder approved. */\n\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n\n        if (now < startTime && _from != owner) revert(); //check if the crowdsale is already over\n\n        //prevent the owner of spending his share of tokens so that owner has to burn the token left after ICO\n\n        if (_from == owner && now >= startTime && !burned) {\n\n            burn();\n\n            return;\n\n        }\n\n        if (now < startTime){\n\n            if(_value < maxGoalInICO ) {\n\n                tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value);\n\n            } else {\n\n                _value = safeSub(_value, maxGoalInICO);\n\n            }\n\n        }\n\n        var _allowance = allowance[_from][msg.sender];\n\n        // Subtract from the sender\n\n        balanceOf[_from] = safeSub(balanceOf[_from], _value);\n\n        // Add the same to the recipient\n\n        balanceOf[_to] = safeAdd(balanceOf[_to], _value);\n\n        allowance[_from][msg.sender] = safeSub(_allowance, _value);\n\n        Transfer(_from, _to, _value);\n\n\n\n        return true;\n\n    }\n\n\n\n    function burn(){\n\n        // if tokens have not been burned already and the ICO ended or Tokens have been sold out before ICO end.\n\n        if(!burned && ( now > startTime || tokensSoldToInvestors >= maxGoalInICO) ) {\n\n            // checked for overflow above\n\n            totalSupply = safeSub(totalSupply, balanceOf[owner]) + 900000000;\n\n            uint tokensLeft = balanceOf[owner];\n\n            balanceOf[owner] = 0;\n\n            balanceOf[tokensHolder] = 900000000;\n\n            startTime = now;\n\n            burned = true;\n\n            Burned(tokensLeft);\n\n        }\n\n    }\n\n\n\n}",
    "function_sum": 5,
    "compiler_version": "0.4.11",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2017-10-30\n\n*/\n\ncontract SafeMath {\n\n    //internals\n\n\n\n    function safeMul(uint a, uint b) internal returns(uint) {\n\n        uint c = a * b;\n\n        Assert(a == 0 || c / a == b);\n\n        return c;\n\n    }\n\n\n\n    function safeSub(uint a, uint b) internal returns(uint) {\n\n        Assert(b <= a);\n\n        return a - b;\n\n    }\n\n\n\n    function safeAdd(uint a, uint b) internal returns(uint) {\n\n        uint c = a + b;\n\n        Assert(c >= a && c >= b);\n\n        return c;\n\n    }\n\n\n\n    function Assert(bool assertion) internal {\n\n        if (!assertion) {\n\n            revert();\n\n        }\n\n    }\n\n}\n\n\n\n// You task is to complete the smart contract Kubera strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.11, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Kubera Token Contract\n * @notice This contract implements the ERC20 token standard with additional features such as a burn function and ICO management.\n * @dev The contract includes functionalities for transferring tokens, approving token transfers, and managing the ICO process.\n */\ncontract Kubera is SafeMath {\n\n    /* Public variables of the token */\n\n    string public standard = 'ERC20';\n\n    string public name = 'Kubera token';\n\n    string public symbol = 'KBR';\n\n    uint8 public decimals = 0;\n\n    uint256 public totalSupply;\n\n    address public owner;\n\n    uint public tokensSoldToInvestors = 0;\n\n    uint public maxGoalInICO = 2100000000;\n\n    /* From this time on tokens may be transferred (after ICO 23h59 10/11/2017)*/\n\n    uint256 public startTime = 1510325999;\n\n    /* Tells if tokens have been burned already */\n\n    bool burned;\n\n    bool hasICOStarted;\n\n    /* This wallet will hold tokens after ICO*/\n\n    address tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;\n\n    /* This creates an array with all balances */\n\n    mapping (address => uint256) public balanceOf;\n\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /* This generates a public event on the blockchain that will notify clients */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event TransferToReferral(address indexed referralAddress, uint256 value);\n\n    event Approval(address indexed Owner, address indexed spender, uint256 value);\n\n    event Burned(uint amount);\n\n    /**\n     * @notice Initializes the contract with initial supply tokens to the creator of the contract.\n     * @dev Sets the owner and distributes the initial supply of tokens to the owner.\n     */\n    function Kubera() {\n        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;\n        // Give the owner all initial tokens\n        balanceOf[owner] = 2205000000;\n        // Update total supply\n        totalSupply      = 2205000000;\n    }\n\n    /**\n     * @notice Send some of your tokens to a given address.\n     * @param _to The address to which the tokens will be sent.\n     * @param _value The amount of tokens to send.\n     * @return A boolean indicating the success of the transfer.\n     * @dev Transfers tokens from the sender's address to the recipient's address.\n     */\n    function transfer(address _to, uint256 _value) returns(bool success) {}\n\n    /**\n     * @notice Allow another contract or person to spend some tokens in your behalf.\n     * @param _spender The address that will be allowed to spend the tokens.\n     * @param _value The amount of tokens that can be spent.\n     * @return A boolean indicating the success of the approval.\n     * @dev Approves a specified address to spend a certain amount of tokens on behalf of the message sender.\n     */\n    function approve(address _spender, uint256 _value) returns(bool success) {}\n\n    /**\n     * @dev Transfers tokens with ICO restrictions and validations.\n     * @param _from Source address\n     * @param _to Destination address\n     * @param _value Amount to transfer\n     * @return success Transfer success status\n     * @dev Requirements:\n     *   - Pre-ICO: Only owner can transfer, must burn unsold tokens\n     *   - ICO: Tracks tokens sold vs goal\n     *   - Post-ICO: Normal transfers allowed\n     * @dev Behavior:\n     *   - Validates timing and ownership\n     *   - Adjusts value if exceeding ICO goal\n     *   - Updates balances and allowance\n     *   - Emits Transfer event\n     */\n    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {}\n\n    /**\n     * @notice Burns the remaining tokens of the owner after the ICO ends.\n     * @dev Burns the remaining tokens of the owner and transfers a fixed amount to the tokensHolder address.\n     */\n    function burn() {}\n}\n"
}