{
    "contract_name": "KyberGenesisToken",
    "ground_truth": "contract KyberGenesisToken is Ownable {\n  string  public  constant name     = \"Kyber Genesis Token\";\n  string  public  constant symbol   = \"KGT\";\n  uint    public  constant decimals = 0;\n\n  uint                   public totalSupply = 0;\n  mapping(address=>uint) public balanceOf;\n\n  function KyberGenesisToken( address minter ) {\n    transferOwnership(minter);\n  }\n\n  event Transfer(address indexed _from, address indexed _to, uint _value);\n  event EndMinting( uint timestamp );\n\n  function mint( address[] recipients ) onlyOwner {\n    uint newRecipients = 0;\n    for( uint i = 0 ; i < recipients.length ; i++ ){\n      address recipient = recipients[i];\n      if( balanceOf[recipient] == 0 ){\n        Transfer( address(0x0), recipient, 1 );\n        balanceOf[recipient] = 1;\n        newRecipients++;\n      }\n    }\n\n    totalSupply += newRecipients;\n  }\n\n  function endMinting() onlyOwner {\n    transferOwnership(address(0xdead));\n    EndMinting(block.timestamp);\n  }\n\n  function burn() {\n    require(balanceOf[msg.sender] == 1 );\n    Transfer( msg.sender, address(0x0), 1 );\n    balanceOf[msg.sender] = 0;\n    totalSupply--;\n  }\n\n  function emergencyERC20Drain( ERC20Interface token, uint amount ){\n      // callable by anyone\n      address kyberMultisig = 0x3EB01B3391EA15CE752d01Cf3D3F09deC596F650;\n      token.transfer( kyberMultisig, amount );\n  }\n\n\n  // ERC20 stubs\n  function transfer(address _to, uint _value) returns (bool){ revert(); }\n  function transferFrom(address _from, address _to, uint _value) returns (bool){ revert(); }\n  function approve(address _spender, uint _value) returns (bool){ revert(); }\n  function allowance(address _owner, address _spender) constant returns (uint){ return 0; }\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\n}",
    "function_sum": 9,
    "compiler_version": "0.4.15",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    if (newOwner != address(0)) {\n      owner = newOwner;\n    }\n  }\n\n}\n\ncontract ERC20Interface {\n  function transferFrom(address _from, address _to, uint _value) returns (bool){}\n  function transfer(address _to, uint _value) returns (bool){}\n  function ERC20Interface(){}\n}\n\n\n\n// You task is to complete the smart contract KyberGenesisToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.15, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title KyberGenesisToken\n * @notice This contract is a simple token contract with minting and burning capabilities. It is designed to be owned by a minter who can mint new tokens and end the minting process.\n * @dev Inherits from Ownable, allowing for ownership management. The token has a fixed supply mechanism where each address can only hold one token.\n */\ncontract KyberGenesisToken is Ownable {\n  string  public  constant name     = \"Kyber Genesis Token\";\n  string  public  constant symbol   = \"KGT\";\n  uint    public  constant decimals = 0;\n\n  uint                   public totalSupply = 0;\n  mapping(address=>uint) public balanceOf;\n\n  /**\n   * @notice Initializes the contract and sets the minter as the owner.\n   * @param minter The address of the minter who will own the contract.\n   */\n  function KyberGenesisToken( address minter ) {\n    transferOwnership(minter);\n  }\n\n  /**\n   * @notice Event emitted when tokens are transferred.\n   * @param _from The address from which the tokens are sent.\n   * @param _to The address to which the tokens are sent.\n   * @param _value The amount of tokens transferred.\n   */\n  event Transfer(address indexed _from, address indexed _to, uint _value);\n\n  /**\n   * @notice Event emitted when the minting process is ended.\n   * @param timestamp The block timestamp when the minting was ended.\n   */\n  event EndMinting( uint timestamp );\n\n  /**\n   * @notice Mints new tokens for the specified recipients.\n   * @dev Only the owner (minter) can call this function. Each recipient can only receive one token.\n   * @param recipients Array of addresses to receive the new tokens.\n   */\n  function mint( address[] recipients ) onlyOwner {\n  }\n\n  /**\n   * @notice Ends the minting process and transfers ownership to a dead address.\n   * @dev Only the owner (minter) can call this function. After calling this function, no more tokens can be minted.\n   */\n  function endMinting() onlyOwner {\n  }\n\n  /**\n   * @notice Burns the token held by the sender.\n   * @dev The sender must hold exactly one token to burn it.\n   */\n  function burn() {\n  }\n\n  /**\n   * @notice Drains ERC20 tokens from the contract to a predefined multisig address.\n   * @dev This function can be called by anyone to drain any accidentally sent ERC20 tokens.\n   * @param token The ERC20 token contract to drain.\n   * @param amount The amount of tokens to drain.\n   */\n  function emergencyERC20Drain( ERC20Interface token, uint amount ){\n  }\n\n  // ERC20 stubs\n  /**\n   * @notice Transfers tokens from the sender to the specified address.\n   * @dev This function reverts as it is not implemented in this contract.\n   * @param _to The address to which the tokens are transferred.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean value indicating whether the operation succeeded.\n   */\n  function transfer(address _to, uint _value) returns (bool){\n  }\n\n  /**\n   * @notice Transfers tokens from one address to another.\n   * @dev This function reverts as it is not implemented in this contract.\n   * @param _from The address from which the tokens are transferred.\n   * @param _to The address to which the tokens are transferred.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean value indicating whether the operation succeeded.\n   */\n  function transferFrom(address _from, address _to, uint _value) returns (bool){\n  }\n\n  /**\n   * @notice Approves an address to spend a certain amount of tokens on behalf of the sender.\n   * @dev This function reverts as it is not implemented in this contract.\n   * @param _spender The address that is being approved to spend the tokens.\n   * @param _value The amount of tokens to approve.\n   * @return A boolean value indicating whether the operation succeeded.\n   */\n  function approve(address _spender, uint _value) returns (bool){\n  }\n\n  /**\n   * @notice Returns the amount of tokens that an owner allowed to a spender.\n   * @dev This function always returns 0 as it is not implemented in this contract.\n   * @param _owner The address of the token owner.\n   * @param _spender The address of the spender.\n   * @return The amount of tokens allowed to the spender.\n   */\n  function allowance(address _owner, address _spender) constant returns (uint){\n  }\n\n  /**\n   * @notice Event emitted when an approval is made.\n   * @param _owner The address of the token owner.\n   * @param _spender The address of the spender.\n   * @param _value The amount of tokens approved.\n   */\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n"
}