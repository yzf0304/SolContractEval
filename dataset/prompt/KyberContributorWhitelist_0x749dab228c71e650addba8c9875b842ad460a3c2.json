{
    "contract_name": "KyberContributorWhitelist",
    "ground_truth": "contract KyberContributorWhitelist is Ownable {\n    // 7 wei is a dummy cap. Will be set by owner to a real cap after registration ends.\n    uint public slackUsersCap = 7;\n    mapping(address=>uint) public addressCap;\n\n    function KyberContributorWhitelist() {}\n\n    event ListAddress( address _user, uint _cap, uint _time );\n\n    // Owner can delist by setting cap = 0.\n    // Onwer can also change it at any time\n    function listAddress( address _user, uint _cap ) onlyOwner {\n        addressCap[_user] = _cap;\n        ListAddress( _user, _cap, now );\n    }\n\n    // an optimasition in case of network congestion\n    function listAddresses( address[] _users, uint[] _cap ) onlyOwner {\n        require(_users.length == _cap.length );\n        for( uint i = 0 ; i < _users.length ; i++ ) {\n            listAddress( _users[i], _cap[i] );\n        }\n    }\n\n    function setSlackUsersCap( uint _cap ) onlyOwner {\n        slackUsersCap = _cap;\n    }\n\n    function getCap( address _user ) constant returns(uint) {\n        uint cap = addressCap[_user];\n\n        if( cap == 1 ) return slackUsersCap;\n        else return cap;\n    }\n\n    function destroy() onlyOwner {\n        selfdestruct(owner);\n    }\n}",
    "function_sum": 6,
    "compiler_version": "0.4.13",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\n\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    if (newOwner != address(0)) {\n      owner = newOwner;\n    }\n  }\n\n}\n\n\n\n// You task is to complete the smart contract KyberContributorWhitelist strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.13, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title KyberContributorWhitelist\n * @notice A smart contract for managing a whitelist of contributors, allowing the owner to set and manage contribution caps.\n * @dev This contract extends the Ownable contract, providing ownership control over the whitelisting and cap setting functionalities.\n */\ncontract KyberContributorWhitelist is Ownable {\n    // 7 wei is a dummy cap. Will be set by owner to a real cap after registration ends.\n    uint public slackUsersCap = 7;\n    mapping(address => uint) public addressCap;\n\n    /**\n     * @notice Constructor for the KyberContributorWhitelist contract.\n     * @dev Initializes the contract. No specific initialization is required in this constructor.\n     */\n    function KyberContributorWhitelist() {}\n\n    /**\n     * @notice Event emitted when an address is listed with a specific cap.\n     * @param _user The address being listed.\n     * @param _cap The contribution cap set for the address.\n     * @param _time The timestamp when the address was listed.\n     */\n    event ListAddress(address _user, uint _cap, uint _time);\n\n    /**\n     * @notice Allows the owner to list an address with a specific contribution cap.\n     * @dev The owner can delist an address by setting the cap to 0. The cap can also be changed at any time.\n     * @param _user The address to be listed.\n     * @param _cap The contribution cap for the address.\n     */\n    function listAddress(address _user, uint _cap) onlyOwner {\n    }\n\n    /**\n     * @notice Allows the owner to list multiple addresses with their respective contribution caps.\n     * @dev This function is optimized for network congestion by batching the listing process.\n     * @param _users An array of addresses to be listed.\n     * @param _cap An array of contribution caps corresponding to the addresses.\n     */\n    function listAddresses(address[] _users, uint[] _cap) onlyOwner {\n    }\n\n    /**\n     * @notice Allows the owner to set the global cap for all addresses with a cap value of 1.\n     * @dev This function sets the `slackUsersCap` which is used as the cap for addresses with a cap value of 1.\n     * @param _cap The new global cap value.\n     */\n    function setSlackUsersCap(uint _cap) onlyOwner {\n    }\n\n    /**\n     * @notice Returns the contribution cap for a given address.\n     * @dev If the address has a cap of 1, it returns the `slackUsersCap`. Otherwise, it returns the specific cap.\n     * @param _user The address to check the cap for.\n     * @return The contribution cap for the address.\n     */\n    function getCap(address _user) constant returns (uint) {\n    }\n\n    /**\n     * @notice Allows the owner to destroy the contract and send the remaining funds to the owner's address.\n     * @dev This function self-destructs the contract and transfers any remaining balance to the owner.\n     */\n    function destroy() onlyOwner {\n    }\n}\n"
}