{
    "contract_name": "LockProxy",
    "ground_truth": "contract LockProxy is Ownable {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    struct TxArgs {\n        bytes toAssetHash;\n        bytes toAddress;\n        uint256 amount;\n    }\n    address public managerProxyContract;\n    mapping(uint64 => bytes) public proxyHashMap;\n    mapping(address => mapping(uint64 => bytes)) public assetHashMap;\n    mapping(address => bool) safeTransfer;\n\n    event SetManagerProxyEvent(address manager);\n    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);\n    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);\n    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);\n    \n    modifier onlyManagerContract() {\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n        _;\n    }\n    \n    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\n        managerProxyContract = ethCCMProxyAddr;\n        emit SetManagerProxyEvent(managerProxyContract);\n    }\n    \n    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\n        proxyHashMap[toChainId] = targetProxyHash;\n        emit BindProxyEvent(toChainId, targetProxyHash);\n        return true;\n    }\n    \n    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\n        assetHashMap[fromAssetHash][toChainId] = toAssetHash;\n        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, getBalanceFor(fromAssetHash));\n        return true;\n    }\n    \n    /* @notice                  This function is meant to be invoked by the user,\n    *                           a certin amount teokens will be locked in the proxy contract the invoker/msg.sender immediately.\n    *                           Then the same amount of tokens will be unloked from target chain proxy contract at the target chain with chainId later.\n    *  @param fromAssetHash     The asset address in current chain, uniformly named as `fromAssetHash`\n    *  @param toChainId         The target chain id\n    *                           \n    *  @param toAddress         The address in bytes format to receive same amount of tokens in target chain \n    *  @param amount            The amount of tokens to be crossed from ethereum to the chain with chainId\n    */\n    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {\n        require(amount != 0, \"amount cannot be zero!\");\n        \n        \n        require(_transferToContract(fromAssetHash, amount), \"transfer asset from fromAddress to lock_proxy contract  failed!\");\n        \n        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];\n        require(toAssetHash.length != 0, \"empty illegal toAssetHash\");\n\n        TxArgs memory txArgs = TxArgs({\n            toAssetHash: toAssetHash,\n            toAddress: toAddress,\n            amount: amount\n        });\n        bytes memory txData = _serializeTxArgs(txArgs);\n        \n        IEthCrossChainManagerProxy eccmp = IEthCrossChainManagerProxy(managerProxyContract);\n        address eccmAddr = eccmp.getEthCrossChainManager();\n        IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n        \n        bytes memory toProxyHash = proxyHashMap[toChainId];\n        require(toProxyHash.length != 0, \"empty illegal toProxyHash\");\n        require(eccm.crossChain(toChainId, toProxyHash, \"unlock\", txData), \"EthCrossChainManager crossChain executed error!\");\n\n        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);\n        \n        return true;\n\n    }\n    \n    // /* @notice                  This function is meant to be invoked by the ETH crosschain management contract,\n    // *                           then mint a certin amount of tokens to the designated address since a certain amount \n    // *                           was burnt from the source chain invoker.\n    // *  @param argsBs            The argument bytes recevied by the ethereum lock proxy contract, need to be deserialized.\n    // *                           based on the way of serialization in the source chain proxy contract.\n    // *  @param fromContractAddr  The source chain contract address\n    // *  @param fromChainId       The source chain id\n    // */\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {\n        TxArgs memory args = _deserializeTxArgs(argsBs);\n\n        require(fromContractAddr.length != 0, \"from proxy contract address cannot be empty\");\n        require(Utils.equalStorage(proxyHashMap[fromChainId], fromContractAddr), \"From Proxy contract address error!\");\n        \n        require(args.toAssetHash.length != 0, \"toAssetHash cannot be empty\");\n        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);\n\n        require(args.toAddress.length != 0, \"toAddress cannot be empty\");\n        address toAddress = Utils.bytesToAddress(args.toAddress);\n        \n        \n        require(_transferFromContract(toAssetHash, toAddress, args.amount), \"transfer asset from lock_proxy contract to toAddress failed!\");\n        \n        emit UnlockEvent(toAssetHash, toAddress, args.amount);\n        return true;\n    }\n    \n    function getBalanceFor(address fromAssetHash) public view returns (uint256) {\n        if (fromAssetHash == address(0)) {\n            // return address(this).balance; // this expression would result in error: Failed to decode output: Error: insufficient data for uint256 type\n            address selfAddr = address(this);\n            return selfAddr.balance;\n        } else {\n            IERC20 erc20Token = IERC20(fromAssetHash);\n            return erc20Token.balanceOf(address(this));\n        }\n    }\n    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {\n        if (fromAssetHash == address(0)) {\n            // fromAssetHash === address(0) denotes user choose to lock ether\n            // passively check if the received msg.value equals amount\n            require(msg.value != 0, \"transferred ether cannot be zero!\");\n            require(msg.value == amount, \"transferred ether is not equal to amount!\");\n        } else {\n            // make sure lockproxy contract will decline any received ether\n            require(msg.value == 0, \"there should be no ether transfer!\");\n            // actively transfer amount of asset from msg.sender to lock_proxy contract\n            require(_transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n        }\n        return true;\n    }\n    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n        if (toAssetHash == address(0x0000000000000000000000000000000000000000)) {\n            // toAssetHash === address(0) denotes contract needs to unlock ether to toAddress\n            // convert toAddress from 'address' type to 'address payable' type, then actively transfer ether\n            address(uint160(toAddress)).transfer(amount);\n        } else {\n            // actively transfer amount of asset from msg.sender to lock_proxy contract \n            require(_transferERC20FromContract(toAssetHash, toAddress, amount), \"transfer erc20 asset to lock_proxy contract failed!\");\n        }\n        return true;\n    }\n    \n    \n    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {\n         IERC20 erc20Token = IERC20(fromAssetHash);\n        //  require(erc20Token.transferFrom(fromAddress, toAddress, amount), \"trasnfer ERC20 Token failed!\");\n         erc20Token.safeTransferFrom(fromAddress, toAddress, amount);\n         return true;\n    }\n    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {\n         IERC20 erc20Token = IERC20(toAssetHash);\n        //  require(erc20Token.transfer(toAddress, amount), \"trasnfer ERC20 Token failed!\");\n         erc20Token.safeTransfer(toAddress, amount);\n         return true;\n    }\n    \n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {\n        bytes memory buff;\n        buff = abi.encodePacked(\n            ZeroCopySink.WriteVarBytes(args.toAssetHash),\n            ZeroCopySink.WriteVarBytes(args.toAddress),\n            ZeroCopySink.WriteUint255(args.amount)\n            );\n        return buff;\n    }\n\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {\n        TxArgs memory args;\n        uint256 off = 0;\n        (args.toAssetHash, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        (args.toAddress, off) = ZeroCopySource.NextVarBytes(valueBs, off);\n        (args.amount, off) = ZeroCopySource.NextUint255(valueBs, off);\n        return args;\n    }\n}",
    "function_sum": 12,
    "compiler_version": "0.5.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-09-01\n*/\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n * Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/Context.sol\n */\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public  onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\nlibrary Utils {\n\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\n    *  @param _bs   Source bytes array\n    *  @return      bytes32\n    */\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\n            value := mload(add(_bs, 0x20))\n        }\n    }\n\n    /* @notice      Convert bytes to uint256\n    *  @param _b    Source bytes should have length of 32\n    *  @return      uint256\n    */\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\n        require(_bs.length == 32, \"bytes length is not 32.\");\n        assembly {\n            // load 32 bytes from memory starting from position _bs + 32\n            value := mload(add(_bs, 0x20))\n        }\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n    }\n\n    /* @notice      Convert uint256 to bytes\n    *  @param _b    uint256 that needs to be converted\n    *  @return      bytes\n    */\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n        assembly {\n            // Get a location of some free memory and store it in result as\n            // Solidity does for memory variables.\n            bs := mload(0x40)\n            // Put 0x20 at the first word, the length of bytes for uint256 value\n            mstore(bs, 0x20)\n            //In the next word, put value in bytes format to the next 32 bytes\n            mstore(add(bs, 0x20), _value)\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n            mstore(0x40, add(bs, 0x40))\n        }\n    }\n\n    /* @notice      Convert bytes to address\n    *  @param _bs   Source bytes: bytes length must be 20\n    *  @return      Converted address from source bytes\n    */\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\n    {\n        require(_bs.length == 20, \"bytes length does not match address\");\n        assembly {\n            // for _bs, first word store _bs.length, second word store _bs.value\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\n            addr := mload(add(_bs, 0x14))\n        }\n\n    }\n    \n    /* @notice      Convert address to bytes\n    *  @param _addr Address need to be converted\n    *  @return      Converted bytes from address\n    */\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\n        assembly {\n            // Get a location of some free memory and store it in result as\n            // Solidity does for memory variables.\n            bs := mload(0x40)\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\n            mstore(bs, 0x14)\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\n            mstore(add(bs, 0x20), shl(96, _addr))\n            // Update the free-memory pointer by padding our last write location to 32 bytes\n            mstore(0x40, add(bs, 0x40))\n       }\n    }\n\n    /* @notice          Do hash leaf as the multi-chain does\n    *  @param _data     Data in bytes format\n    *  @return          Hashed value in bytes32 format\n    */\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\n        result = sha256(abi.encodePacked(byte(0x0), _data));\n    }\n\n    /* @notice          Do hash children as the multi-chain does\n    *  @param _l        Left node\n    *  @param _r        Right node\n    *  @return          Hashed value in bytes32 format\n    */\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\n    }\n\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\n    *  @param _preBytes     The bytes stored in storage\n    *  @param _postBytes    The bytes stored in memory\n    *  @return              Bool type indicating if they are equal\n    */\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // fslot can contain both the length and contents of the array\n                // if slength < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                // slength != 0\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\n    *  @param _bytes        The original bytes needs to be sliced\n    *  @param _start        The index of _bytes for the start of sliced bytes\n    *  @param _length       The index of _bytes for the end of sliced bytes\n    *  @return              The sliced bytes\n    */\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                // lengthmod <= _length % 32\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\n    *  @param _keepers      The array consists of serveral address\n    *  @param _signers      Some specific addresses to be looked into\n    *  @param _m            The number requirement paramter\n    *  @return              True means containment, false meansdo do not contain.\n    */\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\n        uint m = 0;\n        for(uint i = 0; i < _signers.length; i++){\n            for (uint j = 0; j < _keepers.length; j++) {\n                if (_signers[i] == _keepers[j]) {\n                    m++;\n                    delete _keepers[j];\n                }\n            }\n        }\n        return m >= _m;\n    }\n\n    /* @notice              TODO\n    *  @param key\n    *  @return\n    */\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\n         require(key.length >= 67, \"key lenggh is too short\");\n         newkey = slice(key, 0, 35);\n         if (uint8(key[66]) % 2 == 0){\n             newkey[2] = byte(0x02);\n         } else {\n             newkey[2] = byte(0x03);\n         }\n         return newkey;\n    }\n    \n    /**\n     * @dev Returns true if `account` is a contract.\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(Utils.isContract(address(token)), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\n * @dev Interface of the EthCrossChainManager contract for business contract like LockProxy to request cross chain transaction\n */\n\ninterface IEthCrossChainManager {\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\n}\n\n/**\n * @dev Interface of the EthCrossChainManagerProxy for business contract like LockProxy to obtain the reliable EthCrossChainManager contract hash.\n */\n\ninterface IEthCrossChainManagerProxy {\n    function getEthCrossChainManager() external view returns (address);\n}\n\n/**\n * @dev Wrappers over decoding and deserialization operation from bytes into bassic types in Solidity for PolyNetwork cross chain utility.\n *\n * Decode into basic types in Solidity from bytes easily. It's designed to be used \n * for PolyNetwork cross chain application, and the decoding rules on Ethereum chain \n * and the encoding rule on other chains should be consistent, and . Here we\n * follow the underlying deserialization rule with implementation found here: \n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_source.go\n *\n * Using this library instead of the unchecked serialization method can help reduce\n * the risk of serious bugs and handfule, so it's recommended to use it.\n *\n * Please note that risk can be minimized, yet not eliminated.\n */\n\nlibrary ZeroCopySource {\n    /* @notice              Read next byte as boolean type starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the boolean value\n    *  @return              The the read boolean value and new offset\n    */\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\n        // byte === bytes1\n        byte v;\n        assembly{\n            v := mload(add(add(buff, 0x20), offset))\n        }\n        bool value;\n        if (v == 0x01) {\n\t\t    value = true;\n    \t} else if (v == 0x00) {\n            value = false;\n        } else {\n            revert(\"NextBool value error\");\n        }\n        return (value, offset + 1);\n    }\n\n    /* @notice              Read next byte starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the byte value\n    *  @return              The read byte value and new offset\n    */\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\n        byte v;\n        assembly{\n            v := mload(add(add(buff, 0x20), offset))\n        }\n        return (v, offset + 1);\n    }\n\n    /* @notice              Read next byte as uint8 starting at offset from buff\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the byte value\n    *  @return              The read uint8 value and new offset\n    */\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\n        uint8 v;\n        assembly{\n            let tmpbytes := mload(0x40)\n            let bvalue := mload(add(add(buff, 0x20), offset))\n            mstore8(tmpbytes, byte(0, bvalue))\n            mstore(0x40, add(tmpbytes, 0x01))\n            v := mload(sub(tmpbytes, 0x1f))\n        }\n        return (v, offset + 1);\n    }\n\n    /* @notice              Read next two bytes as uint16 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint16 value\n    *  @return              The read uint16 value and updated offset\n    */\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\n        \n        uint16 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let bvalue := mload(add(add(buff, 0x20), offset))\n            mstore8(tmpbytes, byte(0x01, bvalue))\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\n            mstore(0x40, add(tmpbytes, 0x02))\n            v := mload(sub(tmpbytes, 0x1e))\n        }\n        return (v, offset + 2);\n    }\n\n\n    /* @notice              Read next four bytes as uint32 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint32 value\n    *  @return              The read uint32 value and updated offset\n    */\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\n        uint32 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x04\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n        }\n        return (v, offset + 4);\n    }\n\n    /* @notice              Read next eight bytes as uint64 type starting from offset\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint64 value\n    *  @return              The read uint64 value and updated offset\n    */\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\n        uint64 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x08\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\n        }\n        return (v, offset + 8);\n    }\n\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\n                            there are limits considering the numerical limits in multi-chain\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the uint256 value\n    *  @return              The read uint256 value and updated offset\n    */\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\n        uint256 v;\n        assembly {\n            let tmpbytes := mload(0x40)\n            let byteLen := 0x20\n            for {\n                let tindex := 0x00\n                let bindex := sub(byteLen, 0x01)\n                let bvalue := mload(add(add(buff, 0x20), offset))\n            } lt(tindex, byteLen) {\n                tindex := add(tindex, 0x01)\n                bindex := sub(bindex, 0x01)\n            }{\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\n            }\n            mstore(0x40, add(tmpbytes, byteLen))\n            v := mload(tmpbytes)\n        }\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\n        return (v, offset + 32);\n    }\n    /* @notice              Read next variable bytes starting from offset,\n                            the decoding rule coming from multi-chain\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read variable bytes array value and updated offset\n    */\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\n        uint len;\n        (len, offset) = NextVarUint(buff, offset);\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\n        bytes memory tempBytes;\n        assembly{\n            switch iszero(len)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(len, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, len)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, len)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return (tempBytes, offset + len);\n    }\n    /* @notice              Read next 32 bytes starting from offset,\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read bytes32 value and updated offset\n    */\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\n        bytes32 v;\n        assembly {\n            v := mload(add(buff, add(offset, 0x20)))\n        }\n        return (v, offset + 32);\n    }\n\n    /* @notice              Read next 20 bytes starting from offset,\n    *  @param buff          Source bytes array\n    *  @param offset        The position from where we read the bytes value\n    *  @return              The read bytes20 value and updated offset\n    */\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\n        bytes20 v;\n        assembly {\n            v := mload(add(buff, add(offset, 0x20)))\n        }\n        return (v, offset + 20);\n    }\n    \n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\n        byte v;\n        (v, offset) = NextByte(buff, offset);\n\n        uint value;\n        if (v == 0xFD) {\n            // return NextUint16(buff, offset);\n            (value, offset) = NextUint16(buff, offset);\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\n            return (value, offset);\n        } else if (v == 0xFE) {\n            // return NextUint32(buff, offset);\n            (value, offset) = NextUint32(buff, offset);\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\n            return (value, offset);\n        } else if (v == 0xFF) {\n            // return NextUint64(buff, offset);\n            (value, offset) = NextUint64(buff, offset);\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\n            return (value, offset);\n        } else{\n            // return (uint8(v), offset);\n            value = uint8(v);\n            require(value < 0xFD, \"NextVarUint, value outside range\");\n            return (value, offset);\n        }\n    }\n}\n\n/**\n * @dev Wrappers over encoding and serialization operation into bytes from bassic types in Solidity for PolyNetwork cross chain utility.\n *\n * Encode basic types in Solidity into bytes easily. It's designed to be used \n * for PolyNetwork cross chain application, and the encoding rules on Ethereum chain \n * and the decoding rules on other chains should be consistent. Here we  \n * follow the underlying serialization rule with implementation found here: \n * https://github.com/polynetwork/poly/blob/master/common/zero_copy_sink.go\n *\n * Using this library instead of the unchecked serialization method can help reduce\n * the risk of serious bugs and handfule, so it's recommended to use it.\n *\n * Please note that risk can be minimized, yet not eliminated.\n */\n\nlibrary ZeroCopySink {\n    /* @notice          Convert boolean value into bytes\n    *  @param b         The boolean value\n    *  @return          Converted bytes array\n    */\n    function WriteBool(bool b) internal pure returns (bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            mstore(buff, 1)\n            switch iszero(b)\n            case 1 {\n                mstore(add(buff, 0x20), shl(248, 0x00))\n                // mstore8(add(buff, 0x20), 0x00)\n            }\n            default {\n                mstore(add(buff, 0x20), shl(248, 0x01))\n                // mstore8(add(buff, 0x20), 0x01)\n            }\n            mstore(0x40, add(buff, 0x21))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert byte value into bytes\n    *  @param b         The byte value\n    *  @return          Converted bytes array\n    */\n    function WriteByte(byte b) internal pure returns (bytes memory) {\n        return WriteUint8(uint8(b));\n    }\n\n    /* @notice          Convert uint8 value into bytes\n    *  @param v         The uint8 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            mstore(buff, 1)\n            mstore(add(buff, 0x20), shl(248, v))\n            // mstore(add(buff, 0x20), byte(0x1f, v))\n            mstore(0x40, add(buff, 0x21))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert uint16 value into bytes\n    *  @param v         The uint16 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x02\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x22))\n        }\n        return buff;\n    }\n    \n    /* @notice          Convert uint32 value into bytes\n    *  @param v         The uint32 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\n        bytes memory buff;\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x04\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x24))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert uint64 value into bytes\n    *  @param v         The uint64 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x08\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x28))\n        }\n        return buff;\n    }\n\n    /* @notice          Convert limited uint256 value into bytes\n    *  @param v         The uint256 value\n    *  @return          Converted bytes array\n    */\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\n        bytes memory buff;\n\n        assembly{\n            buff := mload(0x40)\n            let byteLen := 0x20\n            mstore(buff, byteLen)\n            for {\n                let mindex := 0x00\n                let vindex := 0x1f\n            } lt(mindex, byteLen) {\n                mindex := add(mindex, 0x01)\n                vindex := sub(vindex, 0x01)\n            }{\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\n            }\n            mstore(0x40, add(buff, 0x40))\n        }\n        return buff;\n    }\n\n    /* @notice          Encode bytes format data into bytes\n    *  @param data      The bytes array data\n    *  @return          Encoded bytes array\n    */\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\n        uint64 l = uint64(data.length);\n        return abi.encodePacked(WriteVarUint(l), data);\n    }\n\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\n        if (v < 0xFD){\n    \t\treturn WriteUint8(uint8(v));\n    \t} else if (v <= 0xFFFF) {\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\n    \t} else if (v <= 0xFFFFFFFF) {\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\n    \t} else {\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\n    \t}\n    }\n}\n\n\n\n// You task is to complete the smart contract LockProxy strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title LockProxy\n * @notice A contract for locking and unlocking assets between different blockchain networks.\n * @dev This contract facilitates the cross-chain transfer of assets. It locks assets on one chain and unlocks them on another.\n * The contract is owned and managed, with specific roles to control certain operations.\n */\ncontract LockProxy is Ownable {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    struct TxArgs {\n        bytes toAssetHash;\n        bytes toAddress;\n        uint256 amount;\n    }\n\n    address public managerProxyContract;\n    mapping(uint64 => bytes) public proxyHashMap;\n    mapping(address => mapping(uint64 => bytes)) public assetHashMap;\n    mapping(address => bool) safeTransfer;\n\n    event SetManagerProxyEvent(address manager);\n    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);\n    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);\n    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);\n    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);\n\n    /**\n     * @notice Modifier to ensure that only the EthCrossChainManager contract can call the function.\n     * @dev This modifier checks if the message sender is the EthCrossChainManager contract.\n     */\n    modifier onlyManagerContract() {\n        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);\n        require(_msgSender() == ieccmp.getEthCrossChainManager(), \"msgSender is not EthCrossChainManagerContract\");\n        _;\n    }\n\n    /**\n     * @notice Sets the manager proxy contract address.\n     * @dev Only the owner can set the manager proxy contract address.\n     * @param ethCCMProxyAddr The address of the EthCrossChainManager proxy contract.\n     */\n    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {\n    }\n\n    /**\n     * @notice Binds a proxy hash to a specific chain ID.\n     * @dev Only the owner can bind a proxy hash to a chain ID.\n     * @param toChainId The target chain ID.\n     * @param targetProxyHash The target proxy hash in bytes.\n     * @return bool Returns true if the binding is successful.\n     */\n    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {\n    }\n\n    /**\n     * @notice Binds an asset hash to a specific chain ID.\n     * @dev Only the owner can bind an asset hash to a chain ID.\n     * @param fromAssetHash The asset address in the current chain.\n     * @param toChainId The target chain ID.\n     * @param toAssetHash The target asset hash in bytes.\n     * @return bool Returns true if the binding is successful.\n     */\n    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {\n    }\n\n    /**\n     * @notice Locks a specified amount of tokens in the current chain and prepares to unlock them in the target chain.\n     * @dev This function transfers the tokens from the user to the contract, then sends a cross-chain request to unlock the tokens on the target chain.\n     * @param fromAssetHash The asset address in the current chain.\n     * @param toChainId The target chain ID.\n     * @param toAddress The address in bytes format to receive the tokens in the target chain.\n     * @param amount The amount of tokens to be transferred.\n     * @return bool Returns true if the lock operation is successful.\n     */\n    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {}\n\n    /**\n     * @notice Unlocks a specified amount of tokens on the current chain after they have been locked on the source chain.\n     * @dev This function is called by the ETH crosschain management contract to unlock the tokens and transfer them to the designated address.\n     * @param argsBs The argument bytes received by the Ethereum lock proxy contract, which need to be deserialized.\n     * @param fromContractAddr The source chain contract address.\n     * @param fromChainId The source chain ID.\n     * @return bool Returns true if the unlock operation is successful.\n     */\n    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {}\n\n    /**\n     * @notice Gets the balance of a specific asset in the contract.\n     * @dev If the asset address is zero, it returns the Ether balance; otherwise, it returns the ERC20 token balance.\n     * @param fromAssetHash The asset address in the current chain.\n     * @return uint256 The balance of the specified asset.\n     */\n    function getBalanceFor(address fromAssetHash) public view returns (uint256) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from the user to the contract.\n     * @dev This internal function handles the transfer of both Ether and ERC20 tokens.\n     * @param fromAssetHash The asset address in the current chain.\n     * @param amount The amount of tokens to be transferred.\n     * @return bool Returns true if the transfer is successful.\n     */\n    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from the contract to the designated address.\n     * @dev This internal function handles the transfer of both Ether and ERC20 tokens.\n     * @param toAssetHash The asset address in the current chain.\n     * @param toAddress The address to receive the tokens.\n     * @param amount The amount of tokens to be transferred.\n     * @return bool Returns true if the transfer is successful.\n     */\n    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {}\n\n    /**\n     * @notice Transfers a specified amount of ERC20 tokens from the user to the contract.\n     * @dev This internal function uses the SafeERC20 library to handle the transfer.\n     * @param fromAssetHash The asset address in the current chain.\n     * @param fromAddress The address of the user.\n     * @param toAddress The address of the contract.\n     * @param amount The amount of tokens to be transferred.\n     * @return bool Returns true if the transfer is successful.\n     */\n    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {}\n\n    /**\n     * @notice Transfers a specified amount of ERC20 tokens from the contract to the designated address.\n     * @dev This internal function uses the SafeERC20 library to handle the transfer.\n     * @param toAssetHash The asset address in the current chain.\n     * @param toAddress The address to receive the tokens.\n     * @param amount The amount of tokens to be transferred.\n     * @return bool Returns true if the transfer is successful.\n     */\n    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {}\n\n    /**\n     * @notice Serializes the transaction arguments into a byte array.\n     * @dev This internal function encodes the transaction arguments using the ZeroCopySink utility.\n     * @param args The transaction arguments to be serialized.\n     * @return bytes The serialized transaction arguments.\n     */\n    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {}\n\n    /**\n     * @notice Deserializes the transaction arguments from a byte array.\n     * @dev This internal function decodes the transaction arguments using the ZeroCopySource utility.\n     * @param valueBs The byte array containing the serialized transaction arguments.\n     * @return TxArgs The deserialized transaction arguments.\n     */\n    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {}\n}\n"
}