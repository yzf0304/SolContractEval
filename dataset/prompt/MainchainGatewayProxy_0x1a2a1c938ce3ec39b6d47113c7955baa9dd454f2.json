{
    "contract_name": "Registry",
    "ground_truth": "contract Registry is HasAdmin {\n\n  event ContractAddressUpdated(\n    string indexed _name,\n    bytes32 indexed _code,\n    address indexed _newAddress\n  );\n\n  event TokenMapped(\n    address indexed _mainchainToken,\n    address indexed _sidechainToken,\n    uint32 _standard\n  );\n\n  string public constant GATEWAY = \"GATEWAY\";\n  string public constant WETH_TOKEN = \"WETH_TOKEN\";\n  string public constant VALIDATOR = \"VALIDATOR\";\n  string public constant ACKNOWLEDGEMENT = \"ACKNOWLEDGEMENT\";\n\n  struct TokenMapping {\n    address mainchainToken;\n    address sidechainToken;\n    uint32 standard; // 20, 721 or any other standards\n  }\n\n  mapping(bytes32 => address) public contractAddresses;\n  mapping(address => TokenMapping) public mainchainMap;\n  mapping(address => TokenMapping) public sidechainMap;\n\n  function getContract(string calldata _name)\n    external\n    view\n    returns (address _address)\n  {\n    bytes32 _code = getCode(_name);\n    _address = contractAddresses[_code];\n    require(_address != address(0));\n  }\n\n  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\n    external\n    view\n    returns (bool)\n  {\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n\n    return _mapping.mainchainToken != address(0) &&\n      _mapping.sidechainToken != address(0) &&\n      _mapping.standard == _standard;\n  }\n\n  function updateContract(string calldata _name, address _newAddress)\n    external\n    onlyAdmin\n  {\n    bytes32 _code = getCode(_name);\n    contractAddresses[_code] = _newAddress;\n\n    emit ContractAddressUpdated(_name, _code, _newAddress);\n  }\n\n  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\n    external\n    onlyAdmin\n  {\n    TokenMapping memory _map = TokenMapping(\n      _mainchainToken,\n      _sidechainToken,\n      _standard\n    );\n\n    mainchainMap[_mainchainToken] = _map;\n    sidechainMap[_sidechainToken] = _map;\n\n    emit TokenMapped(\n      _mainchainToken,\n      _sidechainToken,\n      _standard\n    );\n  }\n\n  function clearMapToken(address _mainchainToken, address _sidechainToken)\n    external\n    onlyAdmin\n  {\n    TokenMapping storage _mainchainMap = mainchainMap[_mainchainToken];\n    _clearMapEntry(_mainchainMap);\n\n    TokenMapping storage _sidechainMap = sidechainMap[_sidechainToken];\n    _clearMapEntry(_sidechainMap);\n  }\n\n  function getMappedToken(\n    address _token,\n    bool _isMainchain\n  )\n    external\n    view\n  returns (\n    address _mainchainToken,\n    address _sidechainToken,\n    uint32 _standard\n  )\n  {\n    TokenMapping memory _mapping = _getTokenMapping(_token, _isMainchain);\n    _mainchainToken = _mapping.mainchainToken;\n    _sidechainToken = _mapping.sidechainToken;\n    _standard = _mapping.standard;\n  }\n\n  function getCode(string memory _name)\n    public\n    pure\n    returns (bytes32)\n  {\n    return keccak256(abi.encodePacked(_name));\n  }\n\n  function _getTokenMapping(\n    address _token,\n    bool isMainchain\n  )\n    internal\n    view\n    returns (TokenMapping memory _mapping)\n  {\n    if (isMainchain) {\n      _mapping = mainchainMap[_token];\n    } else {\n      _mapping = sidechainMap[_token];\n    }\n  }\n\n  function _clearMapEntry(TokenMapping storage _entry)\n    internal\n  {\n    _entry.mainchainToken = address(0);\n    _entry.sidechainToken = address(0);\n    _entry.standard = 0;\n  }\n}",
    "function_sum": 9,
    "compiler_version": "0.5.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-04-28\n*/\n// File: @axie/contract-library/contracts/access/HasAdmin.sol\n\ncontract HasAdmin {\n  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\n  event AdminRemoved(address indexed _oldAdmin);\n\n  address public admin;\n\n  modifier onlyAdmin {\n    require(msg.sender == admin);\n    _;\n  }\n\n  constructor() internal {\n    admin = msg.sender;\n    emit AdminChanged(address(0), admin);\n  }\n\n  function changeAdmin(address _newAdmin) external onlyAdmin {\n    require(_newAdmin != address(0));\n    emit AdminChanged(admin, _newAdmin);\n    admin = _newAdmin;\n  }\n\n  function removeAdmin() external onlyAdmin {\n    emit AdminRemoved(admin);\n    admin = address(0);\n  }\n}\n\n\n\n// You task is to complete the smart contract Registry strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract serves as a registry for managing and mapping token addresses between mainchain and sidechain, \n * as well as storing and updating addresses of key contracts such as the gateway, WETH token, validator, and acknowledgement.\n * @dev The contract uses mappings to store the addresses of the contracts and token mappings. It also emits events for updates.\n */\ncontract Registry is HasAdmin {\n\n  event ContractAddressUpdated(\n    string indexed _name,\n    bytes32 indexed _code,\n    address indexed _newAddress\n  );\n\n  event TokenMapped(\n    address indexed _mainchainToken,\n    address indexed _sidechainToken,\n    uint32 _standard\n  );\n\n  string public constant GATEWAY = \"GATEWAY\";\n  string public constant WETH_TOKEN = \"WETH_TOKEN\";\n  string public constant VALIDATOR = \"VALIDATOR\";\n  string public constant ACKNOWLEDGEMENT = \"ACKNOWLEDGEMENT\";\n\n  struct TokenMapping {\n    address mainchainToken;\n    address sidechainToken;\n    uint32 standard; // 20, 721 or any other standards\n  }\n\n  mapping(bytes32 => address) public contractAddresses;\n  mapping(address => TokenMapping) public mainchainMap;\n  mapping(address => TokenMapping) public sidechainMap;\n\n  /**\n   * @notice Retrieves the address of a contract by its name.\n   * @param _name The name of the contract (e.g., \"GATEWAY\").\n   * @return _address The address of the contract.\n   * @dev The function requires that the contract address is not zero.\n   */\n  function getContract(string calldata _name)\n    external\n    view\n    returns (address _address)\n  {}\n\n  /**\n   * @notice Checks if a token is mapped for a given standard on either the mainchain or sidechain.\n   * @param _token The token address to check.\n   * @param _standard The token standard (e.g., 20 for ERC20).\n   * @param _isMainchain A boolean indicating whether the token is on the mainchain.\n   * @return A boolean indicating whether the token is mapped.\n   * @dev The function checks both the mainchain and sidechain mappings.\n   */\n  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)\n    external\n    view\n    returns (bool)\n  {}\n\n  /**\n   * @notice Updates the address of a contract by its name.\n   * @param _name The name of the contract (e.g., \"GATEWAY\").\n   * @param _newAddress The new address of the contract.\n   * @dev Only the admin can call this function. Emits a `ContractAddressUpdated` event.\n   */\n  function updateContract(string calldata _name, address _newAddress)\n    external\n    onlyAdmin\n  {}\n\n  /**\n   * @notice Maps a mainchain token to a sidechain token with a specified standard.\n   * @param _mainchainToken The address of the mainchain token.\n   * @param _sidechainToken The address of the sidechain token.\n   * @param _standard The token standard (e.g., 20 for ERC20).\n   * @dev Only the admin can call this function. Emits a `TokenMapped` event.\n   */\n  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)\n    external\n    onlyAdmin\n  {}\n\n  /**\n   * @notice Clears the mapping for a given mainchain and sidechain token pair.\n   * @param _mainchainToken The address of the mainchain token.\n   * @param _sidechainToken The address of the sidechain token.\n   * @dev Only the admin can call this function. Resets the mapping to zero values.\n   */\n  function clearMapToken(address _mainchainToken, address _sidechainToken)\n    external\n    onlyAdmin\n  {}\n\n  /**\n   * @notice Retrieves the mapped token details for a given token address and chain type.\n   * @param _token The token address to retrieve the mapping for.\n   * @param _isMainchain A boolean indicating whether the token is on the mainchain.\n   * @return _mainchainToken The address of the mainchain token.\n   * @return _sidechainToken The address of the sidechain token.\n   * @return _standard The token standard (e.g., 20 for ERC20).\n   * @dev The function checks both the mainchain and sidechain mappings.\n   */\n  function getMappedToken(\n    address _token,\n    bool _isMainchain\n  )\n    external\n    view\n    returns (\n      address _mainchainToken,\n      address _sidechainToken,\n      uint32 _standard\n    )\n  {}\n\n  /**\n   * @notice Generates a unique code for a contract name.\n   * @param _name The name of the contract (e.g., \"GATEWAY\").\n   * @return The keccak256 hash of the contract name.\n   * @dev This function is used to generate a unique identifier for each contract.\n   */\n  function getCode(string memory _name)\n    public\n    pure\n    returns (bytes32)\n  {}\n\n  /**\n   * @notice Retrieves the token mapping for a given token address and chain type.\n   * @param _token The token address to retrieve the mapping for.\n   * @param isMainchain A boolean indicating whether the token is on the mainchain.\n   * @return _mapping The token mapping structure.\n   * @dev This is an internal function used to fetch the token mapping.\n   */\n  function _getTokenMapping(\n    address _token,\n    bool isMainchain\n  )\n    internal\n    view\n    returns (TokenMapping memory _mapping)\n  {}\n\n  /**\n   * @notice Clears the token mapping entry.\n   * @param _entry The token mapping storage reference to be cleared.\n   * @dev This is an internal function used to reset the token mapping to zero values.\n   */\n  function _clearMapEntry(TokenMapping storage _entry)\n    internal\n  {}\n}\n"
}