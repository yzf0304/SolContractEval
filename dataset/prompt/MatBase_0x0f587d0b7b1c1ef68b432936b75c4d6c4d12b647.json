{
    "contract_name": "MatBase",
    "ground_truth": "contract MatBase is Ownable, MatToken, MatBonus {\n\n using SafeMath for uint256;\n\n  \n\n  uint256 public constant _START_DATE = 1508284800; //  Wednesday, 18-Oct-17 00:00:00 UTC in RFC 2822\n\n  uint256 public constant _END_DATE = 1513641600; // Tuesday, 19-Dec-17 00:00:00 UTC in RFC 2822\n\n  uint256 public constant CROWDSALE_PRICE = 100; // 100 MAT per ETH\n\n  address public constant ICO_ADDRESS = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;\n\n  address public constant PARTNERS_WALLET =  0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;\n\n  address public constant TEAM_WALLET = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;\n\n\n\n  // start and end timestamps where investments are allowed (both inclusive)\n\n  uint256 public startTime;\n\n  uint256 public endTime;\n\n  function setStartTime(uint256 _startTime) onlyOwner\n\n  {\n\n    startTime = _startTime;\n\n  }\n\n  function setEndTime(uint256 _endTime) onlyOwner\n\n  {\n\n    endTime = _endTime;\n\n  }\n\n\n\n  // address  where funds are collected\n\n  address public wallet;\n\n  address public p_wallet;\n\n  address public t_wallet;\n\n\n\n  // total amount of raised money in wei\n\n  uint256 public totalCollected;\n\n  // how many token units a buyer gets per wei\n\n  uint256 public rate;\n\n  // @return true if crowdsale event has ended\n\n  function hasEnded() public constant returns (bool) {\n\n    return now > endTime;\n\n  }\n\n  event Mint(address indexed purchaser, uint256 amount);\n\n  event Bonus(address indexed purchaser,uint256 amount);\n\n  function mint(address _to, uint256 _tokens) internal returns (bool) {\n\n    totalSupply = totalSupply.add(_tokens);\n\n    require(totalSupply <= whiteListLimit);\n\n    require(totalSupply <= MAT_TOTAL_SUPPLY_LIMIT);\n\n\n\n    balances[_to] = balances[_to].add(_tokens);\n\n    Mint(_to, _tokens);\n\n    Transfer(0x0, _to, _tokens);\n\n    return true;\n\n  }\n\n  // send ether to the fund collection wallet\n\n  // override to create custom fund forwarding mechanisms\n\n  function forwardFunds() internal {\n\n    wallet.transfer(msg.value);\n\n  }\n\n\n\n  // @return true if the transaction can buy tokens\n\n  function validPurchase() internal constant returns (bool) {\n\n    bool withinPeriod = now >= startTime && now <= endTime;\n\n    bool nonZeroPurchase = msg.value != 0;\n\n    return withinPeriod && nonZeroPurchase;\n\n  }\n\n  /**\n\n   * event for token purchase logging\n\n   * @param purchaser who paid for the tokens\n\n   * @param beneficiary who got the tokens\n\n   * @param value weis paid for purchase\n\n   * @param amountTokens amount of tokens purchased\n\n   */\n\n  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amountTokens,\n\n    string referral);\n\n\n\n  // fallback function can be used to buy tokens\n\n  function () payable {\n\n    buyTokens(msg.sender);\n\n  }\n\n\n\n  // low level token purchase function\n\n  function buyTokens(address beneficiary) public payable {\n\n    buyTokensReferral(beneficiary, \"\");\n\n  }\n\n\n\n  // low level token purchase function\n\n  function buyTokensReferral(address beneficiary, string referral) public payable {\n\n    require(msg.value > 0);\n\n    require(beneficiary != 0x0);\n\n    require(validPurchase());\n\n\n\n    uint256 weiAmount = msg.value;\n\n\n\n    // calculate token amount to be created\n\n    uint256 tokens = weiAmount.mul(rate);\n\n    uint256 bonus = calcBonus(tokens);\n\n\n\n    // update state\n\n    totalCollected = totalCollected.add(weiAmount);\n\n\n\n    if (!buyTokenWL(tokens)) mint(beneficiary, bonus);\n\n    mint(beneficiary, tokens);\n\n    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, referral);\n\n    forwardFunds();\n\n  }\n\n\n\n//whitelist\n\n  bool isWhitelistOn;\n\n  uint256 public whiteListLimit;\n\n\n\n  enum WLS {notlisted,listed,fulfilled}\n\n  struct FundReservation {\n\n    WLS status;\n\n    uint256  reserved;\n\n  }\n\n  mapping ( address => FundReservation ) whitelist;\n\n\n\n  function stopWhitelistReservetion() onlyOwner public { \n\n    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT; \n\n  }\n\n\n\n  function setWhiteListStatus(bool _isWhitelistOn) onlyOwner public {\n\n    isWhitelistOn = _isWhitelistOn;\n\n  }\n\n\n\n  function buyTokenWL(uint256 tokens) internal returns (bool)\n\n  { \n\n    require(isWhitelistOn);\n\n    require(now >= startTime);\n\n    if (whitelist[msg.sender].status == WLS.listed) {\n\n      uint256 reservation = whitelist[msg.sender].reserved;\n\n      uint256 low = reservation.mul(9).div(10);\n\n      uint256 upper = reservation.mul(11).div(10);\n\n      \n\n      if( low <= msg.value && msg.value <= upper) {\n\n        whitelist[msg.sender].status == WLS.fulfilled;\n\n        uint256 bonus = tokens / 10;\n\n        mint(msg.sender, bonus);\n\n        Bonus(msg.sender,bonus);\n\n        return true;\n\n      }\n\n    }\n\n    return false;\n\n  }\n\n  event White(address indexed to, uint256 reservation);\n\n  function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool status)\n\n  {\n\n    require(now < endTime);\n\n    require(whitelist[wlmember].status == WLS.notlisted);\n\n    \n\n    whitelist[wlmember].status = WLS.listed;\n\n    whitelist[wlmember].reserved = reservation;\n\n    \n\n    whiteListLimit = whiteListLimit.sub(reservation.mul(CROWDSALE_PRICE).mul(11).div(10));\n\n    White(wlmember,reservation);\n\n    return true;\n\n  }\n\n  address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;\n\n    /**\n\n   * @dev presale token conversion \n\n   *\n\n   * @param _to holder of presale tokens\n\n   * @param _pretokens The amount of presale tokens to be spent.\n\n   * @param _tokens The amount of presale tokens to be minted on crowdsale, the rest transfer from partners pool\n\n   */\n\n  function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool){\n\n    require(now <= endTime);\n\n    require(_to != address(0));\n\n    require(_pretokens >=  _tokens);\n\n    \n\n    mint(_to, _tokens); //implicit transfer event\n\n    \n\n    uint256 theRest = _pretokens.sub(_tokens);\n\n    require(balances[PARTNERS_WALLET] >= theRest);\n\n    \n\n    if (theRest > 0) {\n\n      balances[PARTNERS_WALLET] = balances[PARTNERS_WALLET].sub(theRest);\n\n      balances[_to] = balances[_to].add(theRest);\n\n      Transfer(PARTNERS_WALLET, _to, theRest); //explicit transfer event\n\n    }\n\n    uint256 amount = _pretokens.div(rate);\n\n    totalCollected = totalCollected.add(amount);\n\n    return true;\n\n  }\n\n  function MatBase() {\n\n    startTime = _START_DATE;\n\n    endTime = _END_DATE;\n\n    wallet = ICO_ADDRESS;\n\n    rate = CROWDSALE_PRICE;\n\n    p_wallet = PARTNERS_WALLET;\n\n    t_wallet = TEAM_WALLET;\n\n    balances[p_wallet] =  MAT_PARTNERS_SUPPLY_LIMIT;\n\n    balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;\n\n    totalSupply = MAT_PARTNERS_SUPPLY_LIMIT + MAT_TEAM_SUPPLY_LIMIT;\n\n    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;\n\n  }\n\n}",
    "function_sum": 14,
    "compiler_version": "0.4.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2017-10-17\n\n*/\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint256 c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\ncontract Ownable {\n\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n  function transferOwnership(address newOwner) onlyOwner public {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\ncontract ERC20Basic {\n\n  uint256 public totalSupply;\n\n  function balanceOf(address who) public constant returns (uint256);\n\n  function transfer(address to, uint256 value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n}\n\ncontract ERC20 is ERC20Basic {\n\n  function allowance(address owner, address spender) public constant returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}\n\ncontract BasicToken is ERC20Basic, Ownable {\n\n  using SafeMath for uint256;\n\n\n\n  mapping(address => uint256) balances;\n\n\n\n  bool transferAllowed = false;\n\n\n\n  function setTransferAllowed(bool _transferAllowed) public onlyOwner {\n\n    transferAllowed = _transferAllowed;\n\n  }\n\n\n\n  /**\n\n  * @dev transfer token for a specified address\n\n  * @param _to The address to transfer to.\n\n  * @param _value The amount to be transferred.\n\n  */\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n    require(transferAllowed);\n\n\n\n    // SafeMath.sub will throw if there is not enough balance.\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n  * @dev Gets the balance of the specified address.\n\n  * @param _owner The address to query the the balance of.\n\n  * @return An uint256 representing the amount owned by the passed address.\n\n  */\n\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n}\n\n//StandardToken.sol\n\ncontract StandardToken is ERC20, BasicToken {\n\n  using SafeMath for uint256;\n\n\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n\n\n\n  /**\n\n   * @dev Transfer tokens from one address to another\n\n   * @param _from address The address which you want to send tokens from\n\n   * @param _to address The address which you want to transfer to\n\n   * @param _value uint256 the amount of tokens to be transferred\n\n   */\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n    require(transferAllowed);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\n   *\n\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   * @param _spender The address which will spend the funds.\n\n   * @param _value The amount of tokens to be spent.\n\n   */\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /**\n\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\n   * @param _owner address The address which owns the funds.\n\n   * @param _spender address The address which will spend the funds.\n\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n\n   */\n\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n}\n\ncontract MatToken is Ownable, StandardToken {\n\n  string public constant name = \"MiniApps Token\";\n\n  string public constant symbol = \"MAT\";\n\n  uint   public constant decimals = 18;\n\n  \n\n  // token units\n\n  uint256 public constant MAT_UNIT = 10**uint256(decimals);\n\n  uint256 constant MILLION_MAT = 10**6 * MAT_UNIT;\n\n  uint256 constant THOUSAND_MAT = 10**3 * MAT_UNIT;\n\n\n\n  // Token distribution: crowdsale - 50%, partners - 35%, team - 15%, total 20M  \n\n  uint256 public constant MAT_CROWDSALE_SUPPLY_LIMIT = 10 * MILLION_MAT;\n\n  uint256 public constant MAT_TEAM_SUPPLY_LIMIT = 7 * MILLION_MAT;\n\n  uint256 public constant MAT_PARTNERS_SUPPLY_LIMIT = 3 * MILLION_MAT;\n\n  uint256 public constant MAT_TOTAL_SUPPLY_LIMIT = MAT_CROWDSALE_SUPPLY_LIMIT + MAT_TEAM_SUPPLY_LIMIT + MAT_PARTNERS_SUPPLY_LIMIT;\n\n}\n\ncontract MatBonus is MatToken {\n\n  uint256 public constant TOTAL_SUPPLY_UPPER_BOUND = 14000 * THOUSAND_MAT;\n\n  uint256 public constant TOTAL_SUPPLY_BOTTOM_BOUND = 11600 * THOUSAND_MAT;\n\n\n\n  function calcBonus(uint256 tokens) internal returns (uint256){\n\n    if (totalSupply <= TOTAL_SUPPLY_BOTTOM_BOUND)\n\n      return tokens.mul(8).div(100);\n\n    else if (totalSupply > TOTAL_SUPPLY_BOTTOM_BOUND && totalSupply <= TOTAL_SUPPLY_UPPER_BOUND)\n\n      return tokens.mul(5).div(100);\n\n    else\n\n      return 0;\n\n  }\n\n}\n\n\n\n// You task is to complete the smart contract MatBase strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title MatBase\n * @dev This contract is a base for a token crowdsale, including functionalities like minting tokens,\n *      managing the whitelist, and handling token purchases. It inherits from Ownable, MatToken, and MatBonus.\n * @notice Manages the crowdsale process, including setting start and end times, managing funds, and minting tokens.\n */\ncontract MatBase is Ownable, MatToken, MatBonus {\n\n    using SafeMath for uint256;\n\n    /**\n     * @notice The start date of the crowdsale.\n     * @dev Set to 1508284800 (Wednesday, 18-Oct-17 00:00:00 UTC in RFC 2822).\n     */\n    uint256 public constant _START_DATE = 1508284800;\n\n    /**\n     * @notice The end date of the crowdsale.\n     * @dev Set to 1513641600 (Tuesday, 19-Dec-17 00:00:00 UTC in RFC 2822).\n     */\n    uint256 public constant _END_DATE = 1513641600;\n\n    /**\n     * @notice The price of tokens per ETH during the crowdsale.\n     * @dev Set to 100 MAT per ETH.\n     */\n    uint256 public constant CROWDSALE_PRICE = 100;\n\n    /**\n     * @notice The address where the crowdsale funds are collected.\n     * @dev Set to 0x6075a5A0620861cfeF593a51A01aF0fF179168C7.\n     */\n    address public constant ICO_ADDRESS = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;\n\n    /**\n     * @notice The wallet address for partners.\n     * @dev Set to 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E.\n     */\n    address public constant PARTNERS_WALLET = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;\n\n    /**\n     * @notice The wallet address for the team.\n     * @dev Set to 0xe1d32147b08b2a7808026D4A94707E321ccc7150.\n     */\n    address public constant TEAM_WALLET = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;\n\n    /**\n     * @notice The start time of the crowdsale.\n     * @dev Can be set by the owner.\n     */\n    uint256 public startTime;\n\n    /**\n     * @notice The end time of the crowdsale.\n     * @dev Can be set by the owner.\n     */\n    uint256 public endTime;\n\n    /**\n     * @dev Sets the start time of the crowdsale.\n     * @param _startTime The new start time.\n     */\n    function setStartTime(uint256 _startTime) onlyOwner {\n    }\n\n    /**\n     * @dev Sets the end time of the crowdsale.\n     * @param _endTime The new end time.\n     */\n    function setEndTime(uint256 _endTime) onlyOwner {\n    }\n\n    /**\n     * @notice The wallet address where the funds are collected.\n     * @dev Set to the ICO_ADDRESS.\n     */\n    address public wallet;\n\n    /**\n     * @notice The wallet address for partners.\n     * @dev Set to the PARTNERS_WALLET.\n     */\n    address public p_wallet;\n\n    /**\n     * @notice The wallet address for the team.\n     * @dev Set to the TEAM_WALLET.\n     */\n    address public t_wallet;\n\n    /**\n     * @notice The total amount of raised money in wei.\n     * @dev Updated when tokens are purchased.\n     */\n    uint256 public totalCollected;\n\n    /**\n     * @notice The rate at which tokens are sold per wei.\n     * @dev Set to the CROWDSALE_PRICE.\n     */\n    uint256 public rate;\n\n    /**\n     * @notice Checks if the crowdsale has ended.\n     * @dev Returns true if the current time is greater than the end time.\n     * @return True if the crowdsale has ended, false otherwise.\n     */\n    function hasEnded() public constant returns (bool) {\n    }\n\n    /**\n     * @dev Event emitted when tokens are minted.\n     * @param purchaser The address of the purchaser.\n     * @param amount The amount of tokens minted.\n     */\n    event Mint(address indexed purchaser, uint256 amount);\n\n    /**\n     * @dev Event emitted when a bonus is given.\n     * @param purchaser The address of the purchaser.\n     * @param amount The amount of the bonus.\n     */\n    event Bonus(address indexed purchaser, uint256 amount);\n\n    /**\n     * @dev Mints new tokens and assigns them to an account.\n     * @param _to The address to receive the tokens.\n     * @param _tokens The number of tokens to mint.\n     * @return True if the minting was successful.\n     */\n    function mint(address _to, uint256 _tokens) internal returns (bool) {}\n\n    /**\n     * @dev Forwards the funds to the collection wallet.\n     */\n    function forwardFunds() internal {}\n\n    /**\n     * @notice Checks if the transaction can buy tokens.\n     * @dev Ensures the purchase is within the valid period and non-zero.\n     * @return True if the purchase is valid, false otherwise.\n     */\n    function validPurchase() internal constant returns (bool) {}\n\n    /**\n     * @dev Event emitted when tokens are purchased.\n     * @param purchaser The address of the purchaser.\n     * @param beneficiary The address of the beneficiary.\n     * @param value The amount of wei paid for the purchase.\n     * @param amountTokens The amount of tokens purchased.\n     * @param referral The referral string.\n     */\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amountTokens, string referral);\n\n    /**\n     * @dev Fallback function to buy tokens.\n     */\n    function () payable {}\n\n    /**\n     * @notice Buys tokens for the sender.\n     * @param beneficiary The address to receive the tokens.\n     */\n    function buyTokens(address beneficiary) public payable {}\n\n    /**\n     * @notice Buys tokens with a referral code.\n     * @param beneficiary The address to receive the tokens.\n     * @param referral The referral code.\n     */\n    function buyTokensReferral(address beneficiary, string referral) public payable {}\n\n    /**\n     * @notice Checks if the whitelist is enabled.\n     * @dev Used to determine if the whitelist is active.\n     */\n    bool isWhitelistOn;\n\n    /**\n     * @notice The limit for the whitelist.\n     * @dev Updated when reservations are made.\n     */\n    uint256 public whiteListLimit;\n\n    /**\n     * @dev Enum for the whitelist status.\n     */\n    enum WLS {notlisted, listed, fulfilled}\n\n    /**\n     * @dev Struct for fund reservations.\n     * @param status The status of the reservation.\n     * @param reserved The amount reserved.\n     */\n    struct FundReservation {\n        WLS status;\n        uint256 reserved;\n    }\n\n    /**\n     * @dev Mapping of addresses to their fund reservations.\n     */\n    mapping (address => FundReservation) whitelist;\n\n    /**\n     * @dev Stops the whitelist reservation.\n     */\n    function stopWhitelistReservetion() onlyOwner public {}\n\n    /**\n     * @dev Sets the whitelist status.\n     * @param _isWhitelistOn The new whitelist status.\n     */\n    function setWhiteListStatus(bool _isWhitelistOn) onlyOwner public {}\n\n    /**\n     * @dev Handles token purchases for whitelisted users.\n     * @param tokens The number of tokens to purchase.\n     * @return True if the purchase was successful, false otherwise.\n     */\n    function buyTokenWL(uint256 tokens) internal returns (bool) {}\n\n    /**\n     * @dev Event emitted when a user is added to the whitelist.\n     * @param to The address of the user.\n     * @param reservation The amount reserved.\n     */\n    event White(address indexed to, uint256 reservation);\n\n    /**\n     * @dev Registers a user on the whitelist.\n     * @param wlmember The address of the user.\n     * @param reservation The amount reserved.\n     * @return True if the registration was successful.\n     */\n    function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool) {}\n\n    /**\n     * @notice The address of the presale contract.\n     * @dev Set to 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd.\n     */\n    address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;\n\n    /**\n     * @dev Converts presale tokens to main sale tokens.\n     * @param _to The address of the token holder.\n     * @param _pretokens The amount of presale tokens.\n     * @param _tokens The amount of main sale tokens to mint.\n     * @return True if the conversion was successful.\n     */\n    function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool) {}\n\n    /**\n     * @dev Initializes the contract with the necessary parameters.\n     */\n    function MatBase() {\n        startTime = _START_DATE;\n        endTime = _END_DATE;\n        wallet = ICO_ADDRESS;\n        rate = CROWDSALE_PRICE;\n        p_wallet = PARTNERS_WALLET;\n        t_wallet = TEAM_WALLET;\n        balances[p_wallet] = MAT_PARTNERS_SUPPLY_LIMIT;\n        balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;\n        totalSupply = MAT_PARTNERS_SUPPLY_LIMIT + MAT_TEAM_SUPPLY_LIMIT;\n        whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;\n    }\n}\n"
}