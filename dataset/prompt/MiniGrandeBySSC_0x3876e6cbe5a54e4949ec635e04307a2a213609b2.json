{
    "contract_name": "MiniGrandeBySSC",
    "ground_truth": "contract MiniGrandeBySSC is Ownable, ERC721A, ReentrancyGuard {\n\n    uint256 private _publicPrice = 0.007 ether;\n    uint256 private _presalePrice = 0 ether;\n    uint256 private _maxPurchaseDuringWhitelist = 1;\n    uint256 private _maxPurchaseDuringSale = 1;\n    uint256 private _maxPerTransaction = 1;\n    uint256 private _maxMint = 2000;\n    address private _team = 0x6FEf5A781A35d158096736dBc561F298ef47B86c;\n    bytes32 public merkleRoot = 0x8daf3296866531d8a9a23e382da52d37f29af1f17e5e9ed8a403c896de82be5f;\n    mapping(address => uint256) public presaleAddressMintCount;\n    mapping(address => uint256) public saleAddressMintCount;\n    uint32 public whitelistMinted = 0;\n    uint32 private _maxWhitelistMints = 200;\n\n    bool public isPaused = false;\n    bool public isPublicMint = false;\n    bool public isWhitelistMint = false;\n    string private _tokenURI = \"ipfs://QmZzPHpPmtBHACKpu4MQ6XH2mNXJcJgRhdv1KYpnHqQ6q9/\";\n    \n    constructor() ERC721A(\"MiniGrandeBySecretSocietyClub\", \"MINIBYSSC\", _maxPerTransaction, _maxMint) {}\n\n    function setMaxWhitelistMints (uint32 val) external onlyOwner {\n        _maxWhitelistMints = val;\n    }\n\n    function setMaxMintPerWalletWhitelist (uint256 val) external onlyOwner {\n        _maxPurchaseDuringWhitelist = val;\n    }\n\n    function setMaxMintPerWalletSale (uint256 val) external onlyOwner {\n        _maxPurchaseDuringSale = val;\n    }\n\n    function checkIsPublicMint () external view returns (bool) {\n        return isPublicMint;\n    }\n\n    function pause() external onlyOwner {\n        isPaused = true;\n    }\n\n    function unpause() external onlyOwner {\n        isPaused = false;\n    }\n\n    function setTeam(address team) external onlyOwner {\n        _team = team;\n    }\n\n    function getPublicPrice() external view returns(uint256) {\n        return _publicPrice;\n    }\n\n    function setPublicMint (bool value) external onlyOwner {\n        isPublicMint = value;\n    }\n\n    function setWhitelistMint (bool value) external onlyOwner {\n        isWhitelistMint = value;\n    }\n\n    function setPresalePrice (uint256 price) external onlyOwner {\n        _presalePrice = price;\n    }\n\n    function setPublicPrice (uint256 price) external onlyOwner {\n        _publicPrice = price;\n    }\n\n    function setCollectionSize (uint256 size) external onlyOwner {\n        collectionSize = size;\n        _maxMint = size;\n    }\n\n    modifier mintGuard(uint256 tokenCount) {\n        require(!isPaused, \"Paused!\");\n        \n        require(tokenCount > 0 && tokenCount <= _maxPerTransaction, \"Max one per transaction\");\n        require(msg.sender == tx.origin, \"Sender not origin\");\n        // Price check\n        if (isPublicMint) {\n            require(_publicPrice * tokenCount <= msg.value, \"Insufficient funds\");\n        } else {\n            require(_presalePrice * tokenCount <= msg.value, \"Insufficient funds\");\n        }\n        require(totalSupply() + tokenCount <= _maxMint+1, \"Sold out!\");\n        _;\n    }\n\n    function mint(uint256 amount) external payable mintGuard(amount) {\n        require(isPublicMint, \"Sale has not started!\");\n        require(saleAddressMintCount[msg.sender] + amount <= _maxPurchaseDuringSale, \"Only one NFT can be minted\");\n        saleAddressMintCount[msg.sender] += amount;\n\n        _safeMint(msg.sender, amount);\n    }\n\n    function mintPresale(bytes32[] calldata proof, uint256 amount) external payable mintGuard(amount) {\n        require(MerkleProof.verify(proof, merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"You're not on the whitelist\");\n        require(isWhitelistMint, \"You're on the whitelist but mint has not started!!\");\n        require(presaleAddressMintCount[msg.sender] + amount <= _maxPurchaseDuringWhitelist, \"Only one NFT can be minted\");\n        presaleAddressMintCount[msg.sender] += amount;\n        require(whitelistMinted < _maxWhitelistMints, \"All whitelist mints have been claimed!\");\n        whitelistMinted += 1;\n\n        _safeMint(msg.sender, amount);\n    }\n\n    function setMaxBatchSize (uint256 val) external onlyOwner {\n        maxBatchSize = val;\n        _maxPerTransaction = val;\n    }\n\n    function cashout() external onlyOwner {\n        payable(_team).transfer(address(this).balance);\n    }\n\n    function setCashout(address addr) external onlyOwner returns(address) {\n        _team = addr;\n        return addr;\n    }\n\n    function devMint(uint32 qty) external onlyOwner {\n        _safeMint(msg.sender, qty);\n    }\n\n    function setMerkleRoot(bytes32 root) external onlyOwner {\n        merkleRoot = root;\n    }\n\n    function setMaxMint(uint256 maxMint) external onlyOwner {\n        _maxMint = maxMint;\n    }\n\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n        _tokenURI = baseURI;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return _tokenURI;\n    }\n}",
    "function_sum": 24,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2022-12-22\n*/\n// SPDX-License-Identifier: MIT\n// /ReentrancyGuard.sol\n\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// /Strings.sol\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// /Context.sol\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// /Ownable.sol\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// /Address.sol\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        return account.code.length > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// /IERC721Receiver.sol\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// /IERC165.sol\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// /ERC165.sol\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\n\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// /IERC721.sol\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// /IERC721Metadata.sol\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n// /IERC721Enumerable.sol\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\n\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// /ERC721A.sol\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.\n *\n * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).\n *\n * Assumes the number of issuable tokens (collection size) is capped and fits in a uint128.\n *\n * Does not support burning tokens to address(0).\n */\n\ncontract ERC721A is\n  Context,\n  ERC165,\n  IERC721,\n  IERC721Metadata,\n  IERC721Enumerable\n{\n  using Address for address;\n  using Strings for uint256;\n\n  struct TokenOwnership {\n    address addr;\n    uint64 startTimestamp;\n  }\n\n  struct AddressData {\n    uint128 balance;\n    uint128 numberMinted;\n  }\n\n  uint256 private currentIndex = 0;\n\n  uint256 collectionSize;\n  uint256 maxBatchSize;\n\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Mapping from token ID to ownership details\n  // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n  mapping(uint256 => TokenOwnership) private _ownerships;\n\n  // Mapping owner address to address data\n  mapping(address => AddressData) private _addressData;\n\n  // Mapping from token ID to approved address\n  mapping(uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to operator approvals\n  mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n  /**\n   * @dev\n   * `maxBatchSize` refers to how much a minter can mint at a time.\n   * `collectionSize_` refers to how many tokens are in the collection.\n   */\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint256 maxBatchSize_,\n    uint256 collectionSize_\n  ) {\n    require(\n      collectionSize_ > 0,\n      \"ERC721A: collection must have a nonzero supply\"\n    );\n    require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n    _name = name_;\n    _symbol = symbol_;\n    maxBatchSize = maxBatchSize_;\n    collectionSize = collectionSize_;\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-totalSupply}.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return currentIndex;\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenByIndex}.\n   */\n  function tokenByIndex(uint256 index) public view override returns (uint256) {\n    require(index < totalSupply(), \"ERC721A: global index out of bounds\");\n    return index;\n  }\n\n  /**\n   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n   * This read function is O(collectionSize). If calling from a separate contract, be sure to test gas first.\n   * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\n    uint256 numMintedSoFar = totalSupply();\n    uint256 tokenIdsIdx = 0;\n    address currOwnershipAddr = address(0);\n    for (uint256 i = 0; i < numMintedSoFar; i++) {\n      TokenOwnership memory ownership = _ownerships[i];\n      if (ownership.addr != address(0)) {\n        currOwnershipAddr = ownership.addr;\n      }\n      if (currOwnershipAddr == owner) {\n        if (tokenIdsIdx == index) {\n          return i;\n        }\n        tokenIdsIdx++;\n      }\n    }\n    revert(\"ERC721A: unable to get token of owner by index\");\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      interfaceId == type(IERC721).interfaceId ||\n      interfaceId == type(IERC721Metadata).interfaceId ||\n      interfaceId == type(IERC721Enumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev See {IERC721-balanceOf}.\n   */\n  function balanceOf(address owner) public view override returns (uint256) {\n    require(owner != address(0), \"ERC721A: balance query for the zero address\");\n    return uint256(_addressData[owner].balance);\n  }\n\n  function _numberMinted(address owner) internal view returns (uint256) {\n    require(\n      owner != address(0),\n      \"ERC721A: number minted query for the zero address\"\n    );\n    return uint256(_addressData[owner].numberMinted);\n  }\n\n  function ownershipOf(uint256 tokenId)\n    internal\n    view\n    returns (TokenOwnership memory)\n  {\n    require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\n\n    uint256 lowestTokenToCheck;\n    if (tokenId >= maxBatchSize) {\n      lowestTokenToCheck = tokenId - maxBatchSize + 1;\n    }\n\n    for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\n      TokenOwnership memory ownership = _ownerships[curr];\n      if (ownership.addr != address(0)) {\n        return ownership;\n      }\n    }\n\n    revert(\"ERC721A: unable to determine the owner of token\");\n  }\n\n  /**\n   * @dev See {IERC721-ownerOf}.\n   */\n  function ownerOf(uint256 tokenId) public view override returns (address) {\n    return ownershipOf(tokenId).addr;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-name}.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-symbol}.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev See {IERC721Metadata-tokenURI}.\n   */\n  function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n  {\n    require(\n      _exists(tokenId),\n      \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory baseURI = _baseURI();\n    return\n      bytes(baseURI).length > 0\n        ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\"))\n        : \"\";\n  }\n\n  /**\n   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n   * by default, can be overriden in child contracts.\n   */\n  function _baseURI() internal view virtual returns (string memory) {\n    return \"\";\n  }\n\n  /**\n   * @dev See {IERC721-approve}.\n   */\n  function approve(address to, uint256 tokenId) public override {\n    address owner = ERC721A.ownerOf(tokenId);\n    require(to != owner, \"ERC721A: approval to current owner\");\n\n    require(\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n      \"ERC721A: approve caller is not owner nor approved for all\"\n    );\n\n    _approve(to, tokenId, owner);\n  }\n\n  /**\n   * @dev See {IERC721-getApproved}.\n   */\n  function getApproved(uint256 tokenId) public view override returns (address) {\n    require(_exists(tokenId), \"ERC721A: approved query for nonexistent token\");\n\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev See {IERC721-setApprovalForAll}.\n   */\n  function setApprovalForAll(address operator, bool approved) public override {\n    require(operator != _msgSender(), \"ERC721A: approve to caller\");\n\n    _operatorApprovals[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }\n\n  /**\n   * @dev See {IERC721-isApprovedForAll}.\n   */\n  function isApprovedForAll(address owner, address operator)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev See {IERC721-transferFrom}.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public override {\n    _transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) public override {\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev See {IERC721-safeTransferFrom}.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) public override {\n    _transfer(from, to, tokenId);\n    require(\n      _checkOnERC721Received(from, to, tokenId, _data),\n      \"ERC721A: transfer to non ERC721Receiver implementer\"\n    );\n  }\n\n  /**\n   * @dev Returns whether `tokenId` exists.\n   *\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n   *\n   * Tokens start existing when they are minted (`_mint`),\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return tokenId < currentIndex;\n  }\n\n  function _safeMint(address to, uint256 quantity) internal {\n    _safeMint(to, quantity, \"\");\n  }\n\n  /**\n   * @dev Mints `quantity` tokens and transfers them to `to`.\n   *\n   * Requirements:\n   *\n   * - there must be `quantity` tokens remaining unminted in the total collection.\n   * - `to` cannot be the zero address.\n   * - `quantity` cannot be larger than the max batch size.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _safeMint(\n    address to,\n    uint256 quantity,\n    bytes memory _data\n  ) internal {\n    uint256 startTokenId = currentIndex;\n    require(to != address(0), \"ERC721A: mint to the zero address\");\n    // We know if the first token in the batch doesn't exist, the other ones don't as well, because of serial ordering.\n    require(!_exists(startTokenId), \"ERC721A: token already minted\");\n    // require(quantity <= maxBatchSize, \"ERC721A: quantity to mint too high\");\n\n    _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n    AddressData memory addressData = _addressData[to];\n    _addressData[to] = AddressData(\n      addressData.balance + uint128(quantity),\n      addressData.numberMinted + uint128(quantity)\n    );\n    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\n\n    uint256 updatedIndex = startTokenId;\n\n    for (uint256 i = 0; i < quantity; i++) {\n      emit Transfer(address(0), to, updatedIndex);\n      require(\n        _checkOnERC721Received(address(0), to, updatedIndex, _data),\n        \"ERC721A: transfer to non ERC721Receiver implementer\"\n      );\n      updatedIndex++;\n    }\n\n    currentIndex = updatedIndex;\n    _afterTokenTransfers(address(0), to, startTokenId, quantity);\n  }\n\n  /**\n   * @dev Transfers `tokenId` from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _transfer(\n    address from,\n    address to,\n    uint256 tokenId\n  ) private {\n    TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n    bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n      getApproved(tokenId) == _msgSender() ||\n      isApprovedForAll(prevOwnership.addr, _msgSender()));\n\n    require(\n      isApprovedOrOwner,\n      \"ERC721A: transfer caller is not owner nor approved\"\n    );\n\n    require(\n      prevOwnership.addr == from,\n      \"ERC721A: transfer from incorrect owner\"\n    );\n    require(to != address(0), \"ERC721A: transfer to the zero address\");\n\n    _beforeTokenTransfers(from, to, tokenId, 1);\n\n    // Clear approvals from the previous owner\n    _approve(address(0), tokenId, prevOwnership.addr);\n\n    _addressData[from].balance -= 1;\n    _addressData[to].balance += 1;\n    _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));\n\n    // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n    // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n    uint256 nextTokenId = tokenId + 1;\n    if (_ownerships[nextTokenId].addr == address(0)) {\n      if (_exists(nextTokenId)) {\n        _ownerships[nextTokenId] = TokenOwnership(\n          prevOwnership.addr,\n          prevOwnership.startTimestamp\n        );\n      }\n    }\n\n    emit Transfer(from, to, tokenId);\n    _afterTokenTransfers(from, to, tokenId, 1);\n  }\n\n  /**\n   * @dev Approve `to` to operate on `tokenId`\n   *\n   * Emits a {Approval} event.\n   */\n  function _approve(\n    address to,\n    uint256 tokenId,\n    address owner\n  ) private {\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  uint256 public nextOwnerToExplicitlySet = 0;\n\n  /**\n   * @dev Explicitly set `owners` to eliminate loops in future calls of ownerOf().\n   */\n  function _setOwnersExplicit(uint256 quantity) internal {\n    uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;\n    require(quantity > 0, \"quantity must be nonzero\");\n    uint256 endIndex = oldNextOwnerToSet + quantity - 1;\n    if (endIndex > collectionSize - 1) {\n      endIndex = collectionSize - 1;\n    }\n    // We know if the last one in the group exists, all in the group exist, due to serial ordering.\n    require(_exists(endIndex), \"not enough minted yet for this cleanup\");\n    for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {\n      if (_ownerships[i].addr == address(0)) {\n        TokenOwnership memory ownership = ownershipOf(i);\n        _ownerships[i] = TokenOwnership(\n          ownership.addr,\n          ownership.startTimestamp\n        );\n      }\n    }\n    nextOwnerToExplicitlySet = endIndex + 1;\n  }\n\n  /**\n   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n   * The call is not executed if the target address is not a contract.\n   *\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return bool whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (to.isContract()) {\n      try\n        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\n      returns (bytes4 retval) {\n        return retval == IERC721Receiver(to).onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721A: transfer to non ERC721Receiver implementer\");\n        } else {\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.\n   *\n   * startTokenId - the first token id to be transferred\n   * quantity - the amount to be transferred\n   *\n   * Calling conditions:\n   *\n   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n   * transferred to `to`.\n   * - When `from` is zero, `tokenId` will be minted for `to`.\n   */\n  function _beforeTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes\n   * minting.\n   *\n   * startTokenId - the first token id to be transferred\n   * quantity - the amount to be transferred\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero.\n   * - `from` and `to` are never both zero.\n   */\n  function _afterTokenTransfers(\n    address from,\n    address to,\n    uint256 startTokenId,\n    uint256 quantity\n  ) internal virtual {}\n}\n\n// /MerkleProof.sol\n\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n\n\n\n// You task is to complete the smart contract MiniGrandeBySSC strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title MiniGrandeBySSC\n * @notice This contract is an NFT minting contract that supports both public and whitelist mints. It includes functionalities for setting prices, pausing the contract, and managing the whitelist.\n * @dev The contract inherits from Ownable, ERC721A, and ReentrancyGuard. It uses a Merkle tree for whitelist verification and allows for different minting phases (presale and public sale).\n */\ncontract MiniGrandeBySSC is Ownable, ERC721A, ReentrancyGuard {\n\n    uint256 private _publicPrice = 0.007 ether;\n    uint256 private _presalePrice = 0 ether;\n    uint256 private _maxPurchaseDuringWhitelist = 1;\n    uint256 private _maxPurchaseDuringSale = 1;\n    uint256 private _maxPerTransaction = 1;\n    uint256 private _maxMint = 2000;\n    address private _team = 0x6FEf5A781A35d158096736dBc561F298ef47B86c;\n    bytes32 public merkleRoot = 0x8daf3296866531d8a9a23e382da52d37f29af1f17e5e9ed8a403c896de82be5f;\n    mapping(address => uint256) public presaleAddressMintCount;\n    mapping(address => uint256) public saleAddressMintCount;\n    uint32 public whitelistMinted = 0;\n    uint32 private _maxWhitelistMints = 200;\n\n    bool public isPaused = false;\n    bool public isPublicMint = false;\n    bool public isWhitelistMint = false;\n    string private _tokenURI = \"ipfs://QmZzPHpPmtBHACKpu4MQ6XH2mNXJcJgRhdv1KYpnHqQ6q9/\";\n\n    /**\n     * @notice Initializes the contract with the specified name, symbol, and minting parameters.\n     * @dev This function sets up the initial state of the contract and is called only once during deployment.\n     */\n    constructor() ERC721A(\"MiniGrandeBySecretSocietyClub\", \"MINIBYSSC\", _maxPerTransaction, _maxMint) {}\n\n    /**\n     * @notice Sets the maximum number of whitelist mints.\n     * @dev Only the contract owner can call this function.\n     * @param val The new maximum number of whitelist mints.\n     */\n    function setMaxWhitelistMints (uint32 val) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the maximum number of mints per wallet during the whitelist phase.\n     * @dev Only the contract owner can call this function.\n     * @param val The new maximum number of mints per wallet during the whitelist phase.\n     */\n    function setMaxMintPerWalletWhitelist (uint256 val) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the maximum number of mints per wallet during the public sale phase.\n     * @dev Only the contract owner can call this function.\n     * @param val The new maximum number of mints per wallet during the public sale phase.\n     */\n    function setMaxMintPerWalletSale (uint256 val) external onlyOwner {\n    }\n\n    /**\n     * @notice Checks if the public mint is currently active.\n     * @dev This function returns a boolean indicating whether the public mint is active.\n     * @return A boolean indicating whether the public mint is active.\n     */\n    function checkIsPublicMint () external view returns (bool) {\n    }\n\n    /**\n     * @notice Pauses the contract, preventing further mints.\n     * @dev Only the contract owner can call this function.\n     */\n    function pause() external onlyOwner {\n    }\n\n    /**\n     * @notice Unpauses the contract, allowing mints to resume.\n     * @dev Only the contract owner can call this function.\n     */\n    function unpause() external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the team's address for cashout.\n     * @dev Only the contract owner can call this function.\n     * @param team The new team's address.\n     */\n    function setTeam(address team) external onlyOwner {\n    }\n\n    /**\n     * @notice Gets the current public mint price.\n     * @dev This function returns the current public mint price.\n     * @return The current public mint price.\n     */\n    function getPublicPrice() external view returns(uint256) {\n    }\n\n    /**\n     * @notice Sets the public mint status.\n     * @dev Only the contract owner can call this function.\n     * @param value The new public mint status.\n     */\n    function setPublicMint (bool value) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the whitelist mint status.\n     * @dev Only the contract owner can call this function.\n     * @param value The new whitelist mint status.\n     */\n    function setWhitelistMint (bool value) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the presale mint price.\n     * @dev Only the contract owner can call this function.\n     * @param price The new presale mint price.\n     */\n    function setPresalePrice (uint256 price) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the public mint price.\n     * @dev Only the contract owner can call this function.\n     * @param price The new public mint price.\n     */\n    function setPublicPrice (uint256 price) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the collection size.\n     * @dev Only the contract owner can call this function.\n     * @param size The new collection size.\n     */\n    function setCollectionSize (uint256 size) external onlyOwner {\n    }\n\n    /**\n     * @notice A modifier to guard against invalid mint conditions.\n     * @dev This modifier checks for various conditions such as paused state, transaction limits, and sufficient funds.\n     * @param tokenCount The number of tokens to mint.\n     */\n    modifier mintGuard(uint256 tokenCount) {\n        require(!isPaused, \"Paused!\");\n        \n        require(tokenCount > 0 && tokenCount <= _maxPerTransaction, \"Max one per transaction\");\n        require(msg.sender == tx.origin, \"Sender not origin\");\n        // Price check\n        if (isPublicMint) {\n            require(_publicPrice * tokenCount <= msg.value, \"Insufficient funds\");\n        } else {\n            require(_presalePrice * tokenCount <= msg.value, \"Insufficient funds\");\n        }\n        require(totalSupply() + tokenCount <= _maxMint+1, \"Sold out!\");\n        _;\n    }\n\n    /**\n     * @notice Mints tokens during the public sale phase.\n     * @dev This function mints tokens for the caller, ensuring all conditions are met.\n     * @param amount The number of tokens to mint.\n     */\n    function mint(uint256 amount) external payable mintGuard(amount) {\n    }\n\n    /**\n     * @notice Mints tokens during the presale phase.\n     * @dev This function mints tokens for the caller, ensuring they are on the whitelist and all other conditions are met.\n     * @param proof The Merkle proof for the whitelist.\n     * @param amount The number of tokens to mint.\n     */\n    function mintPresale(bytes32[] calldata proof, uint256 amount) external payable mintGuard(amount) {\n    }\n\n    /**\n     * @notice Sets the maximum batch size for minting.\n     * @dev Only the contract owner can call this function.\n     * @param val The new maximum batch size.\n     */\n    function setMaxBatchSize (uint256 val) external onlyOwner {\n    }\n\n    /**\n     * @notice Transfers the contract's balance to the team's address.\n     * @dev Only the contract owner can call this function.\n     */\n    function cashout() external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the team's address for cashout and returns the new address.\n     * @dev Only the contract owner can call this function.\n     * @param addr The new team's address.\n     * @return The new team's address.\n     */\n    function setCashout(address addr) external onlyOwner returns(address) {\n    }\n\n    /**\n     * @notice Mints tokens for the contract owner.\n     * @dev Only the contract owner can call this function.\n     * @param qty The number of tokens to mint.\n     */\n    function devMint(uint32 qty) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the Merkle root for the whitelist.\n     * @dev Only the contract owner can call this function.\n     * @param root The new Merkle root.\n     */\n    function setMerkleRoot(bytes32 root) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the maximum number of tokens that can be minted.\n     * @dev Only the contract owner can call this function.\n     * @param maxMint The new maximum number of tokens.\n     */\n    function setMaxMint(uint256 maxMint) external onlyOwner {\n    }\n\n    /**\n     * @notice Sets the base URI for the token metadata.\n     * @dev Only the contract owner can call this function.\n     * @param baseURI The new base URI.\n     */\n    function setBaseURI(string calldata baseURI) external onlyOwner {\n    }\n\n    /**\n     * @notice Returns the base URI for the token metadata.\n     * @dev This function is used by the ERC721A standard to fetch the base URI.\n     * @return The base URI for the token metadata.\n     */\n    function _baseURI() internal view virtual override returns (string memory) {\n    }\n}\n"
}