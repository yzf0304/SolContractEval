{
    "contract_name": "MintHelper",
    "ground_truth": "contract MintHelper is Ownable {\n   using SafeMath for uint;\n\n    string public name;\n    address public mintableToken;\n    mapping(bytes32 => bool) successfulPayments;\n\n    constructor(address mToken, string memory mName)\n    public\n    {\n      mintableToken = mToken;\n      name = mName;\n    }\n\n    function setMintableToken(address mToken)\n    public onlyOwner\n    returns (bool)\n    {\n      mintableToken = mToken;\n      return true;\n    }\n\n    function paymentSuccessful(bytes32 paymentId) public view returns (bool){\n        return (successfulPayments[paymentId] == true);\n    }\n    \n    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n    public\n    returns (bool)\n    {\n      require(ERC918Interface(mintableToken).mint(nonce, challenge_digest), \"Could not mint token\");\n      return true;\n    }\n\n    //withdraw any eth inside\n    function withdraw()\n    public onlyOwner\n    {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    //send tokens out\n    function send(address _tokenAddr, address dest, uint value)\n    public onlyOwner\n    returns (bool)\n    {\n     return ERC20Interface(_tokenAddr).transfer(dest, value);\n    }\n\n    //batch send tokens\n    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values)\n    public onlyOwner\n    returns (uint256)\n    {\n        require(dests.length > 0, \"Must have more than 1 destination address\");\n        require(values.length >= dests.length, \"Address to Value array size mismatch\");\n        require(successfulPayments[paymentId] != true, \"Payment ID already exists and was successful\");\n\n        uint256 i = 0;\n        while (i < dests.length) {\n           require(ERC20Interface(_tokenAddr).transfer(dests[i], values[i]));\n           i += 1;\n        }\n\n        successfulPayments[paymentId] = true;\n        return (i);\n    }\n}",
    "function_sum": 6,
    "compiler_version": "0.5.10",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract ERC918Interface {\n  function totalSupply() public view returns (uint);\n  function getMiningDifficulty() public view returns (uint);\n  function getMiningTarget() public view returns (uint);\n  function getMiningReward() public view returns (uint);\n  function balanceOf(address tokenOwner) public view returns (uint balance);\n\n  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n\n  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n}\n\n\n\n// You task is to complete the smart contract MintHelper strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.10, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract serves as a helper for minting tokens and managing token transfers. It allows the owner to set a mintable token, proxy minting of tokens, and manage token and ETH withdrawals. The contract also supports batch sending of tokens to multiple addresses.\n * @dev Inherits from OpenZeppelin's Ownable contract for access control. Uses SafeMath for arithmetic operations to prevent overflows/underflows. Implements a mapping to track successful payments by payment ID.\n */\ncontract MintHelper is Ownable {\n   using SafeMath for uint;\n\n    string public name;\n    address public mintableToken;\n    mapping(bytes32 => bool) successfulPayments;\n\n    constructor(address mToken, string memory mName)\n    public\n    {\n      mintableToken = mToken;\n      name = mName;\n    }\n\n    /**\n     * @notice Allows the owner to set the mintable token address.\n     * @dev Only the owner can call this function. Updates the `mintableToken` state variable.\n     * @param mToken The address of the mintable token.\n     * @return A boolean indicating the success of the operation.\n     */\n    function setMintableToken(address mToken)\n    public onlyOwner\n    returns (bool)\n    {}\n\n    /**\n     * @notice Checks if a payment with a given ID was successful.\n     * @dev Uses the `successfulPayments` mapping to check the status of the payment.\n     * @param paymentId The unique identifier for the payment.\n     * @return A boolean indicating whether the payment was successful.\n     */\n    function paymentSuccessful(bytes32 paymentId) public view returns (bool){\n    }\n\n    /**\n     * @notice Proxies the minting of a token using the provided nonce and challenge digest.\n     * @dev Calls the `mint` function on the `mintableToken` contract. Requires that the minting is successful.\n     * @param nonce The nonce used in the minting process.\n     * @param challenge_digest The challenge digest used in the minting process.\n     * @return A boolean indicating the success of the minting operation.\n     */\n    function proxyMint(uint256 nonce, bytes32 challenge_digest )\n    public\n    returns (bool)\n    {}\n\n    /**\n     * @notice Allows the owner to withdraw any ETH held by the contract.\n     * @dev Only the owner can call this function. Transfers the entire balance of the contract to the owner.\n     */\n    function withdraw()\n    public onlyOwner\n    {}\n\n    /**\n     * @notice Sends a specified amount of tokens to a destination address.\n     * @dev Only the owner can call this function. Uses the ERC20 `transfer` function to send tokens.\n     * @param _tokenAddr The address of the ERC20 token to send.\n     * @param dest The destination address to receive the tokens.\n     * @param value The amount of tokens to send.\n     * @return A boolean indicating the success of the transfer.\n     */\n    function send(address _tokenAddr, address dest, uint value)\n    public onlyOwner\n    returns (bool)\n    {}\n\n    /**\n     * @notice Sends tokens to multiple destination addresses in a single transaction.\n     * @dev Only the owner can call this function. Ensures that the payment ID is unique and not already marked as successful. Uses the ERC20 `transfer` function to send tokens to each destination.\n     * @param _tokenAddr The address of the ERC20 token to send.\n     * @param paymentId The unique identifier for the payment.\n     * @param dests An array of destination addresses.\n     * @param values An array of token amounts corresponding to each destination address.\n     * @return The number of successful transfers.\n     */\n    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values)\n    public onlyOwner\n    returns (uint256)\n    {}\n}\n"
}