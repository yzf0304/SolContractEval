{
    "contract_name": "MonethaBuyer",
    "ground_truth": "contract MonethaBuyer {\n  // Store the amount of ETH deposited by each account.\n  mapping (address => uint256) public balances;\n  // Bounty for executing buy.\n  uint256 public buy_bounty;\n  // Bounty for executing withdrawals.\n  uint256 public withdraw_bounty;\n  // Track whether the contract has bought the tokens yet.\n  bool public bought_tokens;\n  // Record ETH value of tokens currently held by contract.\n  uint256 public contract_eth_value;\n  // Emergency kill switch in case a critical bug is found.\n  bool public kill_switch;\n  \n  // SHA3 hash of kill switch password.\n  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;\n  // Earliest time contract is allowed to buy into the crowdsale.\n  uint256 public earliest_buy_time = 1504188000;\n  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n  uint256 public eth_cap = 30000 ether;\n  // The developer address.\n  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;\n  // The crowdsale address.  Settable by the developer.\n  address public sale;\n  // The token address.  Settable by the developer.\n  ERC20 public token;\n  \n  // Allows the developer to set the crowdsale and token addresses.\n  function set_addresses(address _sale, address _token) {\n    // Only allow the developer to set the sale and token addresses.\n    require(msg.sender == developer);\n    // Only allow setting the addresses once.\n    require(sale == 0x0);\n    // Set the crowdsale and token addresses.\n    sale = _sale;\n    token = ERC20(_token);\n  }\n  \n  // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies.\n  function activate_kill_switch(string password) {\n    // Only activate the kill switch if the sender is the developer or the password is correct.\n    require(msg.sender == developer || sha3(password) == password_hash);\n    // Store the claimed bounty in a temporary variable.\n    uint256 claimed_bounty = buy_bounty;\n    // Update bounty prior to sending to prevent recursive call.\n    buy_bounty = 0;\n    // Irreversibly activate the kill switch.\n    kill_switch = true;\n    // Send the caller their bounty for activating the kill switch.\n    msg.sender.transfer(claimed_bounty);\n  }\n  \n  // Withdraws all ETH deposited or tokens purchased by the given user and rewards the caller.\n  function withdraw(address user){\n    // Only allow withdrawals after the contract has had a chance to buy in.\n    require(bought_tokens || now > earliest_buy_time + 1 hours);\n    // Short circuit to save gas if the user doesn't have a balance.\n    if (balances[user] == 0) return;\n    // If the contract failed to buy into the sale, withdraw the user's ETH.\n    if (!bought_tokens) {\n      // Store the user's balance prior to withdrawal in a temporary variable.\n      uint256 eth_to_withdraw = balances[user];\n      // Update the user's balance prior to sending ETH to prevent recursive call.\n      balances[user] = 0;\n      // Return the user's funds.  Throws on failure to prevent loss of funds.\n      user.transfer(eth_to_withdraw);\n    }\n    // Withdraw the user's tokens if the contract has purchased them.\n    else {\n      // Retrieve current token balance of contract.\n      uint256 contract_token_balance = token.balanceOf(address(this));\n      // Disallow token withdrawals if there are no tokens to withdraw.\n      require(contract_token_balance != 0);\n      // Store the user's token balance in a temporary variable.\n      uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;\n      // Update the value of tokens currently held by the contract.\n      contract_eth_value -= balances[user];\n      // Update the user's balance prior to sending to prevent recursive call.\n      balances[user] = 0;\n      // 1% fee if contract successfully bought tokens.\n      uint256 fee = tokens_to_withdraw / 100;\n      // Send the fee to the developer.\n      require(token.transfer(developer, fee));\n      // Send the funds.  Throws on failure to prevent loss of funds.\n      require(token.transfer(user, tokens_to_withdraw - fee));\n    }\n    // Each withdraw call earns 1% of the current withdraw bounty.\n    uint256 claimed_bounty = withdraw_bounty / 100;\n    // Update the withdraw bounty prior to sending to prevent recursive call.\n    withdraw_bounty -= claimed_bounty;\n    // Send the caller their bounty for withdrawing on the user's behalf.\n    msg.sender.transfer(claimed_bounty);\n  }\n  \n  // Allows developer to add ETH to the buy execution bounty.\n  function add_to_buy_bounty() payable {\n    // Only allow the developer to contribute to the buy execution bounty.\n    require(msg.sender == developer);\n    // Update bounty to include received amount.\n    buy_bounty += msg.value;\n  }\n  \n  // Allows developer to add ETH to the withdraw execution bounty.\n  function add_to_withdraw_bounty() payable {\n    // Only allow the developer to contribute to the buy execution bounty.\n    require(msg.sender == developer);\n    // Update bounty to include received amount.\n    withdraw_bounty += msg.value;\n  }\n  \n  // Buys tokens in the crowdsale and rewards the caller, callable by anyone.\n  function claim_bounty(){\n    // Short circuit to save gas if the contract has already bought tokens.\n    if (bought_tokens) return;\n    // Short circuit to save gas if the earliest buy time hasn't been reached.\n    if (now < earliest_buy_time) return;\n    // Short circuit to save gas if kill switch is active.\n    if (kill_switch) return;\n    // Disallow buying in if the developer hasn't set the sale address yet.\n    require(sale != 0x0);\n    // Record that the contract has bought the tokens.\n    bought_tokens = true;\n    // Store the claimed bounty in a temporary variable.\n    uint256 claimed_bounty = buy_bounty;\n    // Update bounty prior to sending to prevent recursive call.\n    buy_bounty = 0;\n    // Record the amount of ETH sent as the contract's current value.\n    contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty);\n    // Transfer all the funds (less the bounties) to the crowdsale address\n    // to buy tokens.  Throws if the crowdsale hasn't started yet or has\n    // already completed, preventing loss of funds.\n    require(sale.call.value(contract_eth_value)());\n    // Send the caller their bounty for buying tokens for the contract.\n    msg.sender.transfer(claimed_bounty);\n  }\n  \n  // Default function.  Called when a user sends ETH to the contract.\n  function () payable {\n    // Disallow deposits if kill switch is active.\n    require(!kill_switch);\n    // Only allow deposits if the contract hasn't already purchased the tokens.\n    require(!bought_tokens);\n    // Only allow deposits that won't exceed the contract's ETH cap.\n    require(this.balance < eth_cap);\n    // Update records of deposited ETH to include the received amount.\n    balances[msg.sender] += msg.value;\n  }\n}",
    "function_sum": 6,
    "compiler_version": "0.4.15",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/*\n\nMonetha Buyer\n========================\n\nBuys Monetha tokens from the crowdsale on your behalf.\nAuthor: /u/Cintix\n\n*/\n// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20\n\ncontract ERC20 {\n  function transfer(address _to, uint256 _value) returns (bool success);\n  function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n\n\n// You task is to complete the smart contract MonethaBuyer strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.15, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title MonethaBuyer\n * @notice A smart contract for managing ETH deposits, purchasing tokens in a crowdsale, and handling withdrawals.\n * @dev This contract includes features like bounties for executing buy and withdrawal actions, an emergency kill switch,\n *      and the ability to set the crowdsale and token addresses. It ensures that funds are only used for their intended purpose\n *      and provides mechanisms for users to withdraw their ETH or tokens.\n */\ncontract MonethaBuyer {\n  // Store the amount of ETH deposited by each account.\n  mapping (address => uint256) public balances;\n  // Bounty for executing buy.\n  uint256 public buy_bounty;\n  // Bounty for executing withdrawals.\n  uint256 public withdraw_bounty;\n  // Track whether the contract has bought the tokens yet.\n  bool public bought_tokens;\n  // Record ETH value of tokens currently held by contract.\n  uint256 public contract_eth_value;\n  // Emergency kill switch in case a critical bug is found.\n  bool public kill_switch;\n  \n  // SHA3 hash of kill switch password.\n  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;\n  // Earliest time contract is allowed to buy into the crowdsale.\n  uint256 public earliest_buy_time = 1504188000;\n  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.\n  uint256 public eth_cap = 30000 ether;\n  // The developer address.\n  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;\n  // The crowdsale address.  Settable by the developer.\n  address public sale;\n  // The token address.  Settable by the developer.\n  ERC20 public token;\n\n  /**\n   * @notice Allows the developer to set the crowdsale and token addresses.\n   * @dev Only the developer can set the addresses, and it can only be done once.\n   * @param _sale The address of the crowdsale.\n   * @param _token The address of the token.\n   */\n  function set_addresses(address _sale, address _token) {}\n\n  /**\n   * @notice Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. Send the caller their bounty for activating the kill switch.\n   * @dev Activates the kill switch, which prevents further buys and sets the bounty to zero.\n   * @param password The password to activate the kill switch.\n   */\n  function activate_kill_switch(string memory password) {}\n\n  /**\n    * @dev Allows the caller to withdraw all ETH or tokens deposited by a specified user, \n    *      with appropriate reward distribution and safety checks.\n    * This function handles two scenarios:\n    * 1. If tokens haven't been purchased yet (or purchase window hasn't passed), \n    *    it refunds the user's deposited ETH.\n    * 2. If tokens have been successfully purchased, it distributes the user's proportional \n    *    share of tokens with a 1% developer fee and updates contract state.\n    * The caller receives a 1% bounty for initiating the withdrawal on behalf of the user.\n    * @param user The address of the user whose funds/tokens are being withdrawn.\n    * @notice The function includes gas optimization techniques:\n    *         - Early return if user has no balance\n    *         - State updates before external calls to prevent reentrancy\n    *         - Temporary variables for intermediate calculations\n    */\n  function withdraw(address user) {}\n\n  /**\n   * @notice Allows the developer to add ETH to the buy execution bounty.\n   * @dev Only the developer can contribute to the buy bounty.\n   */\n  function add_to_buy_bounty() payable {}\n\n  /**\n   * @notice Allows the developer to add ETH to the withdraw execution bounty.\n   * @dev Only the developer can contribute to the withdraw bounty.\n   */\n  function add_to_withdraw_bounty() payable {}\n\n  /**\n    * @dev Claims the contract's token purchase bounty by executing the initial token  purchase.\n    * This function:\n    * 1. Verifies preconditions (tokens not yet purchased, time window valid, kill switch  inactive)\n    * 2. Sets the purchase flag\n    * 3. Transfers ETH to the crowdsale contract\n    * 4. Distributes the claimed bounty to the caller\n    * \n    * @notice Includes gas optimizations through early returns and state updates before    external calls.\n    * /\n  function claim_bounty() {}\n\n  /**\n   * @notice Default function. Called when a user sends ETH to the contract.\n   * @dev Ensures the contract has not already purchased the tokens and that the ETH cap is not exceeded.\n   */\n  function () payable {\n    require(!kill_switch);\n    require(!bought_tokens);\n    require(this.balance < eth_cap);\n    balances[msg.sender] += msg.value;\n  }\n}\n"
}