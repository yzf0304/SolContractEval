{
    "contract_name": "MoonCatKeyVote",
    "ground_truth": "contract MoonCatKeyVote {\n\n    // Should the MoonCatRescue developers destroy their private key so that no future Genesis MoonCats can ever be released?\n    // true  = Yes\n    // false = No\n\n    event VoteSubmitted(address voter, bool vote);\n\n    uint public voteStartTime = 0;\n    bool public voteCancelled = false;\n    mapping (address => bool) public hasVoted;\n    uint32 public yesVotes = 0;\n    uint32 public noVotes = 0;\n\n    //bytes32 public immutable voterRollSha256;\n    bytes32 public immutable merkleRoot;\n    address public immutable owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Owner Only\");\n        _;\n    }\n\n    modifier voteContractIsPending {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime == 0, \"Vote Already Started\");\n        _;\n    }\n\n    modifier voteContractIsActive {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime > 0, \"Vote Not Started\");\n        require(block.timestamp < (voteStartTime + 48 hours), \"Vote Ended\");\n        _;\n    }\n\n    modifier voteContractIsComplete {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime > 0, \"Vote Not Started\");\n        require(block.timestamp > (voteStartTime + 48 hours), \"Vote Not Ended\");\n        _;\n    }\n\n    constructor(bytes32 merkleRoot_) {\n        merkleRoot = merkleRoot_;\n        owner = msg.sender;\n    }\n\n    function startVote() public onlyOwner voteContractIsPending  {\n        voteStartTime = block.timestamp;\n    }\n\n    function cancelVote() public onlyOwner voteContractIsPending {\n        voteCancelled = true;\n    }\n\n    function getResult() public view voteContractIsComplete returns (bool) {\n        return (yesVotes > noVotes);\n    }\n\n    uint24 empty = 0;\n\n    function submitVote(bytes32[] calldata eligibilityProof, bool vote) public voteContractIsActive  {\n        require(!hasVoted[msg.sender], \"Duplicate Vote\");\n\n        // https://github.com/miguelmota/merkletreejs-solidity/blob/master/contracts/MerkleProof.sol\n        bytes32 computedHash = keccak256(abi.encodePacked(msg.sender));\n        for (uint256 i = 0; i < eligibilityProof.length; i++) {\n            bytes32 proofElement = eligibilityProof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n\n        require(computedHash == merkleRoot, \"Ineligible Voter\");\n\n        hasVoted[msg.sender] = true;\n\n        if(vote){\n            yesVotes++;\n        } else {\n            noVotes++;\n        }\n\n        emit VoteSubmitted(msg.sender, vote);\n\n    }\n}",
    "function_sum": 4,
    "compiler_version": "0.8.1",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n\n\n// You task is to complete the smart contract MoonCatKeyVote strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.1, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title MoonCatKeyVote\n * @notice This contract allows for a community vote to decide whether the MoonCatRescue developers should destroy their private key, preventing the release of future Genesis MoonCats.\n * @dev The contract uses a Merkle tree to verify voter eligibility. The vote is open for 48 hours once started and can be cancelled by the owner before it starts.\n */\ncontract MoonCatKeyVote {\n\n    // Should the MoonCatRescue developers destroy their private key so that no future Genesis MoonCats can ever be released?\n    // true  = Yes\n    // false = No\n\n    event VoteSubmitted(address voter, bool vote);\n\n    uint public voteStartTime = 0;\n    bool public voteCancelled = false;\n    mapping (address => bool) public hasVoted;\n    uint32 public yesVotes = 0;\n    uint32 public noVotes = 0;\n\n    //bytes32 public immutable voterRollSha256;\n    bytes32 public immutable merkleRoot;\n    address public immutable owner;\n\n    /**\n     * @dev Modifier to restrict function access to the contract owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Owner Only\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the vote is pending and not yet started or cancelled.\n     */\n    modifier voteContractIsPending {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime == 0, \"Vote Already Started\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the vote is active and within the 48-hour voting period.\n     */\n    modifier voteContractIsActive {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime > 0, \"Vote Not Started\");\n        require(block.timestamp < (voteStartTime + 48 hours), \"Vote Ended\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to ensure the vote is complete and the 48-hour voting period has ended.\n     */\n    modifier voteContractIsComplete {\n        require(!voteCancelled, \"Vote Contract Cancelled\");\n        require(voteStartTime > 0, \"Vote Not Started\");\n        require(block.timestamp > (voteStartTime + 48 hours), \"Vote Not Ended\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract with the provided Merkle root and sets the owner.\n     * @param merkleRoot_ The Merkle root used to verify voter eligibility.\n     */\n    constructor(bytes32 merkleRoot_) {\n        merkleRoot = merkleRoot_;\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Starts the vote, setting the start time to the current block timestamp.\n     * @dev Can only be called by the contract owner and when the vote is pending.\n     */\n    function startVote() public onlyOwner voteContractIsPending  {}\n\n    /**\n     * @notice Cancels the vote, setting the `voteCancelled` flag to true.\n     * @dev Can only be called by the contract owner and when the vote is pending.\n     */\n    function cancelVote() public onlyOwner voteContractIsPending {}\n\n    /**\n     * @notice Returns the result of the vote, indicating whether the \"Yes\" votes outnumber the \"No\" votes.\n     * @dev Can only be called after the vote has ended.\n     * @return bool True if \"Yes\" votes are greater than \"No\" votes, otherwise false.\n     */\n    function getResult() public view voteContractIsComplete returns (bool) {}\n\n    uint24 empty = 0;\n\n    /**\n    * @dev Submits a vote to the contract after verifying voter eligibility through Merkleproof.\n    * This function:\n    * 1. Checks if the voter has already voted (prevents duplicate votes)\n    * 2. Verifies voter eligibility using a Merkle proof\n    * 3. Records the vote (yes/no) and updates vote counts\n    * 4. Emits an event to log the submission\n    * \n    * @param eligibilityProof The Merkle proof array used to verify voter eligibility\n    * @param vote The vote being submitted (true for yes, false for no)\n    * @notice The Merkle proof verification follows standard techniques:\n    *         - Computes a hash chain from the voter's address and proof elements\n    *         - Compares the final hash with the stored merkleRoot\n    */\n    function submitVote(bytes32[] calldata eligibilityProof, bool vote) public voteContractIsActive  {}\n}\n"
}