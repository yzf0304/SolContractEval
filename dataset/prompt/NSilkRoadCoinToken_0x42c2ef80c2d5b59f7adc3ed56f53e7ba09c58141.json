{
    "contract_name": "standardToken",
    "ground_truth": "contract standardToken is ERC20Token, limitedFactor {\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowances;\n\n\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n\n        return balances[_owner];\n\n    }\n\n\n\n    /* Transfers tokens from your address to other */\n\n    function transfer(address _to, uint256 _value) public FoundationAccountNeedFreezeOneYear(msg.sender) returns (bool success) {\n\n        require (balances[msg.sender] >= _value);           // Throw if sender has insufficient balance\n\n        require (balances[_to] + _value >= balances[_to]);  // Throw if owerflow detected\n\n        balances[msg.sender] -= _value;                     // Deduct senders balance\n\n        balances[_to] += _value;                            // Add recivers blaance\n\n        Transfer(msg.sender, _to, _value);                  // Raise Transfer event\n\n        return true;\n\n    }\n\n\n\n    /* Approve other address to spend tokens on your account */\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n\n        require(balances[msg.sender] >= _value);\n\n        allowances[msg.sender][_spender] = _value;          // Set allowance\n\n        Approval(msg.sender, _spender, _value);             // Raise Approval event\n\n        return true;\n\n    }\n\n\n\n    /* Approve and then communicate the approved contract in a single tx */\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n\n        tokenRecipient spender = tokenRecipient(_spender);              // Cast spender to tokenRecipient contract\n\n        approve(_spender, _value);                                      // Set approval to contract for _value\n\n        spender.receiveApproval(msg.sender, _value, this, _extraData);  // Raise method on _spender contract\n\n        return true;\n\n    }\n\n\n\n    /* A contract attempts to get the coins */\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n        require (balances[_from] >= _value);                // Throw if sender does not have enough balance\n\n        require (balances[_to] + _value >= balances[_to]);  // Throw if overflow detected\n\n        require (_value <= allowances[_from][msg.sender]);  // Throw if you do not have allowance\n\n        balances[_from] -= _value;                          // Deduct senders balance\n\n        balances[_to] += _value;                            // Add recipient blaance\n\n        allowances[_from][msg.sender] -= _value;            // Deduct allowance for this address\n\n        Transfer(_from, _to, _value);                       // Raise Transfer event\n\n        return true;\n\n    }\n\n\n\n    /* Get the amount of allowed tokens to spend */\n\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n\n        return allowances[_owner][_spender];\n\n    }\n\n\n\n}",
    "function_sum": 5,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ncontract tokenRecipient {\n\n  function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n\n}\n\ncontract ERC20Token {\n\n    /* This is a slight change to the ERC20 base standard.\n\n    function totalSupply() constant returns (uint256 supply);\n\n    is replaced with:\n\n    uint256 public totalSupply;\n\n    This automatically creates a getter function for the totalSupply.\n\n    This is moved to the base contract since public getter functions are not\n\n    currently recognised as an implementation of the matching abstract\n\n    function by the compiler.\n\n    */\n\n    /// total amount of tokens\n\n    uint256 public totalSupply;\n\n\n\n    /// @param _owner The address from which the balance will be retrieved\n\n    /// @return The balance\n\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n\n    /// @param _from The address of the sender\n\n    /// @param _to The address of the recipient\n\n    /// @param _value The amount of token to be transferred\n\n    /// @return Whether the transfer was successful or not\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @param _value The amount of tokens to be approved for transfer\n\n    /// @return Whether the approval was successful or not\n\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n\n\n    /// @param _owner The address of the account owning tokens\n\n    /// @param _spender The address of the account able to transfer the tokens\n\n    /// @return Amount of remaining tokens allowed to spent\n\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract limitedFactor {\n\n    uint256 public FoundationAddressFreezeTime;\n\n    address public FoundationAddress;\n\n    address public TeamAddress;\n\n    modifier FoundationAccountNeedFreezeOneYear(address _address) {\n\n        if(_address == FoundationAddress) {\n\n            require(now >= FoundationAddressFreezeTime + 1 years);\n\n        }\n\n        _;\n\n    }\n\n\n\n}\n\n\n\n// You task is to complete the smart contract standardToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title StandardToken\n * @dev This contract implements the standard token functionality, including ERC223's transfer and approve functions,\n * as well as an additional approveAndCall function for more advanced use cases. It also includes a modifier to restrict\n * certain actions if the sender is a foundation account.\n */\ncontract standardToken is ERC20Token, limitedFactor {\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowances;\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @param _owner The address to query the balance of.\n     * @return The balance of the specified address.\n     * @dev This function is used to check the balance of a specific address.\n     */\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return balances[_owner];\n    }\n\n    /**\n     * @notice Transfers tokens from the sender's address to another address.\n     * @param _to The recipient address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean value indicating whether the transfer was successful.\n     * @dev This function transfers tokens from the sender's address to another address, checking for sufficient balance and preventing overflow.\n     */\n    function transfer(address _to, uint256 _value) public FoundationAccountNeedFreezeOneYear(msg.sender) returns (bool success) {}\n\n    /**\n     * @notice Approves another address to spend tokens on behalf of the sender.\n     * @param _spender The address that will be allowed to spend the tokens.\n     * @param _value The amount of tokens to approve.\n     * @return A boolean value indicating whether the approval was successful.\n     * @dev This function sets the allowance for a spender and raises an Approval event.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Approves and then calls the recipient contract with the approved amount and extra data.\n     * @param _spender The address of the recipient contract.\n     * @param _value The amount of tokens to approve.\n     * @param _extraData Additional data to pass to the recipient contract.\n     * @return A boolean value indicating whether the operation was successful.\n     * @dev This function approves a spender and then calls a method on the spender contract, passing the approved amount and extra data.\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {}\n\n    /**\n     * @notice Transfers tokens from one address to another, using the allowance mechanism.\n     * @param _from The address to transfer tokens from.\n     * @param _to The address to transfer tokens to.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean value indicating whether the transfer was successful.\n     * @dev This function transfers tokens from one address to another, checking for sufficient balance, allowance, and preventing overflow.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Returns the amount of tokens that an owner has allowed a spender to spend.\n     * @param _owner The address of the token owner.\n     * @param _spender The address of the spender.\n     * @return The remaining allowance for the spender.\n     * @dev This function checks the allowance set by the owner for the spender.\n     */\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\n}\n"
}