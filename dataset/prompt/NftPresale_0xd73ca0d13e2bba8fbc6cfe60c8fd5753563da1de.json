{
    "contract_name": "NftPresale",
    "ground_truth": "contract NftPresale is INftPresale, Ownable {\n\n\tuint public constant START_TIME = 1634929200;\n\tuint public constant FINISH_TIME = 1635015600;\n\tuint public constant PRE_SALE_PRICE = 0.2 ether;\n\n\tINFT public nft;\n\t\n\taddress public verifyAddress = 0x142581fda5769fe7f8d3b50794dBda454DA4F3ac;\n\tmapping(address => bool) public buyers;\n\t\n\taddress payable public receiver;\n\n\tconstructor(address _nftAddress, address payable _receiverAddress) {\n\t\tnft = INFT(_nftAddress);\n\t\t\n\t\t//receiver - 0xD3db8094b50F2F094D164C1131BB9E604dfe0590\n\t\treceiver = _receiverAddress;\n\t}\n\n\t/*\n\t * @dev function to buy tokens. Can be bought only 1. \n\t * @param _amount how much tokens can be bought.\n\t * @param _signature Signed message from verifyAddress private key\n\t */\n\tfunction buy(uint _amount, bytes memory _signature) external override payable {\n\t    require(_amount == 1, \"only 1 token can be bought on presale\");\n\t    require(block.timestamp >= START_TIME && block.timestamp < FINISH_TIME, \"not a presale time\");\n\t\trequire(msg.value == PRE_SALE_PRICE, \"token price 0.2 ETH\");\n\t\trequire(!buyers[msg.sender], \"only one token can be bought on presale\");\n\t\trequire(verify(_signature), \"invalid signature\");\n\t\tbuyers[msg.sender] = true;\n\n\t\tnft.mintBatch(msg.sender, _amount);\n\t\t(bool sent, ) = receiver.call{value: address(this).balance}(\"\");\n        require(sent, \"Something wrong with receiver\");\n\t}\n\t\n\t/*\n\t * @dev function to withdraw all tokens\n\t * @param _to ETH receiver address\n\t */\n\tfunction cashOut(address _to) public onlyOwner {\n        // Call returns a boolean value indicating success or failure.\n        // This is the current recommended method to use.\n        \n        (bool sent, ) = _to.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n\t/// signature methods.\n\tfunction verify(bytes memory _signature) internal view returns(bool) {\n\t\tbytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, address(this))));\n        return (recoverSigner(message, _signature) == verifyAddress);\n\t}\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(sig, (uint8, bytes32, bytes32));\n\n        return ecrecover(message, v, r, s);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}",
    "function_sum": 5,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-10-22\n*/\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface INFT {\n\tfunction mint(address _to) external;\n\tfunction mintBatch(address _to, uint _amount) external;\n}\n\ninterface INftPresale {\n\tfunction buy(uint _amount, bytes memory _signature) external payable;\n}\n\n\n\n// You task is to complete the smart contract NftPresale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title NftPresale\n * @author [Your Name]\n * @notice This contract allows for a presale of NFTs, where users can buy one token each during a specified time window.\n * @dev The contract includes functionality to verify signatures and ensures that only authorized purchases are made. \n * It also supports withdrawing funds by the owner.\n */\ncontract NftPresale is INftPresale, Ownable {\n\n    uint public constant START_TIME = 1634929200;\n    uint public constant FINISH_TIME = 1635015600;\n    uint public constant PRE_SALE_PRICE = 0.2 ether;\n\n    INFT public nft;\n    \n    address public verifyAddress = 0x142581fda5769fe7f8d3b50794dBda454DA4F3ac;\n    mapping(address => bool) public buyers;\n    \n    address payable public receiver;\n\n    /**\n     * @notice Initializes the contract with the NFT contract address and the receiver's address.\n     * @param _nftAddress The address of the NFT contract.\n     * @param _receiverAddress The address to receive the funds from the presale.\n     */\n    constructor(address _nftAddress, address payable _receiverAddress) {\n        nft = INFT(_nftAddress);\n        \n        //receiver - 0xD3db8094b50F2F094D164C1131BB9E604dfe0590\n        receiver = _receiverAddress;\n    }\n\n    /**\n     * @notice Allows a user to buy one NFT during the presale period.\n     * @dev Ensures that the purchase is within the presale time, the correct amount is paid, and the signature is valid.\n     * @param _amount The number of tokens to buy (must be 1).\n     * @param _signature The signed message from the verifyAddress.\n     */\n    function buy(uint _amount, bytes memory _signature) external override payable {}\n\n    /**\n     * @notice Allows the contract owner to withdraw all ETH from the contract.\n     * @dev Only the owner can call this function.\n     * @param _to The address to send the ETH to.\n     */\n    function cashOut(address _to) public onlyOwner {}\n\n    /**\n     * @notice Verifies the signature against the verifyAddress.\n     * @dev Uses the prefixed hash and ecrecover to validate the signature.\n     * @param _signature The signature to verify.\n     * @return bool True if the signature is valid, false otherwise.\n     */\n    function verify(bytes memory _signature) internal view returns(bool) {}\n\n    /**\n     * @notice Recovers the signer from the message and signature.\n     * @dev Decodes the signature and uses ecrecover to find the signer.\n     * @param message The message hash.\n     * @param sig The signature.\n     * @return address The recovered signer.\n     */\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address) {}\n\n    /**\n     * @dev Prepends the Ethereum signed message prefix to a hash and returns the resulting hash.\n     * This function is typically used to prepare a hash for signature verification by adding the\n     * standard Ethereum prefix that indicates the message was signed by an externally owned account (EOA).\n     * The prefix format follows the Ethereum standard:\n     * \"\\x19Ethereum Signed Message:\\n32\" followed by the original hash.\n     * @param hash The original hash value to be prefixed.\n     * @return bytes32 The resulting hash after prepending the Ethereum prefix.\n     * @notice This function is marked as `pure` because it doesn't access any contract state.\n     * @dev The resulting hash is what should be passed to ecrecover for verifying signatures created by externally owned accounts (EOAs) on Ethereum.\n     */\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {}\n}\n"
}