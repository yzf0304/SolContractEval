{
    "contract_name": "Nokon",
    "ground_truth": "contract Nokon is IERC20 {\n\n    string public constant name = \"Nokon\";\n    string public constant symbol = \"NKO\";\n    uint8 public constant decimals = 8;\n\n\n    event Bought(uint256 amountz);\n    event Sold(uint256 amount);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    mapping(address => bool) public authorizedAddress;\n\n    address authAddress = parseAddr('0x44F6827aa307F4d7FAeb64Be47543647B3a871dB');\n    uint256 totalSupply_ = 1200000000000000000;\n    bool presell = true;\n    uint256 ethRateFix = 10000000000;\n\n    using SafeMath for uint256;\n\n    constructor() {\n\n        balances[msg.sender] = totalSupply_;\n        balances[address(this)] = totalSupply_;\n        balances[authAddress] = totalSupply_;\n\n        authorizedAddress[msg.sender] = true;\n        authorizedAddress[authAddress] = true;\n    }\n\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n            iaddr *= 256;\n            b1 = uint160(uint8(tmp[i]));\n            b2 = uint160(uint8(tmp[i + 1]));\n            if ((b1 >= 97) && (b1 <= 102)) {\n                b1 -= 87;\n            } else if ((b1 >= 65) && (b1 <= 70)) {\n                b1 -= 55;\n            } else if ((b1 >= 48) && (b1 <= 57)) {\n                b1 -= 48;\n            }\n            if ((b2 >= 97) && (b2 <= 102)) {\n                b2 -= 87;\n            } else if ((b2 >= 65) && (b2 <= 70)) {\n                b2 -= 55;\n            } else if ((b2 >= 48) && (b2 <= 57)) {\n                b2 -= 48;\n            }\n            iaddr += (b1 * 16 + b2);\n        }\n        return address(iaddr);\n    }\n\n    function toAsciiString(address x) internal view returns (string memory) {\n        bytes memory s = new bytes(40);\n        for (uint i = 0; i < 20; i++) {\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n            bytes1 hi = bytes1(uint8(b) / 16);\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n            s[2 * i] = char(hi);\n            s[2 * i + 1] = char(lo);\n        }\n        return string(s);\n    }\n\n    function char(bytes1 b) internal view returns (bytes1 c) {\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n        else return bytes1(uint8(b) + 0x57);\n    }\n\n    function recover(bytes32 hash, bytes memory signature)\n    internal\n    pure\n    returns (address)\n    {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        if (signature.length != 65) {\n            return (address(0));\n        }\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            // solium-disable-next-line arg-overflow\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n\n    function calculateRate() private returns (uint256){\n        uint256 balance = balanceOf(address(this));\n        if (balance > 100000000000000000)\n            return 666666;\n        if (balance > 50000000000000000)\n            return 333333;\n        return 250000;\n    }\n\n    function totalSupply() public override view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function getRate() public returns (uint256) {\n        return calculateRate();\n    }\n\n    function balanceOf(address tokenOwner) public override view returns (uint256) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint256 numTokens) public override returns (bool)\n    {\n        require(numTokens <= balances[msg.sender], \"transfer error\");\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public override view returns (uint) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {\n        require(numTokens <= balances[owner]);\n        require(numTokens <= allowed[owner][msg.sender]);\n\n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n\n    receive() payable external\n    {\n        buy();\n    }\n\n    function buy() public payable\n    {\n        require(presell, \"presell is closed\");\n        uint256 minBuy = 50000000000000000;\n        uint256 amountToBuy = msg.value / ethRateFix * calculateRate();\n        uint256 dexBalance = balanceOf(address(this));\n        require(msg.value >= minBuy, \"minimum buy is 0.05 eth\");\n\n        require(amountToBuy < dexBalance, \"not enough token in reserve\");\n\n        balances[address(this)] = balances[address(this)] - amountToBuy;\n        balances[msg.sender] = balances[msg.sender] + amountToBuy;\n        emit Transfer(address(this), msg.sender, amountToBuy);\n        emit Bought(amountToBuy);\n    }\n\n    function closePresell(bytes32 hash, bytes memory signature) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        presell = false;\n    }\n\n    function openPresell(bytes32 hash, bytes memory signature) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        presell = true;\n    }\n\n    function getEthBalance(bytes32 hash, bytes memory signature) public returns (uint256)\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        return address(this).balance;\n    }\n\n    function transferEth(bytes32 hash, bytes memory signature,uint256 _amount) public\n    {\n        address senderAddress = recover(hash,signature);\n        require(authorizedAddress[senderAddress], \"you are not authorized for this operation\");\n\n        require(address(this).balance >= _amount, \"insufficient eth balance\");\n\n        address payable wallet = payable(authAddress);\n        wallet.transfer(_amount);\n    }\n\n    function supply() public returns (uint256) {\n        return balanceOf(address(this));\n    }\n\n    function presellStatus() public returns (bool) {\n        return presell;\n    }\n\n    function getAddress() public returns (address) {\n        return address(this);\n    }\n}",
    "function_sum": 20,
    "compiler_version": "0.7.4",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-09-20\n*/\n// SPDX-License-Identifier: GPL-3.0\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n\n    //    event Transfer(address indexed from, address indexed to, uint256 value);\n    //    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary SafeMath {\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n\n\n// You task is to complete the smart contract Nokon strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.7.4, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Nokon Token Contract\n * @author [Your Name]\n * @notice This contract implements the ERC20 standard and includes additional functionalities for presell, buying, and administrative operations.\n * @dev The contract uses SafeMath for arithmetic operations to prevent overflows and underflows.\n */\ncontract Nokon is IERC20 {\n\n    string public constant name = \"Nokon\";\n    string public constant symbol = \"NKO\";\n    uint8 public constant decimals = 8;\n\n    event Bought(uint256 amountz);\n    event Sold(uint256 amount);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n    mapping(address => bool) public authorizedAddress;\n\n    address authAddress = parseAddr('0x44F6827aa307F4d7FAeb64Be47543647B3a871dB');\n    uint256 totalSupply_ = 1200000000000000000;\n    bool presell = true;\n    uint256 ethRateFix = 10000000000;\n\n    using SafeMath for uint256;\n\n    constructor() {\n        balances[msg.sender] = totalSupply_;\n        balances[address(this)] = totalSupply_;\n        balances[authAddress] = totalSupply_;\n\n        authorizedAddress[msg.sender] = true;\n        authorizedAddress[authAddress] = true;\n    }\n\n    /**\n     * @notice Parses a string address into an address type.\n     * @dev This function converts a string representation of an address into an actual address.\n     * @param _a The string representation of the address.\n     * @return _parsedAddress The parsed address.\n     */\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n            iaddr *= 256;\n            b1 = uint160(uint8(tmp[i]));\n            b2 = uint160(uint8(tmp[i + 1]));\n            if ((b1 >= 97) && (b1 <= 102)) {\n                b1 -= 87;\n            } else if ((b1 >= 65) && (b1 <= 70)) {\n                b1 -= 55;\n            } else if ((b1 >= 48) && (b1 <= 57)) {\n                b1 -= 48;\n            }\n            if ((b2 >= 97) && (b2 <= 102)) {\n                b2 -= 87;\n            } else if ((b2 >= 65) && (b2 <= 70)) {\n                b2 -= 55;\n            } else if ((b2 >= 48) && (b2 <= 57)) {\n                b2 -= 48;\n            }\n            iaddr += (b1 * 16 + b2);\n        }\n        return address(iaddr);\n    }\n\n    /**\n     * @notice Converts an address to its ASCII string representation.\n     * @dev This function is used to convert an address to a human-readable string.\n     * @param x The address to convert.\n     * @return The ASCII string representation of the address.\n     */\n    function toAsciiString(address x) internal view returns (string memory) {}\n\n    /**\n     * @notice Converts a byte to its corresponding character.\n     * @dev This helper function is used in the toAsciiString function.\n     * @param b The byte to convert.\n     * @return c The character corresponding to the byte.\n     */\n    function char(bytes1 b) internal view returns (bytes1 c) {}\n\n    /**\n     * @dev Recovers the signer address from a hash and signature.\n     * This function\n     * 1. Validates the signature length (must be 65 bytes)\n     * 2. Extracts the r, s, and v components from the signature\n     * 3. Adjusts the v value if needed (converts 0/1 to 27/28)\n     * 4. Uses ecrecover to get the signer address\n     * @param hash The hash that was signed\n     * @param signature The signature bytes (must be 65 bytes)\n     * @return address The recovered signer address, or address(0) if invalid\n     * @notice The function performs basic signature validation:\n     *         - Rejects signatures that aren't 65 bytes\n     *         - Rejects invalid v values (must be 27 or 28)\n     *         - Returns address(0) for any validation failure\n     * @dev Uses inline assembly for efficient signature component extraction.\n     *      The v value is adjusted to match Ethereum's expected range (27/28).\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {}\n\n    /**\n     * @dev Calculates a rate based on the contract's token balance.\n     * The rate decreases as the balance increases, with specific thresholds:\n     * - > 1.0 tokens \u2192 rate = 666,666\n     * - > 0.5 tokens \u2192 rate = 333,333\n     * - Otherwise \u2192 rate = 250,000\n     * @return uint256 The calculated rate value\n     */\n    function calculateRate() private returns (uint256) {}\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @dev This function overrides the IERC20 interface.\n     * @return The total supply of the token.\n     */\n    function totalSupply() public override view returns (uint256) {}\n\n    /**\n     * @notice Returns the current rate for buying tokens.\n     * @dev This function calls the calculateRate function.\n     * @return The current rate.\n     */\n    function getRate() public returns (uint256) {}\n\n    /**\n     * @notice Returns the balance of a specific token owner.\n     * @dev This function overrides the IERC20 interface.\n     * @param tokenOwner The address of the token owner.\n     * @return The balance of the token owner.\n     */\n    function balanceOf(address tokenOwner) public override view returns (uint256) {}\n\n    /**\n     * @notice Transfers a specified number of tokens to a receiver.\n     * @dev This function overrides the IERC20 interface.\n     * @param receiver The address of the receiver.\n     * @param numTokens The number of tokens to transfer.\n     * @return A boolean indicating the success of the transfer.\n     */\n    function transfer(address receiver, uint256 numTokens) public override returns (bool) {}\n\n    /**\n     * @notice Approves a delegate to spend a specified number of tokens on behalf of the sender.\n     * @dev This function overrides the IERC20 interface.\n     * @param delegate The address of the delegate.\n     * @param numTokens The number of tokens to approve.\n     * @return A boolean indicating the success of the approval.\n     */\n    function approve(address delegate, uint256 numTokens) public override returns (bool) {}\n\n    /**\n     * @notice Returns the number of tokens that a delegate is allowed to spend on behalf of an owner.\n     * @dev This function overrides the IERC20 interface.\n     * @param owner The address of the token owner.\n     * @param delegate The address of the delegate.\n     * @return The allowance amount.\n     */\n    function allowance(address owner, address delegate) public override view returns (uint) {}\n\n    /**\n     * @notice Transfers a specified number of tokens from one address to another.\n     * @dev This function overrides the IERC20 interface.\n     * @param owner The address of the token owner.\n     * @param buyer The address of the buyer.\n     * @param numTokens The number of tokens to transfer.\n     * @return A boolean indicating the success of the transfer.\n     */\n    function transferFrom(address owner, address buyer, uint256 numTokens) public override returns (bool) {}\n\n    receive() payable external {\n        buy();\n    }\n\n    /**\n     * @dev Allows token purchase during presale.\n     * Requirements\n     * - Presale active (presell = true)\n     * - msg.value \u2265 0.05 ETH (50000000000000000 wei)\n     * - Sufficient contract token balance\n     * Logic\n     * 1. amountToBuy = (msg.value / ethRateFix) * calculateRate()\n     * 2. Verify msg.value \u2265 0.05 ETH\n     * 3. Verify amountToBuy < contract balance\n     * 4. Transfer tokens to buyer\n     * @notice Emits Transfer and Bought events\n     * @dev Tokens deducted from contract, added to buyer\n     */\n    function buy() public payable {}\n\n    /**\n     * @notice Closes the presell period.\n     * @dev This function can only be called by an authorized address.\n     * @param hash The message hash.\n     * @param signature The signature of the message.\n     */\n    function closePresell(bytes32 hash, bytes memory signature) public {}\n\n    /**\n     * @notice Opens the presell period.\n     * @dev This function can only be called by an authorized address.\n     * @param hash The message hash.\n     * @param signature The signature of the message.\n     */\n    function openPresell(bytes32 hash, bytes memory signature) public {}\n\n    /**\n     * @notice Returns the current Ether balance of the contract.\n     * @dev This function can only be called by an authorized address.\n     * @param hash The message hash.\n     * @param signature The signature of the message.\n     * @return The Ether balance of the contract.\n     */\n    function getEthBalance(bytes32 hash, bytes memory signature) public returns (uint256) {}\n\n    /**\n     * @notice Transfers a specified amount of Ether to the authorized address.\n     * @dev This function can only be called by an authorized address.\n     * @param hash The message hash.\n     * @param signature The signature of the message.\n     * @param _amount The amount of Ether to transfer.\n     */\n    function transferEth(bytes32 hash, bytes memory signature, uint256 _amount) public {}\n\n    /**\n     * @notice Returns the current supply of tokens in the contract.\n     * @return The current supply of tokens.\n     */\n    function supply() public returns (uint256) {}\n\n    /**\n     * @notice Returns the current status of the presell period.\n     * @return A boolean indicating whether the presell period is open or closed.\n     */\n    function presellStatus() public returns (bool) {}\n\n    /**\n     * @notice Returns the address of the contract.\n     * @return The address of the contract.\n     */\n    function getAddress() public returns (address) {}\n}\n"
}