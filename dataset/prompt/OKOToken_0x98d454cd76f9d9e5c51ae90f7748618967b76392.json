{
    "contract_name": "StandardToken",
    "ground_truth": "contract StandardToken is SafeMath {\n\n\n\n  uint256 public totalSupply;\n\n\n\n  /* Actual balances of token holders */\n\n  mapping(address => uint) balances;\n\n\n\n  /* approve() allowances */\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n\n   *\n\n   * Fix for the ERC20 short address attack\n\n   *\n\n   * http://vessenes.com/the-erc20-short-address-attack-explained/\n\n   */\n\n  modifier onlyPayloadSize(uint256 size) {\n\n     require(msg.data.length == size + 4);\n\n     _;\n\n  }\n\n\n\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {\n\n    require(_to != 0);\n\n    uint256 balanceFrom = balances[msg.sender];\n\n    require(_value <= balanceFrom);\n\n\n\n    // SafeMath safeSub will throw if there is not enough balance.\n\n    balances[msg.sender] = safeSub(balanceFrom, _value);\n\n    balances[_to] = safeAdd(balances[_to], _value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n    require(_to != 0);\n\n    uint256 allowToTrans = allowed[_from][msg.sender];\n\n    uint256 balanceFrom = balances[_from];\n\n    require(_value <= balanceFrom);\n\n    require(_value <= allowToTrans);\n\n\n\n    balances[_to] = safeAdd(balances[_to], _value);\n\n    balances[_from] = safeSub(balanceFrom, _value);\n\n    allowed[_from][msg.sender] = safeSub(allowToTrans, _value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n  function approve(address _spender, uint256 _value) public returns (bool success) {\n\n\n\n    // To change the approve amount you first have to reduce the addresses`\n\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n    //  already 0 to mitigate the race condition described here:\n\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n//    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    // require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  /**\n\n   * Atomic increment of approved spending\n\n   *\n\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   *\n\n   */\n\n  function addApproval(address _spender, uint256 _addedValue)\n\n  onlyPayloadSize(2 * 32)\n\n  public returns (bool success) {\n\n      uint256 oldValue = allowed[msg.sender][_spender];\n\n      allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue);\n\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n      return true;\n\n  }\n\n\n\n  /**\n\n   * Atomic decrement of approved spending.\n\n   *\n\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   */\n\n  function subApproval(address _spender, uint256 _subtractedValue)\n\n  onlyPayloadSize(2 * 32)\n\n  public returns (bool success) {\n\n\n\n      uint256 oldVal = allowed[msg.sender][_spender];\n\n\n\n      if (_subtractedValue > oldVal) {\n\n          allowed[msg.sender][_spender] = 0;\n\n      } else {\n\n          allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue);\n\n      }\n\n      Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n      return true;\n\n  }\n\n\n\n}",
    "function_sum": 4,
    "compiler_version": "0.4.19",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2017-12-12\n\n*/\n/**\n\n * Math operations with safety checks\n\n */\n\ncontract SafeMath {\n\n\n\n  function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b > 0);\n\n    uint256 c = a / b;\n\n    assert(a == b * c + a % b);\n\n    return c;\n\n  }\n\n\n\n  function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    uint256 c = a + b;\n\n    assert(c >= a && c >= b);\n\n    return c;\n\n  }\n\n\n\n}\n\n\n\n// You task is to complete the smart contract StandardToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.19, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice StandardToken is an implementation of the ERC20 token standard with additional features.\n * @dev This contract includes functions for transferring tokens, checking balances, and managing allowances.\n * It also includes a fix for the ERC223 short address attack and atomic approval increments and decrements.\n */\ncontract StandardToken is SafeMath {\n\n  uint256 public totalSupply;\n\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) allowed;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @notice Modifier to prevent the ERC20 short address attack.\n   * @dev Ensures that the payload size matches the expected size.\n   * @param size The expected size of the payload.\n   */\n  modifier onlyPayloadSize(uint256 size) {\n    require(msg.data.length == size + 4);\n    _;\n  }\n\n  /**\n   * @notice Transfers `_value` tokens from the caller's account to `_to`.\n   * @dev Emits a {Transfer} event and uses the `onlyPayloadSize` modifier to prevent the short address attack.\n   * @param _to The recipient address.\n   * @param _value The amount of tokens to transfer.\n   * @return success A boolean indicating if the transfer was successful.\n   */\n  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {}\n\n  /**\n   * @notice Transfers `_value` tokens from `_from` to `_to` using the allowance mechanism.\n   * @dev Emits a {Transfer} event.\n   * @param _from The address to transfer tokens from.\n   * @param _to The recipient address.\n   * @param _value The amount of tokens to transfer.\n   * @return success A boolean indicating if the transfer was successful.\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n  /**\n   * @notice Returns the balance of the `_owner` address.\n   * @dev Simply returns the balance stored in the `balances` mapping.\n   * @param _owner The address to check the balance of.\n   * @return balance The balance of the `_owner` address.\n   */\n  function balanceOf(address _owner) public view returns (uint256 balance) {}\n\n  /**\n   * @notice Approves `_spender` to spend up to `_value` tokens on behalf of the caller.\n   * @dev Emits an {Approval} event.\n   * @param _spender The address that will be approved to spend tokens.\n   * @param _value The amount of tokens to approve.\n   * @return success A boolean indicating if the approval was successful.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n  /**\n   * @notice Returns the remaining allowance of `_spender` over the caller's tokens.\n   * @dev Simply returns the allowance stored in the `allowed` mapping.\n   * @param _owner The address that gave the allowance.\n   * @param _spender The address that has the allowance.\n   * @return remaining The remaining allowance.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {}\n\n  /**\n   * @notice Atomically increases the allowance granted to `_spender` by `_addedValue`.\n   * @dev Emits an {Approval} event.\n   * @param _spender The address that will have its allowance increased.\n   * @param _addedValue The amount by which to increase the allowance.\n   * @return success A boolean indicating if the operation was successful.\n   */\n  function addApproval(address _spender, uint256 _addedValue) onlyPayloadSize(2 * 32) public returns (bool success) {}\n\n  /**\n   * @notice Atomically decreases the allowance granted to `_spender` by `_subtractedValue`.\n   * @dev Emits an {Approval} event.\n   * @param _spender The address that will have its allowance decreased.\n   * @param _subtractedValue The amount by which to decrease the allowance.\n   * @return success A boolean indicating if the operation was successful.\n   */\n  function subApproval(address _spender, uint256 _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool success) {}\n}\n"
}