{
    "contract_name": "OdinToken",
    "ground_truth": "contract OdinToken is ERC20Interface, Owned {\n\n  using SafeMath for uint256;\n\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint private _totalSupply;\n    bool private _whitelistAll;\n\n    struct balanceData {  \n       bool locked;\n       uint balance;\n       uint airDropQty;\n    }\n\n    mapping(address => balanceData) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n\n  /**\n  * @dev Constructor for Odin creation\n  * @dev Initially assigns the totalSupply to the contract creator\n  */\n    function OdinToken() public {\n        \n        // owner of this contract\n        owner = msg.sender;\n        symbol = \"ODIN\";\n        name = \"ODIN Token\";\n        decimals = 18;\n        _whitelistAll=false;\n        _totalSupply = 100000000000000000000000;\n        balances[owner].balance = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function totalSupply() constant public returns (uint256 totalSupply) {\n        return _totalSupply;\n    }\n\n    // ------------------------------------------------------------------------\n    // whitelist an address\n    // ------------------------------------------------------------------------\n    function whitelistAddress(address to) onlyOwner public  returns (bool)    {\n\t\tbalances[to].airDropQty = 0;\n\t\treturn true;\n    }\n\n\n  /**\n  * @dev Whitelist all addresses early\n  * @return An bool showing if the function succeeded.\n  */\n    function whitelistAllAddresses() onlyOwner public returns (bool) {\n        _whitelistAll = true;\n        return true;\n    }\n\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param tokenOwner The address to query the the balance of.\n  * @return An uint representing the amount owned by the passed address.\n  */\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\n        return balances[tokenOwner].balance;\n    }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param tokens The amount to be transferred.\n  */\n    function transfer(address to, uint tokens) public returns (bool success) {\n\n        require (msg.sender != to);                             // cannot send to yourself\n        require(to != address(0));                              // cannot send to address(0)\n        require(tokens <= balances[msg.sender].balance);        // do you have enough to send?\n        \n        if (!_whitelistAll) {\n\n            // do not allow transfering air dropped tokens prior to Sep 1 2018\n             if (msg.sender != owner && block.timestamp < 1535760000 && balances[msg.sender].airDropQty>0) {\n                 require(tokens < 0);\n            }\n\n            // after Sep 1 2018 and before Dec 31, 2018, do not allow transfering more than 10% of air dropped tokens\n            if (msg.sender != owner && block.timestamp < 1546214400 && balances[msg.sender].airDropQty>0) {\n                require((balances[msg.sender].balance - tokens) >= (balances[msg.sender].airDropQty / 10 * 9));\n            }\n\n            // after Dec 31 2018 and before March 31, 2019, do not allow transfering more than 25% of air dropped tokens\n            if (msg.sender != owner && block.timestamp < 1553990400 && balances[msg.sender].airDropQty>0) {\n                require((balances[msg.sender].balance - tokens) >= balances[msg.sender].airDropQty / 4 * 3);\n            }\n\n            // after March 31, 2019 and before Jun 30, 2019, do not allow transfering more than 50% of air dropped tokens\n            if (msg.sender != owner && block.timestamp < 1561852800 && balances[msg.sender].airDropQty>0) {\n                require((balances[msg.sender].balance - tokens) >= balances[msg.sender].airDropQty / 2);\n            }\n\n            // after Jun 30, 2019 and before Oct 2, 2019, do not allow transfering more than 75% of air dropped tokens\n            if (msg.sender != owner && block.timestamp < 1569974400 && balances[msg.sender].airDropQty>0) {\n                require((balances[msg.sender].balance - tokens) >= balances[msg.sender].airDropQty / 4);\n            }\n            \n            // otherwise, no transfer restrictions\n\n        }\n        \n        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);\n        balances[to].balance = balances[to].balance.add(tokens);\n        if (msg.sender == owner) {\n            balances[to].airDropQty = balances[to].airDropQty.add(tokens);\n        }\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    // ------------------------------------------------------------------------\n    // not implemented\n    // ------------------------------------------------------------------------\n    function approve(address spender, uint tokens) public returns (bool success) {\n        return false;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // not implemented\n    // ------------------------------------------------------------------------\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        return false;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // not implemented\n    // ------------------------------------------------------------------------\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return 0;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // not implemented\n    // ------------------------------------------------------------------------\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n        return false;\n    }\n    \n    // ------------------------------------------------------------------------\n    // Used to burn unspent tokens in the contract\n    // ------------------------------------------------------------------------\n    function burn(uint256 tokens) onlyOwner public returns (bool) {\n        require((balances[owner].balance - tokens) >= 0);\n        balances[owner].balance = balances[owner].balance.sub(tokens);\n        _totalSupply = _totalSupply.sub(tokens);\n        emit Burn(tokens);\n        return true;\n    }\n\n\n    function ()  {\n        //if ether is sent to this address, send it back.\n        throw;\n    }\n}",
    "function_sum": 11,
    "compiler_version": "0.4.21",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// ODIN token contract \n// ----------------------------------------------------------------------------\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\n\ncontract ERC20Interface {\n    function totalSupply() public constant returns (uint);\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Burn(uint tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Owned contract\n// ----------------------------------------------------------------------------\n\ncontract Owned {\n    address public owner;\n    address private newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) onlyOwner public onlyOwner {\n        owner = _newOwner;\n        emit OwnershipTransferred(msg.sender, _newOwner);\n    }\n\n}\n\n\n\n// You task is to complete the smart contract OdinToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.21, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice OdinToken is an ERC20 token with additional features such as airdrop restrictions and owner-controlled whitelisting.\n * @dev This contract extends the ERC20Interface and Owned contracts, providing basic token functionality along with specific rules for airdropped tokens and whitelisting.\n */\ncontract OdinToken is ERC20Interface, Owned {\n\n  using SafeMath for uint256;\n\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint private _totalSupply;\n    bool private _whitelistAll;\n\n    struct balanceData {  \n       bool locked;\n       uint balance;\n       uint airDropQty;\n    }\n\n    mapping(address => balanceData) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n  /**\n  * @dev Constructor for Odin creation\n  * @dev Initially assigns the totalSupply to the contract creator\n  */\n    function OdinToken() public {\n        \n        // owner of this contract\n        owner = msg.sender;\n        symbol = \"ODIN\";\n        name = \"ODIN Token\";\n        decimals = 18;\n        _whitelistAll=false;\n        _totalSupply = 100000000000000000000000;\n        balances[owner].balance = _totalSupply;\n\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n  /**\n  * @notice Returns the total supply of the token.\n  * @return The total supply of the token.\n  * @dev This function returns the total number of tokens in circulation.\n  */\n    function totalSupply() constant public returns (uint256 totalSupply) {}\n\n  /**\n  * @notice Whitelist an address to allow it to receive airdrops.\n  * @param to The address to whitelist.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function sets the airdrop quantity for the specified address to 0, effectively whitelisting it.\n  */\n    function whitelistAddress(address to) onlyOwner public  returns (bool) {}\n\n  /**\n  * @notice Whitelist all addresses early.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function sets the `_whitelistAll` flag to true, allowing all addresses to be whitelisted.\n  */\n    function whitelistAllAddresses() onlyOwner public returns (bool) {}\n\n  /**\n  * @notice Gets the balance of the specified address.\n  * @param tokenOwner The address to query the balance of.\n  * @return The amount owned by the passed address.\n  * @dev This function returns the balance of the specified address.\n  */\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {}\n\n  /**\n    * @dev Transfers tokens from sender to recipient with transfer restrictions.\n    * \n    * Restrictions:\n    * - Cannot send to self or address(0)\n    * - Sender must have sufficient balance\n    * - Air-dropped tokens have time-based transfer limits (if whitelistAll=false):\n    *   - Before Sep 1 2018: Cannot transfer any air-dropped tokens\n    *   - Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens\n    *   - Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens\n    *   - Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens\n    *   - Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens\n    *   - After Jun 30 2019: No restrictions\n    * \n    * @param to Recipient address (cannot be zero address)\n    * @param tokens Amount to transfer (must be \u2264 sender's balance)\n    * @return success Always returns true if transfer succeeds\n    * \n    * @notice Emits Transfer event\n    * @dev AirDropQty tracks air-dropped tokens for each account\n    *      Owner transfers bypass air-drop restrictions\n    */\n    function transfer(address to, uint tokens) public returns (bool success) {}\n\n  /**\n  * @notice Approve the spender to spend a specified amount of tokens.\n  * @param spender The address that will spend the tokens.\n  * @param tokens The amount of tokens to approve.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function is not implemented in this contract.\n  */\n    function approve(address spender, uint tokens) public returns (bool success) {}\n\n  /**\n  * @notice Transfer tokens from one address to another, using the allowance mechanism.\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param tokens The amount to be transferred.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function is not implemented in this contract.\n  */\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {}\n\n  /**\n  * @notice Get the remaining number of tokens that `spender` is allowed to spend on behalf of `tokenOwner`.\n  * @param tokenOwner The address that owns the tokens.\n  * @param spender The address that will spend the tokens.\n  * @return The remaining allowance.\n  * @dev This function is not implemented in this contract.\n  */\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {}\n\n  /**\n  * @notice Approve the spender to spend a specified amount of tokens and call a contract.\n  * @param spender The address that will spend the tokens.\n  * @param tokens The amount of tokens to approve.\n  * @param data Extra data to send to the approved contract.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function is not implemented in this contract.\n  */\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {}\n\n  /**\n  * @notice Burn a specified amount of tokens from the owner's balance.\n  * @param tokens The amount of tokens to burn.\n  * @return A boolean indicating whether the operation was successful.\n  * @dev This function burns a specified amount of tokens from the owner's balance, reducing the total supply.\n  */\n    function burn(uint256 tokens) onlyOwner public returns (bool) {}\n\n    function ()  {\n        //if ether is sent to this address, send it back.\n        throw;\n    }\n}\n"
}