{
    "contract_name": "PIKA",
    "ground_truth": "contract PIKA is Context,Owned,  ERC20 {\n    using SafeMath for uint256;\n    uint256 public _taxFee;\n    uint256 public totalSupply;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint256 private _taxFeepercent = 225;\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    mapping (address => bool) private _isExcludedFromFee;\n    uint256 public ContractDeployed;\n    address oldPika = 0xE09fB60E8D6e7E1CEbBE821bD5c3FC67a40F86bF;\n    uint256 public oldPika_amount;\n    uint256 private minamountTakenOut = 1000000 *10**9 * 10 **9;  \n    uint256 private MinimumSupply = 100000000 *10**9 * 10**9;\n    \n    mapping (address=>uint256) balances;\n    mapping (address=>mapping (address=>uint256)) allowed;\n\n    event TransferFee(address indexed _from, address indexed _to, uint256 _value);\n    \n    function balanceOf(address _owner) view    public override  returns (uint256 balance) {return balances[_owner];}\n    \n    function transfer(address _to, uint256 _amount)  public override     returns (bool success) {\n        _transfer(_msgSender(), _to, _amount);\n        return true;\n    }\n  \n    function transferFrom(address sender, address recipient, uint256 amount) public override  returns (bool success) {\n        \n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = allowed[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n\n        \n    }\n  \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        if(_isExcludedFromFee[sender]  ||  _isExcludedFromFee[recipient])\n        {\n            uint256 senderBalance = balances[sender];\n            require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n            balances[sender] = senderBalance - amount;\n            balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n        }\n        else\n        {\n            uint256 _Fee = calSwapToken(amount,_taxFeepercent);\n            _taxFee +=  _Fee;\n            if(_taxFee >= minamountTakenOut )\n            {\n                swapTokensForEth(_taxFee);\n            }\n            \n                uint256 senderBalance = balances[sender];\n                require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n                balances[sender] = senderBalance - amount;\n                balances[recipient] += amount-_Fee ;\n                emit Transfer(sender, recipient, amount-_Fee);\n            \n        }\n\n\n      \n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n  \n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function allowance(address _owner, address _spender) view public override  returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n    \n    function _burn(address account, uint256 amount) internal virtual {\n        \n        \n            require(account != address(0), \"ERC20: burn from the zero address\");\n            uint256 accountBalance = balances[account];\n            require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n            balances[account] = accountBalance - amount;\n            totalSupply -= amount;\n            emit Transfer(account, address(0), amount);\n        \n            \n        }\n    \n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            owner,\n            block.timestamp\n        );\n        \n        _taxFee =0;\n    }\n\n    function viewMinExtractAmt() public view returns(uint256){\n         return minamountTakenOut;\n     }    \n        \n    function setMinExtractAmt(uint256 _amount) public onlyOwner() {\n         minamountTakenOut = _amount;\n     }\n    \n    function viewFee() public view  returns(uint256){\n       return  _taxFeepercent ;\n    } \n    \n    function exchnagePika(uint256 tokens)external{\n            \n        require(tokens <= PIKA(address(this)).balanceOf(address(this)), \"Not enough tokens in the reserve\");\n        require(ERC20(oldPika).transferFrom(_msgSender(), address(this), tokens), \"Tokens cannot be transferred from user account\");      \n            \n\n               uint256 time = block.timestamp - ContractDeployed;\n               uint256 day = time.div(86400);\n               require(day <= 4, \"Sorry Swaping Time Period is finished\");\n\n                if(tokens < 10000000000 * 10**9 * 10**9)\n                {\n                    uint256 extra = calSwapToken(tokens,500);\n                    PIKA(address(this)).transfer(_msgSender(), tokens.add(extra));\n                }\n                \n                else if ( (tokens >= 10000000000 * 10**9 * 10**9)  &&  (tokens < 100000000000 * 10**9 * 10**9))\n                {\n                    uint256 extra = calSwapToken(tokens,250);\n                    PIKA(address(this)).transfer(_msgSender(), tokens.add(extra));\n                }\n                else if( tokens >= 100000000000 * 10**9 * 10**9 )\n                {\n                    uint256 extra = calSwapToken(tokens,100);\n                    PIKA(address(this)).transfer(_msgSender(), tokens.add(extra));\n                }\n                \n            \n            oldPika_amount = oldPika_amount.add(tokens);\n\n    }\n    \n    function extractOldPIKA() external onlyOwner(){\n            ERC20(oldPika).transfer(_msgSender(), oldPika_amount);\n            oldPika_amount = 0;\n        }\n        \n    function extractfee() external onlyOwner(){\n        PIKA(address(this)).transfer(_msgSender(), _taxFee);\n        _taxFee = 0;\n       }\n   \n    function calSwapToken(uint256 _tokens, uint256 cust) internal virtual returns (uint256) {\n        uint256 custPercentofTokens = _tokens.mul(cust).div(100 * 10**uint(2));\n        return custPercentofTokens;\n        }\n\n    function burn(uint256 value) public returns(bool flag) {\n     if(totalSupply >= MinimumSupply)         \n     {\n      _burn(_msgSender(), value);\n      return true;\n     } \n     else\n     return false;\n\n    }\n    \n    function viewMinSupply()public view  returns(uint256) {\n            return MinimumSupply;\n    }\n    \n    function changeMinSupply(uint256 newMinSupply)onlyOwner() public{\n            MinimumSupply = newMinSupply;\n    }\n    \n    function addLiquidity(uint256 tokenAmount) public payable onlyOwner() {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH{value: msg.value}(\n            address(this),\n            tokenAmount,\n            0,\n            0, // slippage is unavoidable\n           owner,\n            block.timestamp\n        );\n    }\n    \n    constructor() {\n       symbol = \"PIKA\";\n       name = \"PIKA\";\n       decimals = 18;\n       totalSupply = 50000000000000 * 10**9 * 10**9; //50 trillion\n        owner = _msgSender();\n       balances[owner] = totalSupply;\n       _isExcludedFromFee[owner] = true;\n       _isExcludedFromFee[address(this)] = true;\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n    ContractDeployed = block.timestamp;\n   }\n\n    receive () payable external {\n       require(msg.value>0);\n       owner.transfer(msg.value);\n   }\n    \n}",
    "function_sum": 20,
    "compiler_version": "0.7.6",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-05-08\n*/\n// SPDX-License-Identifier: UNLICENSED\n\nlibrary SafeMath\n{\n\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n       uint256 c = a + b;\n       require(c >= a, \"SafeMath: addition overflow\");\n       return c;\n   }\n\n   \n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n       return sub(a, b, \"SafeMath: subtraction overflow\");\n   }\n\n   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n       require(b <= a, errorMessage);\n       uint256 c = a - b;\n\n       return c;\n   }\n\n   \n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n       // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n       // benefit is lost if 'b' is also tested.\n       // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n       if (a == 0) {\n           return 0;\n       }\n\n       uint256 c = a * b;\n       require(c / a == b, \"SafeMath: multiplication overflow\");\n\n       return c;\n   }\n\n\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n       return div(a, b, \"SafeMath: division by zero\");\n   }\n\n   \n   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n       require(b > 0, errorMessage);\n       uint256 c = a / b;\n       // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n       return c;\n   }\n\n   \n   function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n       return mod(a, b, \"SafeMath: modulo by zero\");\n   }\n\n   \n   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n       require(b != 0, errorMessage);\n       return a % b;\n   }\n\n   function ceil(uint a, uint m) internal pure returns (uint r) {\n       return (a + m - 1) / m * m;\n   }\n\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Owned is Context\n{\n   modifier onlyOwner() virtual{\n       require(_msgSender()==owner);\n       _;\n   }\n   address payable owner;\n   address payable newOwner;\n   function changeOwner(address payable _newOwner) external onlyOwner {\n       require(_newOwner!=address(0));\n       newOwner = _newOwner;\n   }\n   function acceptOwnership() external {\n       if (_msgSender()==newOwner) {\n           owner = newOwner;\n       }\n   }\n}\n\ninterface ERC20 \n{\n   function balanceOf(address _owner) view external  returns (uint256 balance);\n   function transfer(address _to, uint256 _value) external  returns (bool success);\n   function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);\n   function approve(address _spender, uint256 _value) external returns (bool success);\n   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\n\n\n// You task is to complete the smart contract PIKA strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.7.6, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title PIKA Token Contract\n * @notice This contract implements the ERC223 token standard with additional features such as tax fees, swapping, and liquidity management.\n * @dev The contract is designed to handle token transfers, fee calculations, and interactions with Uniswap for liquidity and swapping.\n */\ncontract PIKA is Context, Owned, ERC20 {\n    using SafeMath for uint256;\n\n    uint256 public _taxFee;\n    uint256 public totalSupply;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    uint256 private _taxFeepercent = 225;\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    mapping (address => bool) private _isExcludedFromFee;\n    uint256 public ContractDeployed;\n    address oldPika = 0xE09fB60E8D6e7E1CEbBE821bD5c3FC67a40F86bF;\n    uint256 public oldPika_amount;\n    uint256 private minamountTakenOut = 1000000 * 10**9 * 10 **9;  \n    uint256 private MinimumSupply = 100000000 * 10**9 * 10**9;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    event TransferFee(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * @notice Returns the balance of a specific address.\n     * @param _owner The address to query the balance of.\n     * @return balance The balance of the specified address.\n     */\n    function balanceOf(address _owner) view public override returns (uint256 balance) {}\n\n    /**\n     * @notice Transfers tokens from the sender to a recipient.\n     * @param _to The recipient address.\n     * @param _amount The amount of tokens to transfer.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address _to, uint256 _amount) public override returns (bool success) {}\n\n    /**\n     * @notice Transfers tokens from one address to another, using an allowance mechanism.\n     * @param sender The address to transfer tokens from.\n     * @param recipient The address to transfer tokens to.\n     * @param amount The amount of tokens to transfer.\n     * @return success A boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool success) {}\n\n    /**\n     * @notice Internal function to handle the actual transfer of tokens.\n     * @param sender The address to transfer tokens from.\n     * @param recipient The address to transfer tokens to.\n     * @param amount The amount of tokens to transfer.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {}\n\n    /**\n     * @notice Approves a spender to transfer a certain amount of tokens on behalf of the owner.\n     * @param spender The address that will be approved to spend tokens.\n     * @param amount The amount of tokens to approve.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {}\n\n    /**\n     * @notice Internal function to set the allowance of a spender.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will be approved to spend tokens.\n     * @param amount The amount of tokens to approve.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {}\n\n    /**\n     * @notice Returns the remaining allowance of a spender.\n     * @param _owner The address that owns the tokens.\n     * @param _spender The address that is allowed to spend tokens.\n     * @return remaining The remaining allowance of the spender.\n     */\n    function allowance(address _owner, address _spender) view public override returns (uint256 remaining) {}\n\n    /**\n     * @notice Burns a specified amount of tokens from an account.\n     * @param account The address to burn tokens from.\n     * @param amount The amount of tokens to burn.\n     */\n    function _burn(address account, uint256 amount) internal virtual {}\n\n    /**\n     * @notice Swaps tokens for ETH using Uniswap.\n     * @param tokenAmount The amount of tokens to swap.\n     */\n    function swapTokensForEth(uint256 tokenAmount) private {}\n\n    /**\n     * @notice Returns the minimum amount of tokens that can be taken out.\n     * @return The minimum amount of tokens that can be taken out.\n     */\n    function viewMinExtractAmt() public view returns (uint256) {}\n\n    /**\n     * @notice Sets the minimum amount of tokens that can be taken out.\n     * @param _amount The new minimum amount of tokens that can be taken out.\n     */\n    function setMinExtractAmt(uint256 _amount) public onlyOwner() {}\n\n    /**\n     * @notice Returns the current tax fee percentage.\n     * @return The current tax fee percentage.\n     */\n    function viewFee() public view returns (uint256) {}\n\n    /**\n     * @dev Exchanges Pika tokens with bonus rewards based on swap tier.\n     * Requirements\n     * - Contract must have sufficient Pika tokens in reserve\n     * - User must approve token transfer\n     * - Swap must occur within 4 days of contract deployment\n     * Bonus Tiers\n     * - < 1 trillion: 500% bonus\n     * - 1-10 trillion: 250% bonus\n     * - \u2265 10 trillion: 100% bonus\n     * @param tokens Amount of old Pika tokens to exchange\n     * @return None\n     * @notice Updates oldPika_amount with swapped tokens\n     * @dev Uses calSwapToken() to calculate bonus amount\n     */\n    function exchnagePika(uint256 tokens) external {}\n\n    /**\n     * @dev Allows the owner to withdraw all accumulated old Pika tokens.\n     * @notice Transfers the entire balance of old Pika tokens from the contract\n     *         to the owner's account and resets the stored amount to zero.\n     * @dev Requires the caller to be the contract owner.\n     * @dev Uses the ERC20 transfer function for the withdrawal.\n     */\n    function extractOldPIKA() external onlyOwner() {}\n\n    /**\n     * @dev Allows the owner to extract accumulated fees.\n     * @notice Transfers the current tax fee balance to the owner's account\n     *         and resets the tax fee counter to zero.\n     * @dev Can only be called by the contract owner.\n     */\n    function extractfee() external onlyOwner() {}\n\n    /**\n     * @notice Calculates the swap token amount based on a custom percentage.\n     * @param _tokens The amount of tokens to calculate the swap for.\n     * @param cust The custom percentage to apply.\n     * @return The calculated swap token amount.\n     */\n    function calSwapToken(uint256 _tokens, uint256 cust) internal virtual returns (uint256) {}\n\n    /**\n     * @notice Burns a specified amount of tokens from the caller's account.\n     * @param value The amount of tokens to burn.\n     * @return flag A boolean value indicating whether the operation succeeded.\n     */\n    function burn(uint256 value) public returns (bool flag) {}\n\n    /**\n     * @notice Returns the minimum supply of tokens.\n     * @return The minimum supply of tokens.\n     */\n    function viewMinSupply() public view returns (uint256) {}\n\n    /**\n     * @notice Changes the minimum supply of tokens.\n     * @param newMinSupply The new minimum supply of tokens.\n     */\n    function changeMinSupply(uint256 newMinSupply) onlyOwner() public {}\n\n    /**\n     * @dev Adds liquidity to Uniswap V2 pool.\n     * @param tokenAmount Amount of tokens to add as liquidity\n     * @notice\n     * - Approves token transfer to Uniswap router\n     * - Adds ETH and tokens as liquidity\n     * - Uses msg.value for ETH amount\n     * - Sets slippage parameters to 0 (no minimums)\n     * - Transaction must be sent by contract owner\n     * @dev\n     * - Automatically approves maximum token amount\n     * - Liquidity will be added at current price\n     * - No slippage protection (may fail if price changes)\n     */\n    function addLiquidity(uint256 tokenAmount) public payable onlyOwner() {}\n\n    constructor() {\n        symbol = \"PIKA\";\n        name = \"PIKA\";\n        decimals = 18;\n        totalSupply = 50000000000000 * 10**9 * 10**9; //50 trillion\n        owner = _msgSender();\n        balances[owner] = totalSupply;\n        _isExcludedFromFee[owner] = true;\n        _isExcludedFromFee[address(this)] = true;\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        uniswapV2Router = _uniswapV2Router;\n        ContractDeployed = block.timestamp;\n    }\n\n    /**\n     * @notice Fallback function to receive ETH.\n     */\n    receive() payable external {\n        require(msg.value > 0);\n        owner.transfer(msg.value);\n    }\n}\n"
}