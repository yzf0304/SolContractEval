{
    "contract_name": "POWNFTv3",
    "ground_truth": "contract POWNFTv3{\n\n    //v2 Variables\n    uint public UNMIGRATED = 0;\n    uint public V2_TOTAL = 0;\n    bytes32 public PREV_CHAIN_LAST_HASH;\n    POWNFTv2 CONTRACT_V2;\n\n    constructor(address contract_v2){\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\n        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\n\n        CONTRACT_V2 = POWNFTv2(contract_v2);\n        V2_TOTAL =\n        UNMIGRATED = CONTRACT_V2.totalSupply();\n        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);\n\n    }\n\n\n    //////===721 Standard\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    //////===721 Implementation\n    mapping(address => uint256) internal BALANCES;\n    mapping (uint256 => address) internal ALLOWANCE;\n    mapping (address => mapping (address => bool)) internal AUTHORISED;\n\n    bytes32[] TOKENS;  //Array of all tokens [hash,hash,...]\n    mapping(uint256 => address) OWNERS;  //Mapping of owners\n\n\n    //    METADATA VARS\n    string private __name = \"POW NFT\";\n    string private __symbol = \"POW\";\n    bytes private __uriBase = bytes(\"https://www.pownftmetadata.com/t/\");\n\n\n    //    ENUMERABLE VARS\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\n    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\n    mapping(uint => uint) internal ID_TO_INDEX;\n    mapping(uint => uint) internal INDEX_TO_ID;\n\n\n    //ETH VAR\n    mapping(uint256 => uint256) WITHDRAWALS;\n\n\n    //      MINING VARS\n    uint BASE_COST = 0.000045 ether;\n    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)/uint(300);\n    uint DIFFICULTY_RAMP = 3;\n\n\n    event Migrate(uint indexed _tokenId);\n\n    //      MINING EVENTS\n    event Mined(uint indexed _tokenId, bytes32 hash);\n    event Withdraw(uint indexed _tokenId, uint value);\n\n    //      MINING FUNCTIONS\n    function generationOf(uint _tokenId) private pure returns(uint generation){\n        for(generation = 0; _tokenId > 0; generation++){\n            _tokenId /= 2;\n        }\n        return generation - 1;\n    }\n    function hashOf(uint _tokenId) public view returns(bytes32){\n        require(isValidToken(_tokenId),\"invalid\");\n        return TOKENS[ID_TO_INDEX[_tokenId]];\n    }\n\n\n    function migrate(uint _tokenId,uint _withdrawEthUntil) public {\n            _migrate(_tokenId);\n            if(_withdrawEthUntil > 0){\n                withdraw(_tokenId, _withdrawEthUntil);\n            }\n    }\n    function _migrate(uint _tokenId) internal {\n        //require not migrated\n        require(!isValidToken(_tokenId),'is_migrated');\n\n        //Require before snapshot\n        require(_tokenId <= V2_TOTAL,'forgery');\n\n        //require owner on original contract\n        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender,'owner');\n        //mint the token with hash from prev contract\n        UNMIGRATED--;\n        mint(_tokenId,\n            CONTRACT_V2.hashOf(_tokenId)\n        );\n        emit Migrate(_tokenId);\n    }\n    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {\n        for(uint i = 0; i < _tokenIds.length; i++){\n            _migrate(_tokenIds[i]);\n        }\n        withdrawMultiple(_tokenIds,_withdrawUntil);\n    }\n\n\n\n    function withdraw(uint _tokenId, uint _withdrawUntil) public {\n        payable(msg.sender).transfer(\n            _withdraw(_tokenId, _withdrawUntil)\n        );\n    }\n    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint){\n        require(isValidToken(_withdrawUntil),'withdrawUntil_exist');\n\n        require(ownerOf(_tokenId) == msg.sender,\"owner\");\n        require(_withdrawUntil > WITHDRAWALS[_tokenId],'withdrawn');\n\n        uint generation = generationOf(_tokenId);\n        uint firstPayable = 2**(generation+1);\n\n        uint withdrawFrom = WITHDRAWALS[_tokenId];\n        if(withdrawFrom < _tokenId){\n            withdrawFrom = _tokenId;\n\n            //withdraw from if _tokenId < number brought over\n            if(withdrawFrom < V2_TOTAL){\n                withdrawFrom = V2_TOTAL;\n            }\n            if(withdrawFrom < firstPayable){\n                withdrawFrom = firstPayable - 1;\n            }\n        }\n\n        require(_withdrawUntil > withdrawFrom,'underflow');\n\n        uint payout = BASE_COST * (_withdrawUntil - withdrawFrom);\n\n        WITHDRAWALS[_tokenId] = _withdrawUntil;\n\n        emit Withdraw(_tokenId,payout);\n\n        return payout;\n    }\n\n    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public{\n        uint payout = 0;\n        for(uint i = 0; i < _tokenIds.length; i++){\n            if(_withdrawUntil[i] > 0){\n                payout += _withdraw(_tokenIds[i],_withdrawUntil[i]);\n            }\n        }\n        payable(msg.sender).transfer(payout);\n    }\n\n    function mine(uint nonce) external payable{\n        uint tokenId = UNMIGRATED + TOKENS.length + 1;\n        uint generation = generationOf(tokenId);\n\n        uint difficulty = BASE_DIFFICULTY / (DIFFICULTY_RAMP**generation);\n        if(generation > 13){ //Token 16384\n            difficulty /= (tokenId - 2**14 + 1);\n        }\n\n        uint cost = (2**generation - 1)* BASE_COST;\n\n\n        bytes32 hash;\n        if(V2_TOTAL - UNMIGRATED != TOKENS.length){\n            hash = keccak256(abi.encodePacked(\n                    msg.sender,\n                    TOKENS[ID_TO_INDEX[tokenId-1]],\n                    nonce\n                ));\n        }else{\n//            First mine on new contract\n            hash = keccak256(abi.encodePacked(\n                        msg.sender,\n                        PREV_CHAIN_LAST_HASH,\n                    nonce\n                ));\n        }\n\n\n        require(uint(hash) < difficulty,\"difficulty\");\n        require(msg.value ==cost,\"cost\");\n\n        hash = keccak256(abi.encodePacked(hash,block.timestamp));\n\n        mint(tokenId, hash);\n\n        emit Mined(tokenId,hash);\n    }\n\n    function mint(uint tokenId, bytes32 hash) private{\n        OWNERS[tokenId] = msg.sender;\n        BALANCES[msg.sender]++;\n        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;\n        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);\n\n        ID_TO_INDEX[tokenId] = TOKENS.length;\n        INDEX_TO_ID[TOKENS.length] = tokenId;\n        TOKENS.push(hash);\n\n        emit Transfer(address(0),msg.sender,tokenId);\n    }\n\n\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\n        return OWNERS[_tokenId] != address(0);\n    }\n\n    function balanceOf(address _owner) external view returns (uint256){\n        return BALANCES[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId) public view returns(address){\n        require(isValidToken(_tokenId),\"invalid\");\n        return OWNERS[_tokenId];\n    }\n\n\n    function approve(address _approved, uint256 _tokenId)  external{\n        address owner = ownerOf(_tokenId);\n        require( owner == msg.sender                    //Require Sender Owns Token\n            || AUTHORISED[owner][msg.sender]                //  or is approved for all.\n        ,\"permission\");\n        emit Approval(owner, _approved, _tokenId);\n        ALLOWANCE[_tokenId] = _approved;\n    }\n\n    function getApproved(uint256 _tokenId) external view returns (address) {\n        require(isValidToken(_tokenId),\"invalid\");\n        return ALLOWANCE[_tokenId];\n    }\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return AUTHORISED[_owner][_operator];\n    }\n\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n        emit ApprovalForAll(msg.sender,_operator, _approved);\n        AUTHORISED[msg.sender][_operator] = _approved;\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n\n        //Check Transferable\n        //There is a token validity check in ownerOf\n        address owner = ownerOf(_tokenId);\n\n        require ( owner == msg.sender             //Require sender owns token\n        //Doing the two below manually instead of referring to the external methods saves gas\n        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\n            || AUTHORISED[owner][msg.sender]          //or is approved for all\n        ,\"permission\");\n        require(owner == _from,\"owner\");\n        require(_to != address(0),\"zero\");\n\n        emit Transfer(_from, _to, _tokenId);\n\n\n        OWNERS[_tokenId] =_to;\n\n        BALANCES[_from]--;\n        BALANCES[_to]++;\n\n        //Reset approved if there is one\n        if(ALLOWANCE[_tokenId] != address(0)){\n            delete ALLOWANCE[_tokenId];\n        }\n\n        //Enumerable Additions\n        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\n        //If the token isn't the last one in the owner's index\n        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\n            //Move the old one in the index list\n            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\n            //Update the token's reference to its place in the index list\n            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\n        }\n        OWNER_INDEX_TO_ID[_from].pop();\n\n        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\n        OWNER_INDEX_TO_ID[_to].push(_tokenId);\n\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\n        transferFrom(_from, _to, _tokenId);\n\n        //Get size of \"_to\" address, if 0 it's a wallet\n        uint32 size;\n        assembly {\n            size := extcodesize(_to)\n        }\n        if(size > 0){\n            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")),\"receiver\");\n        }\n\n    }\n\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\n        safeTransferFrom(_from,_to,_tokenId,\"\");\n    }\n\n\n    // METADATA FUNCTIONS\n    function tokenURI(uint256 _tokenId) public view returns (string memory){\n        //Note: changed visibility to public\n        require(isValidToken(_tokenId),'tokenId');\n\n        uint _i = _tokenId;\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n\n\n        return string(abi.encodePacked(__uriBase,bstr));\n\n    }\n\n\n\n    function name() external view returns (string memory _name){\n        return __name;\n    }\n\n    function symbol() external view returns (string memory _symbol){\n        return __symbol;\n    }\n\n\n    // ENUMERABLE FUNCTIONS\n    function totalSupply() external view returns (uint256){\n        return TOKENS.length;\n    }\n\n    function tokenByIndex(uint256 _index) external view returns(uint256){\n        require(_index < TOKENS.length,\"index\");\n        return INDEX_TO_ID[_index];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\n        require(_index < BALANCES[_owner],\"index\");\n        return OWNER_INDEX_TO_ID[_owner][_index];\n    }\n\n    // End 721 Implementation\n\n    ///////===165 Implementation\n    mapping (bytes4 => bool) internal supportedInterfaces;\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\n        return supportedInterfaces[interfaceID];\n    }\n    ///==End 165\n}",
    "function_sum": 27,
    "compiler_version": "0.8.0",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\ninterface ERC721TokenReceiver {\n    //note: the national treasure is buried under parliament house\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\ninterface POWNFTv2 {\n    function hashOf(uint _tokenId) external view returns(bytes32);\n    function ownerOf(uint256 _tokenId) external view returns(address);\n    function totalSupply() external view returns (uint256);\n    //NWH YDY DDUG SEGEN DIN\n}\n\n\n\n// You task is to complete the smart contract POWNFTv3 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.0, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title POWNFTv3\n * @notice This contract implements an upgradeable version of a non-fungible token (NFT) with mining capabilities. It supports ERC721, ERC721Metadata, and ERC721Enumerable standards.\n * @dev The contract allows for the migration of tokens from a previous version (v2), mining new tokens, and managing token ownership and transfers.\n */\ncontract POWNFTv3 {\n\n    //v2 Variables\n    uint public UNMIGRATED = 0;\n    uint public V2_TOTAL = 0;\n    bytes32 public PREV_CHAIN_LAST_HASH;\n    POWNFTv2 CONTRACT_V2;\n\n    /**\n     * @notice Initializes the contract and sets up the necessary mappings and interfaces.\n     * @param contract_v2 The address of the previous version (v2) of the NFT contract.\n     * @dev Sets up the supported interfaces and initializes v2-related variables.\n     */\n    constructor(address contract_v2) {\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\n        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\n\n        CONTRACT_V2 = POWNFTv2(contract_v2);\n        V2_TOTAL = CONTRACT_V2.totalSupply();\n        UNMIGRATED = V2_TOTAL;\n        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);\n    }\n\n    //////===721 Standard\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    //////===721 Implementation\n    mapping(address => uint256) internal BALANCES;\n    mapping(uint256 => address) internal ALLOWANCE;\n    mapping(address => mapping(address => bool)) internal AUTHORISED;\n\n    bytes32[] TOKENS;  // Array of all tokens [hash, hash, ...]\n    mapping(uint256 => address) OWNERS;  // Mapping of owners\n\n    // METADATA VARS\n    string private __name = \"POW NFT\";\n    string private __symbol = \"POW\";\n    bytes private __uriBase = bytes(\"https://www.pownftmetadata.com/t/\");\n\n    // ENUMERABLE VARS\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\n    mapping(uint256 => uint) internal OWNER_ID_TO_INDEX;\n    mapping(uint256 => uint) internal ID_TO_INDEX;\n    mapping(uint => uint) internal INDEX_TO_ID;\n\n    // ETH VAR\n    mapping(uint256 => uint256) WITHDRAWALS;\n\n    // MINING VARS\n    uint BASE_COST = 0.000045 ether;\n    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / uint(300);\n    uint DIFFICULTY_RAMP = 3;\n\n    event Migrate(uint indexed _tokenId);\n\n    // MINING EVENTS\n    event Mined(uint indexed _tokenId, bytes32 hash);\n    event Withdraw(uint indexed _tokenId, uint value);\n\n    /**\n     * @notice Calculates the generation of a given token ID.\n     * @param _tokenId The ID of the token.\n     * @return generation The generation of the token.\n     * @dev Used to determine the difficulty and cost for mining.\n     */\n    function generationOf(uint _tokenId) private pure returns(uint generation) {}\n\n    /**\n     * @notice Returns the hash of a given token ID.\n     * @param _tokenId The ID of the token.\n     * @return The hash of the token.\n     * @dev Requires the token to be valid.\n     */\n    function hashOf(uint _tokenId) public view returns(bytes32) {}\n\n    /**\n     * @notice Migrates a token from the v2 contract to this contract.\n     * @param _tokenId The ID of the token to migrate.\n     * @param _withdrawEthUntil The block number until which to withdraw ETH.\n     * @dev Handles the migration and withdrawal of ETH if specified.\n     */\n    function migrate(uint _tokenId, uint _withdrawEthUntil) public {}\n\n    /**\n     * @notice Internal function to handle the migration of a single token.\n     * @param _tokenId The ID of the token to migrate.\n     * @dev Ensures the token is not already migrated and is owned by the sender in the v2 contract.\n     */\n    function _migrate(uint _tokenId) internal {}\n\n    /**\n     * @notice Migrates multiple tokens from the v2 contract to this contract.\n     * @param _tokenIds The IDs of the tokens to migrate.\n     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.\n     * @dev Calls the internal `_migrate` function for each token and handles withdrawals.\n     */\n    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {}\n\n    /**\n     * @notice Withdraws ETH for a given token up to a specified block number.\n     * @param _tokenId The ID of the token.\n     * @param _withdrawUntil The block number until which to withdraw ETH.\n     * @dev Transfers the calculated ETH amount to the sender.\n     */\n    function withdraw(uint _tokenId, uint _withdrawUntil) public {}\n\n    /**\n     * @notice Calculates and processes token withdrawal with ETH payout.\n     * @param _tokenId ID of the token to withdraw\n     * @param _withdrawUntil Block number until which to withdraw ETH\n     * @return uint Amount of ETH withdrawn\n     * @dev\n     * - Validates token existence and ownership\n     * - Ensures withdrawal is from a valid block number\n     * - Calculates payout based on token generation\n     * - Updates withdrawal record and emits event\n     * @notice Handles edge cases for V2 migration and first payable blocks\n     */\n    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {}\n\n    /**\n     * @notice Withdraws ETH for multiple tokens up to specified block numbers.\n     * @param _tokenIds The IDs of the tokens.\n     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.\n     * @dev Calls the internal `_withdraw` function for each token and transfers the total ETH amount to the sender.\n     */\n    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {}\n\n    /**\n     * @notice Mines a new token by solving a cryptographic puzzle.\n     * @param nonce Random value used in the mining puzzle\n     * @dev\n     * - Calculates token ID based on current token count\n     * - Determines mining difficulty based on token generation\n     * - Applies exponential difficulty ramp and additional adjustment for high generations\n     * - Calculates mining cost based on token generation\n     * - Uses different hash inputs depending on migration status\n     * - Verifies solution matches difficulty target\n     * - Validates correct payment amount\n     * - Mints new token and emits Mined event\n     * @notice Difficulty adjustment prevents excessive mining speed\n     * @dev Cost calculation ensures fair mining rewards\n     */\n    function mine(uint nonce) external payable {}\n\n    /**\n     * @notice Mints a new token with a given token ID and hash.\n     * @param tokenId The ID of the token to mint.\n     * @param hash The hash of the token.\n     * @dev Updates the token ownership and emits the `Transfer` event.\n     */\n    function mint(uint tokenId, bytes32 hash) private {}\n\n    /**\n     * @notice Checks if a token is valid.\n     * @param _tokenId The ID of the token.\n     * @return True if the token is valid, false otherwise.\n     * @dev A token is valid if it has a non-zero owner.\n     */\n    function isValidToken(uint256 _tokenId) internal view returns(bool) {}\n\n    /**\n     * @notice Returns the balance of a given owner.\n     * @param _owner The address of the owner.\n     * @return The balance of the owner.\n     * @dev Queries the `BALANCES` mapping.\n     */\n    function balanceOf(address _owner) external view returns (uint256) {}\n\n    /**\n     * @notice Returns the owner of a given token ID.\n     * @param _tokenId The ID of the token.\n     * @return The owner of the token.\n     * @dev Requires the token to be valid.\n     */\n    function ownerOf(uint256 _tokenId) public view returns(address) {}\n\n    /**\n     * @notice Approves a specific address to transfer a given token.\n     * @param _approved The address to approve.\n     * @param _tokenId The ID of the token.\n     * @dev Requires the sender to own the token or be approved for all tokens.\n     */\n    function approve(address _approved, uint256 _tokenId) external {}\n\n    /**\n     * @notice Returns the address approved for a given token.\n     * @param _tokenId The ID of the token.\n     * @return The approved address.\n     * @dev Requires the token to be valid.\n     */\n    function getApproved(uint256 _tokenId) external view returns (address) {}\n\n    /**\n     * @notice Checks if an operator is approved for all tokens of a given owner.\n     * @param _owner The address of the owner.\n     * @param _operator The address of the operator.\n     * @return True if the operator is approved for all, false otherwise.\n     * @dev Queries the `AUTHORISED` mapping.\n     */\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {}\n\n    /**\n     * @notice Sets or unsets the approval for all tokens of the sender for a given operator.\n     * @param _operator The address of the operator.\n     * @param _approved True to set approval, false to unset.\n     * @dev Emits the `ApprovalForAll` event.\n     */\n    function setApprovalForAll(address _operator, bool _approved) external {}\n\n    /**\n     * @notice Transfers ownership of a token from one address to another.\n     * @param _from Current owner of the token\n     * @param _to New owner of the token\n     * @param _tokenId ID of the token to transfer\n     * @dev\n     * - Verifies sender has permission (owner, approved for token, or approved for all)\n     * - Validates token ownership and non-zero recipient address\n     * - Emits Transfer event\n     * - Updates ownership and balances\n     * - Clears token approval if exists\n     * - Maintains enumerable ownership index\n     * @notice Overrides standard ERC721 transferFrom for gas optimization\n     * @dev Manual allowance check saves gas compared to external calls\n     */\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {}\n\n    /**\n     * @notice Safely transfers a token from one address to another, with additional data.\n     * @param _from The address to transfer from.\n     * @param _to The address to transfer to.\n     * @param _tokenId The ID of the token.\n     * @param data Additional data to send to the receiver.\n     * @dev Calls `transferFrom` and checks if the receiver is a contract.\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {}\n\n    /**\n     * @notice Safely transfers a token from one address to another.\n     * @param _from The address to transfer from.\n     * @param _to The address to transfer to.\n     * @param _tokenId The ID of the token.\n     * @dev Calls `safeTransferFrom` with empty data.\n     */\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {}\n\n    /**\n     * @notice Returns the metadata URI for a specific token.\n     * @param _tokenId The ID of the token to query\n     * @return string The metadata URI for the token\n     * @dev\n     * - Validates token existence\n     * - Converts token ID to string format\n     * - Combines with base URI to form complete metadata URL\n     * @notice Replaces private visibility with public for external access\n     * @dev Manual string conversion optimizes gas usage compared to toString()\n     */\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {}\n\n    /**\n     * @notice Returns the name of the NFT collection.\n     * @return The name of the NFT collection.\n     * @dev Returns the `__name` variable.\n     */\n    function name() external view returns (string memory) {}\n\n    /**\n     * @notice Returns the symbol of the NFT collection.\n     * @return The symbol of the NFT collection.\n     * @dev Returns the `__symbol` variable.\n     */\n    function symbol() external view returns (string memory) {}\n\n    /**\n     * @notice Returns the total supply of tokens.\n     * @return The total supply of tokens.\n     * @dev Returns the length of the `TOKENS` array.\n     */\n    function totalSupply() external view returns (uint256) {}\n\n    /**\n     * @notice Returns the token at a given index.\n     * @param _index The index of the token.\n     * @return The token ID at the given index.\n     * @dev Requires the index to be within the bounds of the `TOKENS` array.\n     */\n    function tokenByIndex(uint256 _index) external view returns(uint256) {}\n\n    /**\n     * @notice Returns the token at a given index for a specific owner.\n     * @param _owner The address of the owner.\n     * @param _index The index of the token.\n     * @return The token ID at the given index for the owner.\n     * @dev Requires the index to be within the bounds of the owner's token list.\n     */\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {}\n\n    ///////===165 Implementation\n    mapping (bytes4 => bool) internal supportedInterfaces;\n\n    /**\n     * @notice Checks if the contract supports a given interface.\n     * @param interfaceID The ID of the interface.\n     * @return True if the interface is supported, false otherwise.\n     * @dev Queries the `supportedInterfaces` mapping.\n     */\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {}\n}\n"
}