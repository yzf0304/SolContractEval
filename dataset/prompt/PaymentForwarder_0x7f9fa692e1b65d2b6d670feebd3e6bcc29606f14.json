{
    "contract_name": "PaymentForwarder",
    "ground_truth": "contract PaymentForwarder is Haltable {\n\n\n\n  /** Who will get all ETH in the end */\n\n  address public teamMultisig;\n\n\n\n  /** Total incoming money */\n\n  uint public totalTransferred;\n\n\n\n  /** How many distinct customers we have that have made a payment */\n\n  uint public customerCount;\n\n\n\n  /** Total incoming money per centrally tracked customer id */\n\n  mapping(uint128 => uint) public paymentsByCustomer;\n\n\n\n  /** Total incoming money per benefactor address */\n\n  mapping(address => uint) public paymentsByBenefactor;\n\n\n\n  /** A customer has made a payment. Benefactor is the address where the tokens will be ultimately issued.*/\n\n  event PaymentForwarded(address source, uint amount, uint128 customerId, address benefactor);\n\n\n\n  function PaymentForwarder(address _owner, address _teamMultisig) {\n\n    teamMultisig = _teamMultisig;\n\n    owner = _owner;\n\n  }\n\n\n\n  function payWithoutChecksum(uint128 customerId, address benefactor) public stopInEmergency payable {\n\n\n\n    uint weiAmount = msg.value;\n\n\n\n    PaymentForwarded(msg.sender, weiAmount, customerId, benefactor);\n\n\n\n    // We trust Ethereum amounts cannot overflow uint256\n\n    totalTransferred += weiAmount;\n\n\n\n    if(paymentsByCustomer[customerId] == 0) {\n\n      customerCount++;\n\n    }\n\n\n\n    paymentsByCustomer[customerId] += weiAmount;\n\n\n\n    // We track benefactor addresses for extra safety;\n\n    // In the case of central ETH issuance tracking has problems we can\n\n    // construct ETH contributions solely based on blockchain data\n\n    paymentsByBenefactor[benefactor] += weiAmount;\n\n\n\n    // May run out of gas\n\n    if(!teamMultisig.send(weiAmount)) throw;\n\n  }\n\n\n\n  /**\n\n   * Pay on a behalf of an address.\n\n   *\n\n   * @param customerId Identifier in the central database, UUID v4\n\n   *\n\n   */\n\n   function pay(uint128 customerId, address benefactor, bytes1 checksum) public stopInEmergency payable {\n\n    // see customerid.py\n\n     if (bytes1(sha3(customerId, benefactor)) != checksum) throw;\n\n     payWithoutChecksum(customerId, benefactor);\n\n   }\n\n\n\n  /**\n\n   * Pay on a behalf of the sender.\n\n   *\n\n   * @param customerId Identifier in the central database, UUID v4\n\n   *\n\n   */\n\n  function payForMyselfWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n\n    // see customerid.py\n\n    if (bytes1(sha3(customerId)) != checksum) throw;\n\n    payWithoutChecksum(customerId, msg.sender);\n\n  }\n\n\n\n  /**\n\n   * Legacy API signature.\n\n   */\n\n  function payForMyself(uint128 customerId) public payable {\n\n    payWithoutChecksum(customerId, msg.sender);\n\n  }\n\n\n\n}",
    "function_sum": 5,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-01-30\n\n*/\n/**\n\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n\n *\n\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n\n */\n/**\n\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\n\n *\n\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\n\n */\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner {\n\n    require(newOwner != address(0));      \n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n/*\n\n * Haltable\n\n *\n\n * Abstract contract that allows children to implement an\n\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\n\n *\n\n *\n\n * Originally envisioned in FirstBlood ICO contract.\n\n */\n\ncontract Haltable is Ownable {\n\n  bool public halted;\n\n\n\n  modifier stopInEmergency {\n\n    if (halted) throw;\n\n    _;\n\n  }\n\n\n\n  modifier stopNonOwnersInEmergency {\n\n    if (halted && msg.sender != owner) throw;\n\n    _;\n\n  }\n\n\n\n  modifier onlyInEmergency {\n\n    if (!halted) throw;\n\n    _;\n\n  }\n\n\n\n  // called by the owner on emergency, triggers stopped state\n\n  function halt() external onlyOwner {\n\n    halted = true;\n\n  }\n\n\n\n  // called by the owner on end of emergency, returns to normal state\n\n  function unhalt() external onlyOwner onlyInEmergency {\n\n    halted = false;\n\n  }\n\n\n\n}\n\n\n\n// You task is to complete the smart contract PaymentForwarder strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title PaymentForwarder\n * @notice A contract to forward payments to a team multisig address, tracking the total amount transferred, number of customers, and individual customer and benefactor contributions.\n * @dev This contract inherits from Haltable, allowing for emergency stops. It records payments and forwards them to a specified team multisig address.\n */\ncontract PaymentForwarder is Haltable {\n\n  /** Who will get all ETH in the end */\n  address public teamMultisig;\n\n  /** Total incoming money */\n  uint public totalTransferred;\n\n  /** How many distinct customers we have that have made a payment */\n  uint public customerCount;\n\n  /** Total incoming money per centrally tracked customer id */\n  mapping(uint128 => uint) public paymentsByCustomer;\n\n  /** Total incoming money per benefactor address */\n  mapping(address => uint) public paymentsByBenefactor;\n\n  /** A customer has made a payment. Benefactor is the address where the tokens will be ultimately issued. */\n  event PaymentForwarded(address source, uint amount, uint128 customerId, address benefactor);\n\n  /**\n   * @notice Initializes the contract with the owner and team multisig addresses.\n   * @dev Sets the `teamMultisig` and `owner` addresses.\n   * @param _owner The address of the contract owner.\n   * @param _teamMultisig The address of the team multisig wallet.\n   */\n  function PaymentForwarder(address _owner, address _teamMultisig) {\n    teamMultisig = _teamMultisig;\n    owner = _owner;\n  }\n\n  /**\n   * @notice Allows a customer to make a payment without a checksum.\n   * @dev Records the payment, updates the total transferred, and forwards the payment to the team multisig address.\n   * @param customerId The unique identifier for the customer.\n   * @param benefactor The address that will benefit from the payment.\n   */\n  function payWithoutChecksum(uint128 customerId, address benefactor) public stopInEmergency payable {}\n\n  /**\n   * @notice Allows a customer to make a payment on behalf of an address with a checksum.\n   * @dev Verifies the checksum and then calls `payWithoutChecksum` to process the payment.\n   * @param customerId The unique identifier for the customer.\n   * @param benefactor The address that will benefit from the payment.\n   * @param checksum The checksum to verify the payment.\n   */\n  function pay(uint128 customerId, address benefactor, bytes1 checksum) public stopInEmergency payable {}\n\n  /**\n   * @notice Allows a customer to make a payment on their own behalf with a checksum.\n   * @dev Verifies the checksum and then calls `payWithoutChecksum` to process the payment.\n   * @param customerId The unique identifier for the customer.\n   * @param checksum The checksum to verify the payment.\n   */\n  function payForMyselfWithChecksum(uint128 customerId, bytes1 checksum) public payable {}\n\n  /**\n   * @notice Allows a customer to make a payment on their own behalf without a checksum.\n   * @dev Calls `payWithoutChecksum` to process the payment.\n   * @param customerId The unique identifier for the customer.\n   */\n  function payForMyself(uint128 customerId) public payable {}\n\n  /**\n   * @notice Fallback function to receive Ether.\n   * @dev Reverts if the contract receives Ether directly.\n   */\n  receive() external payable {}\n}\n"
}