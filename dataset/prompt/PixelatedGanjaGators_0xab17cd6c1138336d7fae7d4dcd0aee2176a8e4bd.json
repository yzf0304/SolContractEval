{
    "contract_name": "ERC721A",
    "ground_truth": "contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 internal currentIndex;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return currentIndex;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        require(index < totalSupply(), \"ERC721A: global index out of bounds\");\n        return index;\n    }\n\n   \n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\n        uint256 numMintedSoFar = totalSupply();\n        uint256 tokenIdsIdx;\n        address currOwnershipAddr;\n\n        // Counter overflow is impossible as the loop breaks when uint256 i is equal to another uint256 numMintedSoFar.\n        unchecked {\n            for (uint256 i; i < numMintedSoFar; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    if (tokenIdsIdx == index) {\n                        return i;\n                    }\n                    tokenIdsIdx++;\n                }\n            }\n        }\n\n        revert(\"ERC721A: unable to get token of owner by index\");\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721A: balance query for the zero address\");\n        return uint256(_addressData[owner].balance);\n    }\n\n    function _numberMinted(address owner) internal view returns (uint256) {\n        require(owner != address(0), \"ERC721A: number minted query for the zero address\");\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    /**\n     * Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\n     */\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {\n        require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\n\n        unchecked {\n            for (uint256 curr = tokenId; curr >= 0; curr--) {\n                TokenOwnership memory ownership = _ownerships[curr];\n                if (ownership.addr != address(0)) {\n                    return ownership;\n                }\n            }\n        }\n\n        revert(\"ERC721A: unable to determine the owner of token\");\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), \".json\")) : \"\";\n    }\n\n   \n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        require(to != owner, \"ERC721A: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721A: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId, owner);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721A: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public override {\n        require(operator != _msgSender(), \"ERC721A: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721A: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n  \n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenId < currentIndex;\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n\n    \n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        _mint(to, quantity, _data, true);\n    }\n\n  \n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {\n        uint256 startTokenId = currentIndex;\n        require(to != address(0), \"ERC721A: mint to the zero address\");\n        require(quantity != 0, \"ERC721A: quantity must be greater than 0\");\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1\n        // updatedIndex overflows if currentIndex + quantity > 1.56e77 (2**256) - 1\n        unchecked {\n            _addressData[to].balance += uint128(quantity);\n            _addressData[to].numberMinted += uint128(quantity);\n\n            _ownerships[startTokenId].addr = to;\n            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);\n\n            uint256 updatedIndex = startTokenId;\n\n            for (uint256 i; i < quantity; i++) {\n                emit Transfer(address(0), to, updatedIndex);\n                if (safe) {\n                    require(\n                        _checkOnERC721Received(address(0), to, updatedIndex, _data),\n                        \"ERC721A: transfer to non ERC721Receiver implementer\"\n                    );\n                }\n\n                updatedIndex++;\n            }\n\n            currentIndex = updatedIndex;\n        }\n\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n            getApproved(tokenId) == _msgSender() ||\n            isApprovedForAll(prevOwnership.addr, _msgSender()));\n\n        require(isApprovedOrOwner, \"ERC721A: transfer caller is not owner nor approved\");\n\n        require(prevOwnership.addr == from, \"ERC721A: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721A: transfer to the zero address\");\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId, prevOwnership.addr);\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\n        unchecked {\n            _addressData[from].balance -= 1;\n            _addressData[to].balance += 1;\n\n            _ownerships[tokenId].addr = to;\n            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);\n\n            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.\n            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.\n            uint256 nextTokenId = tokenId + 1;\n            if (_ownerships[nextTokenId].addr == address(0)) {\n                if (_exists(nextTokenId)) {\n                    _ownerships[nextTokenId].addr = prevOwnership.addr;\n                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721A: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n  \n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n  \n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}",
    "function_sum": 25,
    "compiler_version": "0.8.7",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n// File: @openzeppelin/contracts/utils/Strings.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n/**\n * @dev String operations.\n */\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Context.sol\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n// File: @openzeppelin/contracts/utils/Address.sol\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n/**\n * @dev Collection of functions related to the address type\n */\n\nlibrary Address {\n    \n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n   \n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\n\ninterface IERC721Receiver {\n   \n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n \n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n   \n    function approve(address to, uint256 tokenId) external;\n\n  \n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n   \n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\n\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\n\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\n\n// You task is to complete the smart contract ERC721A strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ERC721A\n * @notice This contract implements the ERC721 standard with additional features for efficient batch minting and enumeration.\n * @dev This implementation is optimized for gas efficiency and includes the IERC721, IERC721Metadata, and IERC721Enumerable interfaces.\n */\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 internal currentIndex;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.\n    mapping(uint256 => TokenOwnership) internal _ownerships;\n\n    // Mapping owner address to address data\n    mapping(address => AddressData) private _addressData;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @notice Initializes the contract by setting a name and a symbol to the token collection.\n     * @dev The constructor sets the name and symbol of the token.\n     * @param name_ The name of the token.\n     * @param symbol_ The symbol of the token.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @notice Returns the total amount of tokens stored by the contract.\n     * @dev This function returns the total supply of tokens.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() public view override returns (uint256) {}\n\n    /**\n     * @notice Returns a token ID at a given index of all the tokens stored by the contract.\n     * @dev This function returns the token ID at a specific index.\n     * @param index A valid index in the list of tokens.\n     * @return The token ID at the given index.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {}\n\n    /**\n     * @notice Returns a token ID at a given index of all the tokens owned by a given address.\n     * @dev This function returns the token ID at a specific index for a given owner.\n     * @param owner The address of the token owner.\n     * @param index A valid index in the list of tokens owned by the owner.\n     * @return The token ID at the given index.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {}\n\n    /**\n     * @notice Returns true if this contract implements the interface defined by `interfaceId`.\n     * @dev This function checks if the contract supports a specific interface.\n     * @param interfaceId The interface identifier, as specified in ERC-165.\n     * @return True if the contract implements the interface, false otherwise.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {}\n\n    /**\n     * @notice Returns the number of tokens in `owner`'s account.\n     * @dev This function returns the balance of a specific owner.\n     * @param owner The address of the token owner.\n     * @return The balance of the owner.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {}\n\n    /**\n     * @notice Returns the number of tokens minted by a given address.\n     * @dev This function returns the number of tokens minted by a specific address.\n     * @param owner The address of the minter.\n     * @return The number of tokens minted by the address.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {}\n\n    /**\n     * @notice Returns the ownership details of a given token ID.\n     * @dev This function returns the ownership details of a specific token.\n     * @param tokenId The ID of the token.\n     * @return The ownership details of the token.\n     */\n    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {}\n\n    /**\n     * @notice Returns the owner of the `tokenId` token.\n     * @dev This function returns the owner of a specific token.\n     * @param tokenId The ID of the token.\n     * @return The owner of the token.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {}\n\n    /**\n     * @notice Returns the name of the token.\n     * @dev This function returns the name of the token.\n     * @return The name of the token.\n     */\n    function name() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @dev This function returns the symbol of the token.\n     * @return The symbol of the token.\n     */\n    function symbol() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the URI for a given token ID.\n     * @dev This function returns the URI for a specific token.\n     * @param tokenId The ID of the token.\n     * @return The URI for the token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the base URI for the token.\n     * @dev This function returns the base URI for the token.\n     * @return The base URI for the token.\n     */\n    function _baseURI() internal view virtual returns (string memory) {}\n\n    /**\n     * @notice Gives permission to `to` to transfer `tokenId` token to another account.\n     * @dev This function approves an address to transfer a specific token.\n     * @param to The address to approve.\n     * @param tokenId The ID of the token to approve.\n     */\n    function approve(address to, uint256 tokenId) public override {}\n\n    /**\n     * @notice Returns the account approved for `tokenId` token.\n     * @dev This function returns the approved address for a specific token.\n     * @param tokenId The ID of the token.\n     * @return The approved address for the token.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {}\n\n    /**\n     * @notice Approve or remove `operator` as an operator for the caller.\n     * @dev This function sets or removes the approval for an operator.\n     * @param operator The address of the operator.\n     * @param approved True if the operator is approved, false to revoke approval.\n     */\n    function setApprovalForAll(address operator, bool approved) public override {}\n\n    /**\n     * @notice Returns if the `operator` is allowed to manage all of `owner`'s assets.\n     * @dev This function checks if an operator is approved for all assets of an owner.\n     * @param owner The address of the token owner.\n     * @param operator The address of the operator.\n     * @return True if the operator is approved for all, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {}\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev This function transfers a specific token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The ID of the token to transfer.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {}\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @dev This function safely transfers a specific token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The ID of the token to transfer.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {}\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @dev This function safely transfers a specific token from one address to another with additional data.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The ID of the token to transfer.\n     * @param _data Additional data with no specified format.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {}\n\n    /**\n     * @notice Checks if a token exists.\n     * @dev This function checks if a specific token exists.\n     * @param tokenId The ID of the token.\n     * @return True if the token exists, false otherwise.\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {}\n\n    /**\n     * @notice Mints `quantity` tokens and transfers them to `to`.\n     * @dev This function mints a specific quantity of tokens and transfers them to an address.\n     * @param to The address to transfer the tokens to.\n     * @param quantity The number of tokens to mint.\n     */\n    function _safeMint(address to, uint256 quantity) internal {}\n\n    /**\n     * @notice Mints `quantity` tokens and transfers them to `to`.\n     * @dev This function mints a specific quantity of tokens and transfers them to an address with additional data.\n     * @param to The address to transfer the tokens to.\n     * @param quantity The number of tokens to mint.\n     * @param _data Additional data with no specified format.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {}\n\n    /**\n     * @notice Mints `quantity` tokens and transfers them to `to`.\n     * @dev This function mints a specific quantity of tokens and transfers them to an address.\n     * @param to The address to transfer the tokens to.\n     * @param quantity The number of tokens to mint.\n     * @param _data Additional data with no specified format.\n     * @param safe Whether to check onERC721Received.\n     * @notice\n     * - Mints NFTs starting from the current index\n     * - Updates balances and ownership records\n     * - Emits Transfer events for each minted NFT\n     * - Performs safety checks for ERC721Receiver if enabled\n     * @dev\n     * - Uses unchecked arithmetic for performance\n     * - Calls _beforeTokenTransfers and _afterTokenTransfers hooks\n     * - Requires valid recipient address and quantity\n     * - Automatically increments the current index\n     */\n    function _mint(\n        address to,\n        uint256 quantity,\n        bytes memory _data,\n        bool safe\n    ) internal {}\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev This function transfers a specific token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The ID of the token to transfer.\n     * @notice\n     * - Verifies sender is owner or approved operator\n     * - Checks for valid 'from' address\n     * - Prevents transfer to zero address\n     * - Emits Transfer event\n     * - Updates ownership and balance records\n     * \n     * @dev\n     * - Uses unchecked arithmetic for performance\n     * - Handles adjacent token ownership continuity\n     * - Calls before/after transfer hooks\n     * - Clears previous approvals\n     * - Maintains data consistency for ownerOf(tokenId+1) checks\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {}\n\n    /**\n     * @notice Approves `to` to operate on `tokenId`.\n     * @dev This function approves an address to operate on a specific token.\n     * @param to The address to approve.\n     * @param tokenId The ID of the token to approve.\n     * @param owner The address of the token owner.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {}\n\n    /**\n     * @notice Checks if the recipient is an ERC721Receiver and if it accepts the token.\n     * @dev This function checks if the recipient is an ERC721Receiver and if it accepts the token.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The ID of the token to transfer.\n     * @param _data Additional data with no specified format.\n     * @return True if the recipient is an ERC721Receiver and accepts the token, false otherwise.\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {}\n\n    /**\n     * @notice Hook that is called before any token transfer.\n     * @dev This function is called before any token transfer.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens to transfer.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @notice Hook that is called after any token transfer.\n     * @dev This function is called after any token transfer.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens to transfer.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"
}