{
    "contract_name": "PortalToken",
    "ground_truth": "contract PortalToken is ERC20Token {\n    address public initialOwner;\n    uint256 public supply   = 1000000000 * 10 ** 18;  // 100, 000, 000\n    string  public name     = 'PortalToken';\n    uint8   public decimals = 18;\n    string  public symbol   = 'PTC';\n    string  public version  = 'v0.1';\n    bool    public transfersEnabled = true;\n    uint    public creationBlock;\n    uint    public creationTime;\n\n    mapping (address => uint256) balance;\n    mapping (address => mapping (address => uint256)) m_allowance;\n    mapping (address => uint) jail;\n    mapping (address => uint256) jailAmount;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function PortalToken() public{\n        initialOwner        = msg.sender;\n        balance[msg.sender] = supply;\n        creationBlock       = block.number;\n        creationTime        = block.timestamp;\n    }\n\n    function balanceOf(address _account) constant public returns (uint) {\n        return balance[_account];\n    }\n\n    function jailAmountOf(address _account) constant public returns (uint256) {\n        return jailAmount[_account];\n    }\n\n    function totalSupply() constant public returns (uint) {\n        return supply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        // `revert()` | `throw`\n        //      http://solidity.readthedocs.io/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions\n        //      https://ethereum.stackexchange.com/questions/20978/why-do-throw-and-revert-create-different-bytecodes/20981\n        if (!transfersEnabled) revert();\n        if ( jail[msg.sender] >= block.timestamp ) revert();\n        if ( balance[msg.sender] - _value < jailAmount[msg.sender]) revert();\n\n        return doTransfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        if (!transfersEnabled) revert();\n        if ( jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();\n        if ( balance[_from] - _value < jailAmount[_from]) revert();\n\n        if (allowance(_from, msg.sender) < _value) revert();\n\n        m_allowance[_from][msg.sender] -= _value;\n\n        if ( !(doTransfer(_from, _to, _value)) ) {\n            m_allowance[_from][msg.sender] += _value;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function doTransfer(address _from, address _to, uint _value) internal returns (bool success) {\n        if (balance[_from] >= _value && balance[_to] + _value >= balance[_to]) {\n            balance[_from] -= _value;\n            balance[_to] += _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if (!transfersEnabled) revert();\n        if ( jail[msg.sender] >= block.timestamp || jail[_spender] >= block.timestamp ) revert();\n        if ( balance[msg.sender] - _value < jailAmount[msg.sender]) revert();\n\n        // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        if ( (_value != 0) && (allowance(msg.sender, _spender) != 0) ) revert();\n\n        m_allowance[msg.sender][_spender] = _value;\n\n        Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        if (!transfersEnabled) revert();\n\n        return m_allowance[_owner][_spender];\n    }\n\n    function enableTransfers(bool _transfersEnabled) public returns (bool) {\n        if (msg.sender != initialOwner) revert();\n        transfersEnabled = _transfersEnabled;\n        return transfersEnabled;\n    }\n\n    function catchYou(address _target, uint _timestamp, uint256 _amount) public returns (uint) {\n        if (msg.sender != initialOwner) revert();\n        if (!transfersEnabled) revert();\n\n        jail[_target] = _timestamp;\n        jailAmount[_target] = _amount;\n\n        return jail[_target];\n    }\n\n}",
    "function_sum": 11,
    "compiler_version": "0.4.22",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n// https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs#transferable-fungibles-see-erc-20-for-the-latest\n\ncontract ERC20Token {\n    // Triggered when tokens are transferred.\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Get the total token supply\n    function totalSupply() constant public returns (uint256 supply);\n\n    // Get the account `balance` of another account with address `_owner`\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n    // Send `_value` amount of tokens to address `_to`\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    // Send `_value` amount of tokens from address `_from` to address `_to`\n    // The `transferFrom` method is used for a withdraw workflow, allowing contracts to send tokens on your behalf,\n    // for example to \"deposit\" to a contract address and/or to charge fees in sub-currencies;\n    // the command should fail unless the `_from` account has deliberately authorized the sender of the message\n    // via some mechanism; we propose these standardized APIs for `approval`:\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n    // If this function is called again it overwrites the current allowance with _value.\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    // Returns the amount which _spender is still allowed to withdraw from _owner\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n}\n\n\n\n// You task is to complete the smart contract PortalToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.22, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title PortalToken\n * @notice This contract implements a basic ERC20 token with additional features such as jail functionality and transfer enabling.\n * @dev The contract extends the ERC20Token interface and includes mappings for balances, allowances, and jail information.\n */\ncontract PortalToken is ERC20Token {\n    address public initialOwner;\n    uint256 public supply   = 1000000000 * 10 ** 18;  // 100, 000, 000\n    string  public name     = 'PortalToken';\n    uint8   public decimals = 18;\n    string  public symbol   = 'PTC';\n    string  public version  = 'v0.1';\n    bool    public transfersEnabled = true;\n    uint    public creationBlock;\n    uint    public creationTime;\n\n    mapping (address => uint256) balance;\n    mapping (address => mapping (address => uint256)) m_allowance;\n    mapping (address => uint) jail;\n    mapping (address => uint256) jailAmount;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n     * @notice Initializes the contract and sets the initial owner's balance to the total supply.\n     * @dev The constructor sets the initial owner, assigns the total supply to the owner, and records the creation block and time.\n     */\n    function PortalToken() public{\n        initialOwner        = msg.sender;\n        balance[msg.sender] = supply;\n        creationBlock       = block.number;\n        creationTime        = block.timestamp;\n    }\n\n    /**\n     * @notice Returns the balance of the specified account.\n     * @param _account The address of the account to check.\n     * @return The balance of the specified account.\n     * @dev This function is marked as `constant` and does not modify the state.\n     */\n    function balanceOf(address _account) constant public returns (uint) {}\n\n    /**\n     * @notice Returns the amount of tokens that are jailed for the specified account.\n     * @param _account The address of the account to check.\n     * @return The amount of jailed tokens for the specified account.\n     * @dev This function is marked as `constant` and does not modify the state.\n     */\n    function jailAmountOf(address _account) constant public returns (uint256) {}\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @return The total supply of the token.\n     * @dev This function is marked as `constant` and does not modify the state.\n     */\n    function totalSupply() constant public returns (uint) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from the sender to the recipient.\n     * @param _to The address of the recipient.\n     * @param _value The amount of tokens to transfer.\n     * @return success A boolean value indicating whether the transfer was successful.\n     * @dev This function checks if transfers are enabled, if the sender is jailed, and if the sender has enough balance.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Transfers tokens from one account to another using allowance mechanism.\n     * @param _from Source account address (must not be jailed and have sufficient balance)\n     * @param _to Destination account address (must not be jailed)\n     * @param _value Amount of tokens to transfer (must be within allowance)\n     * @return bool True if transfer succeeded, false otherwise\n     * @dev\n     * - Checks if transfers are enabled\n     * - Verifies no involved accounts are jailed\n     * - Ensures sufficient balance and allowance\n     * - Deducts from allowance upon successful transfer\n     * - Reverts allowance if transfer fails\n     * - Uses doTransfer for actual transfer execution\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {}\n\n    /**\n     * @notice Internal function to perform the actual transfer of tokens.\n     * @param _from The address of the account to transfer from.\n     * @param _to The address of the recipient.\n     * @param _value The amount of tokens to transfer.\n     * @return success A boolean value indicating whether the transfer was successful.\n     * @dev This function updates the balances and emits a Transfer event.\n     */\n    function doTransfer(address _from, address _to, uint _value) internal returns (bool success) {}\n\n    /**\n     * @notice Approves a specified address to spend a certain amount of tokens on behalf of the sender.\n     * @param _spender The address to approve.\n     * @param _value The amount of tokens to approve.\n     * @return success A boolean value indicating whether the approval was successful.\n     * @dev This function checks if transfers are enabled, if the sender or spender is jailed, and if the allowance is valid.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Returns the remaining number of tokens that a spender is allowed to spend on behalf of an owner.\n     * @param _owner The address of the token owner.\n     * @param _spender The address of the spender.\n     * @return The remaining allowance.\n     * @dev This function checks if transfers are enabled.\n     */\n    function allowance(address _owner, address _spender) constant public returns (uint256) {}\n\n    /**\n     * @notice Enables or disables token transfers.\n     * @param _transfersEnabled A boolean value indicating whether transfers should be enabled.\n     * @return A boolean value indicating the new state of transfers.\n     * @dev This function can only be called by the initial owner.\n     */\n    function enableTransfers(bool _transfersEnabled) public returns (bool) {}\n\n    /**\n     * @notice Jails a specified address, preventing them from transferring tokens until a specified timestamp.\n     * @param _target The address to jail.\n     * @param _timestamp The timestamp until which the target is jailed.\n     * @param _amount The amount of tokens to jail.\n     * @return The timestamp until which the target is jailed.\n     * @dev This function can only be called by the initial owner and checks if transfers are enabled.\n     */\n    function catchYou(address _target, uint _timestamp, uint256 _amount) public returns (uint) {}\n\n    /**\n     * @notice Fallback function to receive Ether.\n     * @dev This function is used to receive Ether and does nothing in this contract.\n     */\n    function() external payable {}\n}\n"
}