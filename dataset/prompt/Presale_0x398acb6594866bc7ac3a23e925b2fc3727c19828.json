{
    "contract_name": "Presale",
    "ground_truth": "contract Presale is Claimable, Pausable {\n\n  using Discounts for Discounts.Collection;\n\n  using Limits for Limits.Window;\n\n\n\n  struct Participant {\n\n    bool authorized;\n\n\n\n    uint256 minimumTier;\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * STORAGE / EVENTS\n\n   *************************************************************************/\n\n\n\n  SeeToken token;\n\n  Discounts.Collection discounts;\n\n  Limits.Window cap;\n\n\n\n  mapping (address => Participant) participants;\n\n\n\n\n\n  event Tier(uint256 discount, uint256 available);\n\n\n\n\n\n  /**************************************************************************\n\n   * CONSTRUCTOR / LIFECYCLE\n\n   *************************************************************************/\n\n\n\n  function Presale(address _token)\n\n    public\n\n  {\n\n    token = SeeToken(_token);\n\n\n\n    paused = true;\n\n  }\n\n\n\n  /*\n\n   * @dev (Done as part of migration) Claims ownership of token contract\n\n   */\n\n  function claimToken() public {\n\n    token.claimOwnership();\n\n  }\n\n\n\n  /*\n\n   * Allow purchase\n\n   * @dev while paused\n\n   */\n\n  function unpause()\n\n    onlyOwner\n\n    whenPaused\n\n    whenRateSet\n\n    whenCapped\n\n    whenOwnsToken\n\n    public\n\n  {\n\n    super.unpause();\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * ADMIN INTERFACE\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * Set the base purchase rate for the token\n\n   * @param _purchaseRate - number of tokens granted per wei\n\n   */\n\n  function setRate(uint256 _purchaseRate)\n\n    onlyOwner\n\n    whenPaused\n\n    public\n\n  {\n\n    discounts.baseRate = _purchaseRate;\n\n  }\n\n\n\n  /*\n\n   * Specify purchasing limits for a single account: the limit of tokens\n\n   * that a participant may purchase in a set amount of time (blocks)\n\n   * @param _amount - Number of tokens\n\n   * @param _duration - Number of blocks\n\n   */\n\n  function limitPurchasing(uint256 _amount, uint256 _duration)\n\n    onlyOwner\n\n    whenPaused\n\n    public\n\n  {\n\n    cap.amount = _amount;\n\n    cap.duration = _duration;\n\n  }\n\n\n\n  /*\n\n   * Add a tier with a given discount and available supply\n\n   * @param _discount - Discount in basis points\n\n   * @param _available - Available supply at tier\n\n   */\n\n  function addTier(uint256 _discount, uint256 _available)\n\n    onlyOwner\n\n    whenPaused\n\n    public\n\n  {\n\n    discounts.addTier(_discount, _available);\n\n\n\n    Tier(_discount, _available);\n\n  }\n\n\n\n  /*\n\n   * Authorize a group of participants for a tier\n\n   * @param _minimumTier - minimum tier for list of participants\n\n   * @param _participants - array of authorized addresses\n\n   */\n\n  function authorizeForTier(uint256 _minimumTier, address[] _authorized)\n\n    onlyOwner\n\n    public\n\n  {\n\n    for (uint256 i = 0; i < _authorized.length; i++) {\n\n      participants[_authorized[i]] = Participant({\n\n        authorized: true,\n\n        minimumTier: _minimumTier\n\n      });\n\n    }\n\n  }\n\n\n\n  /*\n\n   * Withdraw balance from presale\n\n   */\n\n  function withdraw()\n\n    onlyOwner\n\n    public\n\n  {\n\n    owner.transfer(this.balance);\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * PURCHASE INTERFACE\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * Fallback (default) function.\n\n   * @dev Forwards to `purchaseTokens()`\n\n   */\n\n  function ()\n\n    public\n\n    payable\n\n  {\n\n    purchaseTokens();\n\n  }\n\n\n\n  /*\n\n   * Public purchase interface for authorized Dragon Holders\n\n   * @dev Purchases tokens starting in authorized minimum tier\n\n   */\n\n  function purchaseTokens()\n\n    onlyAuthorized\n\n    whenNotPaused\n\n    public\n\n    payable\n\n  {\n\n    var limit = cap.getLimit(msg.sender);\n\n\n\n    var (purchased, refund) = discounts.purchaseTokens(\n\n      limit,\n\n      msg.value,\n\n      participants[msg.sender].minimumTier\n\n    );\n\n\n\n    cap.recordPurchase(msg.sender, purchased);\n\n\n\n    // issue new tokens\n\n    token.issue(msg.sender, purchased);\n\n\n\n    // if there are funds left, send refund\n\n    if (refund > 0) {\n\n      msg.sender.transfer(refund);\n\n    }\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * PRICING / AVAILABILITY - VIEW INTERFACE\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * Get terms for purchasing limit window\n\n   * @return number of tokens and duration in blocks\n\n   */\n\n  function getPurchaseLimit()\n\n    public\n\n    view\n\n    returns (uint256 _amount, uint256 _duration)\n\n  {\n\n    _amount = cap.amount;\n\n    _duration = cap.duration;\n\n  }\n\n\n\n  /*\n\n   * Get tiers currently set up, with discounts and available supplies\n\n   * @return array of tuples (discount, available)\n\n   */\n\n  function getTiers()\n\n    public\n\n    view\n\n    returns (uint256[2][])\n\n  {\n\n    var records = discounts.tiers;\n\n    uint256[2][] memory tiers = new uint256[2][](records.length);\n\n\n\n    for (uint256 i = 0; i < records.length; i++) {\n\n      tiers[i][0] = records[i].discount;\n\n      tiers[i][1] = records[i].available;\n\n    }\n\n\n\n    return tiers;\n\n  }\n\n\n\n  /*\n\n   * Get available supply for each tier for a given participant\n\n   * @dev starts at minimum tier for participant (requiring auth)\n\n   * @return available supply by tier index, zeroes for non-auth\n\n   */\n\n  function getAvailability(address _participant)\n\n    public\n\n    view\n\n    returns (uint256[])\n\n  {\n\n    var participant = participants[_participant];\n\n    uint256 minimumTier = participant.minimumTier;\n\n\n\n    // minor HACK - if the participant isn't authorized, just set the\n\n    // minimum tier above the bounds\n\n    if (!participant.authorized) {\n\n      minimumTier = discounts.tiers.length;\n\n    }\n\n\n\n    uint256[] memory tiers = new uint256[](discounts.tiers.length);\n\n\n\n    for (uint256 i = minimumTier; i < tiers.length; i++) {\n\n      tiers[i] = discounts.tiers[i].available;\n\n    }\n\n\n\n    return tiers;\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * MODIFIERS\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * @dev require participant is whitelist-authorized\n\n   */\n\n  modifier onlyAuthorized() {\n\n    require(participants[msg.sender].authorized);\n\n    _;\n\n  }\n\n\n\n  /*\n\n   * @dev baseRate will default to 0\n\n   */\n\n  modifier whenRateSet() {\n\n    require(discounts.baseRate != 0);\n\n    _;\n\n  }\n\n\n\n  /*\n\n   * @dev to prevent accidentally capping at 0\n\n   */\n\n  modifier whenCapped() {\n\n    require(cap.amount != 0);\n\n    _;\n\n  }\n\n\n\n  /*\n\n   * @dev asserts zeppelin Claimable workflow is finalized\n\n   */\n\n  modifier whenOwnsToken() {\n\n    require(token.owner() == address(this));\n\n    _;\n\n  }\n\n}",
    "function_sum": 12,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n// File: contracts/Discounts.sol\n\nlibrary Discounts {\n\n  using SafeMath for uint256;\n\n\n\n  /**************************************************************************\n\n   * TYPES\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * Top-level struct for grouping of tiers with a base purchase rate\n\n   */\n\n  struct Collection {\n\n    Tier[] tiers;\n\n\n\n    // number of tokens per wei\n\n    uint256 baseRate;\n\n  }\n\n\n\n  /*\n\n   * Struct for a given tier - discount and availability\n\n   */\n\n  struct Tier {\n\n    // discount the set purchase price, expressed in basis points (\u2031)\n\n    // range (0\u2031 .. 10,000\u2031) corresponds to (0.00% .. 100.00%)\n\n    uint256 discount;\n\n\n\n    // number of remaining available tokens in tier\n\n    uint256 available;\n\n  }\n\n\n\n  // upper-bound of basis point scale\n\n  uint256 public constant MAX_DISCOUNT = 10000;\n\n\n\n\n\n  /**************************************************************************\n\n   * CREATE\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * @dev Add a new tier at the end of the list\n\n   * @param _discount - Discount in basis points\n\n   * @param _available - Available supply at tier\n\n   */\n\n  function addTier(\n\n    Collection storage self,\n\n    uint256 _discount,\n\n    uint256 _available\n\n  )\n\n    internal\n\n  {\n\n    self.tiers.push(Tier({\n\n      discount: _discount,\n\n      available: _available\n\n    }));\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * PURCHASE\n\n   *************************************************************************/\n\n\n\n  /*\n\n   * @dev Subtracts supply from tiers starting at a minimum, using up funds\n\n   * @param _amount - Maximum number of tokens to purchase\n\n   * @param _funds - Allowance in Wei\n\n   * @param _minimumTier - Minimum tier to start purchasing from\n\n   * @return Total tokens purchased and remaining funds in wei\n\n   */\n\n  function purchaseTokens(\n\n    Collection storage self,\n\n    uint256 _amount,\n\n    uint256 _funds,\n\n    uint256 _minimumTier\n\n  )\n\n    internal\n\n    returns (\n\n      uint256 purchased,\n\n      uint256 remaining\n\n    )\n\n  {\n\n    uint256 issue = 0; // tracks total tokens to issue\n\n    remaining = _funds;\n\n\n\n    uint256 available;  // var for available tokens at tier\n\n    uint256 spend; // amount spent at tier\n\n    uint256 affordable;  // var for # funds can pay for at tier\n\n    uint256 purchase; // var for # to purchase at tier\n\n\n\n    // for each tier starting at minimum\n\n    // draw from the sent funds and count tokens to issue\n\n    for (var i = _minimumTier; i < self.tiers.length && issue < _amount; i++) {\n\n      // get the available tokens left at each tier\n\n      available = self.tiers[i].available;\n\n\n\n      // compute the maximum tokens that the funds can pay for\n\n      affordable = _computeTokensPurchasedAtTier(self, i, remaining);\n\n\n\n      // either purchase what the funds can afford, or the whole supply\n\n      // at the tier\n\n      if (affordable < available) {\n\n        purchase = affordable;\n\n      } else {\n\n        purchase = available;\n\n      }\n\n\n\n      // limit the amount purchased up to specified amount\n\n      // use safemath here in case of unknown overflow risk\n\n      if (purchase.add(issue) > _amount) {\n\n        purchase = _amount.sub(issue);\n\n      }\n\n\n\n      spend = _computeCostForTokensAtTier(self, i, purchase);\n\n\n\n      // decrease available supply at tier\n\n      self.tiers[i].available -= purchase;\n\n\n\n      // increase tokens to issue\n\n      issue += purchase;\n\n\n\n      // decrement funds to proceed\n\n      remaining -= spend;\n\n    }\n\n\n\n    return (issue, remaining);\n\n  }\n\n\n\n\n\n  /**************************************************************************\n\n   * PRICE MATH\n\n   *************************************************************************/\n\n\n\n  // @return total number of tokens for an amount of wei, discount-adjusted\n\n  function _computeTokensPurchasedAtTier(\n\n    Collection storage self,\n\n    uint256 _tier,\n\n    uint256 _wei\n\n  )\n\n    private\n\n    view\n\n    returns (uint256)\n\n  {\n\n    var paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);\n\n\n\n    return _wei.mul(self.baseRate).mul(MAX_DISCOUNT) / paidBasis;\n\n  }\n\n\n\n  // @return cost in wei for that many tokens\n\n  function _computeCostForTokensAtTier(\n\n    Collection storage self,\n\n    uint256 _tier,\n\n    uint256 _tokens\n\n  )\n\n    private\n\n    view\n\n    returns (uint256)\n\n  {\n\n    var paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);\n\n\n\n    var numerator = _tokens.mul(paidBasis);\n\n    var denominator = MAX_DISCOUNT.mul(self.baseRate);\n\n\n\n    var floor = _tokens.mul(paidBasis).div(\n\n      MAX_DISCOUNT.mul(self.baseRate)\n\n    );\n\n\n\n    // must round up cost to next wei (cause token computation rounds down)\n\n    if (numerator % denominator != 0) {\n\n      floor = floor + 1;\n\n    }\n\n\n\n    return floor;\n\n  }\n\n}\n\n// File: contracts/Limits.sol\n\nlibrary Limits {\n\n  using SafeMath for uint256;\n\n\n\n  struct PurchaseRecord {\n\n    uint256 blockNumber;\n\n    uint256 amount;\n\n  }\n\n\n\n  struct Window {\n\n    uint256 amount;  // # of tokens\n\n    uint256 duration;  // # of blocks\n\n\n\n    mapping (address => PurchaseRecord) purchases;\n\n  }\n\n\n\n  /*\n\n   * Record a purchase towards a purchaser's cap limit\n\n   * @dev resets the purchaser's cap if the window duration has been met\n\n   * @param _participant - purchaser\n\n   * @param _amount - token amount of new purchase\n\n   */\n\n  function recordPurchase(\n\n    Window storage self,\n\n    address _participant,\n\n    uint256 _amount\n\n  )\n\n    internal\n\n  {\n\n    var blocksLeft = getBlocksUntilReset(self, _participant);\n\n    var record = self.purchases[_participant];\n\n\n\n    if (blocksLeft == 0) {\n\n      record.amount = _amount;\n\n      record.blockNumber = block.number;\n\n    } else {\n\n      record.amount = record.amount.add(_amount);\n\n    }\n\n  }\n\n\n\n  /*\n\n   * Retrieve the current limit for a given participant, based on previous\n\n   * purchase history\n\n   * @param _participant - Purchaser\n\n   * @return amount of tokens left for participant with cap\n\n   */\n\n  function getLimit(Window storage self, address _participant)\n\n    public\n\n    view\n\n    returns (uint256 _amount)\n\n  {\n\n    var blocksLeft = getBlocksUntilReset(self, _participant);\n\n\n\n    if (blocksLeft == 0) {\n\n      return self.amount;\n\n    } else {\n\n      return self.amount.sub(self.purchases[_participant].amount);\n\n    }\n\n  }\n\n\n\n  function getBlocksUntilReset(Window storage self, address _participant)\n\n    public\n\n    view\n\n    returns (uint256 _blocks)\n\n  {\n\n    var expires = self.purchases[_participant].blockNumber + self.duration;\n\n    if (block.number > expires) {\n\n      return 0;\n\n    } else {\n\n      return expires - block.number;\n\n    }\n\n  }\n\n}\n\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n\n * @title Ownable\n\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n\n * functions, this simplifies the implementation of \"user permissions\".\n\n */\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n\n\n  /**\n\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n\n   * account.\n\n   */\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Throws if called by any account other than the owner.\n\n   */\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n\n\n  /**\n\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n\n\n}\n\n// File: zeppelin-solidity/contracts/ownership/Claimable.sol\n/**\n\n * @title Claimable\n\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n\n * This allows the new owner to accept the transfer.\n\n */\n\ncontract Claimable is Ownable {\n\n  address public pendingOwner;\n\n\n\n  /**\n\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n\n   */\n\n  modifier onlyPendingOwner() {\n\n    require(msg.sender == pendingOwner);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the current owner to set the pendingOwner address.\n\n   * @param newOwner The address to transfer ownership to.\n\n   */\n\n  function transferOwnership(address newOwner) onlyOwner public {\n\n    pendingOwner = newOwner;\n\n  }\n\n\n\n  /**\n\n   * @dev Allows the pendingOwner address to finalize the transfer.\n\n   */\n\n  function claimOwnership() onlyPendingOwner public {\n\n    OwnershipTransferred(owner, pendingOwner);\n\n    owner = pendingOwner;\n\n    pendingOwner = address(0);\n\n  }\n\n}\n\n// File: contracts/SeeToken.sol\n/**\n\n * @title SEE Token\n\n * Not a full ERC20 token - prohibits transferring. Serves as a record of\n\n * account, to redeem for real tokens after launch.\n\n */\n\ncontract SeeToken is Claimable {\n\n  using SafeMath for uint256;\n\n\n\n  string public constant name = \"See Presale Token\";\n\n  string public constant symbol = \"SEE\";\n\n  uint8 public constant decimals = 18;\n\n\n\n  uint256 public totalSupply;\n\n  mapping (address => uint256) balances;\n\n\n\n  event Issue(address to, uint256 amount);\n\n\n\n  /**\n\n   * @dev Issue new tokens\n\n   * @param _to The address that will receive the minted tokens\n\n   * @param _amount the amount of new tokens to issue\n\n   */\n\n  function issue(address _to, uint256 _amount) onlyOwner public {\n\n    totalSupply = totalSupply.add(_amount);\n\n    balances[_to] = balances[_to].add(_amount);\n\n\n\n    Issue(_to, _amount);\n\n  }\n\n\n\n  /**\n\n   * @dev Get the balance for a particular token holder\n\n   * @param _holder The token holder's address\n\n   * @return The holder's balance\n\n   */\n\n  function balanceOf(address _holder) public view returns (uint256 balance) {\n\n    balance = balances[_holder];\n\n  }\n\n}\n\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n\n * @title Pausable\n\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n\n */\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is not paused.\n\n   */\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev Modifier to make a function callable only when the contract is paused.\n\n   */\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to pause, triggers stopped state\n\n   */\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    Pause();\n\n  }\n\n\n\n  /**\n\n   * @dev called by the owner to unpause, returns to normal state\n\n   */\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    Unpause();\n\n  }\n\n}\n\n\n\n// You task is to complete the smart contract Presale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title Presale\n * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.\n * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,\n *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.\n */\ncontract Presale is Claimable, Pausable {\n\n  using Discounts for Discounts.Collection;\n  using Limits for Limits.Window;\n\n  /**\n   * @notice Struct to store participant information.\n   * @dev Contains whether the participant is authorized and their minimum tier.\n   */\n  struct Participant {\n    bool authorized;\n    uint256 minimumTier;\n  }\n\n  /**************************************************************************\n   * STORAGE / EVENTS\n   *************************************************************************/\n\n  SeeToken token;\n  Discounts.Collection discounts;\n  Limits.Window cap;\n  mapping (address => Participant) participants;\n\n  /**\n   * @notice Emitted when a new tier is added.\n   * @param discount The discount in basis points.\n   * @param available The available supply at the tier.\n   */\n  event Tier(uint256 discount, uint256 available);\n\n  /**************************************************************************\n   * CONSTRUCTOR / LIFECYCLE\n   *************************************************************************/\n\n  function Presale(address _token)\n    public\n  {\n    token = SeeToken(_token);\n    paused = true;\n  }\n\n  /**\n   * @notice Claims ownership of the token contract.\n   * @dev This function should be called as part of the migration process.\n   */\n  function claimToken() public {\n    token.claimOwnership();\n  }\n\n  /**\n   * @notice Unpauses the contract, allowing purchases.\n   * @dev Can only be called by the owner, and the contract must be paused, have a set rate, be capped, and own the token.\n   */\n  function unpause()\n    onlyOwner\n    whenPaused\n    whenRateSet\n    whenCapped\n    whenOwnsToken\n    public\n  {\n    super.unpause();\n  }\n\n  /**************************************************************************\n   * ADMIN INTERFACE\n   *************************************************************************/\n\n  /**\n   * @notice Sets the base purchase rate for the token.\n   * @param _purchaseRate The number of tokens granted per wei.\n   * @dev Can only be called by the owner and while the contract is paused.\n   */\n  function setRate(uint256 _purchaseRate)\n    onlyOwner\n    whenPaused\n    public\n  {}\n\n  /**\n   * @notice Specifies purchasing limits for a single account.\n   * @param _amount The limit of tokens that a participant may purchase.\n   * @param _duration The duration in blocks over which the limit applies.\n   * @dev Can only be called by the owner and while the contract is paused.\n   */\n  function limitPurchasing(uint256 _amount, uint256 _duration)\n    onlyOwner\n    whenPaused\n    public\n  {}\n\n  /**\n   * @notice Adds a new tier with a given discount and available supply.\n   * @param _discount The discount in basis points.\n   * @param _available The available supply at the tier.\n   * @dev Can only be called by the owner and while the contract is paused.\n   */\n  function addTier(uint256 _discount, uint256 _available)\n    onlyOwner\n    whenPaused\n    public\n  {}\n\n  /**\n   * @notice Authorizes a group of participants for a specific tier.\n   * @param _minimumTier The minimum tier for the list of participants.\n   * @param _authorized An array of addresses to be authorized.\n   * @dev Can only be called by the owner.\n   */\n  function authorizeForTier(uint256 _minimumTier, address[] _authorized)\n    onlyOwner\n    public\n  {}\n\n  /**\n   * @notice Withdraws the balance from the presale contract.\n   * @dev Can only be called by the owner.\n   */\n  function withdraw()\n    onlyOwner\n    public\n  {}\n\n  /**************************************************************************\n   * PURCHASE INTERFACE\n   *************************************************************************/\n\n  /**\n   * @notice Fallback function that forwards to `purchaseTokens()`.\n   * @dev Accepts Ether and calls `purchaseTokens()`.\n   */\n  function ()\n    public\n    payable\n  {}\n\n  /**\n   * @notice Public purchase interface for authorized participants.\n   * @dev Purchases tokens starting from the authorized minimum tier.\n   * Can only be called by an authorized participant and while the contract is not paused.\n   */\n  function purchaseTokens()\n    onlyAuthorized\n    whenNotPaused\n    public\n    payable\n  {}\n\n  /**************************************************************************\n   * PRICING / AVAILABILITY - VIEW INTERFACE\n   *************************************************************************/\n\n  /**\n   * @notice Gets the terms for the purchasing limit window.\n   * @return _amount The number of tokens allowed.\n   * @return _duration The duration in blocks.\n   */\n  function getPurchaseLimit()\n    public\n    view\n    returns (uint256 _amount, uint256 _duration)\n  {}\n\n  /**\n   * @notice Gets the tiers currently set up, with discounts and available supplies.\n   * @return An array of tuples (discount, available).\n   */\n  function getTiers()\n    public\n    view\n    returns (uint256[2][])\n  {}\n\n  /**\n   * @notice Gets the available supply for each tier for a given participant.\n   * @param _participant The address of the participant.\n   * @return An array of available supplies by tier index, zeroes for non-authorized participants.\n   */\n  function getAvailability(address _participant)\n    public\n    view\n    returns (uint256[])\n  {}\n\n  /**************************************************************************\n   * MODIFIERS\n   *************************************************************************/\n\n  /**\n   * @dev Requires the participant to be whitelist-authorized.\n   */\n  modifier onlyAuthorized() {\n    require(participants[msg.sender].authorized);\n    _;\n  }\n\n  /**\n   * @dev Ensures the base rate is set (not zero).\n   */\n  modifier whenRateSet() {\n    require(discounts.baseRate != 0);\n    _;\n  }\n\n  /**\n   * @dev Ensures the contract is capped (cap amount is not zero).\n   */\n  modifier whenCapped() {\n    require(cap.amount != 0);\n    _;\n  }\n\n  /**\n   * @dev Ensures the contract owns the token.\n   */\n  modifier whenOwnsToken() {\n    require(token.owner() == address(this));\n    _;\n  }\n}\n"
}