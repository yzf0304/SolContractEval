{
    "contract_name": "ROAD",
    "ground_truth": "contract ROAD is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    uint256 public _totalSupply;\n    \n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor() public {\n        name = \"ROAD\";\n        symbol = \"ROAD\";\n        decimals = 18;\n        _totalSupply = 2 * 10 ** 27;\n        \n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    function totalSupply() public view returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n    \n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n    \n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n    \n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    \n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    \n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n}",
    "function_sum": 6,
    "compiler_version": "0.5.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-03-13\n*/\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// ----------------------------------------------------------------------------\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library \n// ----------------------------------------------------------------------------\n\ncontract SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a); \n        c = a - b; \n    } \n    function safeMul(uint a, uint b) public pure returns (uint c) { \n        c = a * b; \n        require(a == 0 || c / a == b); \n    } \n    function safeDiv(uint a, uint b) public pure returns (uint c) { \n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\n\n// You task is to complete the smart contract ROAD strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ROAD Token Contract\n * @notice This contract implements the ERC20 token standard and includes additional safety checks using SafeMath.\n * @dev The contract is designed to be a simple, secure, and compliant token for the ROAD project.\n */\ncontract ROAD is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n    uint256 public _totalSupply;\n    \n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n    \n    /**\n     * @notice Constructor function initializes the contract with an initial supply of tokens to the creator.\n     * @dev Sets the token name, symbol, decimals, and total supply. Also, it assigns the total supply to the contract creator.\n     */\n    constructor() public {\n        name = \"ROAD\";\n        symbol = \"ROAD\";\n        decimals = 18;\n        _totalSupply = 2 * 10 ** 27;\n        \n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n    \n    /**\n     * @notice Returns the total token supply available, excluding any tokens sent to the zero address.\n     * @dev This function calculates the total supply by subtracting the balance of the zero address from the total supply.\n     * @return Total supply of tokens.\n     */\n    function totalSupply() public view returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n    \n    /**\n     * @notice Returns the account balance of another account with address `tokenOwner`.\n     * @dev This function simply returns the balance stored in the `balances` mapping.\n     * @param tokenOwner The address of the account to check the balance of.\n     * @return The balance of the specified account.\n     */\n    function balanceOf(address tokenOwner) public view returns (uint balance) {}\n    \n    /**\n     * @notice Returns the amount of tokens that an owner allowed to a spender.\n     * @dev This function retrieves the allowance value from the `allowed` mapping.\n     * @param tokenOwner The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The remaining amount of tokens allowed to be spent by the spender.\n     */\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {}\n    \n    /**\n     * @notice Allows `spender` to withdraw from your account multiple times, up to the `tokens` amount.\n     * @dev If this function is called again, it overwrites the current allowance with `tokens`.\n     * @param spender The address which will spend the funds.\n     * @param tokens The amount of tokens to be approved.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint tokens) public returns (bool success) {}\n    \n    /**\n     * @notice Transfers `tokens` amount of tokens from the message sender's account to `to`.\n     * @dev Uses SafeMath functions to prevent underflow and overflow.\n     * @param to The recipient address.\n     * @param tokens The amount of tokens to transfer.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address to, uint tokens) public returns (bool success) {}\n    \n    /**\n     * @notice Transfers `tokens` amount of tokens from `from` to `to`, using the allowance mechanism.\n     * @dev Decreases the allowance of `from` to the caller by `tokens` and transfers the tokens to `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param tokens The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {}\n}\n"
}