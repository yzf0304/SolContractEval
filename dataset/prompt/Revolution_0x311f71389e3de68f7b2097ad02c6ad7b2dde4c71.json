{
    "contract_name": "Revolution",
    "ground_truth": "contract Revolution is Accessibility, PaymentSystem {\n\n  using Percent for Percent.percent;\n\n  using SafeMath for uint;\n\n  using Zero for *;\n\n  using ToAddress for *;\n\n\n\n  // investors storage - iterable map;\n\n  InvestorsStorage private m_investors;\n\n  mapping(address => bool) private m_referrals;\n\n  bool private m_nextWave;\n\n\n\n  // automatically generates getters\n\n  address public adminAddr;\n\n  address public payerAddr;\n\n  uint public waveStartup;\n\n  uint public investmentsNum;\n\n  uint public constant minInvesment = 10 finney; // 0.01 eth\n\n  uint public constant maxBalance = 333e5 ether; // 33,300,000 eth\n\n  uint public constant pauseOnNextWave = 168 hours; \n\n\n\n  // percents \n\n  Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 333/10000*100% = 3.33%\n\n  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%\n\n  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%\n\n  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%\n\n\n\n  // more events for easy read from blockchain\n\n  event LogNewInvestor(address indexed addr, uint when, uint value);\n\n  event LogNewInvesment(address indexed addr, uint when, uint value);\n\n  event LogNewReferral(address indexed addr, uint when, uint value);\n\n  event LogPayDividends(address indexed addr, uint when, uint value);\n\n  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n\n  event LogBalanceChanged(uint when, uint balance);\n\n  event LogAdminAddrChanged(address indexed addr, uint when);\n\n  event LogPayerAddrChanged(address indexed addr, uint when);\n\n  event LogNextWave(uint when);\n\n\n\n  modifier balanceChanged {\n\n    _;\n\n    emit LogBalanceChanged(now, address(this).balance);\n\n  }\n\n\n\n  modifier notOnPause() {\n\n    require(waveStartup+pauseOnNextWave <= now, \"pause on next wave not expired\");\n\n    _;\n\n  }\n\n\n\n  constructor() public {\n\n    adminAddr = msg.sender;\n\n    emit LogAdminAddrChanged(msg.sender, now);\n\n\n\n    payerAddr = msg.sender;\n\n    emit LogPayerAddrChanged(msg.sender, now);\n\n\n\n    nextWave();\n\n    waveStartup = waveStartup.sub(pauseOnNextWave);\n\n  }\n\n\n\n  function() public payable {\n\n    // investor get him dividends\n\n    if (msg.value == 0) {\n\n      getMyDividends();\n\n      return;\n\n    }\n\n\n\n    // sender do invest\n\n    address a = msg.data.toAddr();\n\n    address[3] memory refs;\n\n    if (a.notZero()) {\n\n      refs[0] = a;\n\n      doInvest(refs); \n\n    } else {\n\n      doInvest(refs);\n\n    }\n\n  }\n\n\n\n  function investorsNumber() public view returns(uint) {\n\n    return m_investors.size()-1;\n\n    // -1 because see InvestorsStorage constructor where keys.length++ \n\n  }\n\n\n\n  function balanceETH() public view returns(uint) {\n\n    return address(this).balance;\n\n  }\n\n\n\n  function payerPercent() public view returns(uint numerator, uint denominator) {\n\n    (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);\n\n  }\n\n\n\n  function dividendsPercent() public view returns(uint numerator, uint denominator) {\n\n    (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);\n\n  }\n\n\n\n  function adminPercent() public view returns(uint numerator, uint denominator) {\n\n    (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);\n\n  }\n\n\n\n  function referrerPercent() public view returns(uint numerator, uint denominator) {\n\n    (numerator, denominator) = (m_refPercent.num, m_refPercent.den);\n\n  }\n\n\n\n  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {\n\n    (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);\n\n    isReferral = m_referrals[addr];\n\n  }\n\n\n\n  function latestPayout() public view returns(uint timestamp) {\n\n    return m_paysys.latestTime;\n\n  }\n\n\n\n  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {\n\n    // check investor info\n\n    InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);\n\n    require(investor.keyIndex > 0, \"sender is not investor\"); \n\n    if (investor.paymentTime < m_paysys.latestTime) {\n\n      assert(m_investors.setPaymentTime(msg.sender, m_paysys.latestTime));\n\n      investor.paymentTime = m_paysys.latestTime;\n\n    }\n\n\n\n    // calculate days after latest payment\n\n    uint256 daysAfter = now.sub(investor.paymentTime).div(24 hours);\n\n    require(daysAfter > 0, \"the latest payment was earlier than 24 hours\");\n\n    assert(m_investors.setPaymentTime(msg.sender, now));\n\n\n\n    // check enough eth \n\n    uint value = m_dividendsPercent.mul(investor.value) * daysAfter;\n\n    if (address(this).balance < value + investor.refBonus) {\n\n      nextWave();\n\n      return;\n\n    }\n\n\n\n    // send dividends and ref bonus\n\n    if (investor.refBonus > 0) {\n\n      assert(m_investors.setRefBonus(msg.sender, 0));\n\n      sendDividendsWithRefBonus(msg.sender, value, investor.refBonus);\n\n    } else {\n\n      sendDividends(msg.sender, value);\n\n    }\n\n  }\n\n\n\n  function doInvest(address[3] refs) public payable notOnPause balanceChanged {\n\n    require(msg.value >= minInvesment, \"msg.value must be >= minInvesment\");\n\n    require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\n\n\n\n    uint value = msg.value;\n\n    // ref system works only once for sender-referral\n\n    if (!m_referrals[msg.sender]) {\n\n      // level 1\n\n      if (notZeroNotSender(refs[0]) && m_investors.contains(refs[0])) {\n\n        uint reward = m_refPercent.mul(value);\n\n        assert(m_investors.addRefBonus(refs[0], reward)); // referrer 1 bonus\n\n        m_referrals[msg.sender] = true;\n\n        value = m_dividendsPercent.add(value); // referral bonus\n\n        emit LogNewReferral(msg.sender, now, value);\n\n        // level 2\n\n        if (notZeroNotSender(refs[1]) && m_investors.contains(refs[1]) && refs[0] != refs[1]) { \n\n          assert(m_investors.addRefBonus(refs[1], reward)); // referrer 2 bonus\n\n          // level 3\n\n          if (notZeroNotSender(refs[2]) && m_investors.contains(refs[2]) && refs[0] != refs[2] && refs[1] != refs[2]) { \n\n            assert(m_investors.addRefBonus(refs[2], reward)); // referrer 3 bonus\n\n          }\n\n        }\n\n      }\n\n    }\n\n\n\n    // commission\n\n    adminAddr.transfer(m_adminPercent.mul(msg.value));\n\n    payerAddr.transfer(m_payerPercent.mul(msg.value));    \n\n    \n\n    // write to investors storage\n\n    if (m_investors.contains(msg.sender)) {\n\n      assert(m_investors.addValue(msg.sender, value));\n\n    } else {\n\n      assert(m_investors.insert(msg.sender, value));\n\n      emit LogNewInvestor(msg.sender, now, value); \n\n    }\n\n    \n\n    if (m_paysys.mode == Paymode.Pull)\n\n      assert(m_investors.setPaymentTime(msg.sender, now));\n\n\n\n    emit LogNewInvesment(msg.sender, now, value);   \n\n    investmentsNum++;\n\n  }\n\n\n\n  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {\n\n    if (m_nextWave) {\n\n      nextWave(); \n\n      return;\n\n    }\n\n   \n\n    // if m_paysys.latestKeyIndex == m_investors.iterStart() then payout NOT in process and we must check latest time of payment.\n\n    if (m_paysys.latestKeyIndex == m_investors.iterStart()) {\n\n      require(now>m_paysys.latestTime+12 hours, \"the latest payment was earlier than 12 hours\");\n\n      m_paysys.latestTime = now;\n\n    }\n\n\n\n    uint i = m_paysys.latestKeyIndex;\n\n    uint value;\n\n    uint refBonus;\n\n    uint size = m_investors.size();\n\n    address investorAddr;\n\n    \n\n    // gasleft and latest key index  - prevent gas block limit \n\n    for (i; i < size && gasleft() > 50000; i++) {\n\n      investorAddr = m_investors.keyFromIndex(i);\n\n      (value, refBonus) = m_investors.investorShortInfo(investorAddr);\n\n      value = m_dividendsPercent.mul(value);\n\n\n\n      if (address(this).balance < value + refBonus) {\n\n        m_nextWave = true;\n\n        break;\n\n      }\n\n\n\n      if (refBonus > 0) {\n\n        require(m_investors.setRefBonus(investorAddr, 0), \"internal error\");\n\n        sendDividendsWithRefBonus(investorAddr, value, refBonus);\n\n        continue;\n\n      }\n\n\n\n      sendDividends(investorAddr, value);\n\n    }\n\n\n\n    if (i == size) \n\n      m_paysys.latestKeyIndex = m_investors.iterStart();\n\n    else \n\n      m_paysys.latestKeyIndex = i;\n\n  }\n\n\n\n  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {\n\n    addr.requireNotZero();\n\n    if (adminAddr != addr) {\n\n      adminAddr = addr;\n\n      emit LogAdminAddrChanged(addr, now);\n\n    }    \n\n  }\n\n\n\n  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {\n\n    addr.requireNotZero();\n\n    if (payerAddr != addr) {\n\n      payerAddr = addr;\n\n      emit LogPayerAddrChanged(addr, now);\n\n    }  \n\n  }\n\n\n\n  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {\n\n    changePaymode(Paymode.Pull);\n\n  }\n\n\n\n  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {\n\n    (uint a, uint b, uint c, uint d) = m_investors.investorFullInfo(addr);\n\n    return InvestorsStorage.investor(a, b, c, d);\n\n  }\n\n\n\n  function notZeroNotSender(address addr) internal view returns(bool) {\n\n    return addr.notZero() && addr != msg.sender;\n\n  }\n\n\n\n  function sendDividends(address addr, uint value) private {\n\n    if (addr.send(value)) emit LogPayDividends(addr, now, value); \n\n  }\n\n\n\n  function sendDividendsWithRefBonus(address addr, uint value,  uint refBonus) private {\n\n    if (addr.send(value+refBonus)) {\n\n      emit LogPayDividends(addr, now, value);\n\n      emit LogPayReferrerBonus(addr, now, refBonus);\n\n    }\n\n  }\n\n\n\n  function nextWave() private {\n\n    m_investors = new InvestorsStorage();\n\n    changePaymode(Paymode.Push);\n\n    m_paysys.latestKeyIndex = m_investors.iterStart();\n\n    investmentsNum = 0;\n\n    waveStartup = now;\n\n    m_nextWave = false;\n\n    emit LogNextWave(now);\n\n  }\n\n}",
    "function_sum": 13,
    "compiler_version": "0.4.24",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-09-14\n\n*/\n/**\n\n*\n\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\n\n* Web              - https://333eth.io\n\n* Twitter          - https://twitter.com/333eth_io\n\n* Telegram_channel - https://t.me/Ethereum333\n\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\n\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\n\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\n\n* Email:             mailto:support(at sign)333eth.io\n\n* \n\n*  - GAIN 3,33% PER 24 HOURS (every 5900 blocks)\n\n*  - Life-long payments\n\n*  - The revolutionary reliability\n\n*  - Minimal contribution 0.01 eth\n\n*  - Currency and payment - ETH\n\n*  - Contribution allocation schemes:\n\n*    -- 83% payments\n\n*    -- 17% Marketing + Operating Expenses\n\n*\n\n*   ---About the Project\n\n*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \n\n*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \n\n*  distribution model is written into a smart contract, uploaded to the Ethereum blockchain and can be \n\n*  freely accessed online. In order to insure our investors' complete security, full control over the \n\n*  project has been transferred from the organizers to the smart contract: nobody can influence the \n\n*  system's permanent autonomous functioning.\n\n* \n\n* ---How to use:\n\n*  1. Send from ETH wallet to the smart contract address 0x311f71389e3DE68f7B2097Ad02c6aD7B2dDE4C71\n\n*     any amount from 0.01 ETH.\n\n*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \n\n*     of your wallet.\n\n*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \n\n*      spending too much on GAS)\n\n*  OR\n\n*  3b. For reinvest, you need to first remove the accumulated percentage of charges (by sending 0 ether \n\n*      transaction), and only after that, deposit the amount that you want to reinvest.\n\n*  \n\n* RECOMMENDED GAS LIMIT: 200000\n\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\n\n* You can check the payments on the etherscan.io site, in the \"Internal Txns\" tab of your wallet.\n\n*\n\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \n\n* have private keys.\n\n* \n\n* Contracts reviewed and approved by pros!\n\n* \n\n* Main contract - Revolution. Scroll down to find it.\n\n*/\n\ncontract InvestorsStorage {\n\n  struct investor {\n\n    uint keyIndex;\n\n    uint value;\n\n    uint paymentTime;\n\n    uint refBonus;\n\n  }\n\n  struct itmap {\n\n    mapping(address => investor) data;\n\n    address[] keys;\n\n  }\n\n  itmap private s;\n\n  address private owner;\n\n\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner, \"access denied\");\n\n    _;\n\n  }\n\n\n\n  constructor() public {\n\n    owner = msg.sender;\n\n    s.keys.length++;\n\n  }\n\n\n\n  function insert(address addr, uint value) public onlyOwner returns (bool) {\n\n    uint keyIndex = s.data[addr].keyIndex;\n\n    if (keyIndex != 0) return false;\n\n    s.data[addr].value = value;\n\n    keyIndex = s.keys.length++;\n\n    s.data[addr].keyIndex = keyIndex;\n\n    s.keys[keyIndex] = addr;\n\n    return true;\n\n  }\n\n\n\n  function investorFullInfo(address addr) public view returns(uint, uint, uint, uint) {\n\n    return (\n\n      s.data[addr].keyIndex,\n\n      s.data[addr].value,\n\n      s.data[addr].paymentTime,\n\n      s.data[addr].refBonus\n\n    );\n\n  }\n\n\n\n  function investorBaseInfo(address addr) public view returns(uint, uint, uint) {\n\n    return (\n\n      s.data[addr].value,\n\n      s.data[addr].paymentTime,\n\n      s.data[addr].refBonus\n\n    );\n\n  }\n\n\n\n  function investorShortInfo(address addr) public view returns(uint, uint) {\n\n    return (\n\n      s.data[addr].value,\n\n      s.data[addr].refBonus\n\n    );\n\n  }\n\n\n\n  function addRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n\n    if (s.data[addr].keyIndex == 0) return false;\n\n    s.data[addr].refBonus += refBonus;\n\n    return true;\n\n  }\n\n\n\n  function addValue(address addr, uint value) public onlyOwner returns (bool) {\n\n    if (s.data[addr].keyIndex == 0) return false;\n\n    s.data[addr].value += value;\n\n    return true;\n\n  }\n\n\n\n  function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\n\n    if (s.data[addr].keyIndex == 0) return false;\n\n    s.data[addr].paymentTime = paymentTime;\n\n    return true;\n\n  }\n\n\n\n  function setRefBonus(address addr, uint refBonus) public onlyOwner returns (bool) {\n\n    if (s.data[addr].keyIndex == 0) return false;\n\n    s.data[addr].refBonus = refBonus;\n\n    return true;\n\n  }\n\n\n\n  function keyFromIndex(uint i) public view returns (address) {\n\n    return s.keys[i];\n\n  }\n\n\n\n  function contains(address addr) public view returns (bool) {\n\n    return s.data[addr].keyIndex > 0;\n\n  }\n\n\n\n  function size() public view returns (uint) {\n\n    return s.keys.length;\n\n  }\n\n\n\n  function iterStart() public pure returns (uint) {\n\n    return 1;\n\n  }\n\n}\n\nlibrary SafeMath {\n\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n\n    // benefit is lost if 'b' is also tested.\n\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n\n    if (_a == 0) {\n\n      return 0;\n\n    }\n\n\n\n    uint256 c = _a * _b;\n\n    require(c / _a == _b);\n\n\n\n    return c;\n\n  }\n\n\n\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\n\n    uint256 c = _a / _b;\n\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n\n\n    return c;\n\n  }\n\n\n\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\n    require(_b <= _a);\n\n    uint256 c = _a - _b;\n\n\n\n    return c;\n\n  }\n\n\n\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n\n    uint256 c = _a + _b;\n\n    require(c >= _a);\n\n\n\n    return c;\n\n  }\n\n\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n\n    require(b != 0);\n\n    return a % b;\n\n  }\n\n}\n\nlibrary Percent {\n\n  // Solidity automatically throws when dividing by 0\n\n  struct percent {\n\n    uint num;\n\n    uint den;\n\n  }\n\n  function mul(percent storage p, uint a) internal view returns (uint) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    return a*p.num/p.den;\n\n  }\n\n\n\n  function div(percent storage p, uint a) internal view returns (uint) {\n\n    return a/p.num*p.den;\n\n  }\n\n\n\n  function sub(percent storage p, uint a) internal view returns (uint) {\n\n    uint b = mul(p, a);\n\n    if (b >= a) return 0;\n\n    return a - b;\n\n  }\n\n\n\n  function add(percent storage p, uint a) internal view returns (uint) {\n\n    return a + mul(p, a);\n\n  }\n\n}\n\ncontract Accessibility {\n\n  enum AccessRank { None, Payout, Paymode, Full }\n\n  mapping(address => AccessRank) internal m_admins;\n\n  modifier onlyAdmin(AccessRank  r) {\n\n    require(\n\n      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\n\n      \"access denied\"\n\n    );\n\n    _;\n\n  }\n\n  event LogProvideAccess(address indexed whom, uint when,  AccessRank rank);\n\n\n\n  constructor() public {\n\n    m_admins[msg.sender] = AccessRank.Full;\n\n    emit LogProvideAccess(msg.sender, now, AccessRank.Full);\n\n  }\n\n  \n\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Full) {\n\n    require(rank <= AccessRank.Full, \"invalid access rank\");\n\n    require(m_admins[addr] != AccessRank.Full, \"cannot change full access rank\");\n\n    if (m_admins[addr] != rank) {\n\n      m_admins[addr] = rank;\n\n      emit LogProvideAccess(addr, now, rank);\n\n    }\n\n  }\n\n\n\n  function access(address addr) public view returns(AccessRank rank) {\n\n    rank = m_admins[addr];\n\n  }\n\n}\n\ncontract PaymentSystem {\n\n  // https://consensys.github.io/smart-contract-best-practices/recommendations/#favor-pull-over-push-for-external-calls\n\n  enum Paymode { Push, Pull }\n\n  struct PaySys {\n\n    uint latestTime;\n\n    uint latestKeyIndex;\n\n    Paymode mode; \n\n  }\n\n  PaySys internal m_paysys;\n\n\n\n  modifier atPaymode(Paymode mode) {\n\n    require(m_paysys.mode == mode, \"pay mode does not the same\");\n\n    _;\n\n  }\n\n  event LogPaymodeChanged(uint when, Paymode indexed mode);\n\n  \n\n  function paymode() public view returns(Paymode mode) {\n\n    mode = m_paysys.mode;\n\n  }\n\n\n\n  function changePaymode(Paymode mode) internal {\n\n    require(mode <= Paymode.Pull, \"invalid pay mode\");\n\n    if (mode == m_paysys.mode ) return; \n\n    if (mode == Paymode.Pull) require(m_paysys.latestTime != 0, \"cannot set pull pay mode if latest time is 0\");\n\n    if (mode == Paymode.Push) m_paysys.latestTime = 0;\n\n    m_paysys.mode = mode;\n\n    emit LogPaymodeChanged(now, m_paysys.mode);\n\n  }\n\n}\n\nlibrary Zero {\n\n  function requireNotZero(uint a) internal pure {\n\n    require(a != 0, \"require not zero\");\n\n  }\n\n\n\n  function requireNotZero(address addr) internal pure {\n\n    require(addr != address(0), \"require not zero address\");\n\n  }\n\n\n\n  function notZero(address addr) internal pure returns(bool) {\n\n    return !(addr == address(0));\n\n  }\n\n\n\n  function isZero(address addr) internal pure returns(bool) {\n\n    return addr == address(0);\n\n  }\n\n}\n\nlibrary ToAddress {\n\n  function toAddr(uint source) internal pure returns(address) {\n\n    return address(source);\n\n  }\n\n\n\n  function toAddr(bytes source) internal pure returns(address addr) {\n\n    assembly { addr := mload(add(source,0x14)) }\n\n    return addr;\n\n  }\n\n}\n\n\n\n// You task is to complete the smart contract Revolution strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.24, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract implements a system for managing investments, dividends, and referrals.\n * It supports both pull and push payment modes for distributing dividends and handles investment\n * cycles (waves) with a pause period between them. The contract also includes a referral system\n * that rewards up to three levels of referrals.\n * @dev Inherits from `Accessibility` and `PaymentSystem` to manage access control and payment modes.\n */\ncontract Revolution is Accessibility, PaymentSystem {\n\n  using Percent for Percent.percent;\n  using SafeMath for uint;\n  using Zero for *;\n  using ToAddress for *;\n\n  // investors storage - iterable map;\n  InvestorsStorage private m_investors;\n  mapping(address => bool) private m_referrals;\n  bool private m_nextWave;\n\n  // automatically generates getters\n  address public adminAddr;\n  address public payerAddr;\n  uint public waveStartup;\n  uint public investmentsNum;\n  uint public constant minInvesment = 10 finney; // 0.01 eth\n  uint public constant maxBalance = 333e5 ether; // 33,300,000 eth\n  uint public constant pauseOnNextWave = 168 hours;\n\n  // percents \n  Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 333/10000*100% = 3.33%\n  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%\n  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%\n  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%\n\n  // more events for easy read from blockchain\n  event LogNewInvestor(address indexed addr, uint when, uint value);\n  event LogNewInvesment(address indexed addr, uint when, uint value);\n  event LogNewReferral(address indexed addr, uint when, uint value);\n  event LogPayDividends(address indexed addr, uint when, uint value);\n  event LogPayReferrerBonus(address indexed addr, uint when, uint value);\n  event LogBalanceChanged(uint when, uint balance);\n  event LogAdminAddrChanged(address indexed addr, uint when);\n  event LogPayerAddrChanged(address indexed addr, uint when);\n  event LogNextWave(uint when);\n\n  /**\n   * @dev Modifier to emit an event when the contract's balance changes.\n   */\n  modifier balanceChanged {\n    _;\n    emit LogBalanceChanged(now, address(this).balance);\n  }\n\n  /**\n   * @dev Modifier to ensure the function is not called during the pause period after a new wave starts.\n   */\n  modifier notOnPause() {\n    require(waveStartup + pauseOnNextWave <= now, \"pause on next wave not expired\");\n    _;\n  }\n\n  constructor() public {\n    adminAddr = msg.sender;\n    emit LogAdminAddrChanged(msg.sender, now);\n\n    payerAddr = msg.sender;\n    emit LogPayerAddrChanged(msg.sender, now);\n\n    nextWave();\n    waveStartup = waveStartup.sub(pauseOnNextWave);\n  }\n\n  /**\n   * @notice Fallback function to handle incoming ETH. If no ETH is sent, it triggers dividend withdrawal.\n   * Otherwise, it processes a new investment.\n   * @dev Uses the `notOnPause` and `balanceChanged` modifiers to enforce conditions.\n   */\n  function() public payable {\n    // investor get him dividends\n    if (msg.value == 0) {\n      getMyDividends();\n      return;\n    }\n\n    // sender do invest\n    address a = msg.data.toAddr();\n    address[3] memory refs;\n    if (a.notZero()) {\n      refs[0] = a;\n      doInvest(refs); \n    } else {\n      doInvest(refs);\n    }\n  }\n\n  /**\n   * @notice Returns the number of investors in the system.\n   * @dev Adjusts the count by subtracting one due to the initial state of the storage.\n   * @return The number of investors.\n   */\n  function investorsNumber() public view returns(uint) {}\n\n  /**\n   * @notice Returns the current ETH balance of the contract.\n   * @return The current balance in wei.\n   */\n  function balanceETH() public view returns(uint) {}\n\n  /**\n   * @notice Returns the percentage used for the payer's commission.\n   * @return The numerator and denominator of the percentage.\n   */\n  function payerPercent() public view returns(uint numerator, uint denominator) {}\n\n  /**\n   * @notice Returns the percentage used for calculating dividends.\n   * @return The numerator and denominator of the percentage.\n   */\n  function dividendsPercent() public view returns(uint numerator, uint denominator) {}\n\n  /**\n   * @notice Returns the percentage used for the admin's commission.\n   * @return The numerator and denominator of the percentage.\n   */\n  function adminPercent() public view returns(uint numerator, uint denominator) {}\n\n  /**\n   * @notice Returns the percentage used for the referrer's bonus.\n   * @return The numerator and denominator of the percentage.\n   */\n  function referrerPercent() public view returns(uint numerator, uint denominator) {}\n\n  /**\n   * @notice Returns detailed information about an investor.\n   * @param addr The address of the investor.\n   * @return The value of the investment, the last payment time, the referral bonus, and whether the investor is a referral.\n   */\n  function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {}\n\n  /**\n   * @notice Returns the timestamp of the latest payout.\n   * @return The timestamp of the latest payout.\n   */\n  function latestPayout() public view returns(uint timestamp) {}\n\n  /**\n   * @notice Allows an investor to claim their accumulated dividends.\n   * @dev:\n   * - Checks if the contract is not paused and the caller is in pull payment mode\n   * - Verifies the caller has an active investor account\n   * - Updates the investor's payment timestamp if needed\n   * - Calculates the dividends based on investment amount and days since last payment\n   * - Ensures sufficient contract balance before distribution\n   * - Handles referral bonuses if applicable\n   * - Triggers a new dividend wave if insufficient funds\n   * @return None\n   * @notice Emits events related to dividend payments and referral bonuses\n   * @dev:\n   * - Uses SafeMath operations for arithmetic calculations\n   * - Validates investor status and payment timestamps\n   * - Manages dividend distribution and referral bonuses\n   * - Implements wave-based dividend distribution logic\n   */\n  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {}\n\n  /**\n   * @notice Processes investment with referral bonuses and commissions.\n   * @param refs Array of up to three referral addresses (level 1, 2, 3).\n   * @dev:\n   * - Requires contract not paused and within balance limits\n   * - Validates minimum investment amount\n   * - Implements tiered referral bonus system (max 3 levels)\n   * - Prevents duplicate referrals for sender\n   * - Distributes admin/payer commissions\n   * - Updates investor records and payment time (if pull mode)\n   * - Emits investment/referral events\n   * @notice Referral bonuses calculated as percentage of investment value\n   */\n  function doInvest(address[3] refs) public payable notOnPause balanceChanged {}\n\n  /**\n   * @notice Distributes dividends to investors in push mode.\n   * @dev:\n   * - Only callable by admin with Payout access rank\n   * - Uses push payment mode (atPaymode(Paymode.Push))\n   * - Checks if next wave should be initiated\n   * - Validates minimum payment interval (12 hours)\n   * - Processes investor payments in batches to prevent gas limit issues\n   * - Calculates dividends based on investment value and percentage\n   * - Handles referral bonuses if applicable\n   * - Updates payment progress tracking\n   * - Automatically starts new wave if funds are insufficient\n   * @notice Emits events for dividend payments and referral bonuses\n   * @dev:\n   * - Uses gasleft() check to prevent out-of-gas errors\n   * - Implements batch processing with safe iteration\n   * - Maintains payment progress between transactions\n   */\n  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {}\n\n  /**\n   * @notice Sets the admin address.\n   * @param addr The new admin address.\n   * @dev Requires the caller to have full admin access.\n   */\n  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {}\n\n  /**\n   * @notice Sets the payer address.\n   * @param addr The new payer address.\n   * @dev Requires the caller to have full admin access.\n   */\n  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {}\n\n  /**\n   * @notice Changes the payment mode to pull.\n   * @dev Requires the caller to have paymode admin access and the current mode to be push.\n   */\n  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {}\n\n  /**\n   * @notice Retrieves the investor information from storage.\n   * @param addr The address of the investor.\n   * @return The investor's information.\n   * @dev Internal function used to fetch investor data.\n   */\n  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {}\n\n  /**\n   * @notice Checks if an address is not zero and not the sender.\n   * @param addr The address to check.\n   * @return True if the address is valid, false otherwise.\n   * @dev Internal function used to validate referral addresses.\n   */\n  function notZeroNotSender(address addr) internal view returns(bool) {}\n\n  /**\n   * @notice Sends dividends to an investor.\n   * @param addr The address of the investor.\n   * @param value The amount of dividends to send.\n   * @dev Private function to handle the actual transfer.\n   */\n  function sendDividends(address addr, uint value) private {}\n\n  /**\n   * @notice Sends dividends along with a referral bonus to an investor.\n   * @param addr The address of the investor.\n   * @param value The amount of dividends to send.\n   * @param refBonus The amount of referral bonus to send.\n   * @dev Private function to handle the combined transfer.\n   */\n  function sendDividendsWithRefBonus(address addr, uint value, uint refBonus) private {}\n\n  /**\n   * @notice Initializes a new wave, resetting the system and changing the payment mode.\n   * @dev Private function to handle the transition to a new wave.\n   */\n  function nextWave() private {}\n}\n"
}