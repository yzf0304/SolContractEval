{
    "contract_name": "Shibereum",
    "ground_truth": "contract Shibereum is IERC20, Ownable {       \n    string private constant _name = \"Shibereum.Ai\";\n    string private constant _symbol = \"Shibereum\";\n    uint8 private constant _decimals = 9;\n    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _blocked;\n\n    mapping (address => uint256) private _lastTradeBlock;\n    mapping (address => bool) private isContractExempt;\n    uint256 private tradeCooldown = 1;\n    \n    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;\n    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;\n    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;\n\n    struct TradingFees{\n        uint256 buyTax;\n        uint256 sellTax;\n    }  \n\n    TradingFees public tradingFees = TradingFees(10,45);\n    uint256 public constant sniperTax = 49;\n\n    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address private immutable ETH = uniswapRouter.WETH();\n    address private immutable uniswapPair;\n\n    address payable private immutable deployerAddress = payable(msg.sender);\n    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);\n\n    bool private tradingOpen = false;\n    bool private swapping = false;\n    bool private antiMEV = false;\n    uint256 private startingBlock;\n    uint private preLaunch;\n\n    modifier swapLock {\n        swapping = true;\n        _;\n        swapping = false;\n    }\n\n    modifier tradingLock(address sender) {\n        require(tradingOpen || sender == deployerAddress || sender == devWallet);\n        _;\n    }\n\n    constructor () {\n        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);\n        isContractExempt[address(this)] = true;\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable {}\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Token: transfer amount must be greater than zero\");\n\n        _balances[from] -= amount;\n\n        if (from != address(this) && from != devWallet && to != devWallet && to != deployerAddress) {\n            \n            if(antiMEV && !isContractExempt[from] && !isContractExempt[to]){\n                address human = ensureOneHuman(from, to);\n                ensureMaxTxFrequency(human);\n                _lastTradeBlock[human] = block.number;\n            }\n\n            if (from == uniswapPair && to != address(uniswapRouter)) {\n                require(balanceOf(to) + amount <= maxWalletAmount, \"Token: transfer implies violation of max wallet\");\n            }\n\n           uint256 contractTokenBalance = balanceOf(address(this));\n           if (shouldSwapback(from, contractTokenBalance)) \n               swapback(contractTokenBalance);                            \n\n           uint256 taxedTokens = takeFee(from, amount);\n           if(taxedTokens > 0){\n                amount -= taxedTokens;\n                _balances[address(this)] += taxedTokens;\n                emit Transfer(from, address(this), taxedTokens);\n            }\n        }\n\n        _balances[to] += amount;\n        emit Transfer(from, to, amount);\n    }\n\n    function swapback(uint256 tokenAmount) private swapLock {\n        tokenAmount = getSwapAmount(tokenAmount);\n        if(allowance(address(this), address(uniswapRouter)) < tokenAmount) {\n            _approve(address(this), address(uniswapRouter), _totalSupply);\n        }\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = ETH;\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n        uint256 contractETHBalance = address(this).balance;\n        if(contractETHBalance > 0) {\n            devWallet.transfer(contractETHBalance);\n        }\n    }\n\n    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool shouldSwap) {\n        shouldSwap = !swapping && from != uniswapPair && tokenAmount > contractSwapLimit && 1 + startingBlock <= block.number;\n    }\n\n    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256 swapAmount) {\n        swapAmount = tokenAmount > contractSwapMax ? contractSwapMax : contractSwapLimit;\n    }\n\n    function takeFee(address from, uint256 amount) private view returns (uint256 feeAmount) {\n         if(_blocked[from] || block.number <= startingBlock)\n                feeAmount = amount * sniperTax / 100;\n        else\n            feeAmount = amount * (startingBlock == 0 ? 25 : (from == uniswapPair ? tradingFees.buyTax : tradingFees.sellTax)) / 100;\n    }\n\n    function isContract(address account) private view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function ensureOneHuman(address _to, address _from) private view returns (address) {\n        require(!isContract(_to) || !isContract(_from));\n        if (isContract(_to)) return _from;\n        else return _to;\n    }\n\n    function ensureMaxTxFrequency(address addr) view private {\n        bool isAllowed = _lastTradeBlock[addr] == 0 ||\n            ((_lastTradeBlock[addr] + tradeCooldown) < (block.number + 1));\n        require(isAllowed, \"Max tx frequency exceeded!\");\n    }\n\n    function toggleAntiMEV(bool toggle) external {\n        require(msg.sender == deployerAddress);\n        antiMEV = toggle;\n    }\n\n    function setTradeCooldown(uint256 newTradeCooldown) external {\n        require(msg.sender == deployerAddress);\n        require(newTradeCooldown > 0 && newTradeCooldown < 4, \"Token: only trade cooldown values in range (0,4) permissible\");\n        tradeCooldown = newTradeCooldown;\n    }\n\n    function manualSwapback(uint256 percent) external {\n        require(msg.sender == deployerAddress);\n        require(0 < percent && percent <= 100, \"Token: only percent values in range (0,100] permissible\");\n        uint256 tokensToSwap = percent * balanceOf(address(this)) / 100;\n        swapback(tokensToSwap);\n    }\n\n    function setFees(uint256 newBuyTax, uint256 newSellTax) external {\n        require(msg.sender == deployerAddress);\n        require(newBuyTax <= tradingFees.buyTax, \"Token: only fee reduction permitted\");\n        require(newSellTax <= tradingFees.sellTax, \"Token: only fee reduction permitted\");\n        tradingFees.buyTax = newBuyTax;\n        tradingFees.sellTax = newSellTax;\n    }\n\n    function setContractExempt(address account, bool value) external onlyOwner {\n        require(account != address(this));\n        isContractExempt[account] = value;\n    }\n\n    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {\n        for (uint i = 0; i < bots.length; i++) {\n            require(bots[i] != uniswapPair && \n                    bots[i] != address(uniswapRouter) &&\n                    bots[i] != address(this));\n            _blocked[bots[i]] = shouldBlock;\n        }\n    }\n\n    function initialize() external onlyOwner {\n        require(preLaunch++<2);\n    }\n\n    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {\n        assert(preLaunch<2&&preLaunch+1>=2); \n        preLaunch++;param;\n        startingBlock += nrBlocks;\n    }\n\n    function openTrading() external onlyOwner {\n        require(preLaunch == 2 && !tradingOpen, \"Token: trading already open\");\n        startingBlock += block.number;\n        tradingOpen = true;\n    }\n}",
    "function_sum": 28,
    "compiler_version": "0.8.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2023-02-04\n*/\n// SPDX-License-Identifier: MIT\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IUniswapV2Router {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IUniswapV2Factory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    constructor () {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n}\n\n\n\n// You task is to complete the smart contract Shibereum strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice Shibereum is an ERC20 token with additional features such as trading fees, anti-sniping, and swapback mechanisms.\n * @dev This contract implements the IERC20 interface and extends the Ownable contract for access control.\n */\ncontract Shibereum is IERC20, Ownable {       \n    string private constant _name = \"Shibereum.Ai\";\n    string private constant _symbol = \"Shibereum\";\n    uint8 private constant _decimals = 9;\n    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    mapping (address => bool) private _blocked;\n\n    mapping (address => uint256) private _lastTradeBlock;\n    mapping (address => bool) private isContractExempt;\n    uint256 private tradeCooldown = 1;\n    \n    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;\n    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;\n    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;\n\n    struct TradingFees{\n        uint256 buyTax;\n        uint256 sellTax;\n    }  \n\n    TradingFees public tradingFees = TradingFees(10,45);\n    uint256 public constant sniperTax = 49;\n\n    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address private immutable ETH = uniswapRouter.WETH();\n    address private immutable uniswapPair;\n\n    address payable private immutable deployerAddress = payable(msg.sender);\n    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);\n\n    bool private tradingOpen = false;\n    bool private swapping = false;\n    bool private antiMEV = false;\n    uint256 private startingBlock;\n    uint private preLaunch;\n\n    modifier swapLock {\n        swapping = true;\n        _;\n        swapping = false;\n    }\n\n    modifier tradingLock(address sender) {\n        require(tradingOpen || sender == deployerAddress || sender == devWallet);\n        _;\n    }\n\n    constructor () {\n        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);\n        isContractExempt[address(this)] = true;\n        _balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    receive() external payable {}\n\n    /**\n     * @notice Returns the name of the token.\n     * @dev The name is a constant string.\n     * @return The name of the token.\n     */\n    function name() public pure returns (string memory) {}\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @dev The symbol is a constant string.\n     * @return The symbol of the token.\n     */\n    function symbol() public pure returns (string memory) {}\n\n    /**\n     * @notice Returns the number of decimals used to get its user representation.\n     * @dev The decimals are a constant value.\n     * @return The number of decimals.\n     */\n    function decimals() public pure returns (uint8) {}\n\n    /**\n     * @notice Returns the total supply of tokens in existence.\n     * @dev The total supply is a constant value.\n     * @return The total supply of tokens.\n     */\n    function totalSupply() public pure returns (uint256) {}\n\n    /**\n     * @notice Returns the balance of the specified address.\n     * @param account The address to query the balance of.\n     * @return The balance of the specified address.\n     */\n    function balanceOf(address account) public view returns (uint256) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from the caller's address to a recipient.\n     * @param recipient The recipient address.\n     * @param amount The amount of tokens to transfer.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {}\n\n    /**\n     * @notice Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through `transferFrom`.\n     * @param owner The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The remaining allowance.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {}\n\n    /**\n     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to approve.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens from one address to another, using the allowance mechanism.\n     * @param sender The address to transfer from.\n     * @param recipient The address to transfer to.\n     * @param amount The amount of tokens to transfer.\n     * @return A boolean value indicating whether the operation succeeded.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {}\n\n    /**\n     * @notice Internal function to set the allowance of `spender` over the `owner`'s tokens.\n     * @param owner The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to approve.\n     */\n    function _approve(address owner, address spender, uint256 amount) private {}\n\n    /**\n     * @dev Transfers tokens between accounts with trading restrictions and fees.\n     * @param from Source address (must not be zero address)\n     * @param to Destination address (must not be zero address)\n     * @param amount Transfer amount (must be > 0)\n     * @dev\n     * - Enforces zero address checks\n     * - Handles anti-MEV measures for non-contract accounts\n     * - Validates max wallet limits for transfers to/from uniswapPair\n     * - Executes swapback if conditions are met\n     * - Applies transaction fees and emits events\n     * @notice Trading is locked during certain periods (via tradingLock modifier)\n     */\n    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {}\n\n    /**\n     * @notice Swaps a specified amount of tokens for ETH and sends the ETH to the dev wallet.\n     * @param tokenAmount The amount of tokens to swap.\n     */\n    function swapback(uint256 tokenAmount) private swapLock {}\n\n    /**\n     * @notice Determines if a swapback should occur based on the current conditions.\n     * @param from The address sending the tokens.\n     * @param tokenAmount The amount of tokens to check.\n     * @return A boolean value indicating whether a swapback should occur.\n     */\n    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool) {}\n\n    /**\n     * @notice Calculates the amount of tokens to swap, ensuring it does not exceed the maximum limit.\n     * @param tokenAmount The amount of tokens to check.\n     * @return The amount of tokens to swap.\n     */\n    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {}\n\n    /**\n     * @notice Calculates the fee amount to be deducted from the transfer.\n     * @param from The address sending the tokens.\n     * @param amount The amount of tokens to transfer.\n     * @return The fee amount.\n     */\n    function takeFee(address from, uint256 amount) private view returns (uint256) {}\n\n    /**\n     * @notice Checks if the given address is a contract.\n     * @param account The address to check.\n     * @return A boolean value indicating whether the address is a contract.\n     */\n    function isContract(address account) private view returns (bool) {}\n\n    /**\n     * @notice Ensures that at least one of the addresses involved in the transaction is a human (not a contract).\n     * @param _to The recipient address.\n     * @param _from The sender address.\n     * @return The address of the human.\n     */\n    function ensureOneHuman(address _to, address _from) private view returns (address) {}\n\n    /**\n     * @notice Ensures that the transaction frequency does not exceed the allowed limit.\n     * @param addr The address to check.\n     */\n    function ensureMaxTxFrequency(address addr) view private {}\n\n    /**\n     * @notice Toggles the anti-MEV feature.\n     * @param toggle The new state of the anti-MEV feature.\n     */\n    function toggleAntiMEV(bool toggle) external {}\n\n    /**\n     * @notice Sets the trade cooldown period.\n     * @param newTradeCooldown The new trade cooldown period.\n     */\n    function setTradeCooldown(uint256 newTradeCooldown) external {}\n\n    /**\n     * @notice Manually triggers a swapback for a specified percentage of the contract's token balance.\n     * @param percent The percentage of the contract's token balance to swap.\n     */\n    function manualSwapback(uint256 percent) external {}\n\n    /**\n     * @notice Sets the trading fees for buying and selling.\n     * @param newBuyTax The new buy tax.\n     * @param newSellTax The new sell tax.\n     */\n    function setFees(uint256 newBuyTax, uint256 newSellTax) external {}\n\n    /**\n     * @notice Sets the contract exemption status for a specified address.\n     * @param account The address to set the exemption status for.\n     * @param value The new exemption status.\n     */\n    function setContractExempt(address account, bool value) external onlyOwner {}\n\n    /**\n     * @notice Sets the bot blocking status for multiple addresses.\n     * @param bots The list of addresses to set the bot blocking status for.\n     * @param shouldBlock The new bot blocking status.\n     */\n    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {}\n\n    /**\n     * @notice Initializes the contract, allowing certain parameters to be set.\n     */\n    function initialize() external onlyOwner {}\n\n    /**\n     * @notice Modifies the contract parameters, including the starting block.\n     * @param param The parameters to modify.\n     * @param nrBlocks The number of blocks to add to the starting block.\n     */\n    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {}\n\n    /**\n     * @notice Opens trading, setting the starting block and enabling trading.\n     */\n    function openTrading() external onlyOwner {}\n}\n"
}