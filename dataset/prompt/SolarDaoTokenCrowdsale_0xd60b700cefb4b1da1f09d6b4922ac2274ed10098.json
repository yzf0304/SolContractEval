{
    "contract_name": "SolarDaoToken",
    "ground_truth": "contract SolarDaoToken is SafeMath, ERC20, Ownable {\n\n string public name = \"Solar DAO Token\";\n\n string public symbol = \"SDAO\";\n\n uint public decimals = 4;\n\n\n\n /// contract that is allowed to create new tokens and allows unlift the transfer limits on this token\n\n address public crowdsaleAgent;\n\n /// A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.\n\n bool public released = false;\n\n /// approve() allowances\n\n mapping (address => mapping (address => uint)) allowed;\n\n /// holder balances\n\n mapping(address => uint) balances;\n\n\n\n /// @dev Limit token transfer until the crowdsale is over.\n\n modifier canTransfer() {\n\n   if(!released) {\n\n       require(msg.sender == crowdsaleAgent);\n\n   }\n\n   _;\n\n }\n\n\n\n /// @dev The function can be called only before or after the tokens have been releasesd\n\n /// @param _released token transfer and mint state\n\n modifier inReleaseState(bool _released) {\n\n   require(_released == released);\n\n   _;\n\n }\n\n\n\n /// @dev The function can be called only by release agent.\n\n modifier onlyCrowdsaleAgent() {\n\n   require(msg.sender == crowdsaleAgent);\n\n   _;\n\n }\n\n\n\n /// @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n\n /// @param size payload size\n\n modifier onlyPayloadSize(uint size) {\n\n    require(msg.data.length >= size + 4);\n\n    _;\n\n }\n\n\n\n /// @dev Make sure we are not done yet.\n\n modifier canMint() {\n\n    require(!released);\n\n    _;\n\n  }\n\n\n\n /// @dev Constructor\n\n function SolarDaoToken() {\n\n   owner = msg.sender;\n\n }\n\n\n\n /// Fallback method will buyout tokens\n\n function() payable {\n\n   revert();\n\n }\n\n\n\n /// @dev Create new tokens and allocate them to an address. Only callably by a crowdsale contract\n\n /// @param receiver Address of receiver\n\n /// @param amount  Number of tokens to issue.\n\n function mint(address receiver, uint amount) onlyCrowdsaleAgent canMint public {\n\n    totalSupply = safeAdd(totalSupply, amount);\n\n    balances[receiver] = safeAdd(balances[receiver], amount);\n\n    Transfer(0, receiver, amount);\n\n }\n\n\n\n /// @dev Set the contract that can call release and make the token transferable.\n\n /// @param _crowdsaleAgent crowdsale contract address\n\n function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner inReleaseState(false) public {\n\n   crowdsaleAgent = _crowdsaleAgent;\n\n }\n\n /// @dev One way function to release the tokens to the wild. Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n\n function releaseTokenTransfer() public onlyCrowdsaleAgent {\n\n   released = true;\n\n }\n\n /// @dev Tranfer tokens to address\n\n /// @param _to dest address\n\n /// @param _value tokens amount\n\n /// @return transfer result\n\n function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\n\n   balances[msg.sender] = safeSub(balances[msg.sender], _value);\n\n   balances[_to] = safeAdd(balances[_to], _value);\n\n\n\n   Transfer(msg.sender, _to, _value);\n\n   return true;\n\n }\n\n\n\n /// @dev Tranfer tokens from one address to other\n\n /// @param _from source address\n\n /// @param _to dest address\n\n /// @param _value tokens amount\n\n /// @return transfer result\n\n function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\n\n   var _allowance = allowed[_from][msg.sender];\n\n\n\n    balances[_to] = safeAdd(balances[_to], _value);\n\n    balances[_from] = safeSub(balances[_from], _value);\n\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n }\n\n /// @dev Tokens balance\n\n /// @param _owner holder address\n\n /// @return balance amount\n\n function balanceOf(address _owner) constant returns (uint balance) {\n\n   return balances[_owner];\n\n }\n\n\n\n /// @dev Approve transfer\n\n /// @param _spender holder address\n\n /// @param _value tokens amount\n\n /// @return result\n\n function approve(address _spender, uint _value) returns (bool success) {\n\n   // To change the approve amount you first have to reduce the addresses`\n\n   //  allowance to zero by calling `approve(_spender, 0)` if it is not\n\n   //  already 0 to mitigate the race condition described here:\n\n   //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n   require ((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n\n\n   allowed[msg.sender][_spender] = _value;\n\n   Approval(msg.sender, _spender, _value);\n\n   return true;\n\n }\n\n\n\n /// @dev Token allowance\n\n /// @param _owner holder address\n\n /// @param _spender spender address\n\n /// @return remain amount\n\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n\n   return allowed[_owner][_spender];\n\n }\n\n}",
    "function_sum": 7,
    "compiler_version": "0.4.16",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2017-10-11\n\n*/\n/// @title SafeMath contract - math operations with safety checks\n\ncontract SafeMath {\n\n  function safeMul(uint a, uint b) internal returns (uint) {\n\n    uint c = a * b;\n\n    assert(a == 0 || c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n\n    assert(b > 0);\n\n    uint c = a / b;\n\n    assert(a == b * c + a % b);\n\n    return c;\n\n  }\n\n\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n\n    uint c = a + b;\n\n    assert(c>=a && c>=b);\n\n    return c;\n\n  }\n\n\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n\n    return a >= b ? a : b;\n\n  }\n\n\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n\n    return a < b ? a : b;\n\n  }\n\n\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    return a >= b ? a : b;\n\n  }\n\n\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    return a < b ? a : b;\n\n  }\n\n\n\n \n\n}\n\n/// @title Ownable contract - base contract with an owner\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n  function Ownable() {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  function transferOwnership(address newOwner) onlyOwner {\n\n    if (newOwner != address(0)) {\n\n      owner = newOwner;\n\n    }\n\n  }\n\n}\n\n/// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n\ncontract ERC20 {\n\n  uint public totalSupply;\n\n  function balanceOf(address who) constant returns (uint);\n\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function mint(address receiver, uint amount);\n\n  function transfer(address to, uint value) returns (bool ok);\n\n  function transferFrom(address from, address to, uint value) returns (bool ok);\n\n  function approve(address spender, uint value) returns (bool ok);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n}\n\n\n\n// You task is to complete the smart contract SolarDaoToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.16, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title SolarDaoToken\n * @notice This contract implements the ERC20 token standard and includes additional features for a crowdsale, such as minting new tokens and controlling the transferability of tokens.\n * @dev The contract is based on the SafeMath, ERC20, and Ownable contracts. It allows the owner to set a crowdsale agent and control the release of tokens. The contract also includes safeguards against common attacks like the short address attack.\n */\ncontract SolarDaoToken is SafeMath, ERC20, Ownable {\n\n    string public name = \"Solar DAO Token\";\n\n    string public symbol = \"SDAO\";\n\n    uint public decimals = 4;\n\n    /// @notice The address of the crowdsale agent that can create new tokens and lift transfer limits.\n    address public crowdsaleAgent;\n\n    /// @notice A boolean flag indicating whether the token is in a transfer lockup period or not.\n    bool public released = false;\n\n    /// @dev Mapping to store the approve() allowances.\n    mapping (address => mapping (address => uint)) allowed;\n\n    /// @dev Mapping to store the balances of token holders.\n    mapping(address => uint) balances;\n\n    /// @dev Modifier to limit token transfers until the crowdsale is over.\n    modifier canTransfer() {\n        if(!released) {\n            require(msg.sender == crowdsaleAgent);\n        }\n        _;\n    }\n\n    /// @dev Modifier to ensure the function can only be called before or after the tokens have been released.\n    /// @param _released The state of the token release.\n    modifier inReleaseState(bool _released) {\n        require(_released == released);\n        _;\n    }\n\n    /// @dev Modifier to ensure the function can only be called by the crowdsale agent.\n    modifier onlyCrowdsaleAgent() {\n        require(msg.sender == crowdsaleAgent);\n        _;\n    }\n\n    /// @dev Modifier to prevent the ERC20 short address attack.\n    /// @param size The expected payload size.\n    modifier onlyPayloadSize(uint size) {\n        require(msg.data.length >= size + 4);\n        _;\n    }\n\n    /// @dev Modifier to ensure minting can only occur before the tokens are released.\n    modifier canMint() {\n        require(!released);\n        _;\n    }\n\n    /// @dev Constructor to initialize the contract with the owner.\n    function SolarDaoToken() {\n        owner = msg.sender;\n    }\n\n    /// @dev Fallback method to handle incoming Ether. Reverts to prevent accidental sending of Ether.\n    function() payable {\n        revert();\n    }\n\n    /// @dev Creates new tokens and allocates them to an address. Can only be called by the crowdsale agent.\n    /// @param receiver The address to receive the newly minted tokens.\n    /// @param amount The number of tokens to mint.\n    function mint(address receiver, uint amount) onlyCrowdsaleAgent canMint public {}\n\n    /// @dev Sets the address of the crowdsale agent. Can only be called by the owner and when the tokens are not yet released.\n    /// @param _crowdsaleAgent The address of the crowdsale agent.\n    function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner inReleaseState(false) public {}\n\n    /// @dev Releases the tokens to allow transfers. Can only be called by the crowdsale agent.\n    function releaseTokenTransfer() public onlyCrowdsaleAgent {}\n\n    /// @dev Transfers tokens from the sender to the specified address.\n    /// @param _to The recipient address.\n    /// @param _value The amount of tokens to transfer.\n    /// @return success A boolean indicating the success of the transfer.\n    function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer returns (bool success) {}\n\n    /// @dev Transfers tokens from one address to another, using the allowance mechanism.\n    /// @param _from The source address.\n    /// @param _to The recipient address.\n    /// @param _value The amount of tokens to transfer.\n    /// @return success A boolean indicating the success of the transfer.\n    function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer returns (bool success) {}\n\n    /// @dev Returns the balance of the specified address.\n    /// @param _owner The address to check the balance of.\n    /// @return balance The balance of the specified address.\n    function balanceOf(address _owner) constant returns (uint balance) {}\n\n    /// @dev Approves an address to spend a specified amount of tokens on behalf of the sender.\n    /// @param _spender The address to approve.\n    /// @param _value The amount of tokens to approve.\n    /// @return success A boolean indicating the success of the approval.\n    function approve(address _spender, uint _value) returns (bool success) {}\n\n    /// @dev Returns the remaining allowance of the spender for the owner.\n    /// @param _owner The address of the token owner.\n    /// @param _spender The address of the spender.\n    /// @return remaining The remaining allowance.\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n}\n"
}