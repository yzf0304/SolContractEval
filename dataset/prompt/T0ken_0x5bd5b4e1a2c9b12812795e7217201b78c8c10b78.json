{
    "contract_name": "T0ken",
    "ground_truth": "contract T0ken is ERC20, Ownable, LockableDestroyable {\n\n    // ------------------------------- Variables -------------------------------\n\n    using AdditiveMath for uint256;\n    using AddressMap for AddressMap.Data;\n\n    address constant internal ZERO_ADDRESS = address(0);\n    string public constant name = \"TZERO PREFERRED\";\n    string public constant symbol = \"TZROP\";\n    uint8 public constant decimals = 0;\n\n    AddressMap.Data public shareholders;\n    Compliance public compliance;\n    address public issuer;\n    bool public issuingFinished = false;\n    mapping(address => address) public cancellations;\n\n    mapping(address => uint256) internal balances;\n    uint256 internal totalSupplyTokens;\n\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    // ------------------------------- Modifiers -------------------------------\n\n    modifier onlyIssuer() {\n        require(msg.sender == issuer, \"Only issuer allowed\");\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuingFinished, \"Issuing is already finished\");\n        _;\n    }\n\n    modifier isNotCancelled(address addr) {\n        require(cancellations[addr] == ZERO_ADDRESS, \"Address has been cancelled\");\n        _;\n    }\n\n    modifier hasFunds(address addr, uint256 tokens) {\n        require(tokens <= balances[addr], \"Insufficient funds\");\n        _;\n    }\n\n    // -------------------------------- Events ---------------------------------\n\n    /**\n     *  This event is emitted when an address is cancelled and replaced with\n     *  a new address.  This happens in the case where a shareholder has\n     *  lost access to their original address and needs to have their share\n     *  reissued to a new address.  This is the equivalent of issuing replacement\n     *  share certificates.\n     *  @param original The address being superseded.\n     *  @param replacement The new address.\n     *  @param sender The address that caused the address to be superseded.\n    */\n    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);\n    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);\n    event Issue(address indexed to, uint256 tokens);\n    event IssueFinished();\n    event ShareholderAdded(address shareholder);\n    event ShareholderRemoved(address shareholder);\n\n    // -------------------------------------------------------------------------\n\n    /**\n     *  @dev Transfers tokens to the whitelisted account.\n     *\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\n     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\n     *  from the list of shareholders.\n     *  MUST be removed from the list of shareholders.\n     *  @param to The address to transfer to.\n     *  @param tokens The number of tokens to be transferred.\n     */\n    function transfer(address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(msg.sender, tokens)\n    returns (bool) {\n        bool transferAllowed;\n\n        // Issuance\n        if (msg.sender == issuer) {\n            transferAllowed = address(compliance) == ZERO_ADDRESS;\n            if (!transferAllowed) {\n                transferAllowed = compliance.canIssue(issuer, issuer, to, tokens);\n            }\n        }\n        // Transfer\n        else {\n            transferAllowed = canTransfer(msg.sender, to, tokens, false);\n        }\n\n        // Ensure the transfer is allowed.\n        if (transferAllowed) {\n            transferTokens(msg.sender, to, tokens);\n        }\n        return transferAllowed;\n    }\n\n    /**\n     *  @dev Transfers tokens between whitelisted accounts.\n     *\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\n     *  If the transfer will reduce 'from' balance to 0 then that address MUST be removed from the list of shareholders.\n     *  @param from The address to transfer from\n     *  @param to The address to transfer to.\n     *  @param tokens uint256 the number of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(from, tokens)\n    returns (bool) {\n        require(tokens <= allowed[from][msg.sender], \"Transfer exceeds allowance\");\n\n        // Transfer the tokens\n        bool transferAllowed = canTransfer(from, to, tokens, false);\n        if (transferAllowed) {\n            // Update the allowance to reflect the transfer\n            allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);\n            // Transfer the tokens\n            transferTokens(from, to, tokens);\n        }\n        return transferAllowed;\n    }\n\n    /**\n     *  @dev Overrides a transfer of tokens to the whitelisted account.\n     *\n     *  If the 'to' address is not currently a shareholder then it MUST become one.\n     *  If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed\n     *  from the list of shareholders.\n     *  MUST be removed from the list of shareholders.\n     *  @param from The address to transfer from\n     *  @param to The address to transfer to.\n     *  @param tokens The number of tokens to be transferred.\n     */\n    function transferOverride(address from, address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(from, tokens)\n    returns (bool) {\n        // Ensure the sender can perform the override.\n        bool transferAllowed = canTransfer(from, to, tokens, true);\n        // Ensure the transfer is allowed.\n        if (transferAllowed) {\n            transferTokens(from, to, tokens);\n        }\n        return transferAllowed;\n    }\n\n    /**\n     *  @dev Tokens will be issued to the issuer's address only.\n     *  @param quantity The number of tokens to mint.\n     *  @return A boolean that indicates if the operation was successful.\n     */\n    function issueTokens(uint256 quantity)\n    external\n    isUnlocked\n    onlyIssuer\n    canIssue\n    returns (bool) {\n        // Avoid doing any state changes for zero quantities\n        if (quantity > 0) {\n            totalSupplyTokens = totalSupplyTokens.add(quantity);\n            balances[issuer] = balances[issuer].add(quantity);\n            shareholders.append(issuer);\n        }\n        emit Issue(issuer, quantity);\n        emit Transfer(ZERO_ADDRESS, issuer, quantity);\n        return true;\n    }\n\n    /**\n     *  @dev Finishes token issuance.\n     *  This is a single use function, once invoked it cannot be undone.\n     */\n    function finishIssuing()\n    external\n    isUnlocked\n    onlyIssuer\n    canIssue\n    returns (bool) {\n        issuingFinished = true;\n        emit IssueFinished();\n        return issuingFinished;\n    }\n\n    /**\n     *  @dev Cancel the original address and reissue the Tokens to the replacement address.\n     *\n     *  Access to this function is restricted to the Issuer only.\n     *  The 'original' address MUST be removed from the set of whitelisted addresses.\n     *  Throw if the 'original' address supplied is not a shareholder.\n     *  Throw if the 'replacement' address is not a whitelisted address.\n     *  This function MUST emit the 'VerifiedAddressSuperseded' event.\n     *  @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.\n     *  @param replacement The address  that supersedes the original. This address MUST be whitelisted.\n     */\n    function cancelAndReissue(address original, address replacement)\n    external\n    isUnlocked\n    onlyIssuer\n    isNotCancelled(replacement) {\n        // Ensure the reissue can take place\n        require(shareholders.exists(original) && !shareholders.exists(replacement), \"Original doesn't exist or replacement does\");\n        if (address(compliance) != ZERO_ADDRESS) {\n            require(compliance.canIssue(msg.sender, original, replacement, balances[original]), \"Failed 'canIssue' check.\");\n        }\n\n        // Replace the original shareholder with the replacement\n        shareholders.remove(original);\n        shareholders.append(replacement);\n        // Add the original as a cancelled address (preventing it from future trading)\n        cancellations[original] = replacement;\n        // Transfer the balance to the replacement\n        balances[replacement] = balances[original];\n        balances[original] = 0;\n        emit VerifiedAddressSuperseded(original, replacement, msg.sender);\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified number of tokens on behalf of msg.sender.\n     *\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param tokens The number of tokens of tokens to be spent.\n     */\n    function approve(address spender, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(msg.sender)\n    returns (bool) {\n        require(shareholders.exists(msg.sender), \"Must be a shareholder to approve token transfer\");\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    /**\n     *  @dev Set the issuer address.\n     *  @param newIssuer The address of the issuer.\n     */\n    function setIssuer(address newIssuer)\n    external\n    isUnlocked\n    onlyOwner {\n        issuer = newIssuer;\n        emit IssuerSet(issuer, newIssuer);\n    }\n\n    /**\n     *  @dev Sets the compliance contract address to use during transfers.\n     *  @param newComplianceAddress The address of the compliance contract.\n     */\n    function setCompliance(address newComplianceAddress)\n    external\n    isUnlocked\n    onlyOwner {\n        compliance = Compliance(newComplianceAddress);\n    }\n\n    // -------------------------------- Getters --------------------------------\n\n    /**\n     *  @dev Returns the total token supply\n     *  @return total number of tokens in existence\n     */\n    function totalSupply()\n    external\n    view\n    returns (uint256) {\n        return totalSupplyTokens;\n    }\n\n    /**\n     *  @dev Gets the balance of the specified address.\n     *  @param addr The address to query the the balance of.\n     *  @return An uint256 representing the tokens owned by the passed address.\n     */\n    function balanceOf(address addr)\n    external\n    view\n    returns (uint256) {\n        return balances[addr];\n    }\n\n    /**\n     *  @dev Gets the number of tokens that an owner has allowed the spender to transfer.\n     *  @param addrOwner address The address which owns the funds.\n     *  @param spender address The address which will spend the funds.\n     *  @return A uint256 specifying the number of tokens still available for the spender.\n     */\n    function allowance(address addrOwner, address spender)\n    external\n    view\n    returns (uint256) {\n        return allowed[addrOwner][spender];\n    }\n\n    /**\n     *  By counting the number of token holders using 'holderCount'\n     *  you can retrieve the complete list of token holders, one at a time.\n     *  It MUST throw if 'index >= holderCount()'.\n     *  @dev Returns the holder at the given index.\n     *  @param index The zero-based index of the holder.\n     *  @return the address of the token holder with the given index.\n     */\n    function holderAt(int256 index)\n    external\n    view\n    returns (address){\n        return shareholders.at(index);\n    }\n\n    /**\n     *  @dev Checks to see if the supplied address is a share holder.\n     *  @param addr The address to check.\n     *  @return true if the supplied address owns a token.\n     */\n    function isHolder(address addr)\n    external\n    view\n    returns (bool) {\n        return shareholders.exists(addr);\n    }\n\n    /**\n     *  @dev Checks to see if the supplied address was superseded.\n     *  @param addr The address to check.\n     *  @return true if the supplied address was superseded by another address.\n     */\n    function isSuperseded(address addr)\n    external\n    view\n    returns (bool) {\n        return cancellations[addr] != ZERO_ADDRESS;\n    }\n\n    /**\n     *  Gets the most recent address, given a superseded one.\n     *  Addresses may be superseded multiple times, so this function needs to\n     *  follow the chain of addresses until it reaches the final, verified address.\n     *  @param addr The superseded address.\n     *  @return the verified address that ultimately holds the share.\n     */\n    function getSuperseded(address addr)\n    external\n    view\n    returns (address) {\n        require(addr != ZERO_ADDRESS, \"Non-zero address required\");\n\n        address candidate = cancellations[addr];\n        if (candidate == ZERO_ADDRESS) {\n            return ZERO_ADDRESS;\n        }\n        return candidate;\n    }\n\n\n    // -------------------------------- Private --------------------------------\n\n    /**\n     *  @dev Checks if a transfer/override may take place between the two accounts.\n     *\n     *   Validates that the transfer can take place.\n     *     - Ensure the 'to' address is not cancelled\n     *     - Ensure the transfer is compliant\n     *  @param from The sender address.\n     *  @param to The recipient address.\n     *  @param tokens The number of tokens being transferred.\n     *  @param isOverride If this is a transfer override\n     *  @return If the transfer can take place.\n     */\n    function canTransfer(address from, address to, uint256 tokens, bool isOverride)\n    private\n    isNotCancelled(to)\n    returns (bool) {\n        // Don't allow overrides and ignore compliance rules when compliance not set.\n        if (address(compliance) == ZERO_ADDRESS) {\n            return !isOverride;\n        }\n\n        // Ensure the override is valid, or that the transfer is compliant.\n        if (isOverride) {\n            return compliance.canOverride(msg.sender, from, to, tokens);\n        } else {\n            return compliance.canTransfer(msg.sender, from, to, tokens);\n        }\n    }\n\n    /**\n     *  @dev Transfers tokens from one address to another\n     *  @param from The sender address.\n     *  @param to The recipient address.\n     *  @param tokens The number of tokens being transferred.\n     */\n    function transferTokens(address from, address to, uint256 tokens)\n    private {\n        // Update balances\n        balances[from] = balances[from].subtract(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n\n        // Adds the shareholder if they don't already exist.\n        if (balances[to] > 0 && shareholders.append(to)) {\n            emit ShareholderAdded(to);\n        }\n        // Remove the shareholder if they no longer hold tokens.\n        if (balances[from] == 0 && shareholders.remove(from)) {\n            emit ShareholderRemoved(from);\n        }\n    }\n\n}",
    "function_sum": 14,
    "compiler_version": "0.5.2",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/**\n *  @title Ownable\n *  @dev Provides a modifier that requires the caller to be the owner of the contract.\n */\n\ncontract Ownable {\n    address payable public owner;\n\n    event OwnerTransferred(\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Owner account is required\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwner(address payable newOwner)\n    public\n    onlyOwner {\n        require(newOwner != owner, \"New Owner cannot be the current owner\");\n        require(newOwner != address(0), \"New Owner cannot be zero address\");\n        address payable prevOwner = owner;\n        owner = newOwner;\n        emit OwnerTransferred(prevOwner, newOwner);\n    }\n}\n\n/**\n *  @title Lockable\n *  @dev The Lockable contract adds the ability for the contract owner to set the lock status\n *  of the account. A modifier is provided that checks the throws when the contract is\n *  in the locked state.\n */\n\ncontract Lockable is Ownable {\n    bool public isLocked;\n\n    constructor() public {\n        isLocked = false;\n    }\n\n    modifier isUnlocked() {\n        require(!isLocked, \"Contract is currently locked for modification\");\n        _;\n    }\n\n    /**\n     *  Set the contract to a read-only state.\n     *  @param locked The locked state to set the contract to.\n     */\n    function setLocked(bool locked)\n    onlyOwner\n    external {\n        require(isLocked != locked, \"Contract already in requested lock state\");\n\n        isLocked = locked;\n    }\n}\n\n/**\n *  @title Destroyable\n *  @dev The Destroyable contract alows the owner address to `selfdestruct` the contract.\n */\n\ncontract Destroyable is Ownable {\n    /**\n     *  Allow the owner to destroy this contract.\n     */\n    function kill()\n    onlyOwner\n    external {\n        selfdestruct(owner);\n    }\n}\n\n/**\n *  Contract to facilitate locking and self destructing.\n */\n\ncontract LockableDestroyable is Lockable, Destroyable { }\n\nlibrary AdditiveMath {\n    /**\n     *  Adds two numbers and returns the result\n     *  THROWS when the result overflows\n     *  @return The sum of the arguments\n     */\n    function add(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256) {\n        uint256 sum = x + y;\n        require(sum >= x, \"Results in overflow\");\n        return sum;\n    }\n\n    /**\n     *  Subtracts two numbers and returns the result\n     *  THROWS when the result underflows\n     *  @return The difference of the arguments\n     */\n    function subtract(uint256 x, uint256 y)\n    internal\n    pure\n    returns (uint256) {\n        require(y <= x, \"Results in underflow\");\n        return x - y;\n    }\n}\n\n/**\n *\n *  @title AddressMap\n *  @dev Map of unique indexed addresseses.\n *\n *  **NOTE**\n *    The internal collections are one-based.\n *    This is simply because null values are expressed as zero,\n *    which makes it hard to check for the existence of items within the array,\n *    or grabbing the first item of an array for non-existent items.\n *\n *    This is only exposed internally, so callers still use zero-based indices.\n *\n */\n\nlibrary AddressMap {\n    struct Data {\n        int256 count;\n        mapping(address => int256) indices;\n        mapping(int256 => address) items;\n    }\n\n    address constant ZERO_ADDRESS = address(0);\n\n    /**\n     *  Appends the address to the end of the map, if the address is not\n     *  zero and the address doesn't currently exist.\n     *  @param addr The address to append.\n     *  @return true if the address was added.\n     */\n    function append(Data storage self, address addr)\n    internal\n    returns (bool) {\n        if (addr == ZERO_ADDRESS) {\n            return false;\n        }\n\n        int256 index = self.indices[addr] - 1;\n        if (index >= 0 && index < self.count) {\n            return false;\n        }\n\n        self.count++;\n        self.indices[addr] = self.count;\n        self.items[self.count] = addr;\n        return true;\n    }\n\n    /**\n     *  Removes the given address from the map.\n     *  @param addr The address to remove from the map.\n     *  @return true if the address was removed.\n     */\n    function remove(Data storage self, address addr)\n    internal\n    returns (bool) {\n        int256 oneBasedIndex = self.indices[addr];\n        if (oneBasedIndex < 1 || oneBasedIndex > self.count) {\n            return false;  // address doesn't exist, or zero.\n        }\n\n        // When the item being removed is not the last item in the collection,\n        // replace that item with the last one, otherwise zero it out.\n        //\n        //  If {2} is the item to be removed\n        //     [0, 1, 2, 3, 4]\n        //  The result would be:\n        //     [0, 1, 4, 3]\n        //\n        if (oneBasedIndex < self.count) {\n            // Replace with last item\n            address last = self.items[self.count];  // Get the last item\n            self.indices[last] = oneBasedIndex;     // Update last items index to current index\n            self.items[oneBasedIndex] = last;       // Update current index to last item\n            delete self.items[self.count];          // Delete the last item, since it's moved\n        } else {\n            // Delete the address\n            delete self.items[oneBasedIndex];\n        }\n\n        delete self.indices[addr];\n        self.count--;\n        return true;\n    }\n\n    /**\n     * Clears all items within the map.\n     */\n    function clear(Data storage self)\n    internal {\n        self.count = 0;\n    }\n\n    /**\n     *  Retrieves the address at the given index.\n     *  THROWS when the index is invalid.\n     *  @param index The index of the item to retrieve.\n     *  @return The address of the item at the given index.\n     */\n    function at(Data storage self, int256 index)\n    internal\n    view\n    returns (address) {\n        require(index >= 0 && index < self.count, \"Index outside of bounds.\");\n        return self.items[index + 1];\n    }\n\n    /**\n     *  Gets the index of the given address.\n     *  @param addr The address of the item to get the index for.\n     *  @return The index of the given address.\n     */\n    function indexOf(Data storage self, address addr)\n    internal\n    view\n    returns (int256) {\n        if (addr == ZERO_ADDRESS) {\n            return -1;\n        }\n\n        int256 index = self.indices[addr] - 1;\n        if (index < 0 || index >= self.count) {\n            return -1;\n        }\n        return index;\n    }\n\n    /**\n     *  Returns whether or not the given address exists within the map.\n     *  @param addr The address to check for existence.\n     *  @return If the given address exists or not.\n     */\n    function exists(Data storage self, address addr)\n    internal\n    view\n    returns (bool) {\n        int256 index = self.indices[addr] - 1;\n        return index >= 0 && index < self.count;\n    }\n\n}\n\ninterface Compliance {\n\n    /**\n     *  This event is emitted when an address's frozen status has changed.\n     *  @param addr The address whose frozen status has been updated.\n     *  @param isFrozen Whether the custodian is being frozen.\n     *  @param owner The address that updated the frozen status.\n     */\n    event AddressFrozen(\n        address indexed addr,\n        bool indexed isFrozen,\n        address indexed owner\n    );\n\n    /**\n     *  Sets an address frozen status for this token\n     *  @param addr The address to update frozen status.\n     *  @param freeze Frozen status of the address.\n     */\n    function setFrozen(address addr, bool freeze)\n    external;\n\n    /**\n     *  Replaces all of the existing rules with the given ones\n     *  @param kind The bucket of rules to set.\n     *  @param rules New compliance rules.\n     */\n    function setRules(uint8 kind, ComplianceRule[] calldata rules)\n    external;\n\n    /**\n     *  Returns all of the current compliance rules for this token\n     *  @param kind The bucket of rules to get.\n     *  @return List of all compliance rules.\n     */\n    function getRules(uint8 kind)\n    external\n    view\n    returns (ComplianceRule[] memory);\n\n    /**\n     *  @dev Checks if issuance can occur between the from/to addresses.\n     *\n     *  Both addresses must be whitelisted and unfrozen\n     *  THROWS when the transfer should fail.\n     *  @param issuer The address initiating the issuance.\n     *  @param from The address of the sender.\n     *  @param to The address of the receiver.\n     *  @param tokens The number of tokens being transferred.\n     *  @return If a issuance can occur between the from/to addresses.\n     */\n    function canIssue(address issuer, address from, address to, uint256 tokens)\n    external\n    returns (bool);\n\n    /**\n     *  @dev Checks if a transfer can occur between the from/to addresses.\n     *\n     *  Both addresses must be whitelisted, unfrozen, and pass all compliance rule checks.\n     *  THROWS when the transfer should fail.\n     *  @param initiator The address initiating the transfer.\n     *  @param from The address of the sender.\n     *  @param to The address of the receiver.\n     *  @param tokens The number of tokens being transferred.\n     *  @return If a transfer can occur between the from/to addresses.\n     */\n    function canTransfer(address initiator, address from, address to, uint256 tokens)\n    external\n    returns (bool);\n\n    /**\n     *  @dev Checks if an override by the sender can occur between the from/to addresses.\n     *\n     *  Both addresses must be whitelisted and unfrozen.\n     *  THROWS when the sender is not allowed to override.\n     *  @param admin The address initiating the transfer.\n     *  @param from The address of the sender.\n     *  @param to The address of the receiver.\n     *  @param tokens The number of tokens being transferred.\n     *  @return If an override can occur between the from/to addresses.\n     */\n    function canOverride(address admin, address from, address to, uint256 tokens)\n    external\n    returns (bool);\n}\n\ninterface ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 value) external returns (bool);\n    function balanceOf(address who) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n\n\n// You task is to complete the smart contract T0ken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.2, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title T0ken\n * @notice A token contract that extends ERC20, Ownable, and LockableDestroyable. It includes features for issuing tokens, managing shareholders, and compliance checks.\n * @dev This contract is designed to manage a token with specific compliance rules, allowing for the issuance of tokens, transfer of tokens, and management of shareholders. It also includes functionality to cancel and reissue tokens to new addresses.\n */\ncontract T0ken is ERC20, Ownable, LockableDestroyable {\n\n    // ------------------------------- Variables -------------------------------\n\n    using AdditiveMath for uint256;\n    using AddressMap for AddressMap.Data;\n\n    address constant internal ZERO_ADDRESS = address(0);\n    string public constant name = \"TZERO PREFERRED\";\n    string public constant symbol = \"TZROP\";\n    uint8 public constant decimals = 0;\n\n    AddressMap.Data public shareholders;\n    Compliance public compliance;\n    address public issuer;\n    bool public issuingFinished = false;\n    mapping(address => address) public cancellations;\n\n    mapping(address => uint256) internal balances;\n    uint256 internal totalSupplyTokens;\n\n    mapping (address => mapping (address => uint256)) private allowed;\n\n    // ------------------------------- Modifiers -------------------------------\n\n    /**\n     * @notice Modifier to ensure only the issuer can call the function.\n     * @dev Reverts if the caller is not the issuer.\n     */\n    modifier onlyIssuer() {\n        require(msg.sender == issuer, \"Only issuer allowed\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure token issuance is not finished.\n     * @dev Reverts if issuing is already finished.\n     */\n    modifier canIssue() {\n        require(!issuingFinished, \"Issuing is already finished\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the address has not been cancelled.\n     * @dev Reverts if the address has been cancelled.\n     * @param addr The address to check.\n     */\n    modifier isNotCancelled(address addr) {\n        require(cancellations[addr] == ZERO_ADDRESS, \"Address has been cancelled\");\n        _;\n    }\n\n    /**\n     * @notice Modifier to ensure the address has sufficient funds.\n     * @dev Reverts if the address does not have enough tokens.\n     * @param addr The address to check.\n     * @param tokens The number of tokens to check.\n     */\n    modifier hasFunds(address addr, uint256 tokens) {\n        require(tokens <= balances[addr], \"Insufficient funds\");\n        _;\n    }\n\n    // -------------------------------- Events ---------------------------------\n\n    /**\n     * @notice Emitted when an address is cancelled and replaced with a new address.\n     * @dev This event is used to log the replacement of a shareholder's address.\n     * @param original The address being superseded.\n     * @param replacement The new address.\n     * @param sender The address that caused the address to be superseded.\n     */\n    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);\n\n    /**\n     * @notice Emitted when the issuer address is set.\n     * @dev This event is used to log the change in the issuer address.\n     * @param previousIssuer The previous issuer address.\n     * @param newIssuer The new issuer address.\n     */\n    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);\n\n    /**\n     * @notice Emitted when tokens are issued.\n     * @dev This event is used to log the issuance of tokens.\n     * @param to The address to which tokens are issued.\n     * @param tokens The number of tokens issued.\n     */\n    event Issue(address indexed to, uint256 tokens);\n\n    /**\n     * @notice Emitted when token issuance is finished.\n     * @dev This event is used to log the completion of token issuance.\n     */\n    event IssueFinished();\n\n    /**\n     * @notice Emitted when a shareholder is added.\n     * @dev This event is used to log the addition of a new shareholder.\n     * @param shareholder The address of the new shareholder.\n     */\n    event ShareholderAdded(address shareholder);\n\n    /**\n     * @notice Emitted when a shareholder is removed.\n     * @dev This event is used to log the removal of a shareholder.\n     * @param shareholder The address of the removed shareholder.\n     */\n    event ShareholderRemoved(address shareholder);\n\n    // -------------------------------------------------------------------------\n\n    /**\n     * @notice Transfers tokens to the whitelisted account.\n     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed from the list of shareholders.\n     * @param to The address to transfer to.\n     * @param tokens The number of tokens to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transfer(address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(msg.sender, tokens)\n    returns (bool) {}\n\n    /**\n     * @notice Transfers tokens between whitelisted accounts.\n     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'from' balance to 0, then that address MUST be removed from the list of shareholders.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokens The number of tokens to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferFrom(address from, address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(from, tokens)\n    returns (bool) {}\n\n    /**\n     * @notice Overrides a transfer of tokens to the whitelisted account.\n     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed from the list of shareholders.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokens The number of tokens to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferOverride(address from, address to, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(to)\n    hasFunds(from, tokens)\n    returns (bool) {}\n\n    /**\n     * @notice Issues tokens to the issuer's address only.\n     * @dev Tokens will be issued to the issuer's address only.\n     * @param quantity The number of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function issueTokens(uint256 quantity)\n    external\n    isUnlocked\n    onlyIssuer\n    canIssue\n    returns (bool) {}\n\n    /**\n     * @notice Finishes token issuance.\n     * @dev This is a single-use function; once invoked, it cannot be undone.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function finishIssuing()\n    external\n    isUnlocked\n    onlyIssuer\n    canIssue\n    returns (bool) {}\n\n    /**\n     * @notice Cancels the original address and reissues the tokens to the replacement address.\n     * @dev Access to this function is restricted to the issuer only. The 'original' address MUST be removed from the set of whitelisted addresses. Throws if the 'original' address supplied is not a shareholder or if the 'replacement' address is not a whitelisted address.\n     * @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.\n     * @param replacement The address that supersedes the original. This address MUST be whitelisted.\n     */\n    function cancelAndReissue(address original, address replacement)\n    external\n    isUnlocked\n    onlyIssuer\n    isNotCancelled(replacement) {}\n\n    /**\n     * @notice Approves the passed address to spend the specified number of tokens on behalf of msg.sender.\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards.\n     * @param spender The address which will spend the funds.\n     * @param tokens The number of tokens to be spent.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approve(address spender, uint256 tokens)\n    external\n    isUnlocked\n    isNotCancelled(msg.sender)\n    returns (bool) {}\n\n    /**\n     * @notice Sets the issuer address.\n     * @dev Only the owner can set the issuer address.\n     * @param newIssuer The address of the new issuer.\n     */\n    function setIssuer(address newIssuer)\n    external\n    isUnlocked\n    onlyOwner {}\n\n    /**\n     * @notice Sets the compliance contract address to use during transfers.\n     * @dev Only the owner can set the compliance contract address.\n     * @param newComplianceAddress The address of the new compliance contract.\n     */\n    function setCompliance(address newComplianceAddress)\n    external\n    isUnlocked\n    onlyOwner {}\n\n    // -------------------------------- Getters --------------------------------\n\n    /**\n     * @notice Returns the total token supply.\n     * @dev Returns the total number of tokens in existence.\n     * @return The total number of tokens in existence.\n     */\n    function totalSupply()\n    external\n    view\n    returns (uint256) {}\n\n    /**\n     * @notice Gets the balance of the specified address.\n     * @dev Returns the number of tokens owned by the passed address.\n     * @param addr The address to query the balance of.\n     * @return The number of tokens owned by the passed address.\n     */\n    function balanceOf(address addr)\n    external\n    view\n    returns (uint256) {}\n\n    /**\n     * @notice Gets the number of tokens that an owner has allowed the spender to transfer.\n     * @dev Returns the number of tokens still available for the spender.\n     * @param addrOwner The address which owns the funds.\n     * @param spender The address which will spend the funds.\n     * @return The number of tokens still available for the spender.\n     */\n    function allowance(address addrOwner, address spender)\n    external\n    view\n    returns (uint256) {}\n\n    /**\n     * @notice Returns the holder at the given index.\n     * @dev By counting the number of token holders using 'holderCount', you can retrieve the complete list of token holders, one at a time. It MUST throw if 'index >= holderCount()'.\n     * @param index The zero-based index of the holder.\n     * @return The address of the token holder with the given index.\n     */\n    function holderAt(int256 index)\n    external\n    view\n    returns (address) {}\n\n    /**\n     * @notice Checks to see if the supplied address is a shareholder.\n     * @dev Returns true if the supplied address owns a token.\n     * @param addr The address to check.\n     * @return True if the supplied address owns a token.\n     */\n    function isHolder(address addr)\n    external\n    view\n    returns (bool) {}\n\n    /**\n     * @notice Checks to see if the supplied address was superseded.\n     * @dev Returns true if the supplied address was superseded by another address.\n     * @param addr The address to check.\n     * @return True if the supplied address was superseded by another address.\n     */\n    function isSuperseded(address addr)\n    external\n    view\n    returns (bool) {}\n\n    /**\n     * @notice Gets the most recent address, given a superseded one.\n     * @dev Addresses may be superseded multiple times, so this function needs to follow the chain of addresses until it reaches the final, verified address.\n     * @param addr The superseded address.\n     * @return The verified address that ultimately holds the share.\n     */\n    function getSuperseded(address addr)\n    external\n    view\n    returns (address) {}\n\n    // -------------------------------- Private --------------------------------\n\n    /**\n     * @notice Checks if a transfer/override may take place between the two accounts.\n     * @dev Validates that the transfer can take place. Ensures the 'to' address is not cancelled and that the transfer is compliant.\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @param tokens The number of tokens being transferred.\n     * @param isOverride If this is a transfer override.\n     * @return If the transfer can take place.\n     */\n    function canTransfer(address from, address to, uint256 tokens, bool isOverride)\n    private\n    isNotCancelled(to)\n    returns (bool) {}\n\n    /**\n     * @notice Transfers tokens from one address to another.\n     * @dev Updates balances and emits the Transfer event. Adds the shareholder if they don't already exist and removes the shareholder if they no longer hold tokens.\n     * @param from The sender address.\n     * @param to The recipient address.\n     * @param tokens The number of tokens being transferred.\n     */\n    function transferTokens(address from, address to, uint256 tokens)\n    private {}\n}\n"
}