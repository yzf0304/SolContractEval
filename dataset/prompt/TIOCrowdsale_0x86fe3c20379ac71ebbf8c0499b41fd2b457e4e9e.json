{
    "contract_name": "CrowdsaleToken",
    "ground_truth": "contract CrowdsaleToken {\n\n  using TokenLib for TokenLib.TokenStorage;\n\n\n\n  TokenLib.TokenStorage public token;\n\n\n\n  function CrowdsaleToken(address owner,\n\n                                   string name,\n\n                                   string symbol,\n\n                                   uint8 decimals,\n\n                                   uint256 initialSupply,\n\n                                   bool allowMinting)\n\n                                   public\n\n  {\n\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n\n  }\n\n\n\n  function name() public view returns (string) {\n\n    return token.name;\n\n  }\n\n\n\n  function symbol() public view returns (string) {\n\n    return token.symbol;\n\n  }\n\n\n\n  function decimals() public view returns (uint8) {\n\n    return token.decimals;\n\n  }\n\n\n\n  function totalSupply() public view returns (uint256) {\n\n    return token.totalSupply;\n\n  }\n\n\n\n  function initialSupply() public view returns (uint256) {\n\n    return token.initialSupply;\n\n  }\n\n\n\n  function balanceOf(address who) public view returns (uint256) {\n\n    return token.balanceOf(who);\n\n  }\n\n\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n\n    return token.allowance(owner, spender);\n\n  }\n\n\n\n  function transfer(address to, uint256 value) public returns (bool ok) {\n\n    return token.transfer(to, value);\n\n  }\n\n\n\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n\n    return token.transferFrom(from, to, value);\n\n  }\n\n\n\n  function approve(address spender, uint256 value) public returns (bool ok) {\n\n    return token.approve(spender, value);\n\n  }\n\n\n\n  function approveChange(address spender, uint256 valueChange, bool increase)\n\n                         public\n\n                         returns (bool)\n\n  {\n\n    return token.approveChange(spender, valueChange, increase);\n\n  }\n\n\n\n  function changeOwner(address newOwner) public returns (bool ok) {\n\n    return token.changeOwner(newOwner);\n\n  }\n\n\n\n  function burnToken(uint256 amount) public returns (bool ok) {\n\n    return token.burnToken(amount);\n\n  }\n\n}",
    "function_sum": 14,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary TokenLib {\n\n  using BasicMathLib for uint256;\n\n\n\n  struct TokenStorage {\n\n    bool initialized;\n\n    mapping (address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n\n\n    string name;\n\n    string symbol;\n\n    uint256 totalSupply;\n\n    uint256 initialSupply;\n\n    address owner;\n\n    uint8 decimals;\n\n    bool stillMinting;\n\n  }\n\n\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  event OwnerChange(address from, address to);\n\n  event Burn(address indexed burner, uint256 value);\n\n  event MintingClosed(bool mintingClosed);\n\n\n\n  /// @dev Called by the Standard Token upon creation.\n\n  /// @param self Stored token from token contract\n\n  /// @param _name Name of the new token\n\n  /// @param _symbol Symbol of the new token\n\n  /// @param _decimals Decimal places for the token represented\n\n  /// @param _initial_supply The initial token supply\n\n  /// @param _allowMinting True if additional tokens can be created, false otherwise\n\n  function init(TokenStorage storage self,\n\n                address _owner,\n\n                string _name,\n\n                string _symbol,\n\n                uint8 _decimals,\n\n                uint256 _initial_supply,\n\n                bool _allowMinting)\n\n                public\n\n  {\n\n    require(!self.initialized);\n\n    self.initialized = true;\n\n    self.name = _name;\n\n    self.symbol = _symbol;\n\n    self.totalSupply = _initial_supply;\n\n    self.initialSupply = _initial_supply;\n\n    self.decimals = _decimals;\n\n    self.owner = _owner;\n\n    self.stillMinting = _allowMinting;\n\n    self.balances[_owner] = _initial_supply;\n\n  }\n\n\n\n  /// @dev Transfer tokens from caller's account to another account.\n\n  /// @param self Stored token from token contract\n\n  /// @param _to Address to send tokens\n\n  /// @param _value Number of tokens to send\n\n  /// @return True if completed\n\n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n\n    require(_to != address(0));\n\n    bool err;\n\n    uint256 balance;\n\n\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n\n    require(!err);\n\n    self.balances[msg.sender] = balance;\n\n    //It's not possible to overflow token supply\n\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Authorized caller transfers tokens from one account to another\n\n  /// @param self Stored token from token contract\n\n  /// @param _from Address to send tokens from\n\n  /// @param _to Address to send tokens to\n\n  /// @param _value Number of tokens to send\n\n  /// @return True if completed\n\n  function transferFrom(TokenStorage storage self,\n\n                        address _from,\n\n                        address _to,\n\n                        uint256 _value)\n\n                        public\n\n                        returns (bool)\n\n  {\n\n    var _allowance = self.allowed[_from][msg.sender];\n\n    bool err;\n\n    uint256 balanceOwner;\n\n    uint256 balanceSpender;\n\n\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n\n    require(!err);\n\n\n\n    (err,balanceSpender) = _allowance.minus(_value);\n\n    require(!err);\n\n\n\n    self.balances[_from] = balanceOwner;\n\n    self.allowed[_from][msg.sender] = balanceSpender;\n\n    self.balances[_to] = self.balances[_to] + _value;\n\n\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Retrieve token balance for an account\n\n  /// @param self Stored token from token contract\n\n  /// @param _owner Address to retrieve balance of\n\n  /// @return balance The number of tokens in the subject account\n\n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n\n    return self.balances[_owner];\n\n  }\n\n\n\n  /// @dev Authorize an account to send tokens on caller's behalf\n\n  /// @param self Stored token from token contract\n\n  /// @param _spender Address to authorize\n\n  /// @param _value Number of tokens authorized account may send\n\n  /// @return True if completed\n\n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n\n    // must set to zero before changing approval amount in accordance with spec\n\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n\n\n    self.allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Remaining tokens third party spender has to send\n\n  /// @param self Stored token from token contract\n\n  /// @param _owner Address of token holder\n\n  /// @param _spender Address of authorized spender\n\n  /// @return remaining Number of tokens spender has left in owner's account\n\n  function allowance(TokenStorage storage self, address _owner, address _spender)\n\n                     public\n\n                     view\n\n                     returns (uint256 remaining) {\n\n    return self.allowed[_owner][_spender];\n\n  }\n\n\n\n  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\n\n  /// @param self Stored token from token contract\n\n  /// @param _spender Address to authorize\n\n  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\n\n  /// @param _increase True if increasing allowance, false if decreasing allowance\n\n  /// @return True if completed\n\n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n\n                          public returns (bool)\n\n  {\n\n    uint256 _newAllowed;\n\n    bool err;\n\n\n\n    if(_increase) {\n\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n\n      require(!err);\n\n\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n\n    } else {\n\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n\n        self.allowed[msg.sender][_spender] = 0;\n\n      } else {\n\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n\n        self.allowed[msg.sender][_spender] = _newAllowed;\n\n      }\n\n    }\n\n\n\n    Approval(msg.sender, _spender, _newAllowed);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Change owning address of the token contract, specifically for minting\n\n  /// @param self Stored token from token contract\n\n  /// @param _newOwner Address for the new owner\n\n  /// @return True if completed\n\n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n\n\n    self.owner = _newOwner;\n\n    OwnerChange(msg.sender, _newOwner);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Mints additional tokens, new tokens go to owner\n\n  /// @param self Stored token from token contract\n\n  /// @param _amount Number of tokens to mint\n\n  /// @return True if completed\n\n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n\n    require((self.owner == msg.sender) && self.stillMinting);\n\n    uint256 _newAmount;\n\n    bool err;\n\n\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n\n    require(!err);\n\n\n\n    self.totalSupply =  _newAmount;\n\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n\n    Transfer(0x0, self.owner, _amount);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Permanent stops minting\n\n  /// @param self Stored token from token contract\n\n  /// @return True if completed\n\n  function closeMint(TokenStorage storage self) public returns (bool) {\n\n    require(self.owner == msg.sender);\n\n\n\n    self.stillMinting = false;\n\n    MintingClosed(true);\n\n    return true;\n\n  }\n\n\n\n  /// @dev Permanently burn tokens\n\n  /// @param self Stored token from token contract\n\n  /// @param _amount Amount of tokens to burn\n\n  /// @return True if completed\n\n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n\n      uint256 _newBalance;\n\n      bool err;\n\n\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n\n      require(!err);\n\n\n\n      self.balances[msg.sender] = _newBalance;\n\n      self.totalSupply = self.totalSupply - _amount;\n\n      Burn(msg.sender, _amount);\n\n      Transfer(msg.sender, 0x0, _amount);\n\n      return true;\n\n  }\n\n}\n\n\n\n// You task is to complete the smart contract CrowdsaleToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract implements a basic ERC20 token with additional features like minting, burning, and owner change.\n * @dev It uses the TokenLib library to handle most of the token functionalities. The contract is designed to be used in a crowdsale context.\n */\ncontract CrowdsaleToken {\n\n  using TokenLib for TokenLib.TokenStorage;\n\n  TokenLib.TokenStorage public token;\n\n  /**\n   * @notice Initializes the token with the provided parameters.\n   * @param owner The initial owner of the token.\n   * @param name The name of the token.\n   * @param symbol The symbol of the token.\n   * @param decimals The number of decimal places the token supports.\n   * @param initialSupply The initial supply of tokens.\n   * @param allowMinting Whether or not minting is allowed.\n   * @dev This function initializes the token with the given parameters and sets the initial supply.\n   */\n  function CrowdsaleToken(address owner,\n                          string memory name,\n                          string memory symbol,\n                          uint8 decimals,\n                          uint256 initialSupply,\n                          bool allowMinting) public {\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n  }\n\n  /**\n   * @notice Returns the name of the token.\n   * @return The name of the token.\n   * @dev This function returns the name of the token as stored in the TokenLib.\n   */\n  function name() public view returns (string memory) {}\n\n  /**\n   * @notice Returns the symbol of the token.\n   * @return The symbol of the token.\n   * @dev This function returns the symbol of the token as stored in the TokenLib.\n   */\n  function symbol() public view returns (string memory) {}\n\n  /**\n   * @notice Returns the number of decimals the token supports.\n   * @return The number of decimals.\n   * @dev This function returns the number of decimals the token supports as stored in the TokenLib.\n   */\n  function decimals() public view returns (uint8) {}\n\n  /**\n   * @notice Returns the total supply of the token.\n   * @return The total supply of the token.\n   * @dev This function returns the total supply of the token as stored in the TokenLib.\n   */\n  function totalSupply() public view returns (uint256) {}\n\n  /**\n   * @notice Returns the initial supply of the token.\n   * @return The initial supply of the token.\n   * @dev This function returns the initial supply of the token as stored in the TokenLib.\n   */\n  function initialSupply() public view returns (uint256) {}\n\n  /**\n   * @notice Returns the balance of the specified address.\n   * @param who The address to query the balance of.\n   * @return The balance of the specified address.\n   * @dev This function returns the balance of the specified address as stored in the TokenLib.\n   */\n  function balanceOf(address who) public view returns (uint256) {}\n\n  /**\n   * @notice Returns the remaining allowance of the spender over the owner's tokens.\n   * @param owner The address of the token owner.\n   * @param spender The address of the spender.\n   * @return The remaining allowance.\n   * @dev This function returns the remaining allowance of the spender over the owner's tokens as stored in the TokenLib.\n   */\n  function allowance(address owner, address spender) public view returns (uint256) {}\n\n  /**\n   * @notice Transfers a specified amount of tokens to the recipient.\n   * @param to The recipient address.\n   * @param value The amount of tokens to transfer.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function transfers a specified amount of tokens to the recipient using the TokenLib.\n   */\n  function transfer(address to, uint256 value) public returns (bool ok) {}\n\n  /**\n   * @notice Transfers tokens from one address to another.\n   * @param from The address to transfer from.\n   * @param to The address to transfer to.\n   * @param value The amount of tokens to transfer.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function transfers tokens from one address to another using the TokenLib.\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {}\n\n  /**\n   * @notice Approves the spender to spend a specified amount of tokens on behalf of the owner.\n   * @param spender The address of the spender.\n   * @param value The amount of tokens to approve.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function approves the spender to spend a specified amount of tokens on behalf of the owner using the TokenLib.\n   */\n  function approve(address spender, uint256 value) public returns (bool ok) {}\n\n  /**\n   * @notice Changes the approved amount for a spender by a specified value.\n   * @param spender The address of the spender.\n   * @param valueChange The amount to change the approval by.\n   * @param increase Whether to increase or decrease the approval.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function changes the approved amount for a spender by a specified value using the TokenLib.\n   */\n  function approveChange(address spender, uint256 valueChange, bool increase) public returns (bool) {}\n\n  /**\n   * @notice Changes the owner of the token.\n   * @param newOwner The new owner address.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function changes the owner of the token using the TokenLib.\n   */\n  function changeOwner(address newOwner) public returns (bool ok) {}\n\n  /**\n   * @notice Burns a specified amount of tokens.\n   * @param amount The amount of tokens to burn.\n   * @return A boolean indicating if the operation was successful.\n   * @dev This function burns a specified amount of tokens using the TokenLib.\n   */\n  function burnToken(uint256 amount) public returns (bool ok) {}\n\n}\n"
}