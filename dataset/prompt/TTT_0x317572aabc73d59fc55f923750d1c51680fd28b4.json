{
    "contract_name": "TTT",
    "ground_truth": "contract TTT is ERC20, ERC223 {\n  using SafeMath for uint;\n     \n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n    uint256 internal _totalSupply;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    function TTT(string name, string symbol, uint8 decimals, uint256 totalSupply) public {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        balances[msg.sender] = totalSupply;\n    }\n\n    function name()\n        public\n        view\n        returns (string) {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        returns (string) {\n        return _symbol;\n    }\n\n    function decimals()\n        public\n        view\n        returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply()\n        public\n        view\n        returns (uint256) {\n        return _totalSupply;\n    }\n\n   function transfer(address _to, uint256 _value) public returns (bool) {\n     require(_to != address(0));\n     require(_value <= balances[msg.sender]);\n     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n     balances[_to] = SafeMath.add(balances[_to], _value);\n     Transfer(msg.sender, _to, _value);\n     return true;\n   }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n   }\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n     require(_value <= balances[_from]);\n     require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = SafeMath.sub(balances[_from], _value);\n     balances[_to] = SafeMath.add(balances[_to], _value);\n     allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n    Transfer(_from, _to, _value);\n     return true;\n   }\n\n   function approve(address _spender, uint256 _value) public returns (bool) {\n     allowed[msg.sender][_spender] = _value;\n     Approval(msg.sender, _spender, _value);\n     return true;\n   }\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n     return allowed[_owner][_spender];\n   }\n\n   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);\n     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n     return true;\n   }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n     uint oldValue = allowed[msg.sender][_spender];\n     if (_subtractedValue > oldValue) {\n       allowed[msg.sender][_spender] = 0;\n     } else {\n       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\n    }\n     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n     return true;\n   }\n   \n  function transfer(address _to, uint _value, bytes _data) public {\n    require(_value > 0 );\n    if(isContract(_to)) {\n        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n    }\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value, _data);\n    }\n    \n  function isContract(address _addr) private returns (bool is_contract) {\n      uint length;\n      assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n      }\n      return (length>0);\n    }\n\n\n}",
    "function_sum": 14,
    "compiler_version": "0.4.24",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ninterface ERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface ERC223 {\n    function transfer(address to, uint value, bytes data) public;\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n}\n\ncontract ERC223ReceivingContract { \n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}\n\n\n\n// You task is to complete the smart contract TTT strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.24, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract implements a token that is ERC20 and ERC223 compliant, allowing for basic token operations such as transfer, approval, and allowance.\n * @dev The contract uses SafeMath to prevent overflows and underflows. It also includes the ability to transfer tokens with additional data, as per the ERC223 standard.\n */\ncontract TTT is ERC20, ERC223 {\n  using SafeMath for uint;\n     \n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n    uint256 internal _totalSupply;\n\n    mapping (address => uint256) internal balances;\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @notice Initializes the token with a name, symbol, decimals, and total supply.\n     * @param name The name of the token.\n     * @param symbol The symbol of the token.\n     * @param decimals The number of decimals the token supports.\n     * @param totalSupply The total supply of the token.\n     */\n    function TTT(string name, string symbol, uint8 decimals, uint256 totalSupply) public {\n        _symbol = symbol;\n        _name = name;\n        _decimals = decimals;\n        _totalSupply = totalSupply;\n        balances[msg.sender] = totalSupply;\n    }\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token.\n     */\n    function name()\n        public\n        view\n        returns (string) {}\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return The symbol of the token.\n     */\n    function symbol()\n        public\n        view\n        returns (string) {}\n\n    /**\n     * @notice Returns the number of decimals the token uses.\n     * @return The number of decimals.\n     */\n    function decimals()\n        public\n        view\n        returns (uint8) {}\n\n    /**\n     * @notice Returns the total supply of the token.\n     * @return The total supply of the token.\n     */\n    function totalSupply()\n        public\n        view\n        returns (uint256) {}\n\n   /**\n    * @notice Transfers a specified amount of tokens from the sender's account to another address.\n    * @param _to The address to which the tokens will be transferred.\n    * @param _value The amount of tokens to transfer.\n    * @return A boolean indicating whether the transfer was successful.\n    */\n   function transfer(address _to, uint256 _value) public returns (bool) {}\n\n  /**\n   * @notice Returns the balance of the specified address.\n   * @param _owner The address to query the balance of.\n   * @return The balance of the specified address.\n   */\n  function balanceOf(address _owner) public view returns (uint256 balance) {}\n\n  /**\n   * @notice Transfers a specified amount of tokens from one address to another, given the sender has been approved by the owner.\n   * @param _from The address from which the tokens will be transferred.\n   * @param _to The address to which the tokens will be transferred.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating whether the transfer was successful.\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {}\n\n   /**\n    * @notice Approves an address to spend a specified amount of tokens on behalf of the sender.\n    * @param _spender The address that is being approved to spend tokens.\n    * @param _value The amount of tokens to approve.\n    * @return A boolean indicating whether the approval was successful.\n    */\n   function approve(address _spender, uint256 _value) public returns (bool) {}\n\n  /**\n   * @notice Returns the remaining number of tokens that `_spender` is allowed to spend on behalf of `_owner`.\n   * @param _owner The address of the token owner.\n   * @param _spender The address of the spender.\n   * @return The remaining allowance.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {}\n\n   /**\n    * @notice Increases the amount of tokens that an approved spender is allowed to withdraw from the sender's account.\n    * @param _spender The address of the spender.\n    * @param _addedValue The additional amount of tokens to allow.\n    * @return A boolean indicating whether the increase was successful.\n    */\n   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {}\n\n  /**\n   * @notice Decreases the amount of tokens that an approved spender is allowed to withdraw from the sender's account.\n   * @param _spender The address of the spender.\n   * @param _subtractedValue The amount of tokens to subtract from the allowance.\n   * @return A boolean indicating whether the decrease was successful.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {}\n   \n  /**\n   * @notice Transfers a specified amount of tokens to another address and calls the `tokenFallback` function if the recipient is a contract.\n   * @param _to The address to which the tokens will be transferred.\n   * @param _value The amount of tokens to transfer.\n   * @param _data Additional data to pass to the `tokenFallback` function.\n   */\n  function transfer(address _to, uint _value, bytes _data) public {}\n\n  /**\n   * @dev Checks if the given address is a contract.\n   * @param _addr The address to check.\n   * @return A boolean indicating whether the address is a contract.\n   */\n  function isContract(address _addr) private returns (bool is_contract) {}\n}\n"
}