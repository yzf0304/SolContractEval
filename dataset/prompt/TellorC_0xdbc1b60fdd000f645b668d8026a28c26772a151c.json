{
    "contract_name": "TellorC",
    "ground_truth": "contract TellorC {\n    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;\n\n    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; // keccak256(\"slotProgress\")\n    address private owner;\n    address private miner;\n    \n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    function changeMiner(address _addr) external {\n        require(msg.sender == owner);\n        \n        miner = _addr;\n    }\n\n    function withdrawTrb(uint256 _amount) external {\n        require(msg.sender == owner);\n\n        TellorWrapper(tellor).transfer(msg.sender, _amount);\n    }\n\n    function withdrawEth(uint256 _amount) external {\n        require(msg.sender == owner);\n\n        msg.sender.transfer(_amount);\n    }\n\n    function depositStake() external {\n        require(msg.sender == owner);\n\n        TellorC(tellor).depositStake();\n    }\n\n    function requestStakingWithdraw() external {\n        require(msg.sender == owner);\n\n        TellorC(tellor).requestStakingWithdraw();\n    }\n\n    // Use finalize() if possible\n    function withdrawStake() external {\n        require(msg.sender == owner);\n\n        TellorC(tellor).withdrawStake();\n    }\n\n    function finalize() external {\n        require(msg.sender == owner);\n\n        TellorWrapper(tellor).withdrawStake();\n        uint256 _balance = TellorWrapper(tellor).balanceOf(address(this));\n        TellorWrapper(tellor).transfer(msg.sender, _balance);\n        selfdestruct(msg.sender);\n    }\n\n    function submitMiningSolution(string calldata _nonce,uint256[5] calldata _requestId, uint256[5] calldata _value) external {\n        require(TellorWrapper(tellor).getUintVar(slotProgress) < 4 || gasleft() > 1000000, \"X\");\n        require(msg.sender == miner || msg.sender == owner, \"Unauthorized\");\n\n        TellorC(tellor).submitMiningSolution(_nonce, _requestId, _value);\n    }\n    \n    function() external {\n        require(msg.sender == address(0), \"Not allowed\"); // Dont allow actual calls, only views\n        \n        address addr = tellor;\n        bytes memory _calldata = msg.data;\n        assembly {\n            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n}",
    "function_sum": 8,
    "compiler_version": "0.5.17",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-02-24\n*/\n\ncontract TellorWrapper {\n    function balanceOf(address _user) external view returns (uint256);\n    function transfer(address _to, uint256 _amount) external returns (bool);\n    \n    function withdrawStake() external;\n    function getUintVar(bytes32 _data) public view returns (uint256);\n}\n\n\n\n// You task is to complete the smart contract TellorC strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract interacts with the Tellor system, allowing for staking, withdrawing, and submitting mining solutions.\n * @dev The contract is designed to be controlled by an owner, who can change the miner, withdraw TRB and ETH, manage staking,\n * and submit mining solutions. It also allows forwarding calls to the Tellor contract under certain conditions.\n */\ncontract TellorC {\n    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;\n\n    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; // keccak256(\"slotProgress\")\n    address private owner;\n    address private miner;\n    \n    /**\n     * @notice Initializes the contract, setting the deployer as the owner.\n     */\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    /**\n     * @notice Allows the owner to change the designated miner.\n     * @dev Only the owner can call this function. The new miner's address is set.\n     * @param _addr The new miner's address.\n     */\n    function changeMiner(address _addr) external {}\n\n    /**\n     * @notice Allows the owner to withdraw TRB tokens from the Tellor contract.\n     * @dev Only the owner can call this function. The specified amount of TRB is transferred to the owner.\n     * @param _amount The amount of TRB to withdraw.\n     */\n    function withdrawTrb(uint256 _amount) external {}\n\n    /**\n     * @notice Allows the owner to withdraw ETH from the contract.\n     * @dev Only the owner can call this function. The specified amount of ETH is transferred to the owner.\n     * @param _amount The amount of ETH to withdraw.\n     */\n    function withdrawEth(uint256 _amount) external {}\n\n    /**\n     * @notice Allows the owner to deposit a stake in the Tellor contract.\n     * @dev Only the owner can call this function. A stake is deposited in the Tellor contract.\n     */\n    function depositStake() external {}\n\n    /**\n     * @notice Allows the owner to request a staking withdrawal from the Tellor contract.\n     * @dev Only the owner can call this function. A staking withdrawal request is made to the Tellor contract.\n     */\n    function requestStakingWithdraw() external {}\n\n    /**\n     * @notice Allows the owner to withdraw their stake from the Tellor contract.\n     * @dev Only the owner can call this function. The stake is withdrawn from the Tellor contract.\n     * Prefer using `finalize` if possible.\n     */\n    function withdrawStake() external {}\n\n    /**\n     * @notice Finalizes the contract, withdrawing the stake and transferring any remaining TRB to the owner before self-destructing.\n     * @dev Only the owner can call this function. The stake is withdrawn, all TRB is transferred to the owner, and the contract is self-destructed.\n     */\n    function finalize() external {}\n\n    /**\n     * @notice Submits a mining solution to the Tellor contract.\n     * @dev Only the miner or the owner can call this function. The solution is submitted to the Tellor contract.\n     * @param _nonce The nonce used for the mining solution.\n     * @param _requestId Array of request IDs.\n     * @param _value Array of values corresponding to the request IDs.\n     */\n    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {}\n\n    /**\n     * @notice Fallback function that forwards calls to the Tellor contract.\n     * @dev This function only allows view calls and ensures that the call is not from a non-zero address.\n     */\n    function() external {\n        require(msg.sender == address(0), \"Not allowed\"); // Dont allow actual calls, only views\n        \n        address addr = tellor;\n        bytes memory _calldata = msg.data;\n        assembly {\n            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result\n                case 0 {\n                    revert(ptr, size)\n                }\n                default {\n                    return(ptr, size)\n                }\n        }\n    }\n}\n"
}