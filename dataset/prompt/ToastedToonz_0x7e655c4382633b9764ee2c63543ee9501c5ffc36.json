{
    "contract_name": "ERC721A",
    "ground_truth": "contract ERC721A is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 private currentIndex = 1;\n\n    uint256 internal immutable collectionSize;\n    uint256 internal immutable maxBatchSize;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => TokenOwnership) private _ownerships;\n    mapping(address => AddressData) private _addressData;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 maxBatchSize_,\n        uint256 collectionSize_\n    ) {\n        require(\n            collectionSize_ > 0,\n            \"ERC721A: collection must have a nonzero supply\"\n        );\n        require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n        _name = name_;\n        _symbol = symbol_;\n        maxBatchSize = maxBatchSize_;\n        collectionSize = collectionSize_;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return currentIndex - 1;\n    }\n\n    function tokenByIndex(uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(index < totalSupply(), \"ERC721A: global index out of bounds\");\n        return index;\n    }\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\n        uint256 numMintedSoFar = totalSupply();\n        uint256 tokenIdsIdx = 0;\n        address currOwnershipAddr = address(0);\n        for (uint256 i = 0; i < numMintedSoFar; i++) {\n            TokenOwnership memory ownership = _ownerships[i];\n            if (ownership.addr != address(0)) {\n                currOwnershipAddr = ownership.addr;\n            }\n            if (currOwnershipAddr == owner) {\n                if (tokenIdsIdx == index) {\n                    return i;\n                }\n                tokenIdsIdx++;\n            }\n        }\n        revert(\"ERC721A: unable to get token of owner by index\");\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721A: balance query for the zero address\"\n        );\n        return uint256(_addressData[owner].balance);\n    }\n\n    function _numberMinted(address owner) internal view returns (uint256) {\n        require(\n            owner != address(0),\n            \"ERC721A: number minted query for the zero address\"\n        );\n        return uint256(_addressData[owner].numberMinted);\n    }\n\n    function ownershipOf(uint256 tokenId)\n        internal\n        view\n        returns (TokenOwnership memory)\n    {\n        require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\n\n        uint256 lowestTokenToCheck;\n        if (tokenId >= maxBatchSize) {\n            lowestTokenToCheck = tokenId - maxBatchSize + 1;\n        }\n\n        for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\n            TokenOwnership memory ownership = _ownerships[curr];\n            if (ownership.addr != address(0)) {\n                return ownership;\n            }\n        }\n\n        revert(\"ERC721A: unable to determine the owner of token\");\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return ownershipOf(tokenId).addr;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n\n        string memory baseURI = _baseURI();\n        return\n            bytes(baseURI).length > 0\n                ? string(\n                    abi.encodePacked(\n                        baseURI,\n                        tokenId.toString(),\n                        _getUriExtension()\n                    )\n                )\n                : \"\";\n    }\n\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function _getUriExtension() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    function approve(address to, uint256 tokenId) public override {\n        address owner = ERC721A.ownerOf(tokenId);\n        require(to != owner, \"ERC721A: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721A: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId, owner);\n    }\n\n    function getApproved(uint256 tokenId)\n        public\n        view\n        override\n        returns (address)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721A: approved query for nonexistent token\"\n        );\n\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override\n    {\n        require(operator != _msgSender(), \"ERC721A: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {\n        _transfer(from, to, tokenId);\n        require(\n            _checkOnERC721Received(from, to, tokenId, _data),\n            \"ERC721A: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return tokenId < currentIndex;\n    }\n\n    function _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, \"\");\n    }\n\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {\n        uint256 startTokenId = currentIndex;\n        require(to != address(0), \"ERC721A: mint to the zero address\");\n        require(!_exists(startTokenId), \"ERC721A: token already minted\");\n        require(quantity <= maxBatchSize, \"ERC721A: quantity to mint too high\");\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        AddressData memory addressData = _addressData[to];\n        _addressData[to] = AddressData(\n            addressData.balance + uint128(quantity),\n            addressData.numberMinted + uint128(quantity)\n        );\n        _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\n\n        uint256 updatedIndex = startTokenId;\n\n        for (uint256 i = 0; i < quantity; i++) {\n            emit Transfer(address(0), to, updatedIndex);\n            require(\n                _checkOnERC721Received(address(0), to, updatedIndex, _data),\n                \"ERC721A: transfer to non ERC721Receiver implementer\"\n            );\n            updatedIndex++;\n        }\n\n        currentIndex = updatedIndex;\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        TokenOwnership memory prevOwnership = ownershipOf(tokenId);\n\n        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\n            getApproved(tokenId) == _msgSender() ||\n            isApprovedForAll(prevOwnership.addr, _msgSender()));\n\n        require(\n            isApprovedOrOwner,\n            \"ERC721A: transfer caller is not owner nor approved\"\n        );\n\n        require(\n            prevOwnership.addr == from,\n            \"ERC721A: transfer from incorrect owner\"\n        );\n        require(to != address(0), \"ERC721A: transfer to the zero address\");\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n        _approve(address(0), tokenId, prevOwnership.addr);\n\n        _addressData[from].balance -= 1;\n        _addressData[to].balance += 1;\n        _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));\n        uint256 nextTokenId = tokenId + 1;\n        if (_ownerships[nextTokenId].addr == address(0)) {\n            if (_exists(nextTokenId)) {\n                _ownerships[nextTokenId] = TokenOwnership(\n                    prevOwnership.addr,\n                    prevOwnership.startTimestamp\n                );\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    uint256 public nextOwnerToExplicitlySet = 0;\n\n    function _setOwnersExplicit(uint256 quantity) internal {\n        uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;\n        require(quantity > 0, \"quantity must be nonzero\");\n        uint256 endIndex = oldNextOwnerToSet + quantity - 1;\n        if (endIndex > collectionSize - 1) {\n            endIndex = collectionSize - 1;\n        }\n        require(_exists(endIndex), \"not enough minted yet for this cleanup\");\n        for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {\n            if (_ownerships[i].addr == address(0)) {\n                TokenOwnership memory ownership = ownershipOf(i);\n                _ownerships[i] = TokenOwnership(\n                    ownership.addr,\n                    ownership.startTimestamp\n                );\n            }\n        }\n        nextOwnerToExplicitlySet = endIndex + 1;\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try\n                IERC721Receiver(to).onERC721Received(\n                    _msgSender(),\n                    from,\n                    tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\n                        \"ERC721A: transfer to non ERC721Receiver implementer\"\n                    );\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}",
    "function_sum": 27,
    "compiler_version": "0.8.11",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function functionDelegateCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return\n            functionDelegateCall(\n                target,\n                data,\n                \"Address: low-level delegate call failed\"\n            );\n    }\n\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\ninterface IERC721Enumerable is IERC721 {\n    function totalSupply() external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        external\n        view\n        returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n\n\n// You task is to complete the smart contract ERC721A strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.11, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title ERC721A\n * @notice This contract implements the ERC721 standard with additional features such as batch minting and improved gas efficiency.\n * @dev This contract is based on the ERC721, ERC721Metadata, and ERC721Enumerable standards.\n */\ncontract ERC721A is\n    Context,\n    ERC165,\n    IERC721,\n    IERC721Metadata,\n    IERC721Enumerable\n{\n    using Address for address;\n    using Strings for uint256;\n\n    struct TokenOwnership {\n        address addr;\n        uint64 startTimestamp;\n    }\n\n    struct AddressData {\n        uint128 balance;\n        uint128 numberMinted;\n    }\n\n    uint256 private currentIndex = 1;\n\n    uint256 internal immutable collectionSize;\n    uint256 internal immutable maxBatchSize;\n    string private _name;\n    string private _symbol;\n    mapping(uint256 => TokenOwnership) private _ownerships;\n    mapping(address => AddressData) private _addressData;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @notice Initializes the contract with the given name, symbol, max batch size, and collection size.\n     * @param name_ The name of the token.\n     * @param symbol_ The symbol of the token.\n     * @param maxBatchSize_ The maximum number of tokens that can be minted in a single transaction.\n     * @param collectionSize_ The total number of tokens in the collection.\n     * @dev Requires that the collection size and max batch size are greater than zero.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint256 maxBatchSize_,\n        uint256 collectionSize_\n    ) {\n        require(\n            collectionSize_ > 0,\n            \"ERC721A: collection must have a nonzero supply\"\n        );\n        require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\n        _name = name_;\n        _symbol = symbol_;\n        maxBatchSize = maxBatchSize_;\n        collectionSize = collectionSize_;\n    }\n\n    /**\n     * @notice Returns the total number of tokens minted so far.\n     * @return The total supply of tokens.\n     * @dev The total supply is calculated by subtracting one from the current index.\n     */\n    function totalSupply() public view override returns (uint256) {}\n\n    /**\n     * @notice Returns the token ID at a given index.\n     * @param index The index to query.\n     * @return The token ID at the specified index.\n     * @dev Requires that the index is within the bounds of the total supply.\n     */\n    function tokenByIndex(uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {}\n\n    /**\n     * @notice Returns the token ID owned by an address at a given index.\n     * @param owner The address of the token owner.\n     * @param index The index to query.\n     * @return The token ID at the specified index for the given owner.\n     * @dev Requires that the index is within the bounds of the owner's balance.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {}\n\n    /**\n     * @notice Checks if the contract supports a given interface.\n     * @param interfaceId The interface identifier to check.\n     * @return True if the contract supports the interface, false otherwise.\n     * @dev Supports ERC721, ERC721Metadata, and ERC721Enumerable interfaces.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {}\n\n    /**\n     * @notice Returns the balance of an address.\n     * @param owner The address to query.\n     * @return The balance of the specified address.\n     * @dev Requires that the address is not the zero address.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {}\n\n    /**\n     * @notice Returns the number of tokens minted by an address.\n     * @param owner The address to query.\n     * @return The number of tokens minted by the specified address.\n     * @dev Requires that the address is not the zero address.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {}\n\n    /**\n     * @notice Returns the ownership details of a token.\n     * @param tokenId The token ID to query.\n     * @return The ownership details of the specified token.\n     * @dev Requires that the token exists.\n     */\n    function ownershipOf(uint256 tokenId)\n        internal\n        view\n        returns (TokenOwnership memory)\n    {}\n\n    /**\n     * @notice Returns the owner of a token.\n     * @param tokenId The token ID to query.\n     * @return The owner of the specified token.\n     * @dev Requires that the token exists.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {}\n\n    /**\n     * @notice Returns the name of the token.\n     * @return The name of the token.\n     */\n    function name() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the symbol of the token.\n     * @return The symbol of the token.\n     */\n    function symbol() public view virtual override returns (string memory) {}\n\n    /**\n     * @notice Returns the URI for a token.\n     * @param tokenId The token ID to query.\n     * @return The URI for the specified token.\n     * @dev Requires that the token exists. The URI is constructed by concatenating the base URI, token ID, and URI extension.\n     */\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        virtual\n        override\n        returns (string memory)\n    {}\n\n    /**\n     * @notice Returns the base URI for the token.\n     * @return The base URI for the token.\n     * @dev By default, this function returns an empty string.\n     */\n    function _baseURI() internal view virtual returns (string memory) {}\n\n    /**\n     * @notice Returns the URI extension for the token.\n     * @return The URI extension for the token.\n     * @dev By default, this function returns an empty string.\n     */\n    function _getUriExtension() internal view virtual returns (string memory) {}\n\n    /**\n     * @notice Approves an address to manage a specific token.\n     * @param to The address to approve.\n     * @param tokenId The token ID to approve.\n     * @dev Requires that the caller is the owner or approved for all, and that the approved address is not the current owner.\n     */\n    function approve(address to, uint256 tokenId) public override {}\n\n    /**\n     * @notice Returns the approved address for a token.\n     * @param tokenId The token ID to query.\n     * @return The approved address for the specified token.\n     * @dev Requires that the token exists.\n     */\n    function getApproved(uint256 tokenId)\n        public\n        view\n        override\n        returns (address)\n    {}\n\n    /**\n     * @notice Sets the approval for all tokens of the caller to a specified operator.\n     * @param operator The address of the operator to set approval for.\n     * @param approved True if the operator is approved, false otherwise.\n     * @dev Emits an ApprovalForAll event. Requires that the operator is not the caller.\n     */\n    function setApprovalForAll(address operator, bool approved)\n        public\n        override\n    {}\n\n    /**\n     * @notice Checks if an operator is approved for all tokens of an owner.\n     * @param owner The address of the token owner.\n     * @param operator The address of the operator to check.\n     * @return True if the operator is approved for all, false otherwise.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        virtual\n        override\n        returns (bool)\n    {}\n\n    /**\n     * @notice Transfers a token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @dev Requires that the caller is the owner, approved, or approved for all, and that the token exists.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {}\n\n    /**\n     * @notice Safely transfers a token from one address to another.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @dev Requires that the caller is the owner, approved, or approved for all, and that the token exists. Calls onERC721Received if the recipient is a contract.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {}\n\n    /**\n     * @notice Safely transfers a token from one address to another with additional data.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param tokenId The token ID to transfer.\n     * @param _data Additional data to send along with the transfer.\n     * @dev Requires that the caller is the owner, approved, or approved for all, and that the token exists. Calls onERC721Received if the recipient is a contract.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public override {}\n\n    /**\n     * @notice Checks if a token exists.\n     * @param tokenId The token ID to query.\n     * @return True if the token exists, false otherwise.\n     * @dev A token exists if its ID is less than the current index.\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {}\n\n    /**\n     * @notice Mints a specified quantity of tokens to a given address.\n     * @param to The address to mint to.\n     * @param quantity The number of tokens to mint.\n     * @dev Requires that the recipient is not the zero address, the starting token ID does not already exist, and the quantity is within the max batch size.\n     */\n    function _safeMint(address to, uint256 quantity) internal {}\n\n    /**\n     * @dev Safely mints multiple tokens to a recipient address with ERC721Receiver validation.\n     * @param to The address receiving the minted tokens.\n     * @param quantity The number of tokens to mint (must be > 0 and <= maxBatchSize).\n     * @param _data Optional data to pass to the recipient's onERC721Received callback.\n     * @notice\n     * - Reverts if minting to zero address or token already exists.\n     * - Validates quantity against maxBatchSize limit.\n     * - Updates recipient's balance and number of minted tokens.\n     * - Records ownership with timestamp for each token.\n     * - Emits Transfer events for each minted token.\n     * - Validates ERC721Receiver implementation for each token.\n     * @dev\n     * - Uses assembly-optimized storage updates (via AddressData and TokenOwnership structs).\n     * - Performs batch minting with per-token validation.\n     * - Maintains currentIndex for next available token ID.\n     * - Calls before/after transfer hooks for extension points.\n     * @dev Note: This is an internal function meant to be called by public mint functions.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal {}\n\n    /**\n     * @dev Transfers ownership of a token from one address to another.\n     * @param from The current owner of the token.\n     * @param to The new owner of the token.\n     * @param tokenId The ID of the token to transfer.\n     * @notice Reverts if:\n     *         - Caller is not owner or approved operator\n     *         - `from` is not the current owner\n     *         - `to` is the zero address\n     * @dev\n     * - Verifies ownership and approval status\n     * - Clears approval for the token\n     * - Updates ownership and address balances\n     * - Handles token ID continuity for adjacent tokens\n     * - Emits Transfer event\n     * @dev Uses packed data structures for efficient storage\n     * @dev Calls before/after transfer hooks for extension points\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {}\n\n    /**\n     * @notice Approves an address to manage a specific token.\n     * @param to The address to approve.\n     * @param tokenId The token ID to approve.\n     * @param owner The owner of the token.\n     * @dev Updates the token approval and emits an Approval event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        address owner\n    ) private {}\n\n    uint256 public nextOwnerToExplicitlySet = 0;\n\n    /**\n     * @notice Explicitly sets the ownership of a range of tokens.\n     * @param quantity The number of tokens to set.\n     * @dev Requires that the quantity is greater than zero and that the ending index is within the collection size.\n     */\n    function _setOwnersExplicit(uint256 quantity) internal {}\n\n    /**\n     * @notice Validates that the recipient address correctly implements the ERC721Receiver interface.\n     * @param from The address transferring the token.\n     * @param to The recipient address of the token transfer.\n     * @param tokenId The unique identifier of the token being transferred.\n     * @param _data Optional data payload to accompany the transfer, sent to the recipient.\n     * @return bool True if the recipient successfully handles the ERC721 received event, false otherwise.\n     * @dev\n     * - Checks if the recipient (`to`) is a contract.\n     * - If `to` is a contract, attempts to call `onERC721Received` with the provided parameters.\n     * - Validates the returned selector matches the expected ERC721Receiver interface.\n     * - Reverts with a descriptive error if the recipient does not implement the interface.\n     * - If `to` is not a contract, implicitly returns true as no validation is needed.\n     * - Handles potential revert reasons from the recipient contract to provide meaningful error messages.\n     * @notice This function ensures compliance with the ERC721 standard by verifying that the recipient\n     *         can properly handle incoming token transfers.\n     * @dev The function uses assembly for efficient revert handling when the recipient reverts with a reason.\n     * It ensures that only valid ERC721Receiver contracts can receive tokens, maintaining protocol integrity.\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {}\n\n    /**\n     * @notice Hook called before a set of tokens is transferred.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens to transfer.\n     * @dev This hook is intended to be overridden by derived contracts.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @notice Hook called after a set of tokens is transferred.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param startTokenId The starting token ID.\n     * @param quantity The number of tokens to transfer.\n     * @dev This hook is intended to be overridden by derived contracts.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n}\n"
}