{
    "contract_name": "TokenCashier",
    "ground_truth": "contract TokenCashier is Pausable {\n    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);\n\n    ITokenList[] public tokenLists;\n    address[] public tokenSafes;\n    mapping(address => uint256) public counts;\n    uint256 public depositFee;\n    IWrappedCoin public wrappedCoin;\n\n    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {\n        require(_tokenLists.length == _tokenSafes.length, \"# of token lists is not equal to # of safes\");\n        wrappedCoin = _wrappedCoin;\n        tokenLists = _tokenLists;\n        tokenSafes = _tokenSafes;\n    }\n\n    function() external {\n        revert();\n    }\n\n    function count(address _token) public view returns (uint256) {\n        return counts[_token];\n    }\n\n    function setDepositFee(uint256 _fee) public onlyOwner {\n        depositFee = _fee;\n    }\n\n    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {\n        require(_to != address(0), \"invalid destination\");\n        bool isCoin = false;\n        uint256 fee = msg.value;\n        if (_token == address(0)) {\n            require(msg.value >= _amount, \"insufficient msg.value\");\n            fee = msg.value - _amount;\n            wrappedCoin.deposit.value(_amount)();\n            _token = address(wrappedCoin);\n            isCoin = true;\n        }\n        require(fee >= depositFee, \"insufficient fee\");\n        for (uint256 i = 0; i < tokenLists.length; i++) {\n            if (tokenLists[i].isAllowed(_token)) {\n                require(_amount >= tokenLists[i].minAmount(_token), \"amount too low\");\n                require(_amount <= tokenLists[i].maxAmount(_token), \"amount too high\");\n                if (tokenSafes[i] == address(0)) {\n                    require(!isCoin && safeTransferFrom(_token, msg.sender, address(this), _amount), \"fail to transfer token to cashier\");\n                    // selector = bytes4(keccak256(bytes('burn(uint256)')))\n                    (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));\n                    require(success && (data.length == 0 || abi.decode(data, (bool))), \"fail to burn token\");\n                } else {\n                    if (isCoin) {\n                        require(safeTransfer(_token, tokenSafes[i], _amount), \"failed to put into safe\");\n                    } else {\n                        require(safeTransferFrom(_token, msg.sender, tokenSafes[i], _amount), \"failed to put into safe\");\n                    }\n                }\n                counts[_token] += 1;\n                emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);\n                return;\n            }\n        }\n        revert(\"not a whitelisted token\");\n    }\n\n    function deposit(address _token, uint256 _amount) public payable {\n        depositTo(_token, msg.sender, _amount);\n    }\n\n    function withdraw() external onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }\n\n    function withdrawToken(address _token) public onlyOwner {\n        // selector = bytes4(keccak256(bytes('balanceOf(address)')))\n        (bool success, bytes memory balance) = _token.call(abi.encodeWithSelector(0x70a08231, address(this)));\n        require(success, \"failed to call balanceOf\");\n        uint256 bal = abi.decode(balance, (uint256));\n        if (bal > 0) {\n            require(safeTransfer(_token, msg.sender, bal), \"failed to withdraw token\");\n        }\n    }\n\n    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        // selector = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')))\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n\n    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {\n        // selector = bytes4(keccak256(bytes('transfer(address,uint256)')))\n        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n}",
    "function_sum": 7,
    "compiler_version": "0.5.12",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-11-04\n*/\n// File: contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\n\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: contracts/iotube/TokenCashier.sol\n\ninterface ITokenList {\n    function isAllowed(address) external returns (bool);\n    function maxAmount(address) external returns (uint256);\n    function minAmount(address) external returns (uint256);\n}\n\ninterface IWrappedCoin {\n    function deposit() external payable;\n}\n\n\n\n// You task is to complete the smart contract TokenCashier strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.12, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice A smart contract for managing token deposits and withdrawals, including fee collection and token whitelisting.\n * @dev This contract allows users to deposit tokens into a safe or burn them, with certain conditions. It also allows the owner to set fees, withdraw funds, and manage token safes.\n */\ncontract TokenCashier is Pausable {\n    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);\n\n    ITokenList[] public tokenLists;\n    address[] public tokenSafes;\n    mapping(address => uint256) public counts;\n    uint256 public depositFee;\n    IWrappedCoin public wrappedCoin;\n\n    /**\n     * @notice Initializes the contract with the provided wrapped coin, token lists, and token safes.\n     * @dev Ensures that the number of token lists matches the number of token safes.\n     * @param _wrappedCoin The address of the wrapped coin contract.\n     * @param _tokenLists Array of token list addresses.\n     * @param _tokenSafes Array of token safe addresses.\n     */\n    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {\n        require(_tokenLists.length == _tokenSafes.length, \"# of token lists is not equal to # of safes\");\n        wrappedCoin = _wrappedCoin;\n        tokenLists = _tokenLists;\n        tokenSafes = _tokenSafes;\n    }\n\n    /**\n     * @notice Fallback function that reverts any ETH sent directly to the contract.\n     * @dev This function prevents accidental ETH transfers to the contract.\n     */\n    function() external {\n        revert();\n    }\n\n    /**\n     * @notice Returns the count of transactions for a specific token.\n     * @dev This function is used to track the number of times a token has been deposited.\n     * @param _token The address of the token.\n     * @return The count of transactions for the token.\n     */\n    function count(address _token) public view returns (uint256) {}\n\n    /**\n     * @notice Sets the deposit fee for the contract.\n     * @dev Only the contract owner can call this function.\n     * @param _fee The new deposit fee.\n     */\n    function setDepositFee(uint256 _fee) public onlyOwner {}\n\n    /**\n     * @notice Deposits tokens or native currency into the contract for further processing.\n     * @param _token The address of the token to deposit (use address(0) for native currency).\n     * @param _to The recipient address for the deposited amount (must not be zero).\n     * @param _amount The amount of tokens or native currency to deposit.\n     * @dev:\n     * - Validates the destination address is not zero.\n     * - Handles both native currency and ERC20 tokens.\n     * - Applies deposit fee and checks against minimum/maximum allowed amounts.\n     * - Routes deposits to designated safes or burns tokens if no safe is configured.\n     * - Emits a Receipt event upon successful deposit.\n     * - Reverts if:\n     *   - Destination is invalid.\n     *   - Insufficient msg.value for native currency deposits.\n     *   - Insufficient fee coverage.\n     *   - Amount is outside allowed limits.\n     *   - Token transfer fails.\n     *   - Token is not whitelisted.\n     * @notice Native currency deposits are wrapped into a wrappedCoin contract if applicable.\n     * @dev Uses safeTransfer and safeTransferFrom for ERC20 token transfers to handle  non-compliant tokens.\n     * For tokens without a designated safe, the function attempts to burn them using the  burn selector (0x42966c68).\n     * @dev The burn selector (0x42966c68) corresponds to the ERC-20 burn function signature: bytes4(keccak256(\"burn(uint256)\")) = 0x42966c68\n     */\n    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {}\n\n    /**\n     * @notice Allows a user to deposit a specified amount of a token to themselves.\n     * @dev This function is a convenience wrapper for `depositTo` where the recipient is the sender.\n     * @param _token The address of the token to deposit.\n     * @param _amount The amount of the token to deposit.\n     */\n    function deposit(address _token, uint256 _amount) public payable {}\n\n    /**\n     * @notice Allows the contract owner to withdraw all ETH from the contract.\n     * @dev This function ensures that only the owner can withdraw funds.\n     */\n    function withdraw() external onlyOwner {}\n\n    /**\n     * @notice Allows the contract owner to withdraw all tokens of a specified type.\n     * @param _token The address of the token to withdraw.\n     * @dev:\n     * - Calls the token's balanceOf function using selector 0x70a08231 (bytes4(keccak256(bytes ('balanceOf(address)'))))\n     * - Verifies the balance call was successful\n     * - If balance > 0, attempts to transfer the full balance to the owner\n     * - Uses safeTransfer for the actual token transfer\n     * @notice The function uses the standard ERC20 balanceOf selector (0x70a08231)\n     *         and transfer selector (0xa9059cbb) for token interactions\n     * @dev Reverts if:\n     *      - BalanceOf call fails\n     *      - Token transfer fails\n     */\n    function withdrawToken(address _token) public onlyOwner {}\n\n    /**\n     * @notice Safely transfers tokens from a specified address to another address.\n     * @param _token The address of the token to transfer.\n     * @param _from The address to transfer tokens from.\n     * @param _to The address to transfer tokens to.\n     * @param _amount The amount of tokens to transfer.\n     * @return bool True if the transfer was successful, false otherwise.\n     * @dev:\n     * - Calls the token's transferFrom function using selector 0x23b872dd \n     *   (bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))))\n     * - Returns success status and whether the return value was true\n     * @notice The function uses the standard ERC20 transferFrom selector (0x23b872dd)\n     *         for token interactions\n     */\n    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {}\n\n    /**\n     * @notice Safely transfers tokens from the contract to a specified address.\n     * @param _token The address of the token to transfer.\n     * @param _to The address to transfer tokens to.\n     * @param _amount The amount of tokens to transfer.\n     * @return bool True if the transfer was successful, false otherwise.\n     * @dev:\n     * - Calls the token's transfer function using selector 0xa9059cbb \n     *   (bytes4(keccak256(bytes('transfer(address,uint256)'))))\n     * - Returns success status and whether the return value was true\n     * @notice The function uses the standard ERC20 transfer selector (0xa9059cbb)\n     *         for token interactions\n     */\n    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {}\n}\n"
}