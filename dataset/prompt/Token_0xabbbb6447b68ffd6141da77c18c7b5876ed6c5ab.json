{
    "contract_name": "Token",
    "ground_truth": "contract Token is Pausable, ERC20 {\n\n  using SafeMath for uint;\n\n\n\n  mapping(address => uint) balances;\n\n  mapping (address => mapping (address => uint)) internal allowed;\n\n\n\n  function Token() ERC20(\"DATx\", \"DATx\", 18) public {\n\n    totalSupply = 10000000000 * 10 ** uint(decimals);  // Update total supply with the decimal amount\n\n    balances[msg.sender] = totalSupply;                   // Give the creator all initial tokens\n\n  }\n\n\n\n  function transfer(address _to, uint _value) whenNotPaused public returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[msg.sender]);\n\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    Transfer(msg.sender, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n\n    return balances[_owner];\n\n  }\n\n\n\n  function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool) {\n\n    require(_to != address(0));\n\n    require(_value <= balances[_from]);\n\n    require(_value <= allowed[_from][msg.sender]);\n\n\n\n    balances[_from] = balances[_from].sub(_value);\n\n    balances[_to] = balances[_to].add(_value);\n\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n    Transfer(_from, _to, _value);\n\n    return true;\n\n  }\n\n\n\n  function approve(address _spender, uint _value) public whenNotPaused returns (bool) {\n\n    allowed[msg.sender][_spender] = _value;\n\n    Approval(msg.sender, _spender, _value);\n\n    return true;\n\n  }\n\n\n\n  function allowance(address _owner, address _spender) public view returns (uint) {\n\n    return allowed[_owner][_spender];\n\n  }\n\n\n\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\n\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\n\n    uint oldValue = allowed[msg.sender][_spender];\n\n    if (_subtractedValue > oldValue) {\n\n      allowed[msg.sender][_spender] = 0;\n\n    } else {\n\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\n    }\n\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n    return true;\n\n  }\n\n}",
    "function_sum": 7,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n\n *Submitted for verification at Etherscan.io on 2018-02-28\n\n*/\n\ncontract Ownable {\n\n  address public owner;\n\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n\n  function Ownable() public {\n\n    owner = msg.sender;\n\n  }\n\n\n\n  modifier onlyOwner() {\n\n    require(msg.sender == owner);\n\n    _;\n\n  }\n\n\n\n  function transferOwnership(address newOwner) public onlyOwner {\n\n    require(newOwner != address(0));\n\n    OwnershipTransferred(owner, newOwner);\n\n    owner = newOwner;\n\n  }\n\n}\n\ncontract Pausable is Ownable {\n\n  event Pause();\n\n  event Unpause();\n\n\n\n  bool public paused = false;\n\n\n\n  modifier whenNotPaused() {\n\n    require(!paused);\n\n    _;\n\n  }\n\n\n\n  modifier whenPaused() {\n\n    require(paused);\n\n    _;\n\n  }\n\n\n\n  function pause() onlyOwner whenNotPaused public {\n\n    paused = true;\n\n    Pause();\n\n  }\n\n\n\n  function unpause() onlyOwner whenPaused public {\n\n    paused = false;\n\n    Unpause();\n\n  }\n\n}\n\nlibrary SafeMath {\n\n  function mul(uint a, uint b) internal pure returns (uint) {\n\n    if (a == 0) {\n\n      return 0;\n\n    }\n\n    uint c = a * b;\n\n    assert(c / a == b);\n\n    return c;\n\n  }\n\n\n\n  function div(uint a, uint b) internal pure returns (uint) {\n\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n\n    uint c = a / b;\n\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n\n  }\n\n\n\n  function sub(uint a, uint b) internal pure returns (uint) {\n\n    assert(b <= a);\n\n    return a - b;\n\n  }\n\n\n\n  function add(uint a, uint b) internal pure returns (uint) {\n\n    uint c = a + b;\n\n    assert(c >= a);\n\n    return c;\n\n  }\n\n}\n\ncontract ERC20 {\n\n  string public name;\n\n  string public symbol;\n\n  uint8 public decimals;\n\n  uint public totalSupply;  \n\n  function ERC20(string _name, string _symbol, uint8 _decimals) public {\n\n    name = _name;\n\n    symbol = _symbol;\n\n    decimals = _decimals;\n\n  }\n\n  function balanceOf(address who) public view returns (uint);\n\n  function transfer(address to, uint value) public returns (bool);\n\n  function allowance(address owner, address spender) public view returns (uint);\n\n  function transferFrom(address from, address to, uint value) public returns (bool);\n\n  function approve(address spender, uint value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  event Approval(address indexed owner, address indexed spender, uint value);\n\n}\n\n\n\n// You task is to complete the smart contract Token strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice DATx Token contract implementing ERC20 standard with pausable transfers.\n * @dev This contract extends the Pausable and ERC20 contracts. It includes additional functionality for managing token balances and approvals.\n */\ncontract Token is Pausable, ERC20 {\n\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n  mapping (address => mapping (address => uint)) internal allowed;\n\n  /**\n   * @notice Initializes the token with a name, symbol, and 18 decimal places.\n   * @dev The total supply is set to 10,000,000,000 tokens, and all tokens are minted to the contract creator.\n   */\n  function Token() ERC20(\"DATx\", \"DATx\", 18) public {\n    totalSupply = 10000000000 * 10 ** uint(decimals);  // Update total supply with the decimal amount\n    balances[msg.sender] = totalSupply;                   // Give the creator all initial tokens\n  }\n\n  /**\n   * @notice Transfers `_value` amount of tokens from the message sender to `_to`.\n   * @dev This function checks for valid recipient and sufficient balance before transferring.\n   * @param _to The address to transfer tokens to.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating if the operation was successful.\n   */\n  function transfer(address _to, uint _value) whenNotPaused public returns (bool) {}\n\n  /**\n   * @notice Returns the balance of the `_owner` address.\n   * @dev This function simply returns the balance stored in the `balances` mapping.\n   * @param _owner The address to query the balance of.\n   * @return The balance of the `_owner` address.\n   */\n  function balanceOf(address _owner) public view returns (uint balance) {}\n\n  /**\n   * @notice Transfers `_value` amount of tokens from `_from` to `_to` using the allowance mechanism.\n   * @dev This function checks for valid recipient, sufficient balance, and allowance before transferring.\n   * @param _from The address to transfer tokens from.\n   * @param _to The address to transfer tokens to.\n   * @param _value The amount of tokens to transfer.\n   * @return A boolean indicating if the operation was successful.\n   */\n  function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool) {}\n\n  /**\n   * @notice Approves `_spender` to spend up to `_value` amount of tokens on behalf of the message sender.\n   * @dev This function sets the allowance in the `allowed` mapping.\n   * @param _spender The address that will be allowed to spend the tokens.\n   * @param _value The amount of tokens to approve.\n   * @return A boolean indicating if the operation was successful.\n   */\n  function approve(address _spender, uint _value) public whenNotPaused returns (bool) {}\n\n  /**\n   * @notice Returns the remaining number of tokens that `_spender` is allowed to spend on behalf of `_owner`.\n   * @dev This function simply returns the allowance stored in the `allowed` mapping.\n   * @param _owner The address which approved the spending.\n   * @param _spender The address which is allowed to spend.\n   * @return The remaining allowance.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint) {}\n\n  /**\n   * @notice Increases the amount of tokens that `_spender` is allowed to spend on behalf of the message sender.\n   * @dev This function adds `_addedValue` to the current allowance.\n   * @param _spender The address that will be allowed to spend the tokens.\n   * @param _addedValue The amount to increase the allowance by.\n   * @return A boolean indicating if the operation was successful.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {}\n\n  /**\n   * @notice Decreases the amount of tokens that `_spender` is allowed to spend on behalf of the message sender.\n   * @dev This function subtracts `_subtractedValue` from the current allowance, ensuring it does not go below zero.\n   * @param _spender The address that will be allowed to spend the tokens.\n   * @param _subtractedValue The amount to decrease the allowance by.\n   * @return A boolean indicating if the operation was successful.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {}\n}\n"
}