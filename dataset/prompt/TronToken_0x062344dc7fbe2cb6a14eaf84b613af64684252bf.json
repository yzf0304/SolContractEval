{
    "contract_name": "TronToken",
    "ground_truth": "contract TronToken {\n\n    string   public name ;            //  token name\n    string   public symbol ;          //  token symbol\n    uint256  public decimals ;        //  token digit\n\n    mapping (address => uint256) public balanceOf;\n\n    uint256 public totalSupply = 0;\n    bool public stopped = false;      //  stopflag: true is stoped,false is not stoped\n\n    uint256 constant valueFounder = 500000000000000000;\n    address owner = 0x0;\n\n    modifier isOwner {\n        assert(owner == msg.sender);\n        _;\n    }\n\n    modifier isRunning {\n        assert (!stopped);\n        _;\n    }\n\n    modifier validAddress {\n        assert(0x0 != msg.sender);\n        _;\n    }\n\n    function TronToken(address _addressFounder,uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {\n        owner = msg.sender;\n        if (_addressFounder == 0x0)\n            _addressFounder = msg.sender;\n        if (_initialSupply == 0) \n            _initialSupply = valueFounder;\n        totalSupply = _initialSupply;   // Set the totalSupply \n        name = _tokenName;              // Set the name for display \n        symbol = _tokenSymbol;          // Set the symbol for display \n        decimals = _decimalUnits;       // Amount of decimals for display purposes\n        balanceOf[_addressFounder] = totalSupply;\n        Transfer(0x0, _addressFounder, totalSupply);\n    }\n\n    function transfer(address _to, uint256 _value) public isRunning validAddress returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function stop() public isOwner {\n        stopped = true;\n    }\n\n    function start() public isOwner {\n        stopped = false;\n    }\n\n    function setName(string _name) public isOwner {\n        name = _name;\n    }\n    \n    function setOwner(address _owner) public isOwner {\n        owner = _owner;\n    }\n\n    function burn(uint256 _value) public {\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        balanceOf[0x0] += _value;\n        Transfer(msg.sender, 0x0, _value);\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n}",
    "function_sum": 7,
    "compiler_version": "0.4.18",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n\n\n// You task is to complete the smart contract TronToken strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title TronToken\n * @notice A simple ERC20-like token contract with additional features like pausing and burning.\n * @dev This contract allows for the creation of a token, transferring tokens, and managing the token's state.\n */\ncontract TronToken {\n\n    string   public name;            //  token name\n    string   public symbol;          //  token symbol\n    uint256  public decimals;        //  token digit\n\n    mapping (address => uint256) public balanceOf;\n\n    uint256 public totalSupply = 0;\n    bool public stopped = false;      //  stopflag: true is stopped, false is not stopped\n\n    uint256 constant valueFounder = 500000000000000000;\n    address owner = 0x0;\n\n    /**\n     * @notice Modifier to check if the caller is the owner of the contract.\n     * @dev Reverts if the caller is not the owner.\n     */\n    modifier isOwner {\n        assert(owner == msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if the contract is running (not paused).\n     * @dev Reverts if the contract is stopped (paused).\n     */\n    modifier isRunning {\n        assert (!stopped);\n        _;\n    }\n\n    /**\n     * @notice Modifier to check if the provided address is valid (not zero).\n     * @dev Reverts if the address is zero.\n     */\n    modifier validAddress {\n        assert(0x0 != msg.sender);\n        _;\n    }\n\n    /**\n     * @notice Constructor to initialize the token with initial supply, name, symbol, and decimal units.\n     * @param _addressFounder The address of the founder who will receive the initial supply.\n     * @param _initialSupply The initial supply of the token.\n     * @param _tokenName The name of the token.\n     * @param _decimalUnits The number of decimal units for the token.\n     * @param _tokenSymbol The symbol of the token.\n     * @dev Sets the initial supply, name, symbol, and decimal units. Also, assigns the total supply to the founder.\n     */\n    function TronToken(address _addressFounder, uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {\n        owner = msg.sender;\n        if (_addressFounder == 0x0)\n            _addressFounder = msg.sender;\n        if (_initialSupply == 0) \n            _initialSupply = valueFounder;\n        totalSupply = _initialSupply;   // Set the totalSupply \n        name = _tokenName;              // Set the name for display \n        symbol = _tokenSymbol;          // Set the symbol for display \n        decimals = _decimalUnits;       // Amount of decimals for display purposes\n        balanceOf[_addressFounder] = totalSupply;\n        Transfer(0x0, _addressFounder, totalSupply);\n    }\n\n    /**\n     * @notice Transfers a specified amount of tokens from the sender to the recipient.\n     * @param _to The address of the recipient.\n     * @param _value The amount of tokens to transfer.\n     * @return success True if the transfer was successful.\n     * @dev Requires the sender to have sufficient balance and the recipient's balance to not overflow.\n     */\n    function transfer(address _to, uint256 _value) public isRunning validAddress returns (bool success) {}\n\n    /**\n     * @notice Stops the contract, preventing any transfers.\n     * @dev Only the owner can call this function.\n     */\n    function stop() public isOwner {}\n\n    /**\n     * @notice Starts the contract, allowing transfers again.\n     * @dev Only the owner can call this function.\n     */\n    function start() public isOwner {}\n\n    /**\n     * @notice Changes the name of the token.\n     * @param _name The new name of the token.\n     * @dev Only the owner can call this function.\n     */\n    function setName(string _name) public isOwner {}\n\n    /**\n     * @notice Changes the owner of the contract.\n     * @param _owner The new owner's address.\n     * @dev Only the owner can call this function.\n     */\n    function setOwner(address _owner) public isOwner {}\n\n    /**\n     * @notice Burns a specified amount of tokens from the sender's balance.\n     * @param _value The amount of tokens to burn.\n     * @dev Requires the sender to have sufficient balance.\n     */\n    function burn(uint256 _value) public {}\n\n    /**\n     * @dev Event to notify when a transfer occurs.\n     * @param _from The address of the sender.\n     * @param _to The address of the recipient.\n     * @param _value The amount of tokens transferred.\n     */\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    /**\n     * @notice Fallback function to handle receiving Ether.\n     * @dev This function does nothing and should be overridden if needed.\n     */\n    function () public payable {}\n}\n"
}