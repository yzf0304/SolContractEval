{
    "contract_name": "UniqlyPresale4",
    "ground_truth": "contract UniqlyPresale4 {\n    // presale target - close presale when reached\n    uint256 public immutable presaleLimit;\n\n    // minimum pay-in per user\n    uint256 public immutable minPerUser;\n\n    // maximum pay-in per user\n    uint256 public immutable maxPerUser;\n\n    // timestamp ending presale\n    uint256 public immutable presaleEnd;\n\n    // failsafe time - fail if not properly closed after presaleEnd\n    uint256 constant failSafeTime = 2 weeks;\n\n    // owner address - will receive ETH if success\n    address public owner;\n\n    //constructor\n    constructor(\n        uint256 _presaleLimit, //maximum amount to be collected\n        uint256 _minPerUser, //minimum buy-in per user\n        uint256 _maxPerUser, //maximum buy-in per user\n        uint256 _presaleEnd, //unix timestamp of presale round end\n        address _owner //privileged address\n    ) {\n        presaleLimit = _presaleLimit;\n        minPerUser = _minPerUser;\n        maxPerUser = _maxPerUser;\n        presaleEnd = _presaleEnd;\n        owner = _owner;\n    }\n\n    //flags need for logic (false is default)\n    bool presaleEnded;\n    bool presaleFailed;\n    bool presaleStarted;\n\n    // list of user balances (zero is default)\n    mapping(address => uint256) private balances;\n\n    // join presale - just send ETH to contract,\n    // remember to check GAS LIMIT > 70000!\n    receive() external payable {\n        // only if not ended\n        require(presaleStarted, \"Presale not started\");\n        require(!presaleEnded, \"Presale ended\");\n        // only if within time limit\n        require(block.timestamp < presaleEnd, \"Presale time's up\");\n\n        // record new user balance if possible\n        uint256 amount = msg.value + balances[msg.sender];\n        require(amount >= minPerUser, \"Below buy-in\");\n        require(amount <= maxPerUser, \"Over buy-in\");\n        balances[msg.sender] = amount;\n\n        // end presale if reached limit\n        if (collected() >= presaleLimit) {\n            presaleEnded = true;\n        }\n    }\n\n    function start() external {\n        require(msg.sender == owner, \"Only for Owner\");\n        presaleStarted = true;\n    }\n\n    // check balance of any user\n    function balanceOf(address user) external view returns (uint256) {\n        return balances[user];\n    }\n\n    // return balance of caller\n    function balanceOf() external view returns (uint256) {\n        return balances[msg.sender];\n    }\n\n    // total ETH on this contract\n    function collected() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // withdraw ETH from contract\n    // can be used by user and owner\n    // return false if nothing to do\n    function withdraw() external returns (bool) {\n        if (!presaleEnded) {\n            // end and fail presale if failsafe time passed\n            if (block.timestamp > presaleEnd + failSafeTime) {\n                presaleEnded = true;\n                presaleFailed = true;\n                // don't return true, you can withdraw in this call\n            }\n        }\n        // owner withdraw - presale succeed ?\n        else if (msg.sender == owner && !presaleFailed) {\n            send(owner, address(this).balance);\n            return true;\n        }\n\n        // presale failed, withdraw to calling user\n        if (presaleFailed) {\n            uint256 amount = balances[msg.sender];\n            balances[msg.sender] = 0;\n            send(msg.sender, amount);\n            return true;\n        }\n\n        // did nothing\n        return false;\n    }\n\n    //send ETH from contract to address or contract\n    function send(address user, uint256 amount) private {\n        bool success = false;\n        (success, ) = address(user).call{value: amount}(\"\");\n        require(success, \"ETH send failed\");\n    }\n\n    // withdraw any ERC20 token send accidentally on this contract address to contract owner\n    function withdrawAnyERC20(IERC20 token) external {\n        uint256 amount = token.balanceOf(address(this));\n        require(amount > 0, \"No tokens to withdraw\");\n        token.transfer(owner, amount);\n    }\n\n    // change ownership in two steps to be sure about owner address\n    address public newOwner;\n\n    // only current owner can delegate new one\n    function giveOwnership(address _newOwner) external {\n        require(msg.sender == owner, \"Only for Owner\");\n        newOwner = _newOwner;\n    }\n\n    // new owner need to accept ownership\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Ure not New Owner\");\n        newOwner = address(0x0);\n        owner = msg.sender;\n    }\n}",
    "function_sum": 9,
    "compiler_version": "0.8.2",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\n/**\n *Submitted for verification at Etherscan.io on 2021-03-30\n*/\n//SPDX-License-Identifier: Unlicense\n//ERC20 functions for fallback tokens recovery\n\nabstract contract IERC20 {\n    function balanceOf(address _owner)\n        external\n        virtual\n        returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external virtual;\n    // can not 'returns (bool success);' because of USDT\n    // and other tokens that not follow ERC20 spec fully.\n}\n\n\n\n// You task is to complete the smart contract UniqlyPresale4 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.2, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title UniqlyPresale4\n * @notice A smart contract for managing a presale of a token, allowing users to contribute ETH within certain limits and time frames.\n * @dev The contract ensures that the presale is conducted within specified parameters and allows for the withdrawal of funds by users or the owner.\n */\ncontract UniqlyPresale4 {\n    // presale target - close presale when reached\n    uint256 public immutable presaleLimit;\n\n    // minimum pay-in per user\n    uint256 public immutable minPerUser;\n\n    // maximum pay-in per user\n    uint256 public immutable maxPerUser;\n\n    // timestamp ending presale\n    uint256 public immutable presaleEnd;\n\n    // failsafe time - fail if not properly closed after presaleEnd\n    uint256 constant failSafeTime = 2 weeks;\n\n    // owner address - will receive ETH if success\n    address public owner;\n\n    /**\n     * @notice Initializes the presale contract with the given parameters.\n     * @param _presaleLimit The maximum amount of ETH to be collected in the presale.\n     * @param _minPerUser The minimum amount of ETH a user can contribute.\n     * @param _maxPerUser The maximum amount of ETH a user can contribute.\n     * @param _presaleEnd The Unix timestamp at which the presale ends.\n     * @param _owner The address of the contract owner.\n     */\n    constructor(\n        uint256 _presaleLimit, \n        uint256 _minPerUser, \n        uint256 _maxPerUser, \n        uint256 _presaleEnd, \n        address _owner\n    ) {\n        presaleLimit = _presaleLimit;\n        minPerUser = _minPerUser;\n        maxPerUser = _maxPerUser;\n        presaleEnd = _presaleEnd;\n        owner = _owner;\n    }\n\n    // flags need for logic (false is default)\n    bool presaleEnded;\n    bool presaleFailed;\n    bool presaleStarted;\n\n    // list of user balances (zero is default)\n    mapping(address => uint256) private balances;\n\n    /**\n     * @notice Allows users to contribute ETH to the presale.\n     * @dev Users can send ETH to the contract, and their contributions are recorded. The presale can end if the limit is reached.\n     */\n    receive() external payable {\n        // only if not ended\n        require(presaleStarted, \"Presale not started\");\n        require(!presaleEnded, \"Presale ended\");\n        // only if within time limit\n        require(block.timestamp < presaleEnd, \"Presale time's up\");\n\n        // record new user balance if possible\n        uint256 amount = msg.value + balances[msg.sender];\n        require(amount >= minPerUser, \"Below buy-in\");\n        require(amount <= maxPerUser, \"Over buy-in\");\n        balances[msg.sender] = amount;\n\n        // end presale if reached limit\n        if (collected() >= presaleLimit) {\n            presaleEnded = true;\n        }\n    }\n\n    /**\n     * @notice Starts the presale, allowing users to contribute.\n     * @dev Only the contract owner can start the presale.\n     */\n    function start() external {}\n\n    /**\n     * @notice Returns the balance of a specific user.\n     * @param user The address of the user.\n     * @return The balance of the user in the presale.\n     */\n    function balanceOf(address user) external view returns (uint256) {}\n\n    /**\n     * @notice Returns the balance of the caller.\n     * @return The balance of the caller in the presale.\n     */\n    function balanceOf() external view returns (uint256) {}\n\n    /**\n     * @notice Returns the total amount of ETH collected in the presale.\n     * @return The total amount of ETH collected.\n     */\n    function collected() public view returns (uint256) {}\n\n    /**\n     * @notice Allows withdrawal of funds based on presale status.\n     * @dev\n     * - If presale hasn't ended and fail-safe time has passed, marks presale as failed.\n     * - If called by owner after successful presale, withdraws all contract balance.\n     * - If presale failed, allows users to withdraw their contributed funds.\n     * - Returns true if withdrawal was successful, false otherwise.\n     * @notice Behavior depends on presale state:\n     *   - Presale ongoing: No action (returns false)\n     *   - Presale ended but not failed: Only owner can withdraw (returns true if owner)\n     *   - Presale failed: Any user can withdraw their contribution (returns true)\n     *   - Presale succeeded: Only owner can withdraw (returns true if owner)\n     * @dev Uses `send` for withdrawals which may fail silently if recipient rejects ETH\n     * @return bool True if funds were withdrawn, false otherwise\n     */\n    function withdraw() external returns (bool) {}\n\n    /**\n     * @notice Sends ETH from the contract to a specified address.\n     * @param user The address to send ETH to.\n     * @param amount The amount of ETH to send.\n     * @dev This function is used internally by the `withdraw` function.\n     */\n    function send(address user, uint256 amount) private {}\n\n    /**\n     * @notice Allows the owner to withdraw any ERC20 tokens accidentally sent to the contract.\n     * @param token The ERC20 token to withdraw.\n     * @dev This function ensures that the owner can recover any ERC20 tokens sent to the contract.\n     */\n    function withdrawAnyERC20(IERC20 token) external {}\n\n    // change ownership in two steps to be sure about owner address\n    address public newOwner;\n\n    /**\n     * @notice Allows the current owner to delegate ownership to a new address.\n     * @param _newOwner The address of the new owner.\n     * @dev Only the current owner can delegate ownership.\n     */\n    function giveOwnership(address _newOwner) external {}\n\n    /**\n     * @notice Allows the new owner to accept the ownership of the contract.\n     * @dev The new owner must call this function to finalize the ownership transfer.\n     */\n    function acceptOwnership() external {}\n}\n"
}