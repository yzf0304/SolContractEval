{
    "contract_name": "UniswapV2ERC20",
    "ground_truth": "contract UniswapV2ERC20 {\n    using SafeMathUniswap for uint;\n\n    string public constant name = 'SushiSwap LP Token';\n    string public constant symbol = 'SLP';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}",
    "function_sum": 8,
    "compiler_version": "0.6.12",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary SafeMathUniswap {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n\n\n\n// You task is to complete the smart contract UniswapV2ERC20 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.6.12, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @notice This contract implements the ERC223 standard for token transfers, including additional functionality for permit-based approvals.\n * @dev The contract is designed to be used as a liquidity provider (LP) token in the SushiSwap decentralized exchange.\n */\ncontract UniswapV2ERC20 {\n    using SafeMathUniswap for uint;\n\n    string public constant name = 'SushiSwap LP Token';\n    string public constant symbol = 'SLP';\n    uint8 public constant decimals = 18;\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /**\n     * @notice Mints new tokens and assigns them to the specified address.\n     * @dev Increases the total supply and the balance of the recipient.\n     * @param to The address to which the tokens will be minted.\n     * @param value The amount of tokens to mint.\n     */\n    function _mint(address to, uint value) internal {}\n\n    /**\n     * @notice Burns tokens from the specified address.\n     * @dev Decreases the total supply and the balance of the sender.\n     * @param from The address from which the tokens will be burned.\n     * @param value The amount of tokens to burn.\n     */\n    function _burn(address from, uint value) internal {}\n\n    /**\n     * @notice Sets the allowance for a spender over the owner's tokens.\n     * @dev Updates the allowance mapping and emits an Approval event.\n     * @param owner The address of the token owner.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens that the spender is allowed to spend.\n     */\n    function _approve(address owner, address spender, uint value) private {}\n\n    /**\n     * @notice Transfers tokens from one address to another.\n     * @dev Updates the balances of the sender and the recipient and emits a Transfer event.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     */\n    function _transfer(address from, address to, uint value) private {}\n\n    /**\n     * @notice Approves a spender to spend a certain amount of tokens on behalf of the message sender.\n     * @dev Calls the internal _approve function and returns true.\n     * @param spender The address of the spender.\n     * @param value The amount of tokens to approve.\n     * @return A boolean indicating the success of the operation.\n     */\n    function approve(address spender, uint value) external returns (bool) {}\n\n    /**\n     * @notice Transfers tokens from the message sender to a specified address.\n     * @dev Calls the internal _transfer function and returns true.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @return A boolean indicating the success of the operation.\n     */\n    function transfer(address to, uint value) external returns (bool) {}\n\n    /**\n     * @notice Transfers tokens from one address to another, given that the message sender has sufficient allowance.\n     * @dev Decreases the allowance if it is not set to the maximum value, calls the internal _transfer function, and returns true.\n     * @param from The address from which the tokens will be transferred.\n     * @param to The address to which the tokens will be transferred.\n     * @param value The amount of tokens to transfer.\n     * @return A boolean indicating the success of the operation.\n     */\n    function transferFrom(address from, address to, uint value) external returns (bool) {}\n\n    /**\n     * @notice Allows token owner to approve spender via signed message (EIP-2612).\n     * @dev\n     * - Validates signature and deadline\n     * - Uses EIP-712 typed data hashing\n     * - Includes nonce replay protection\n     * - Verifies recovered signer matches owner\n     * - Calls internal _approve on success\n     * @param owner Token owner address\n     * @param spender Approved address\n     * @param value Approval amount\n     * @param deadline Transaction expiration timestamp\n     * @param v ECDSA recovery ID\n     * @param r ECDSA signature part\n     * @param s ECDSA signature part\n     * @notice Reverts if signature is invalid/expired or signer mismatch\n     */\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {}\n}\n"
}