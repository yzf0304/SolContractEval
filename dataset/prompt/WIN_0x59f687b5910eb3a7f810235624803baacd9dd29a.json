{
    "contract_name": "WIN",
    "ground_truth": "contract WIN {\n    \n    using SafeMath for uint256;\n    \n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\taddress public owner;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    // event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _from, uint256 value);\n\n    constructor(uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {\n        name = _tokenName;                                   \n        symbol = _tokenSymbol;\n        decimals = _decimalUnits;                            \n        totalSupply = _initialSupply;                        \n        balanceOf[msg.sender] = _initialSupply;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n            // Test validity of the address '_to':\n        require(_to != 0x0);\n            // Test positiveness of '_value':\n\t\trequire(_value > 0);\n\t\t    // Check the balance of the sender:\n        require(balanceOf[msg.sender] >= _value);\n            // Check for overflows:\n        require(balanceOf[_to] + _value >= balanceOf[_to]); \n            // Update balances of msg.sender and _to:\n        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], _value);                     \n        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);                            \n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n            // Test validity of the address '_to':\n        require(_to != 0x0);\n            // Test positiveness of '_value':\n\t\trequire(_value > 0);\n\t\t    // Check the balance of the sender:\n        require(balanceOf[msg.sender] >= _value);\n            // Check for overflows:\n        require(balanceOf[_to] + _value >= balanceOf[_to]); \n            // Update balances of msg.sender and _to:\n            // Check allowance's sufficiency:\n        require(_value <= allowance[_from][msg.sender]);\n            // Update balances of _from and _to:\n        balanceOf[_from] = SafeMath.sub(balanceOf[_from], _value);                           \n        balanceOf[_to] = SafeMath.add(balanceOf[_to], _value);\n            // Update allowance:\n        require(allowance[_from][msg.sender]  < MAX_UINT256);\n        allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender], _value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n            // Test positiveness of '_value':\n\t\trequire(_value > 0); \n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n            // Check msg.sender's balance sufficiency:\n        require(balanceOf[msg.sender] >= _value);           \n            // Test positiveness of '_value':\n\t\trequire(_value > 0); \n        balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender], _value);                    \n        totalSupply = SafeMath.sub(totalSupply,_value);                              \n        emit Burn(msg.sender, _value);\n        return true;\n    }\n            \n}",
    "function_sum": 4,
    "compiler_version": "0.4.24",
    "prompt": "// Below are some contexts potentially relevant to contract code generation.\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n\n\n// You task is to complete the smart contract WIN strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.24, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.\n\n/**\n * @title WIN Token Contract\n * @notice This contract implements a basic ERC20 token with additional functionality for burning tokens.\n * @dev The contract uses SafeMath to prevent overflows and underflows.\n */\ncontract WIN {\n    \n    using SafeMath for uint256;\n    \n    uint256 constant private MAX_UINT256 = 2**256 - 1;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    // event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _from, uint256 value);\n\n    /**\n     * @notice Initializes the token with an initial supply, name, decimal units, and symbol.\n     * @param _initialSupply The initial supply of tokens.\n     * @param _tokenName The name of the token.\n     * @param _decimalUnits The number of decimal units for the token.\n     * @param _tokenSymbol The symbol of the token.\n     * @dev Sets the initial supply, assigns it to the contract creator, and sets the token details.\n     */\n    constructor(uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {\n        name = _tokenName;                                   \n        symbol = _tokenSymbol;\n        decimals = _decimalUnits;                            \n        totalSupply = _initialSupply;                        \n        balanceOf[msg.sender] = _initialSupply;\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Transfers a specified amount of tokens from the sender to a recipient.\n     * @param _to The recipient address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating if the transfer was successful.\n     * @dev Ensures the recipient address is valid, the value is positive, and the sender has sufficient balance.\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Transfers a specified amount of tokens on behalf of another address.\n     * @param _from The address to transfer tokens from.\n     * @param _to The recipient address.\n     * @param _value The amount of tokens to transfer.\n     * @return A boolean indicating if the transfer was successful.\n     * @dev Ensures the recipient address is valid, the value is positive, the sender has sufficient allowance, and the sender has sufficient balance.\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Approves a spender to spend a specified amount of tokens on behalf of the sender.\n     * @param _spender The address that will spend the tokens.\n     * @param _value The amount of tokens to approve.\n     * @return A boolean indicating if the approval was successful.\n     * @dev Ensures the value is positive.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n    /**\n     * @notice Burns a specified amount of tokens from the sender's balance.\n     * @param _value The amount of tokens to burn.\n     * @return A boolean indicating if the burn was successful.\n     * @dev Ensures the sender has sufficient balance and the value is positive.\n     */\n    function burn(uint256 _value) public returns (bool success) {}\n}\n"
}