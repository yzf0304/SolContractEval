# AggregationRouterV3 Contract

Here's the complete implementation of the AggregationRouterV3 contract based on the provided context:

```solidity
/**
 * @notice AggregationRouterV3 is a smart contract that facilitates token swaps and aggregations.
 * It allows users to swap tokens with specific conditions and flags, and also includes functionality for
 * rescuing funds and destroying the contract.
 * @dev This contract inherits from Ownable and UnoswapRouter. It uses SafeMath, SafeERC20, and UniERC20
 * for safe arithmetic and token operations. The contract supports various flags to control the behavior of
 * the swap operations.
 */
contract AggregationRouterV3 is Ownable, UnoswapRouter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    using UniERC20 for IERC20;

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    /**
     * @notice Executes a discounted swap operation, which can burn CHI tokens to reduce gas costs.
     * @dev This function calls the `swap` function internally and handles CHI token burning based on the provided flags.
     * @param caller The aggregation executor that will perform the swap.
     * @param desc The swap description containing all necessary parameters.
     * @param data Additional data required for the swap.
     * @return returnAmount The amount of destination tokens received.
     * @return gasLeft The remaining gas after the swap.
     * @return chiSpent The amount of CHI tokens burned.
     */
    function discountedSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft, uint256 chiSpent)
    {
        uint256 gasStart = gasleft();
        
        // Handle CHI burning based on flags
        if (desc.flags & _BURN_FROM_MSG_SENDER != 0) {
            IChi chi = IChi(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);
            chiSpent = 41;
            chi.freeFromUpTo(msg.sender, chiSpent);
        } else if (desc.flags & _BURN_FROM_TX_ORIGIN != 0) {
            IChi chi = IChi(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);
            chiSpent = 41;
            chi.freeFromUpTo(tx.origin, chiSpent);
        }
        
        // Execute the swap
        (returnAmount, gasLeft) = swap(caller, desc, data);
        
        // Calculate remaining gas
        gasLeft = gasStart.sub(gasLeft);
    }

    /**
     * @notice Executes a token swap operation based on the provided parameters.
     * @dev This function checks the validity of the input parameters and performs the swap using the specified aggregation executor.
     * @param caller The aggregation executor that will perform the swap.
     * @param desc The swap description containing all necessary parameters.
     * @param data Additional data required for the swap.
     * @return returnAmount The amount of destination tokens received.
     * @return gasLeft The remaining gas after the swap.
     */
    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft)
    {
        uint256 initialGas = gasleft();

        // Check if extra ETH is required
        if ((desc.flags & _REQUIRES_EXTRA_ETH) == 0) {
            require(msg.value == (desc.srcToken.isETH() ? desc.amount : 0), "Invalid msg.value");
        }

        // Handle permit if provided
        _permit(desc.srcToken, desc.amount, desc.permit);

        // Transfer source tokens from sender to source receiver (usually the aggregation executor)
        if (!desc.srcToken.isETH()) {
            desc.srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
        }

        // Get initial balance of destination token
        uint256 initialDstBalance = desc.dstToken.uniBalanceOf(address(this));

        // Execute the swap through the aggregation executor
        {
            bytes memory callData = data;
            (bool success, bytes memory result) = address(caller).call{value: msg.value}(callData);
            if (!success) {
                revert(RevertReasonParser.parse(result, "Aggregation executor call failed: "));
            }
        }

        // Calculate the amount received
        returnAmount = desc.dstToken.uniBalanceOf(address(this)).sub(initialDstBalance);

        // Check if partial fill is allowed
        if ((desc.flags & _PARTIAL_FILL) != 0) {
            // For partial fills, we calculate the actual spent amount proportionally
            uint256 actualSpentAmount = desc.amount.mul(returnAmount).div(desc.minReturnAmount);
            require(returnAmount > 0 && actualSpentAmount > 0, "Zero return amount");
            
            // Refund unused source tokens if needed
            if (!desc.srcToken.isETH() && actualSpentAmount < desc.amount) {
                desc.srcToken.safeTransfer(msg.sender, desc.amount.sub(actualSpentAmount));
            }
            
            emit Swapped(
                msg.sender,
                desc.srcToken,
                desc.dstToken,
                desc.dstReceiver,
                actualSpentAmount,
                returnAmount
            );
        } else {
            // For regular fills, check if the minimum return amount is met
            require(returnAmount >= desc.minReturnAmount, "Return amount is not enough");
            
            emit Swapped(
                msg.sender,
                desc.srcToken,
                desc.dstToken,
                desc.dstReceiver,
                desc.amount,
                returnAmount
            );
        }

        // Transfer destination tokens to the destination receiver
        if ((desc.flags & _SHOULD_CLAIM) == 0) {
            desc.dstToken.uniTransfer(payable(desc.dstReceiver), returnAmount);
        }

        // Return remaining gas
        gasLeft = initialGas - gasleft();
    }

    /**
     * @notice Allows the owner to rescue funds from the contract.
     * @dev This function transfers the specified amount of a given token to the owner.
     * @param token The token to be rescued.
     * @param amount The amount of the token to be transferred.
     */
    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {
        token.uniTransfer(payable(owner()), amount);
    }

    /**
     * @notice Allows the owner to destroy the contract and send any remaining ETH to the owner.
     * @dev This function self-destructs the contract and sends the remaining ETH to the owner.
     */
    function destroy() external onlyOwner {
        selfdestruct(payable(owner()));
    }
}
```

This implementation includes all the required functionality for the AggregationRouterV3 contract, including swap execution with various flags, CHI token burning for gas optimization, and administrative functions for fund rescue and contract destruction. The contract inherits from Ownable and UnoswapRouter and utilizes the provided libraries for safe operations.