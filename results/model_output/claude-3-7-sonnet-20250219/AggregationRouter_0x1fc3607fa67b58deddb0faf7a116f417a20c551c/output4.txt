I'll complete the `AggregationRouter` contract based on the provided context:

```solidity
/**
 * @title AggregationRouter
 * @notice A smart contract for aggregating and executing token swaps with various options.
 * @dev This contract allows for swapping between different ERC223 and ERC20 tokens, including ETH, 
 *      with the ability to handle partial fills, extra ETH, and permit-based transfers. It also includes
 *      a rescue function for the owner to recover funds.
 */
contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    /**
     * @notice The address of the WETH contract.
     * @dev This is used to handle ETH as an ERC20 token.
     */
    address public immutable WETH;

    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);

    uint256 private constant _PARTIAL_FILL = 0x01;

    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;

    uint256 private constant _SHOULD_CLAIM = 0x04;

    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;

    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    /**
     * @notice Struct to hold the details of a swap.
     * @dev This struct is used to pass the necessary parameters for a swap.
     */
    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    /**
     * @notice Event emitted when a swap is executed.
     * @dev This event logs the details of a successful swap.
     */
    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    /**
     * @notice Event emitted when an exchange is made.
     * @dev This event logs the details of an exchange.
     */
    event Exchange(address pair, uint256 amountOut, address output);

    /**
     * @notice Modifier to ensure the transaction is not expired.
     * @dev This modifier checks that the deadline has not passed.
     */
    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, "Router: EXPIRED");
        _;
    }

    /**
     * @notice Constructor to set the WETH address.
     * @param _WETH The address of the WETH contract.
     */
    constructor(address _WETH) public {
        WETH = _WETH;
    }

    /**
     * @notice Fallback function to accept ETH.
     * @dev This function ensures that only ETH from the WETH contract is accepted.
     */
    receive() external payable {
    }

    /**
     * @dev Executes token swap via aggregator executor.
     * @param caller Aggregation executor contract
     * @param desc Swap parameters (src/dst tokens, amounts, flags)
     * @param data Encoded swap call data
     * @return returnAmount Actual amount received
     * @dev Requirements
     *   - minReturnAmount > 0
     *   - data must be non-empty
     *   - msg.value matches token requirements (ETH handling)
     *   - Permit/transfer for srcToken if required
     * @dev Behavior
     *   - Handles partial fills and return amount validation
     *   - Emits Swapped and Exchange events
     * @dev Notes
     *   - ETH handling is automatic based on flags
     *   - Caller must implement callBytes interface
     */
    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "Min return amount should be greater than 0");
        require(data.length > 0, "Empty data");

        bool srcETH = isETH(desc.srcToken);
        bool dstETH = isETH(desc.dstToken);
        
        // Check ETH value
        if (srcETH) {
            require(msg.value >= desc.amount, "Insufficient ETH amount");
        } else if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
            require(msg.value > 0, "Extra ETH is required for the swap");
        } else {
            require(msg.value == 0, "Excessive ETH amount");
        }
        
        // Process permit if needed
        if (!srcETH && desc.permit.length > 0) {
            _permit(desc.srcToken, desc.amount, desc.permit);
        }
        
        uint256 initialSrcBalance = getBalance(desc.srcToken, address(this));
        uint256 initialDstBalance = getBalance(desc.dstToken, address(this));
        
        // Transfer tokens from sender to this contract if not ETH
        if (!srcETH) {
            uint256 spendingAmount = desc.amount;
            
            // If partial fill is allowed
            if (desc.flags & _PARTIAL_FILL != 0) {
                uint256 balanceOfSender = desc.srcToken.balanceOf(msg.sender);
                if (balanceOfSender < spendingAmount) {
                    spendingAmount = balanceOfSender;
                }
            }
            
            require(spendingAmount > 0, "Spending amount should be greater than 0");
            
            // Transfer tokens from sender to this contract or source receiver
            if (desc.srcReceiver == address(0) || desc.srcReceiver == address(this)) {
                TransferHelper.safeTransferFrom(
                    address(desc.srcToken),
                    msg.sender,
                    address(this),
                    spendingAmount
                );
            } else {
                TransferHelper.safeTransferFrom(
                    address(desc.srcToken),
                    msg.sender,
                    desc.srcReceiver,
                    spendingAmount
                );
            }
        }
        
        // Execute the swap via the caller contract
        uint256 ethValue = srcETH ? desc.amount : msg.value;
        caller.callBytes{value: ethValue}(data);
        
        // Calculate the spent and return amounts
        uint256 finalSrcBalance = getBalance(desc.srcToken, address(this));
        uint256 finalDstBalance = getBalance(desc.dstToken, address(this));
        
        uint256 spentAmount = initialSrcBalance > finalSrcBalance
            ? initialSrcBalance - finalSrcBalance
            : srcETH ? desc.amount : 0;
            
        returnAmount = finalDstBalance - initialDstBalance;
        
        // Validate return amount against minimum requirement
        if (desc.flags & _PARTIAL_FILL != 0) {
            require(
                returnAmount.mul(desc.amount) >= desc.minReturnAmount.mul(spentAmount),
                "Return amount is not enough (partial fill)"
            );
        } else {
            require(
                returnAmount >= desc.minReturnAmount,
                "Return amount is not enough"
            );
        }
        
        // Transfer the return amount to the destination receiver
        if (dstETH) {
            TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);
        } else {
            TransferHelper.safeTransfer(address(desc.dstToken), desc.dstReceiver, returnAmount);
        }
        
        // Refund remaining ETH if necessary
        if (srcETH && msg.value > spentAmount) {
            TransferHelper.safeTransferETH(msg.sender, msg.value - spentAmount);
        }
        
        // Emit events
        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            spentAmount,
            returnAmount
        );
        
        emit Exchange(
            address(caller),
            returnAmount,
            dstETH ? ETH_ADDRESS : address(desc.dstToken)
        );
    }

    /**
     * @notice Internal function to get the balance of a token.
     * @param token The token to check the balance of.
     * @param account The account to check the balance for.
     * @return The balance of the token for the account.
     * @dev This function returns the balance of a token, or the ETH balance if the token is ETH.
     */
    function getBalance(IERC20 token, address account)
        internal
        view
        returns (uint256)
    {
        if (isETH(token)) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    /**
     * @notice Internal function to check if a token is ETH.
     * @param token The token to check.
     * @return True if the token is ETH, false otherwise.
     * @dev This function checks if the token address is the ETH address.
     */
    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    /**
     * @notice Function to rescue funds.
     * @param token The token to rescue.
     * @param amount The amount of the token to rescue.
     * @dev This function allows the owner to rescue funds from the contract.
     */
    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == ETH_ADDRESS) {
            TransferHelper.safeTransferETH(owner(), amount);
        } else {
            TransferHelper.safeTransfer(token, owner(), amount);
        }
    }
}
```

This implementation includes:

1. A `swap` function that handles all required operations:
   - Token validation and ETH handling
   - Processing permits for ERC20 tokens
   - Handling partial fills based on flags
   - Calling the executor contract
   - Validating return amounts
   - Transferring tokens to destination
   - Refunding excess ETH
   - Emitting appropriate events

2. Helper functions:
   - `getBalance` to check token balances
   - `isETH` to determine if a token is ETH

3. A `rescueFunds` function that allows the owner to recover funds

The contract handles the various flags defined as constants and provides the expected functionality for token swaps through aggregator executors.