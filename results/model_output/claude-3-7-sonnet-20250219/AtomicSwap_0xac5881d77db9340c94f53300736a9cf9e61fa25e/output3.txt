I'll complete the AtomicSwap contract implementation based on the provided context, focusing on the unimplemented function bodies:

```solidity
/**
 * @title AtomicSwap
 * @author [Your Name]
 * @notice This contract facilitates atomic swaps between two parties using a hashed secret.
 * @dev Implements non-reentrancy guard and uses SafeMath and SafeERC20 for secure arithmetic and token operations.
 */
contract AtomicSwap is ReentrancyGuard {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    enum State { Empty, Initiated, Redeemed, Refunded }

    struct Swap {
        bytes32 hashedSecret;
        bytes32 secret;
        address contractAddr;
        address participant;
        address payable initiator;
        uint refundTimestamp;
        uint countdown;
        uint value;
        uint payoff;
        bool active;
        State state;
    }
    
    event Initiated(
        bytes32 indexed _hashedSecret,
        address indexed _contract,
        address indexed _participant,
        address _initiator,
        uint _refundTimestamp,
        uint _countdown,
        uint _value,
        uint _payoff,
        bool _active
    );
    event Added(
        bytes32 indexed _hashedSecret,
        address _sender,
        uint _value  
    );
    event Activated(
        bytes32 indexed _hashedSecret
    );
    event Redeemed(
        bytes32 indexed _hashedSecret,
        bytes32 _secret
    );
    event Refunded(
        bytes32 indexed _hashedSecret
    );

    mapping(bytes32 => Swap) public swaps;

    /**
     * @notice Modifier to ensure the function can only be called by the initiator of the swap.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier onlyByInitiator(bytes32 _hashedSecret) {
        require(msg.sender == swaps[_hashedSecret].initiator, "sender is not the initiator");
        _;
    }

    /**
     * @notice Modifier to ensure the swap can be initiated.
     * @param _hashedSecret The hashed secret of the swap.
     * @param _participant The address of the participant.
     * @param _refundTimestamp The timestamp after which the swap can be refunded.
     * @param _countdown The countdown period before the refund timestamp.
     */
    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint _refundTimestamp, uint _countdown) {
        require(_participant != address(0), "invalid participant address");
        require(swaps[_hashedSecret].state == State.Empty, "swap for this hash is initiated");
        require(block.timestamp <= _refundTimestamp, "invalid refundTimestamp");
        require(_countdown < _refundTimestamp, "invalid countdown");
        _;
    }
    
    /**
     * @notice Modifier to ensure the swap has been initiated.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier isInitiated(bytes32 _hashedSecret) {
        require(swaps[_hashedSecret].state == State.Initiated, "swap for this hash is empty or spent");
        _;
    }

    /**
     * @notice Modifier to ensure the swap can be added to.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier isAddable(bytes32 _hashedSecret) {
        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, "refundTimestamp has come");
        _;
    }
        
    /**
     * @notice Modifier to ensure the swap is activated.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier isActivated(bytes32 _hashedSecret) {
        require(swaps[_hashedSecret].active, "swap is not active");
        _;
    }    
    
    /**
     * @notice Modifier to ensure the swap is not activated.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier isNotActivated(bytes32 _hashedSecret) {
        require(!swaps[_hashedSecret].active, "swap is active");
        _;
    }

    /**
     * @notice Modifier to ensure the swap can be redeemed.
     * @param _hashedSecret The hashed secret of the swap.
     * @param _secret The secret to redeem the swap.
     */
    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {
        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, "refundTimestamp has come");
        require(sha256(abi.encodePacked(sha256(abi.encodePacked(_secret)))) == _hashedSecret, "secret is not correct");
        _;
    }

    /**
     * @notice Modifier to ensure the swap can be refunded.
     * @param _hashedSecret The hashed secret of the swap.
     */
    modifier isRefundable(bytes32 _hashedSecret) {
        require(block.timestamp > swaps[_hashedSecret].refundTimestamp, "refundTimestamp has not come");
        _;
    }

    /**
     * @notice Initiates a new atomic swap.
     * @param _hashedSecret The hashed secret of the swap.
     * @param _contract The address of the ERC20 token contract.
     * @param _participant The address of the participant.
     * @param _refundTimestamp The timestamp after which the swap can be refunded.
     * @param _countdown The countdown period before the refund timestamp.
     * @param _value The total value of the swap.
     * @param _payoff The payoff amount.
     * @param _active Whether the swap is active.
     */
    function initiate (bytes32 _hashedSecret, address _contract, address _participant, uint _refundTimestamp, uint _countdown, uint _value, uint _payoff, bool _active)
        public nonReentrant isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)
    {
        swaps[_hashedSecret].hashedSecret = _hashedSecret;
        swaps[_hashedSecret].contractAddr = _contract;
        swaps[_hashedSecret].participant = _participant;
        swaps[_hashedSecret].initiator = msg.sender;
        swaps[_hashedSecret].refundTimestamp = _refundTimestamp;
        swaps[_hashedSecret].countdown = _countdown;
        swaps[_hashedSecret].value = _value;
        swaps[_hashedSecret].payoff = _payoff;
        swaps[_hashedSecret].active = _active;
        swaps[_hashedSecret].state = State.Initiated;
        
        // Transfer tokens from initiator to this contract
        IERC20(_contract).safeTransferFrom(msg.sender, address(this), _value.add(_payoff));
        
        emit Initiated(_hashedSecret, _contract, _participant, msg.sender, _refundTimestamp, _countdown, _value, _payoff, _active);
    }

    /**
     * @notice Adds more value to an existing swap.
     * @param _hashedSecret The hashed secret of the swap.
     * @param _value The additional value to add.
     */
    function add (bytes32 _hashedSecret, uint _value)
        public nonReentrant isInitiated(_hashedSecret) isAddable(_hashedSecret)    
    {
        swaps[_hashedSecret].value = swaps[_hashedSecret].value.add(_value);
        
        // Transfer additional tokens from sender to this contract
        IERC20(swaps[_hashedSecret].contractAddr).safeTransferFrom(msg.sender, address(this), _value);
        
        emit Added(_hashedSecret, msg.sender, _value);
    }

    /**
     * @notice Activates an initiated swap.
     * @param _hashedSecret The hashed secret of the swap.
     */
    function activate (bytes32 _hashedSecret)
        public nonReentrant isInitiated(_hashedSecret) isNotActivated(_hashedSecret) onlyByInitiator(_hashedSecret)
    {
        swaps[_hashedSecret].active = true;
        
        emit Activated(_hashedSecret);
    }

    /**
     * @dev Redeems a swap by revealing the secret and transferring funds.
     * @param _hashedSecret Hashed secret used to identify the swap
     * @param _secret Actual secret to validate the redemption
     * @dev Requirements:
     *   - Swap must be initialized (isInitiated)
     *   - Swap must be activated (isActivated)
     *   - Swap must be redeemable with provided secret (isRedeemable)
     * @dev Behavior:
     *   - Records the secret and marks swap as redeemed
     *   - Transfers funds based on refund timing:
     *     - If past refund window: transfers base value to participant and payoff to msg.sender
     *     - Otherwise: transfers combined value+payoff to participant
     *   - Emits Redeemed event
     *   - Clears swap data
     * @dev Security:
     *   - Uses nonReentrant modifier to prevent reentrancy attacks
     */
    function redeem(bytes32 _hashedSecret, bytes32 _secret) 
        public nonReentrant isInitiated(_hashedSecret) isActivated(_hashedSecret) isRedeemable(_hashedSecret, _secret) 
    {
        // Store the secret
        swaps[_hashedSecret].secret = _secret;
        swaps[_hashedSecret].state = State.Redeemed;
        
        IERC20 token = IERC20(swaps[_hashedSecret].contractAddr);
        
        // Check if we're in the countdown period
        if (block.timestamp > swaps[_hashedSecret].countdown) {
            // Past countdown period but before refundTimestamp
            // Transfer the base value to participant and payoff to msg.sender
            token.safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value);
            token.safeTransfer(msg.sender, swaps[_hashedSecret].payoff);
        } else {
            // Before countdown period
            // Transfer the combined value and payoff to participant
            token.safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));
        }
        
        emit Redeemed(_hashedSecret, _secret);
    }

    /**
     * @notice Refunds the swap if the refund timestamp has passed.
     * @param _hashedSecret The hashed secret of the swap.
     */
    function refund(bytes32 _hashedSecret)
        public nonReentrant isInitiated(_hashedSecret) isRefundable(_hashedSecret) 
    {
        swaps[_hashedSecret].state = State.Refunded;
        
        // Return all funds to the initiator
        IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(
            swaps[_hashedSecret].initiator, 
            swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff)
        );
        
        emit Refunded(_hashedSecret);
    }
}
```

This implementation completes the AtomicSwap contract with all the required functionality:

1. The `initiate` function creates a new atomic swap, storing all the details and transferring tokens from the initiator to the contract.
2. The `add` function allows adding more value to an existing swap.
3. The `activate` function allows the initiator to activate the swap.
4. The `redeem` function allows the participant to redeem the swap by providing the correct secret, with different payout logic depending on the timing.
5. The `refund` function allows the initiator to reclaim their funds if the refund timestamp has passed.

All functions use appropriate modifiers to enforce security and validation checks, and they emit events to track the swap lifecycle.