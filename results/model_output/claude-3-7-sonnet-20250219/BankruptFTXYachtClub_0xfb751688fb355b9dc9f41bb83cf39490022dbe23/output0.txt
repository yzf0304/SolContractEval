I'll complete the BankruptFTXYachtClub smart contract according to your requirements. Here's the full implementation:

```solidity
/**
 * @title BankruptFTXYachtClub
 * @notice This contract is an ERC721A NFT collection with functionalities for minting, reserving, airdropping, and managing the NFTs.
 * @dev The contract extends ERC721A and Ownable to provide additional features like pausing, revealing, and setting various parameters.
 */
contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;

    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    mapping (address => uint8) public NFTPerPublicAddress;

    /**
     * @notice Constructor to initialize the NFT contract with name and symbol.
     * @dev Sets the name and symbol for the NFT collection.
     */
    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    /**
     * @notice Allows users to mint NFTs by paying the specified cost.
     * @dev Checks if the contract is not paused, does not exceed max supply, and handles free mints per wallet.
     * @param _mintAmount The number of NFTs to mint.
     */
    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Contract is paused");
        require(_mintAmount > 0, "Must mint at least 1 NFT");
        require(_mintAmount <= maxMintAmountPerTx, "Cannot exceed max mint amount per transaction");
        require(totalSupply() + _mintAmount <= maxSupply, "Would exceed max supply");

        uint256 requiredAmount = 0;
        uint8 freeMints = 0;
        
        if (NFTPerPublicAddress[msg.sender] < maxFreeMintAmountPerWallet) {
            freeMints = maxFreeMintAmountPerWallet - NFTPerPublicAddress[msg.sender];
            if (freeMints > _mintAmount) {
                freeMints = _mintAmount;
            }
            requiredAmount = cost * (_mintAmount - freeMints);
        } else {
            requiredAmount = cost * _mintAmount;
        }

        require(msg.value >= requiredAmount, "Insufficient funds");
        
        NFTPerPublicAddress[msg.sender] += _mintAmount;
        _safeMint(msg.sender, _mintAmount);
    }

    /**
     * @notice Allows the owner to reserve a certain amount of NFTs for a specific address.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _mintAmount The number of NFTs to reserve.
     * @param _receiver The address to receive the reserved NFTs.
     */
    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(_mintAmount > 0, "Must reserve at least 1 NFT");
        require(totalSupply() + _mintAmount <= maxSupply, "Would exceed max supply");
        require(_receiver != address(0), "Cannot mint to zero address");

        _safeMint(_receiver, _mintAmount);
    }

    /**
     * @notice Allows the owner to airdrop a certain amount of NFTs to multiple addresses.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _amountPerAddress The number of NFTs to airdrop to each address.
     * @param addresses The list of addresses to airdrop the NFTs to.
     */
    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        require(_amountPerAddress > 0, "Must airdrop at least 1 NFT per address");
        require(totalSupply() + (_amountPerAddress * addresses.length) <= maxSupply, "Would exceed max supply");

        for (uint256 i = 0; i < addresses.length; i++) {
            require(addresses[i] != address(0), "Cannot mint to zero address");
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    /**
     * @notice Sets the maximum supply of NFTs.
     * @dev Only the owner can call this function.
     * @param _maxSupply The new maximum supply.
     */
    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        require(_maxSupply >= totalSupply(), "New max supply cannot be less than current total supply");
        maxSupply = _maxSupply;
    }

    /**
     * @notice Returns the token URI for a given token ID.
     * @dev If the reveal is not set, returns the hidden URL; otherwise, constructs the token URI.
     * @param _tokenId The ID of the token.
     * @return The token URI.
     */
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");

        if (!reveal) {
            return hiddenURL;
        }

        return bytes(uriPrefix).length > 0 
            ? string(abi.encodePacked(uriPrefix, _tokenId.toString(), uriSuffix))
            : "";
    }

    /**
     * @notice Sets the maximum number of free mints per wallet.
     * @dev Only the owner can call this function.
     * @param _limit The new limit for free mints per wallet.
     */
    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    /**
     * @notice Sets the URI prefix for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new URI prefix.
     */
    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    /**
     * @notice Sets the hidden URI for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new hidden URI.
     */
    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        hiddenURL = _uriPrefix;
    }

    /**
     * @notice Toggles the paused state of the contract.
     * @dev Only the owner can call this function.
     */
    function setPaused() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Sets the cost for minting NFTs.
     * @dev Only the owner can call this function.
     * @param _cost The new cost for minting.
     */
    function setCost(uint _cost) external onlyOwner {
        cost = _cost;
    }

    /**
     * @notice Toggles the revealed state of the NFTs.
     * @dev Only the owner can call this function.
     */
    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.
     * @dev Only the owner can call this function.
     * @param _maxtx The new maximum mint amount per transaction.
     */
    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    /**
     * @notice Allows the owner to withdraw the contract's balance.
     * @dev Only the owner can call this function.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Withdrawal failed");
    }

    /**
     * @notice Returns the base URI for the NFTs.
     * @dev This is used to construct the full token URI.
     * @return The base URI.
     */
    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    /**
     * @notice Fallback function to accept ETH.
     * @dev This function is called when the contract receives ETH without any data.
     */
    receive() external payable {}
}
```

This implementation includes all the required functionalities:
1. Minting NFTs with support for free mints per wallet
2. Reserving NFTs for specific addresses
3. Airdropping NFTs to multiple addresses
4. Managing supply limits and minting parameters
5. Controlling the reveal status of NFTs
6. Setting URIs for revealed and hidden NFTs
7. Withdrawing funds from the contract
8. Pausing and unpausing the contract

The contract follows the ERC721A standard for gas-efficient minting and inherits from Ownable for access control.