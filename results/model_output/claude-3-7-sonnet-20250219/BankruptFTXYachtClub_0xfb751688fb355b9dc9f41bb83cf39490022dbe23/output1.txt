I'll complete the BankruptFTXYachtClub contract according to the provided context and description.

```solidity
/**
 * @title BankruptFTXYachtClub
 * @notice This contract is an ERC721A NFT collection with functionalities for minting, reserving, airdropping, and managing the NFTs.
 * @dev The contract extends ERC721A and Ownable to provide additional features like pausing, revealing, and setting various parameters.
 */
contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;

    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    mapping (address => uint8) public NFTPerPublicAddress;

    /**
     * @notice Constructor to initialize the NFT contract with name and symbol.
     * @dev Sets the name and symbol for the NFT collection.
     */
    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    /**
     * @notice Allows users to mint NFTs by paying the specified cost.
     * @dev Checks if the contract is not paused, does not exceed max supply, and handles free mints per wallet.
     * @param _mintAmount The number of NFTs to mint.
     */
    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Contract is paused");
        require(_mintAmount > 0, "Must mint at least one NFT");
        require(_mintAmount <= maxMintAmountPerTx, "Exceeds max mint amount per transaction");
        require(_currentIndex + _mintAmount <= maxSupply, "Exceeds max supply");

        uint8 freeMints = 0;
        if (NFTPerPublicAddress[msg.sender] < maxFreeMintAmountPerWallet) {
            freeMints = maxFreeMintAmountPerWallet - NFTPerPublicAddress[msg.sender];
            if (freeMints > _mintAmount) {
                freeMints = _mintAmount;
            }
        }

        uint8 paidMints = _mintAmount - freeMints;
        require(msg.value >= cost * paidMints, "Insufficient funds");

        NFTPerPublicAddress[msg.sender] += _mintAmount;
        _safeMint(msg.sender, _mintAmount);
    }

    /**
     * @notice Allows the owner to reserve a certain amount of NFTs for a specific address.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _mintAmount The number of NFTs to reserve.
     * @param _receiver The address to receive the reserved NFTs.
     */
    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(_mintAmount > 0, "Must mint at least one NFT");
        require(_currentIndex + _mintAmount <= maxSupply, "Exceeds max supply");
        
        _safeMint(_receiver, _mintAmount);
    }

    /**
     * @notice Allows the owner to airdrop a certain amount of NFTs to multiple addresses.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _amountPerAddress The number of NFTs to airdrop to each address.
     * @param addresses The list of addresses to airdrop the NFTs to.
     */
    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        require(_amountPerAddress > 0, "Must mint at least one NFT per address");
        uint256 totalMintAmount = _amountPerAddress * addresses.length;
        require(_currentIndex + totalMintAmount <= maxSupply, "Exceeds max supply");

        for (uint256 i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    /**
     * @notice Sets the maximum supply of NFTs.
     * @dev Only the owner can call this function.
     * @param _maxSupply The new maximum supply.
     */
    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        require(_maxSupply >= _currentIndex, "New max supply must be greater than current supply");
        maxSupply = _maxSupply;
    }

    /**
     * @notice Returns the token URI for a given token ID.
     * @dev If the reveal is not set, returns the hidden URL; otherwise, constructs the token URI.
     * @param _tokenId The ID of the token.
     * @return The token URI.
     */
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "Token does not exist");

        if (!reveal) {
            return hiddenURL;
        }

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, _tokenId.toString(), uriSuffix)) : "";
    }

    /**
     * @notice Sets the maximum number of free mints per wallet.
     * @dev Only the owner can call this function.
     * @param _limit The new limit for free mints per wallet.
     */
    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    /**
     * @notice Sets the URI prefix for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new URI prefix.
     */
    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    /**
     * @notice Sets the hidden URI for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new hidden URI.
     */
    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        hiddenURL = _uriPrefix;
    }

    /**
     * @notice Toggles the paused state of the contract.
     * @dev Only the owner can call this function.
     */
    function setPaused() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Sets the cost for minting NFTs.
     * @dev Only the owner can call this function.
     * @param _cost The new cost for minting.
     */
    function setCost(uint256 _cost) external onlyOwner {
        cost = _cost;
    }

    /**
     * @notice Toggles the revealed state of the NFTs.
     * @dev Only the owner can call this function.
     */
    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.
     * @dev Only the owner can call this function.
     * @param _maxtx The new maximum mint amount per transaction.
     */
    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    /**
     * @notice Allows the owner to withdraw the contract's balance.
     * @dev Only the owner can call this function.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Withdrawal failed");
    }

    /**
     * @notice Returns the base URI for the NFTs.
     * @dev This is used to construct the full token URI.
     * @return The base URI.
     */
    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    /**
     * @notice Fallback function to accept ETH.
     * @dev This function is called when the contract receives ETH without any data.
     */
    receive() external payable {}
}
```

This contract implements all the specified functions for the BankruptFTXYachtClub NFT collection, including minting, reserving, airdropping, and various management functions. The contract allows users to mint NFTs, with a free mint allowance per wallet, and the owner can reserve NFTs for specific addresses or airdrop them to multiple addresses. The owner can also manage various parameters like maximum supply, cost, URI prefix, and toggle the paused and revealed states.