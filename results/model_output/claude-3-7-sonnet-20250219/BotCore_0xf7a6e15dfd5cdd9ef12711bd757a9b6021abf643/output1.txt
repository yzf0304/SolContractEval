Here's the completed BotMinting contract implementation based on the provided context:

```solidity
/**
 * @notice This contract is responsible for minting and auctioning bots. It extends the BotAuction contract.
 * @dev The contract handles the creation of promo and Gen0 bots, and manages their limits and auction prices.
 */
contract BotMinting is BotAuction {

    uint256 public constant PROMO_CREATION_LIMIT = 5000;
    uint256 public constant GEN0_CREATION_LIMIT = 45000;
    uint256 public constant GEN0_STARTING_PRICE = 10 finney;
    uint256 public constant GEN0_AUCTION_DURATION = 1 days;
    uint256 public promoCreatedCount;
    uint256 public gen0CreatedCount;

    /**
     * @notice Creates a promo bot with the specified genes and assigns it to an owner.
     * @dev Only the COO can call this function. The bot owner defaults to the COO if not specified.
     * @param _genes The genetic makeup of the bot.
     * @param _owner The address of the owner of the new bot.
     */
    function createPromoBot(uint256 _genes, address _owner) external onlyCOO {
        address botOwner = _owner;
        if (botOwner == address(0)) {
            botOwner = cooAddress;
        }
        
        require(promoCreatedCount < PROMO_CREATION_LIMIT);
        promoCreatedCount++;
        
        _createBot(0, 0, 0, _genes, botOwner);
    }

    /**
     * @notice Creates a Gen0 bot with the specified genes and starts an auction for it.
     * @dev Only the COO can call this function. The bot is initially owned by the contract and then put up for auction.
     * @param _genes The genetic makeup of the bot.
     */
    function createGen0Auction(uint256 _genes) external onlyCOO {
        require(gen0CreatedCount < GEN0_CREATION_LIMIT);
        
        uint256 botId = _createBot(0, 0, 0, _genes, address(this));
        
        _approve(botId, saleAuction);
        
        saleAuction.createAuction(
            botId,
            _computeNextGen0Price(),
            0,
            GEN0_AUCTION_DURATION,
            address(this)
        );
        
        gen0CreatedCount++;
    }

    /**
     * @notice Computes the next price for a Gen0 bot based on the average sale price.
     * @dev The price is calculated as the average sale price plus half of the average sale price. If the computed price is below the starting price, it defaults to the starting price.
     * @return The next price for a Gen0 bot.
     */
    function _computeNextGen0Price() internal view returns (uint256) {
        uint256 avePrice = saleAuction.averageGen0SalePrice();
        
        // Ensure we don't overflow uint256
        uint256 nextPrice = avePrice + (avePrice / 2);
        
        // If the price is too low, default to the starting price
        if (nextPrice < GEN0_STARTING_PRICE) {
            nextPrice = GEN0_STARTING_PRICE;
        }
        
        return nextPrice;
    }
}
```

This implementation follows the requirements specified in the contract description:

1. The contract extends BotAuction
2. It defines constants for promo and Gen0 bot creation limits, starting price, and auction duration
3. It tracks counts of created promo and Gen0 bots
4. Implements the createPromoBot function to create promo bots with specific genes and assign them to an owner
5. Implements the createGen0Auction function to create Gen0 bots and put them up for auction
6. Implements the _computeNextGen0Price helper function to calculate dynamic pricing for Gen0 bots

The implementation respects the access control mechanisms of the parent contracts and properly manages the creation limits for both types of bots.