I'll implement the Admin contract with all the required functionality according to the provided specifications:

```solidity
/**
 * @notice This contract provides administrative functionalities for managing token balances, allowed and blocked addresses, and transfer locks.
 * @dev The contract inherits from `Variable`, `Modifiers`, and `Event` contracts. It uses SafeMath for arithmetic operations to prevent overflows and underflows.
 */
contract Admin is Variable, Modifiers, Event {
    using SafeMath for uint256;

    /**
     * @notice Allows the owner to burn a specified amount of tokens from their balance.
     * @dev The function checks if the sender has enough balance before burning the tokens and updates the total supply accordingly.
     * @param _value The amount of tokens to be burned.
     * @return success A boolean indicating whether the operation was successful.
     */
    function tokenBurn(uint256 _value) public isOwner returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance to burn");
        
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        
        emit TokenBurn(msg.sender, _value);
        return true;
    }

    /**
     * @notice Allows the owner to add an address to the list of allowed addresses.
     * @dev The function sets the `_address` as allowed, which can be used in other functions to check permissions.
     * @param _address The address to be added to the allowed list.
     */
    function addAllowedAddress(address _address) public isOwner {
        require(_address != address(0), "Cannot add zero address");
        allowedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of allowed addresses.
     * @dev The function ensures that the owner's address cannot be removed from the allowed list.
     * @param _address The address to be removed from the allowed list.
     */
    function deleteAllowedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot remove owner from allowed addresses");
        allowedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to add an address to the list of blocked addresses.
     * @dev The function ensures that the owner's address cannot be added to the blocked list.
     * @param _address The address to be added to the blocked list.
     */
    function addBlockedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot block the owner address");
        blockedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of blocked addresses.
     * @dev The function removes the `_address` from the blocked list, allowing it to perform certain actions again.
     * @param _address The address to be removed from the blocked list.
     */
    function deleteBlockedAddress(address _address) public isOwner {
        blockedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to set or unset the transfer lock.
     * @dev The function toggles the `transferLock` state, which can be used to enable or disable token transfers.
     * @param _transferLock The new state of the transfer lock (true to enable, false to disable).
     * @return success A boolean indicating whether the operation was successful.
     */
    function setTransferLock(bool _transferLock) public isOwner returns (bool success) {
        transferLock = _transferLock;
        return true;
    }
}
```

This implementation includes all the required functionality for the Admin contract:
1. A token burn function that reduces the sender's balance and total supply
2. Functions to add and remove addresses from the allowed list
3. Functions to add and remove addresses from the blocked list
4. A function to set the transfer lock state

All functions have proper access controls using the `isOwner` modifier and include necessary checks to prevent unwanted behaviors.