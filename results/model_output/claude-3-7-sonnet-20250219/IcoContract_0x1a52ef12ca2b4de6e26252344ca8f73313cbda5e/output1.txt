I'll complete the Bonus contract according to the provided context. Note that for Solidity 0.4.18, the `receive()` function wasn't available - I'll use the fallback function instead:

```solidity
/**
 * @notice This contract manages the bonus distribution for an ICO, allowing the owner to enable or disable bonuses,
 *         calculate bonuses based on time and ETH amount, and manage bonus balances for participants.
 * @dev This contract inherits from IcoPhase and Ownable. It uses SafeMath for arithmetic operations.
 */
contract Bonus is IcoPhase, Ownable {

    using SafeMath for uint256;

    //decimals of tokens
    uint256 constant decimals = 18;

    //enable/disable
    bool public isBonus;

    //storage
    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    /**
     * @notice Initializes the contract with bonuses enabled.
     * @dev Constructor sets the initial state of the contract.
     */
    function Bonus() public {
        isBonus = true;
    }

    /**
     * @notice Enables the bonus system.
     * @dev Can only be called by the contract owner and when bonuses are currently disabled.
     * @return A boolean indicating the success of the operation.
     */
    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus);
        isBonus = true;
        return true;
    }

    /**
     * @notice Disables the bonus system.
     * @dev Can only be called by the contract owner and when bonuses are currently enabled.
     * @return A boolean indicating the success of the operation.
     */
    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus);
        isBonus = false;
        return true;
    }

    /**
     * @notice Gets the bonus percentage based on the current time.
     * @dev Checks the current time against predefined phases and returns the corresponding bonus percentage.
     * @return The bonus percentage as a uint256.
     */
    function getBonusByTime() public constant returns(uint256) {
        if (!isBonus) return 0;
        
        uint256 currentTime = now;
        
        // Presale phase: 40% bonus
        if (currentTime >= phasePresale_From && currentTime <= phasePresale_To) {
            return 40;
        }
        // Public sale phase 1: 25% bonus
        else if (currentTime >= phasePublicSale1_From && currentTime <= phasePublicSale1_To) {
            return 25;
        }
        // Public sale phase 2: 15% bonus
        else if (currentTime >= phasePublicSale2_From && currentTime <= phasePublicSale2_To) {
            return 15;
        }
        // Public sale phase 3: 10% bonus
        else if (currentTime >= phasePublicSale3_From && currentTime <= phasePublicSale3_To) {
            return 10;
        }
        
        return 0;
    }

    /**
     * @notice Calculates the bonus amount based on the provided ETH value.
     * @dev Determines the bonus amount based on the current phase and the provided ETH value.
     * @param _value The amount of ETH to convert to a bonus.
     * @return The bonus amount as a uint256.
     */
    function getBonusByETH(uint256 _value) public constant returns(uint256) {
        if (!isBonus) return 0;
        
        uint256 bonusPercentage = getBonusByTime();
        if (bonusPercentage == 0) return 0;
        
        // Additional bonus based on ETH amount
        if (_value >= 50 * 10**18) {  // 50 ETH or more
            bonusPercentage = bonusPercentage.add(10);
        } else if (_value >= 30 * 10**18) {  // 30 ETH or more
            bonusPercentage = bonusPercentage.add(7);
        } else if (_value >= 10 * 10**18) {  // 10 ETH or more
            bonusPercentage = bonusPercentage.add(5);
        } else if (_value >= 5 * 10**18) {  // 5 ETH or more
            bonusPercentage = bonusPercentage.add(3);
        }
        
        return _value.mul(bonusPercentage).div(100);
    }

    /**
     * @notice Returns the bonus balance of a specific account.
     * @dev Fetches the bonus balance from the storage mapping.
     * @param _owner The address of the account to check the bonus balance for.
     * @return The bonus balance as a uint256.
     */
    function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    /**
     * @notice Pays a bonus to a specified address.
     * @dev Only the contract owner can call this function.
     * @param _address The address to which the bonus will be paid.
     * @return A boolean indicating the success of the operation.
     */
    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        uint256 bonusAmount = bonusAccountBalances[_address];
        require(bonusAmount > 0);
        
        bonusAccountBalances[_address] = 0;
        
        // Add the recipient to the index if not already present
        if (bonusAmount > 0) {
            bonusAccountIndex[bonusAccountCount] = _address;
            bonusAccountCount = bonusAccountCount.add(1);
        }
        
        return true;
    }

    /**
     * @notice Fallback function to receive Ether.
     * @dev This function allows the contract to receive Ether.
     */
    function() public payable {
        // Allow contract to receive ether
    }
}
```

This implementation completes all the required functions for the Bonus contract:
1. Constructor initializing bonuses as enabled
2. Enable/disable bonus functions with owner checks
3. Bonus calculation based on time phases
4. Additional bonus calculation based on ETH amounts
5. Balance checking functionality
6. Bonus payment function (though actual token transfer would need to be implemented in a real ICO)
7. Fallback function to receive ETH (note: in 0.4.18 we use the unnamed function instead of `receive()`)

The implementation follows the inheritance from IcoPhase and Ownable contracts and uses SafeMath for safe arithmetic operations.