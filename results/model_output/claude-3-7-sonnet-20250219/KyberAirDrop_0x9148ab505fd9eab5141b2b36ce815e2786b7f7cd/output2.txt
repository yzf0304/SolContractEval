I'll complete the KyberGenesisToken contract according to the requirements. Here's the full implementation:

```solidity
/**
 * @title KyberGenesisToken
 * @notice This contract is a simple token contract with minting and burning capabilities. It is designed to be owned by a minter who can mint new tokens and end the minting process.
 * @dev Inherits from Ownable, allowing for ownership management. The token has a fixed supply mechanism where each address can only hold one token.
 */
contract KyberGenesisToken is Ownable {
  string  public  constant name     = "Kyber Genesis Token";
  string  public  constant symbol   = "KGT";
  uint    public  constant decimals = 0;

  uint                   public totalSupply = 0;
  mapping(address=>uint) public balanceOf;

  /**
   * @notice Initializes the contract and sets the minter as the owner.
   * @param minter The address of the minter who will own the contract.
   */
  function KyberGenesisToken( address minter ) {
    transferOwnership(minter);
  }

  /**
   * @notice Event emitted when tokens are transferred.
   * @param _from The address from which the tokens are sent.
   * @param _to The address to which the tokens are sent.
   * @param _value The amount of tokens transferred.
   */
  event Transfer(address indexed _from, address indexed _to, uint _value);

  /**
   * @notice Event emitted when the minting process is ended.
   * @param timestamp The block timestamp when the minting was ended.
   */
  event EndMinting( uint timestamp );

  /**
   * @notice Mints new tokens for the specified recipients.
   * @dev Only the owner (minter) can call this function. Each recipient can only receive one token.
   * @param recipients Array of addresses to receive the new tokens.
   */
  function mint( address[] recipients ) onlyOwner {
    for( uint i = 0 ; i < recipients.length ; i++ ) {
      address recipient = recipients[i];
      if (balanceOf[recipient] == 0) {
        balanceOf[recipient] = 1;
        totalSupply++;
        Transfer(0x0, recipient, 1);
      }
    }
  }

  /**
   * @notice Ends the minting process and transfers ownership to a dead address.
   * @dev Only the owner (minter) can call this function. After calling this function, no more tokens can be minted.
   */
  function endMinting() onlyOwner {
    EndMinting(block.timestamp);
    transferOwnership(0x0);
  }

  /**
   * @notice Burns the token held by the sender.
   * @dev The sender must hold exactly one token to burn it.
   */
  function burn() {
    require(balanceOf[msg.sender] == 1);
    
    balanceOf[msg.sender] = 0;
    totalSupply--;
    
    Transfer(msg.sender, 0x0, 1);
  }

  /**
   * @notice Drains ERC20 tokens from the contract to a predefined multisig address.
   * @dev This function can be called by anyone to drain any accidentally sent ERC20 tokens.
   * @param token The ERC20 token contract to drain.
   * @param amount The amount of tokens to drain.
   */
  function emergencyERC20Drain( ERC20Interface token, uint amount ){
    address multisig = 0x65e38111D9302E323E1cBb9F648F2E96c2f5Bf37;
    token.transfer(multisig, amount);
  }

  // ERC20 stubs
  /**
   * @notice Transfers tokens from the sender to the specified address.
   * @dev This function reverts as it is not implemented in this contract.
   * @param _to The address to which the tokens are transferred.
   * @param _value The amount of tokens to transfer.
   * @return A boolean value indicating whether the operation succeeded.
   */
  function transfer(address _to, uint _value) returns (bool){
    revert();
  }

  /**
   * @notice Transfers tokens from one address to another.
   * @dev This function reverts as it is not implemented in this contract.
   * @param _from The address from which the tokens are transferred.
   * @param _to The address to which the tokens are transferred.
   * @param _value The amount of tokens to transfer.
   * @return A boolean value indicating whether the operation succeeded.
   */
  function transferFrom(address _from, address _to, uint _value) returns (bool){
    revert();
  }

  /**
   * @notice Approves an address to spend a certain amount of tokens on behalf of the sender.
   * @dev This function reverts as it is not implemented in this contract.
   * @param _spender The address that is being approved to spend the tokens.
   * @param _value The amount of tokens to approve.
   * @return A boolean value indicating whether the operation succeeded.
   */
  function approve(address _spender, uint _value) returns (bool){
    revert();
  }

  /**
   * @notice Returns the amount of tokens that an owner allowed to a spender.
   * @dev This function always returns 0 as it is not implemented in this contract.
   * @param _owner The address of the token owner.
   * @param _spender The address of the spender.
   * @return The amount of tokens allowed to the spender.
   */
  function allowance(address _owner, address _spender) constant returns (uint){
    return 0;
  }

  /**
   * @notice Event emitted when an approval is made.
   * @param _owner The address of the token owner.
   * @param _spender The address of the spender.
   * @param _value The amount of tokens approved.
   */
  event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

This implementation includes:

1. A `mint` function that allows the owner to mint one token for each address in the provided array, but only if they don't already have a token
2. An `endMinting` function that transfers ownership to the zero address, effectively disabling further minting
3. A `burn` function that allows token holders to burn their token
4. An `emergencyERC20Drain` function that sends any ERC20 tokens to a hardcoded multisig address
5. ERC20 stub functions that revert or return default values

The contract ensures that each address can hold at most one token, and the token is non-transferable through the standard ERC20 functions.