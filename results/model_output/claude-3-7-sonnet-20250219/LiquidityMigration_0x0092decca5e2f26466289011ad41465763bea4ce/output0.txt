```solidity
/**
 * @title LiquidityMigration
 * @notice This contract allows users to stake, migrate, and refund liquidity tokens. It also supports creating new strategies.
 * @dev Inherits from Timelocked and StrategyTypes. Utilizes SafeERC20 for safe token transfers.
 */
contract LiquidityMigration is Timelocked, StrategyTypes {
    using SafeERC20 for IERC20;

    address public generic;
    address public controller;
    IStrategyProxyFactory public factory;

    mapping (address => bool) public adapters;
    mapping (address => uint256) public stakedCount;
    mapping (address => mapping (address => uint256)) public staked;
    mapping (address => bool) private _tempIsUnderlying;

    event Staked(address adapter, address strategy, uint256 amount, address account);
    event Migrated(address adapter, address lp, address strategy, address account);
    event Created(address adapter, address lp, address strategy, address account);
    event Refunded(address lp, uint256 amount, address account);

    /**
     * @notice Modifier to ensure the adapter is registered.
     * @dev Reverts if the adapter is not registered.
     */
    modifier onlyRegistered(address _adapter) {
        require(adapters[_adapter], "Claimable#onlyState: not registered adapter");
        _;
    }

    /**
     * @notice Modifier to ensure the adapter allows the specified LP token.
     * @dev Reverts if the LP token is not whitelisted by the adapter.
     */
    modifier onlyWhitelisted(address _adapter, address _lp) {
        require(IAdapter(_adapter).isWhitelisted(_lp), "Claimable#onlyState: not whitelisted strategy");
        _;
    }

    constructor(
        address[] memory adapters_,
        address generic_,
        IStrategyProxyFactory factory_,
        address controller_,
        uint256 _unlock,
        uint256 _modify,
        address _owner
    )
        Timelocked(_unlock, _modify, _owner)
    {
        for (uint256 i = 0; i < adapters_.length; i++) {
            adapters[adapters_[i]] = true;
        }
        generic = generic_;
        factory = factory_;
        controller = controller_;
    }

    /**
     * @notice Allows a user to stake a specified amount of an LP token.
     * @dev Transfers the LP tokens from the user to this contract and records the stake.
     * @param _lp The address of the LP token.
     * @param _amount The amount of the LP token to stake.
     * @param _adapter The address of the adapter.
     */
    function stake(
        address _lp,
        uint256 _amount,
        address _adapter
    )
        public
    {
        _stake(_lp, _amount, _adapter);
        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);
    }

    /**
     * @notice Allows a user to buy and stake an LP token using ETH.
     * @dev Buys the LP token with the provided ETH and stakes it.
     * @param _lp The address of the LP token.
     * @param _adapter The address of the adapter.
     * @param _exchange The address of the exchange.
     * @param _minAmountOut The minimum amount of LP tokens to receive.
     * @param _deadline The deadline for the transaction.
     */
    function buyAndStake(
        address _lp,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    )
        external
        payable
    {
        _buyAndStake(_lp, msg.value, _adapter, _exchange, _minAmountOut, _deadline);
    }

    /**
     * @notice Allows a user to batch stake multiple LP tokens.
     * @dev Validates the input arrays and calls the `stake` function for each LP token.
     * @param _lp The addresses of the LP tokens.
     * @param _amount The amounts of the LP tokens to stake.
     * @param _adapter The addresses of the adapters.
     */
    function batchStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter
    )
        external
    {
        require(_lp.length == _amount.length && _amount.length == _adapter.length, "LiquidityMigration: array length mismatch");
        
        for (uint256 i = 0; i < _lp.length; i++) {
            stake(_lp[i], _amount[i], _adapter[i]);
        }
    }

    /**
     * @notice Allows a user to batch buy and stake multiple LP tokens using ETH.
     * @dev Validates the input arrays, buys and stakes each LP token, and ensures the total ETH matches the sum of the amounts.
     * @param _lp The addresses of the LP tokens.
     * @param _amount The amounts of the LP tokens to buy and stake.
     * @param _adapter The addresses of the adapters.
     * @param _exchange The addresses of the exchanges.
     * @param _minAmountOut The minimum amounts of LP tokens to receive.
     * @param _deadline The deadline for the transactions.
     */
    function batchBuyAndStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter,
        address[] memory _exchange,
        uint256[] memory _minAmountOut,
        uint256 _deadline
    )
        external
        payable
    {
        require(
            _lp.length == _amount.length &&
            _amount.length == _adapter.length &&
            _adapter.length == _exchange.length &&
            _exchange.length == _minAmountOut.length,
            "LiquidityMigration: array length mismatch"
        );
        
        uint256 total = 0;
        for (uint256 i = 0; i < _lp.length; i++) {
            total += _amount[i];
        }
        require(total == msg.value, "LiquidityMigration: value mismatch");
        
        for (uint256 i = 0; i < _lp.length; i++) {
            _buyAndStake(_lp[i], _amount[i], _adapter[i], _exchange[i], _minAmountOut[i], _deadline);
        }
    }

    /**
     * @notice Allows a user to migrate their staked LP tokens to a new strategy.
     * @dev Transfers the staked LP tokens to the generic address and migrates them to the new strategy.
     * @param _lp The address of the LP token.
     * @param _adapter The address of the adapter.
     * @param _strategy The address of the new strategy.
     * @param _slippage The allowed slippage for the migration.
     */
    function migrate(
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyUnlocked
    {
        _migrate(msg.sender, _lp, _adapter, _strategy, _slippage);
    }

    /**
     * @notice Allows the owner to migrate another user's staked LP tokens to a new strategy.
     * @dev Transfers the staked LP tokens to the generic address and migrates them to the new strategy.
     * @param _user The address of the user.
     * @param _lp The address of the LP token.
     * @param _adapter The address of the adapter.
     * @param _strategy The address of the new strategy.
     * @param _slippage The allowed slippage for the migration.
     */
    function migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        _migrate(_user, _lp, _adapter, _strategy, _slippage);
    }

    /**
     * @notice Allows a user to batch migrate their staked LP tokens to new strategies.
     * @dev Validates the input arrays and calls the `migrate` function for each LP token.
     * @param _lp The addresses of the LP tokens.
     * @param _adapter The addresses of the adapters.
     * @param _strategy The addresses of the new strategies.
     * @param _slippage The allowed slippages for the migrations.
     */
    function batchMigrate(
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyUnlocked
    {
        require(
            _lp.length == _adapter.length &&
            _adapter.length == _strategy.length &&
            _strategy.length == _slippage.length,
            "LiquidityMigration: array length mismatch"
        );
        
        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(msg.sender, _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    /**
     * @notice Allows the owner to batch migrate other users' staked LP tokens to new strategies.
     * @dev Validates the input arrays and calls the `migrate` function for each LP token.
     * @param _user The addresses of the users.
     * @param _lp The addresses of the LP tokens.
     * @param _adapter The addresses of the adapters.
     * @param _strategy The addresses of the new strategies.
     * @param _slippage The allowed slippages for the migrations.
     */
    function batchMigrate(
        address[] memory _user,
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        require(
            _user.length == _lp.length &&
            _lp.length == _adapter.length &&
            _adapter.length == _strategy.length &&
            _strategy.length == _slippage.length,
            "LiquidityMigration: array length mismatch"
        );
        
        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(_user[i], _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    /**
     * @notice Allows the owner to refund a user's staked LP tokens.
     * @dev Transfers the staked LP tokens back to the user.
     * @param _user The address of the user.
     * @param _lp The address of the LP token.
     */
    function refund(
        address _user,
        address _lp
    )
        public
        onlyOwner
    {
        _refund(_user, _lp);
    }

    /**
     * @notice Allows the owner to batch refund multiple users' staked LP tokens.
     * @dev Calls the `refund` function for each user.
     * @param _users The addresses of the users.
     * @param _lp The address of the LP token.
     */
    function batchRefund(address[] memory _users, address _lp)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < _users.length; i++) {
            _refund(_users[i], _lp);
        }
    }

    /**
     * @notice Internal function to refund a user's staked LP tokens.
     * @dev Transfers the staked LP tokens back to the user and emits a `Refunded` event.
     * @param _user The address of the user.
     * @param _lp The address of the LP token.
     */
    function _refund(
        address _user,
        address _lp
    )
        internal
    {
        uint256 amount = staked[_user][_lp];
        require(amount > 0, "LiquidityMigration: no staked balance");
        
        staked[_user][_lp] = 0;
        IERC20(_lp).safeTransfer(_user, amount);
        
        emit Refunded(_lp, amount, _user);
    }

    /**
     * @dev Migrates user's staked liquidity from one pool to another.
     * @param _user Address of the user whose liquidity is being migrated
     * @param _lp Address of the liquidity pool being migrated from
     * @param _adapter Address of the adapter handling the migration
     * @param _strategy Address of the target strategy for migration
     * @param _slippage Maximum allowed slippage for the migration transaction
     * @dev Requirements:
     *   - Adapter must be registered
     *   - Adapter must be whitelisted for the LP
     *   - Strategy must be initialized in the controller
     *   - User must have staked balance in the LP
     * @dev Behavior:
     *   - Validates migration prerequisites
     *   - Transfers staked amount to generic handler
     *   - Encodes migration data and executes migration through controller
     *   - Calculates and transfers migrated amount to user
     *   - Emits Migrated event
     * @dev Notes:
     *   - Uses safe transfer for token movement
     *   - Implements slippage protection
     *   - Maintains atomic migration process
     */
    function _migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        require(IStrategyController(controller).initialized(address(_strategy)), "LiquidityMigration: not initialized");
        
        uint256 amount = staked[_user][_lp];
        require(amount > 0, "LiquidityMigration: no staked balance");
        
        staked[_user][_lp] = 0;
        IERC20(_lp).safeTransfer(generic, amount);
        
        IAdapter.Call[] memory calls = IAdapter(_adapter).encodeMigration(generic, address(_strategy), _lp, amount);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success,) = calls[i].target.call(calls[i].callData);
            require(success, "LiquidityMigration: migration failed");
        }
        
        uint256 balance = _strategy.balanceOf(address(this));
        require(balance > 0, "LiquidityMigration: no strategy tokens");
        
        _strategy.transfer(_user, balance);
        
        emit Migrated(_adapter, _lp, address(_strategy), _user);
    }

    /**
     * @notice Internal function to stake a specified amount of an LP token.
     * @dev Records the stake and increments the staked count for the adapter.
     * @param _lp The address of the LP token.
     * @param _amount The amount of the LP token to stake.
     * @param _adapter The address of the adapter.
     */
    function _stake(
        address _lp,
        uint256 _amount,
        address _adapter
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        require(_amount > 0, "LiquidityMigration: amount must be greater than 0");
        
        staked[msg.sender][_lp] += _amount;
        stakedCount[_adapter] += 1;
        
        emit Staked(_adapter, _lp, _amount, msg.sender);
    }

    /**
     * @notice Internal function to buy and stake an LP token using ETH.
     * @dev Buys the LP token with the provided ETH and stakes it.
     * @param _lp The address of the LP token.
     * @param _amount The amount of ETH to use for buying the LP token.
     * @param _adapter The address of the adapter.
     * @param _exchange The address of the exchange.
     * @param _minAmountOut The minimum amount of LP tokens to receive.
     * @param _deadline The deadline for the transaction.
     */
    function _buyAndStake(
        address _lp,
        uint256 _amount,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    )
        internal
    {
        require(_amount > 0, "LiquidityMigration: amount must be greater than 0");
        
        uint256 balanceBefore = IERC20(_lp).balanceOf(address(this));
        
        IAdapter(_adapter).buy{value: _amount}(_lp, _exchange, _minAmountOut, _deadline);
        
        uint256 balanceAfter = IERC20(_lp).balanceOf(address(this));
        uint256 received = balanceAfter - balanceBefore;
        
        require(received >= _minAmountOut, "LiquidityMigration: slippage exceeded");
        
        _stake(_lp, received, _adapter);
    }

    /**
     * @notice Allows a user to create a new strategy.
     * @dev Decodes the provided data, validates the strategy items, and creates the new strategy.
     * @param _lp The address of the LP token.
     * @param _adapter The address of the adapter.
     * @param data The encoded data for creating the strategy.
     */
    function createStrategy(
        address _lp,
        address _adapter,
        bytes calldata data
    )
        public
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        (
            string memory name,
            string memory symbol,
            StrategyItem[] memory strategyItems,
            InitialState memory strategyInit,
            bytes memory routerData
        ) = abi.decode(data, (string, string, StrategyItem[], InitialState, bytes));
        
        _validateItems(_adapter, _lp, strategyItems);
        
        address strategy = _createStrategy(abi.encode(name, symbol, strategyItems, strategyInit, routerData));
        
        emit Created(_adapter, _lp, strategy, msg.sender);
    }

    /**
     * @notice Allows the owner to update the controller address.
     * @dev Updates the controller address and ensures it is different from the current one.
     * @param _controller The new controller address.
     */
    function updateController(address _controller)
        external
        onlyOwner
    {
        require(_controller != controller, "LiquidityMigration: same controller");
        controller = _controller;
    }

    /**
     * @notice Allows the owner to update the generic address.
     * @dev Updates the generic address and ensures it is different from the current one.
     * @param _generic The new generic address.
     */
    function updateGeneric(address _generic)
        external
        onlyOwner
    {
        require(_generic != generic, "LiquidityMigration: same generic");
        generic = _generic;
    }

    /**
     * @notice Allows the owner to update the factory address.
     * @dev Updates the factory address and ensures it is different from the current one.
     * @param _factory The new factory address.
     */
    function updateFactory(address _factory)
        external
        onlyOwner
    {
        require(address(_factory) != address(factory), "LiquidityMigration: same factory");
        factory = IStrategyProxyFactory(_factory);
    }

    /**
     * @notice Allows the owner to add a new adapter.
     * @dev Adds the adapter and ensures it is not already registered.
     * @param _adapter The address of the new adapter.
     */
    function addAdapter(address _adapter)
        external
        onlyOwner
    {
        require(!adapters[_adapter], "LiquidityMigration: adapter already added");
        adapters[_adapter] = true;
    }

    /**
     * @notice Allows the owner to remove an existing adapter.
     * @dev Removes the adapter and ensures it is currently registered.
     * @param _adapter The address of the adapter to remove.
     */
    function removeAdapter(address _adapter)
        external
        onlyOwner
    {
        require(adapters[_adapter], "LiquidityMigration: adapter not registered");
        adapters[_adapter] = false;
    }

    /**
     * @notice Checks if a user has staked a specific LP token.
     * @dev Returns true if the user has staked the LP token, false otherwise.
     * @param _account The address of the user.
     * @param _lp The address of the LP token.
     * @return bool True if the user has staked the LP token, false otherwise.
     */
    function hasStaked(address _account, address _lp)
        external
        view
        returns(bool)
    {
        return staked[_account][_lp] > 0;
    }

    /**
     * @notice Gets the number of stakes for a specific adapter.
     * @dev Returns the staked count for the adapter.
     * @param _adapter The address of the adapter.
     * @return uint256 The number of stakes for the adapter.
     */
    function getStakeCount(address _adapter)
        external
        view
        returns(uint256)
    {
        return stakedCount[_adapter];
    }

    /**
     * @dev Validates the items in a strategy against the adapter's output tokens.
     * @param adapter Address of the adapter providing the token mapping
     * @param lp Address of the liquidity pool
     * @param strategyItems Array of strategy items to validate
     * @dev Behavior:
     *   1. Retrieves the adapter's output tokens for the LP
     *   2. Caches these tokens in a temporary mapping for validation
     *   3. Validates each strategy item:
     *      - Ignores reserve tokens with 0 percentage
     *      - Reverts if non-output tokens have non-zero percentage
     *      - Cleans up cached tokens after validation
     *   4. Ensures all output tokens are accounted for in the strategy
     * @dev Notes:
     *   - Uses a temporary mapping to track validation state
     *   - Allows reserve tokens (like WETH) with 0 percentage
     *   - Enforces strict validation of strategy composition
     * @dev Error Cases:
     *   - Reverts if non-output tokens are included with non-zero percentage
     *   - Reverts if output tokens are missing from the strategy
     */
    function _validateItems(address adapter, address lp, StrategyItem[] memory strategyItems) private {
        address[] memory outputTokens = IAdapter(adapter).outputTokens(lp);
        
        // Mark all output tokens in our temporary mapping
        for (uint256 i = 0; i < outputTokens.length; i++) {
            _tempIsUnderlying[outputTokens[i]] = true;
        }
        
        // Validate each item in the strategy
        for (uint256 i = 0; i < strategyItems.length; i++) {
            // Skip reserve tokens with 0 percentage
            if (strategyItems[i].percentage == 0 && strategyItems[i].item != address(0)) {
                continue;
            }
            
            // Ensure non-zero percentage items are output tokens
            require(
                _tempIsUnderlying[strategyItems[i].item] || strategyItems[i].percentage == 0,
                "LiquidityMigration: invalid strategy item"
            );
            
            // Mark this token as processed
            if (_tempIsUnderlying[strategyItems[i].item]) {
                _tempIsUnderlying[strategyItems[i].item] = false;
            }
        }
        
        // Ensure all output tokens are accounted for
        for (uint256 i = 0; i < outputTokens.length; i++) {
            require(!_tempIsUnderlying[outputTokens[i]], "LiquidityMigration: missing output token in strategy");
            // Clean up the mapping
            _tempIsUnderlying[outputTokens[i]] = false;
        }
    }

    /**
     * @notice Private function to create a new strategy.
     * @dev Decodes the provided data and creates the new strategy using the factory.
     * @param data The encoded data for creating the strategy.
     * @return address The address of the newly created strategy.
     */
    function _createStrategy(bytes memory data) private returns (address) {
        (
            string memory name,
            string memory symbol,
            StrategyItem[] memory strategyItems,
            InitialState memory strategyInit,
            bytes memory routerData
        ) = abi.decode(data, (string, string, StrategyItem[], InitialState, bytes));
        
        address strategy = factory.createStrategy(
            msg.sender,
            name,
            symbol,
            strategyItems,
            strategyInit,
            address(0),  // Router is not used in initial creation
            routerData
        );
        
        return strategy;
    }
}
```