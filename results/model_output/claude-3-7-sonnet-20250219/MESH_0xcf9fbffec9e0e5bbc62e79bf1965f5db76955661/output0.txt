I'll complete the MESH contract with all the required functionality based on the context provided.

```solidity
/**
 * @title MESH Token Contract
 * @notice This contract implements a custom token called MESH, which extends the StandardToken. It includes functionalities for proxy transfers and approvals, as well as token allocation.
 * @dev The contract also includes a nonce mechanism to prevent replay attacks and a fallback function that reverts any direct ETH transfers.
 */
contract MESH is StandardToken {

    /**
     * @notice Fallback function that reverts any direct ETH transfers to this contract.
     * @dev This function ensures that no ETH can be sent directly to the contract, preventing accidental or malicious deposits.
     */
    function () public {
        revert();
    }

    string public name = "MeshBox";                   //fancy name
    uint8 public decimals = 18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol = "MESH";                 //An identifier
    string public version = 'v0.1';       //MESH 0.1 standard. Just an arbitrary versioning scheme.
    uint256 public allocateEndTime;

    // The nonce for avoiding transfer replay attacks
    mapping(address => uint256) nonces;

    /**
     * @notice Initializes the contract and sets the allocation end time.
     * @dev The constructor sets the `allocateEndTime` to the current block timestamp plus one day.
     */
    constructor() public {
        allocateEndTime = now + 1 days;
    }

    /**
     * @notice Proxy transfer of MESH tokens. Allows a user to authorize an agent to broadcast the transaction, and the agent may charge a fee.
     * @param _from The address from which the tokens will be transferred.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to transfer.
     * @param _feeMesh The fee in MESH tokens that the agent will receive.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function allows a user to transfer tokens to a recipient and pay a proxy fee in a single operation. The transfer is authorized using a cryptographic signature to ensure only the owner of the tokens can initiate the transfer.
     */
    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeMesh,
        uint8 _v, bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool) {
        
        uint256 nonce = nonces[_from];
        bytes32 hash = keccak256(abi.encodePacked(address(this), "transferProxy", _from, _to, _value, _feeMesh, nonce));
        
        require(ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)), _v, _r, _s) == _from);
        
        nonces[_from] = nonce + 1;
        
        require(balances[_from] >= _value + _feeMesh);
        require(balances[_to] + _value >= balances[_to]);
        require(balances[msg.sender] + _feeMesh >= balances[msg.sender]);
        
        balances[_from] -= _value + _feeMesh;
        balances[_to] += _value;
        balances[msg.sender] += _feeMesh;
        
        emit Transfer(_from, _to, _value);
        emit Transfer(_from, msg.sender, _feeMesh);
        
        return true;
    }

    /**
     * @notice Proxy approve function. Allows a user to authorize an agent to broadcast the approval transaction, and the agent may charge a fee.
     * @param _from The address that owns the tokens.
     * @param _spender The address that will be allowed to spend the tokens.
     * @param _value The amount of tokens to approve.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function verifies the signature and sets the allowance for the spender.
     */
    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v, bytes32 _r, bytes32 _s) public returns (bool success) {
        
        uint256 nonce = nonces[_from];
        bytes32 hash = keccak256(abi.encodePacked(address(this), "approveProxy", _from, _spender, _value, nonce));
        
        require(ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)), _v, _r, _s) == _from);
        
        nonces[_from] = nonce + 1;
        allowed[_from][_spender] = _value;
        
        emit Approval(_from, _spender, _value);
        
        return true;
    }

    /**
     * @notice Retrieves the current nonce for a given address.
     * @param _addr The address to get the nonce for.
     * @return The current nonce for the specified address.
     * @dev Nonces are used to prevent replay attacks.
     */
    function getNonce(address _addr) public constant returns (uint256) {
        return nonces[_addr];
    }

    /**
     * @notice Allocates tokens to a list of addresses.
     * @param _owners The list of addresses to allocate tokens to.
     * @param _values The corresponding list of token amounts to allocate.
     * @dev This function can only be called by the contract owner and must be called before the `allocateEndTime`.
     */
    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {
        require(now <= allocateEndTime);
        require(_owners.length == _values.length);
        
        uint256 totalAllocated = 0;
        
        for (uint i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            uint256 value = _values[i];
            
            totalAllocated += value;
            balances[owner] += value;
            
            emit Transfer(address(0), owner, value);
        }
        
        totalSupply += totalAllocated;
    }
}
```

This implementation includes all the required functionality:

1. A fallback function that reverts ETH transfers
2. Token details (name, symbol, decimals, version)
3. Constructor that sets the allocation end time to 1 day after deployment
4. TransferProxy function for delegated transfers with fees
5. ApproveProxy function for delegated approvals
6. getNonce function to retrieve nonces for replay protection
7. allocateTokens function that can only be called by the owner before the allocation end time

The proxy functions use ECDSA signatures to verify that the owner of the tokens has authorized the transaction, and nonces are used to prevent replay attacks.