I'll implement the MESH token contract based on the provided context. Here's the complete implementation:

```solidity
/**
 * @title MESH Token Contract
 * @notice This contract implements a custom token called MESH, which extends the StandardToken. It includes functionalities for proxy transfers and approvals, as well as token allocation.
 * @dev The contract also includes a nonce mechanism to prevent replay attacks and a fallback function that reverts any direct ETH transfers.
 */
contract MESH is StandardToken {

    /**
     * @notice Fallback function that reverts any direct ETH transfers to this contract.
     * @dev This function ensures that no ETH can be sent directly to the contract, preventing accidental or malicious deposits.
     */
    function () public {
        revert();
    }

    string public name = "MeshBox";                   //fancy name
    uint8 public decimals = 18;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.
    string public symbol = "MESH";                 //An identifier
    string public version = 'v0.1';       //MESH 0.1 standard. Just an arbitrary versioning scheme.
    uint256 public allocateEndTime;

    // The nonce for avoiding transfer replay attacks
    mapping(address => uint256) nonces;

    /**
     * @notice Initializes the contract and sets the allocation end time.
     * @dev The constructor sets the `allocateEndTime` to the current block timestamp plus one day.
     */
    constructor() public {
        allocateEndTime = now + 1 days;
    }

    /**
     * @notice Proxy transfer of MESH tokens. Allows a user to authorize an agent to broadcast the transaction, and the agent may charge a fee.
     * @param _from The address from which the tokens will be transferred.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to transfer.
     * @param _feeMesh The fee in MESH tokens that the agent will receive.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function allows a user to transfer tokens to a recipient and pay a proxy fee in a single operation. The transfer is authorized using a cryptographic signature to ensure only the owner of the tokens can initiate the transfer.
     */
    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeMesh,
        uint8 _v, bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool) {
        
        // Prevent overflow
        require(_value + _feeMesh >= _value);
        
        // Calculate total amount to be transferred (tokens + fee)
        uint256 total = _value + _feeMesh;
        
        // Check balance is sufficient
        require(balances[_from] >= total);
        
        // Increment nonce to prevent replay attacks
        uint256 nonce = nonces[_from];
        nonces[_from] = nonce + 1;
        
        // Hash the required data for signature verification
        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _feeMesh, nonce));
        
        // Verify the signature
        require(_from == ecrecover(hash, _v, _r, _s));
        
        // Transfer tokens to recipient
        balances[_from] = balances[_from] - total;
        balances[_to] = balances[_to] + _value;
        
        // Transfer fee to the message sender (agent)
        balances[msg.sender] = balances[msg.sender] + _feeMesh;
        
        // Emit events
        emit Transfer(_from, _to, _value);
        emit Transfer(_from, msg.sender, _feeMesh);
        
        return true;
    }

    /**
     * @notice Proxy approve function. Allows a user to authorize an agent to broadcast the approval transaction, and the agent may charge a fee.
     * @param _from The address that owns the tokens.
     * @param _spender The address that will be allowed to spend the tokens.
     * @param _value The amount of tokens to approve.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function verifies the signature and sets the allowance for the spender.
     */
    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v, bytes32 _r, bytes32 _s) public returns (bool success) {
        
        // Increment nonce to prevent replay attacks
        uint256 nonce = nonces[_from];
        nonces[_from] = nonce + 1;
        
        // Hash the required data for signature verification
        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _spender, _value, nonce));
        
        // Verify the signature
        require(_from == ecrecover(hash, _v, _r, _s));
        
        // Set the allowance
        allowed[_from][_spender] = _value;
        
        // Emit approval event
        emit Approval(_from, _spender, _value);
        
        return true;
    }

    /**
     * @notice Retrieves the current nonce for a given address.
     * @param _addr The address to get the nonce for.
     * @return The current nonce for the specified address.
     * @dev Nonces are used to prevent replay attacks.
     */
    function getNonce(address _addr) public constant returns (uint256) {
        return nonces[_addr];
    }

    /**
     * @notice Allocates tokens to a list of addresses.
     * @param _owners The list of addresses to allocate tokens to.
     * @param _values The corresponding list of token amounts to allocate.
     * @dev This function can only be called by the contract owner and must be called before the `allocateEndTime`.
     */
    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {
        // Check that allocation period hasn't ended
        require(now <= allocateEndTime);
        
        // Check that arrays have the same length
        require(_owners.length == _values.length);
        
        uint256 totalAllocation = 0;
        
        // Calculate total allocation amount
        for(uint i = 0; i < _values.length; i++) {
            totalAllocation += _values[i];
        }
        
        // Update total supply
        totalSupply += totalAllocation;
        
        // Allocate tokens to each address
        for(uint j = 0; j < _owners.length; j++) {
            balances[_owners[j]] += _values[j];
            emit Transfer(0x0, _owners[j], _values[j]);
        }
    }
}
```

This implementation includes:

1. A fallback function that reverts any direct ETH transfers
2. Token details (name, symbol, decimals, version)
3. A constructor that sets the allocation end time
4. A nonce mapping to prevent replay attacks
5. The `transferProxy` function that verifies signatures and allows an agent to broadcast transactions
6. The `approveProxy` function that verifies signatures for approvals
7. The `getNonce` function to get the current nonce for an address
8. The `allocateTokens` function that allows the owner to allocate tokens to multiple addresses during the allocation period

The contract follows the provided structure and maintains the security considerations like replay attack prevention and proper access control.