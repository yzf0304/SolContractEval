Here's the completed MonethaBuyer contract with all required functionality implemented:

```solidity
/**
 * @title MonethaBuyer
 * @notice A smart contract for managing ETH deposits, purchasing tokens in a crowdsale, and handling withdrawals.
 * @dev This contract includes features like bounties for executing buy and withdrawal actions, an emergency kill switch,
 *      and the ability to set the crowdsale and token addresses. It ensures that funds are only used for their intended purpose
 *      and provides mechanisms for users to withdraw their ETH or tokens.
 */
contract MonethaBuyer {
  // Store the amount of ETH deposited by each account.
  mapping (address => uint256) public balances;
  // Bounty for executing buy.
  uint256 public buy_bounty;
  // Bounty for executing withdrawals.
  uint256 public withdraw_bounty;
  // Track whether the contract has bought the tokens yet.
  bool public bought_tokens;
  // Record ETH value of tokens currently held by contract.
  uint256 public contract_eth_value;
  // Emergency kill switch in case a critical bug is found.
  bool public kill_switch;
  
  // SHA3 hash of kill switch password.
  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;
  // Earliest time contract is allowed to buy into the crowdsale.
  uint256 public earliest_buy_time = 1504188000;
  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.
  uint256 public eth_cap = 30000 ether;
  // The developer address.
  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  // The crowdsale address.  Settable by the developer.
  address public sale;
  // The token address.  Settable by the developer.
  ERC20 public token;

  /**
   * @notice Allows the developer to set the crowdsale and token addresses.
   * @dev Only the developer can set the addresses, and it can only be done once.
   * @param _sale The address of the crowdsale.
   * @param _token The address of the token.
   */
  function set_addresses(address _sale, address _token) {
    require(msg.sender == developer);
    require(sale == address(0));
    require(_sale != address(0));
    require(_token != address(0));
    sale = _sale;
    token = ERC20(_token);
  }

  /**
   * @notice Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. Send the caller their bounty for activating the kill switch.
   * @dev Activates the kill switch, which prevents further buys and sets the bounty to zero.
   * @param password The password to activate the kill switch.
   */
  function activate_kill_switch(string memory password) {
    // Only the developer or someone with the password can activate the kill switch
    require(msg.sender == developer || sha3(password) == password_hash);
    // Activate the kill switch
    kill_switch = true;
    // Send the caller their bounty
    if (buy_bounty > 0) {
      uint256 bounty = buy_bounty;
      buy_bounty = 0;
      msg.sender.transfer(bounty);
    }
  }

  /**
    * @dev Allows the caller to withdraw all ETH or tokens deposited by a specified user, 
    *      with appropriate reward distribution and safety checks.
    * This function handles two scenarios:
    * 1. If tokens haven't been purchased yet (or purchase window hasn't passed), 
    *    it refunds the user's deposited ETH.
    * 2. If tokens have been successfully purchased, it distributes the user's proportional 
    *    share of tokens with a 1% developer fee and updates contract state.
    * The caller receives a 1% bounty for initiating the withdrawal on behalf of the user.
    * @param user The address of the user whose funds/tokens are being withdrawn.
    * @notice The function includes gas optimization techniques:
    *         - Early return if user has no balance
    *         - State updates before external calls to prevent reentrancy
    *         - Temporary variables for intermediate calculations
    */
  function withdraw(address user) {
    // If the user has no balance, there's nothing to withdraw
    uint256 bal = balances[user];
    if (bal == 0) return;

    // If the tokens have been bought, calculate the user's share and fees
    if (bought_tokens) {
      // Update the user's balance before making external calls
      balances[user] = 0;

      // Calculate the user's token share
      uint256 token_amount = bal * token.balanceOf(this) / contract_eth_value;
      
      // Calculate fees (1% each for developer and withdrawal initiator)
      uint256 fee = token_amount / 100;
      uint256 developer_fee = fee;
      uint256 caller_fee = fee;
      uint256 user_token_amount = token_amount - developer_fee - caller_fee;
      
      // Send tokens to user, developer, and caller
      require(token.transfer(user, user_token_amount));
      require(token.transfer(developer, developer_fee));
      require(token.transfer(msg.sender, caller_fee));
    } else {
      // Tokens haven't been bought, return the user's ETH
      // Update the user's balance before making external calls
      balances[user] = 0;
      
      // Calculate and update the withdraw bounty
      uint256 fee = bal / 100;
      uint256 withdrawal_amount = bal - fee;
      
      // If there's not enough in the withdrawal bounty, take what's available
      if (fee > withdraw_bounty) {
        fee = withdraw_bounty;
      }
      
      // Update the withdraw bounty
      withdraw_bounty -= fee;
      
      // Send ETH to user and caller
      user.transfer(withdrawal_amount);
      if (fee > 0) {
        msg.sender.transfer(fee);
      }
    }
  }

  /**
   * @notice Allows the developer to add ETH to the buy execution bounty.
   * @dev Only the developer can contribute to the buy bounty.
   */
  function add_to_buy_bounty() payable {
    require(msg.sender == developer);
    buy_bounty += msg.value;
  }

  /**
   * @notice Allows the developer to add ETH to the withdraw execution bounty.
   * @dev Only the developer can contribute to the withdraw bounty.
   */
  function add_to_withdraw_bounty() payable {
    require(msg.sender == developer);
    withdraw_bounty += msg.value;
  }

  /**
    * @dev Claims the contract's token purchase bounty by executing the initial token purchase.
    * This function:
    * 1. Verifies preconditions (tokens not yet purchased, time window valid, kill switch inactive)
    * 2. Sets the purchase flag
    * 3. Transfers ETH to the crowdsale contract
    * 4. Distributes the claimed bounty to the caller
    * 
    * @notice Includes gas optimizations through early returns and state updates before external calls.
    */
  function claim_bounty() {
    // Check if the contract can buy tokens
    require(!bought_tokens);
    require(!kill_switch);
    require(sale != address(0));
    require(now >= earliest_buy_time);
    
    // Update state before external calls
    bought_tokens = true;
    contract_eth_value = this.balance - buy_bounty;
    
    // Calculate and distribute the bounty
    uint256 bounty = buy_bounty;
    buy_bounty = 0;
    
    // Send funds to the crowdsale contract
    uint256 contract_eth_for_sale = contract_eth_value;
    bool transfer_succeeded = sale.call.value(contract_eth_for_sale)();
    require(transfer_succeeded);
    
    // Send the bounty to the caller
    if (bounty > 0) {
      msg.sender.transfer(bounty);
    }
  }

  /**
   * @notice Default function. Called when a user sends ETH to the contract.
   * @dev Ensures the contract has not already purchased the tokens and that the ETH cap is not exceeded.
   */
  function () payable {
    require(!kill_switch);
    require(!bought_tokens);
    require(this.balance < eth_cap);
    balances[msg.sender] += msg.value;
  }
}
```