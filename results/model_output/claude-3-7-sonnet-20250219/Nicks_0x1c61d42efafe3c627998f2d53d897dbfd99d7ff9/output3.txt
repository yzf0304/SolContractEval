I'll complete the Nicks contract according to the specifications provided. Note that for Solidity 0.4.20, the `receive()` function isn't available - we'll need to use the fallback function instead.

```solidity
/**
 * @title Nicks
 * @notice A contract that allows users to set and unset unique nicknames. Each nickname is linked to a single Ethereum address.
 * @dev The contract ensures that each nickname is unique and can only be owned by one address at a time.
 */
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set (string indexed _nick, address indexed _owner);
  event Unset (string indexed _nick, address indexed _owner);

  /**
   * @notice Initializes the contract.
   * @dev The constructor does not perform any specific initialization in this contract.
   */
  function Nicks () public {
    // empty
  }

  /**
   * @notice Retrieves the nickname associated with a given address.
   * @param _owner The Ethereum address of the user.
   * @return _nick The nickname associated with the address.
   * @dev If the address has no nickname, an empty string will be returned.
   */
  function nickOf (address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  /**
   * @notice Retrieves the address associated with a given nickname.
   * @param _nick The nickname to look up.
   * @return _owner The Ethereum address associated with the nickname.
   * @dev If the nickname is not set, the zero address will be returned.
   */
  function ownerOf (string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  /**
   * @notice Sets a new nickname for the sender's address.
   * @param _nick The new nickname to set.
   * @dev The nickname must be more than 2 characters long and must not already be in use.
   *      If the sender already has a nickname, it will be unset before setting the new one.
   *      Emits a `Set` event on successful nickname assignment.
   */
  function set (string _nick) public {
    // Check nickname length (must be more than 2 characters)
    require(bytes(_nick).length > 2);
    
    // Check nickname is not already in use
    require(ownerOfNick[_nick] == address(0));
    
    // If sender already has a nickname, unset it
    if (bytes(nickOfOwner[msg.sender]).length > 0) {
        string memory oldNick = nickOfOwner[msg.sender];
        ownerOfNick[oldNick] = address(0);
    }
    
    // Set the new nickname
    nickOfOwner[msg.sender] = _nick;
    ownerOfNick[_nick] = msg.sender;
    
    // Emit event
    Set(_nick, msg.sender);
  }

  /**
   * @notice Unsets the current nickname for the sender's address.
   * @dev The sender must have a nickname set to call this function.
   *      Emits an `Unset` event on successful unsetting of the nickname.
   */
  function unset () public {
    // Check that sender has a nickname
    string memory nick = nickOfOwner[msg.sender];
    require(bytes(nick).length > 0);
    
    // Unset the nickname
    ownerOfNick[nick] = address(0);
    nickOfOwner[msg.sender] = "";
    
    // Emit event
    Unset(nick, msg.sender);
  }

  /**
   * @notice Fallback function to handle receiving Ether.
   * @dev This function is left empty as the contract does not handle Ether.
   */
  function () public payable {
    // Empty fallback function for Solidity 0.4.20
  }
}
```

Note that I've made the following changes from the template:
1. Implemented the `nickOf` and `ownerOf` functions to return data from the respective mappings
2. Implemented the `set` function with the required checks and updates
3. Implemented the `unset` function with the required checks and updates
4. Changed the `receive()` function to a standard fallback function (`function () public payable`) as that's what was available in Solidity 0.4.20