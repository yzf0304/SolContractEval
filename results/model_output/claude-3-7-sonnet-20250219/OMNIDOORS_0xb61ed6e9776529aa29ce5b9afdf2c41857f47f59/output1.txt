I'll implement the OMNIDOORS contract according to the requirements and provided context:

```solidity
/**
 * @title OMNIDOORS
 * @notice This contract is an ERC721 token that allows minting, burning, and traversing NFTs across different chains using LayerZero.
 * @dev The contract uses the Ownable, ERC721, and NonblockingReceiver patterns. It also includes functionality for setting base URI, donating, and withdrawing funds.
 */
contract OMNIDOORS is Ownable, ERC721, NonblockingReceiver {
    address public _owner;
    string private baseURI;
    uint256 nextTokenId = 5900;
    uint256 MAX_NETWORK_MINT = 9300;

    uint256 gasForDestinationLzReceive = 350000;

    /**
     * @notice Initializes the contract with the provided base URI and LayerZero endpoint.
     * @dev Mints 330 tokens to the contract owner upon deployment.
     * @param baseURI_ The base URI for the NFTs.
     * @param _layerZeroEndpoint The LayerZero endpoint address.
     */
    constructor(string memory baseURI_, address _layerZeroEndpoint)
        ERC721("Omni Doors", "odoors")
    {
        _owner = msg.sender;
        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);
        baseURI = baseURI_;
        for (uint256 i = 0; i < 330; i++) {
            _safeMint(_owner, ++nextTokenId);
        }
    }

    /**
     * @notice Allows users to mint up to one NFT per transaction.
     * @dev Checks if the number of tokens to mint does not exceed the maximum allowed per transaction and the total supply limit.
     * @param numTokens The number of tokens to mint (must be 1).
     */
    function mint(uint8 numTokens) external payable {
        require(numTokens == 1, "Can only mint 1 token at a time");
        require(nextTokenId < MAX_NETWORK_MINT, "Max supply reached");
        
        uint256 tokenId = ++nextTokenId;
        _safeMint(msg.sender, tokenId);
    }

    /**
     * @dev Transfers an NFT to another chain via LayerZero.
     * Requirements:
     * - Caller must be the NFT owner
     * - Destination chain must be available in trustedRemoteLookup
     * Process:
     * 1. Verifies ownership and chain availability
     * 2. Burns the NFT on source chain
     * 3. Prepares payload with sender and token ID
     * 4. Sets adapter parameters for gas requirements
     * 5. Estimates message fees (refundable excess)
     * 6. Sends cross-chain message with payment
     * @param _chainId Destination chain ID
     * @param tokenId ID of the NFT to transfer
     * @return None (void function)
     * @notice Emits Transfer event when burning the NFT
     * @dev
     * - Uses LayerZero endpoint for cross-chain messaging
     * - msg.value covers message delivery fees
     * - Refunds unused gas sent with msg.value
     * - Requires trustedRemoteLookup[_chainId] to be set
     */
    function traverseChains(uint16 _chainId, uint256 tokenId) public payable {
        require(ownerOf(tokenId) == msg.sender, "You don't own this NFT");
        require(trustedRemoteLookup[_chainId].length > 0, "Destination chain not available");
        
        // Burn the NFT on this chain
        _burn(tokenId);
        
        // Encode payload with sender and tokenId
        bytes memory payload = abi.encode(msg.sender, tokenId);
        
        // Configure gas for destination
        bytes memory adapterParams = abi.encodePacked(uint16(1), gasForDestinationLzReceive);
        
        // Estimate fee and send message
        (uint256 messageFee, ) = endpoint.estimateFees(
            _chainId,
            address(this),
            payload,
            false,
            adapterParams
        );
        
        require(msg.value >= messageFee, "Not enough value to cover message fee");
        
        // Send message to destination chain
        _lzSend(
            _chainId, 
            payload, 
            payable(msg.sender), 
            address(0x0), 
            adapterParams
        );
        
        // Refund excess value
        if (msg.value > messageFee) {
            payable(msg.sender).transfer(msg.value - messageFee);
        }
    }

    /**
     * @notice Allows the contract owner to set the base URI for the NFTs.
     * @dev Only the contract owner can call this function.
     * @param URI The new base URI.
     */
    function setBaseURI(string memory URI) external onlyOwner {
        baseURI = URI;
    }

    /**
     * @notice Allows anyone to donate ETH to the contract.
     * @dev This function is payable and can receive ETH.
     */
    function donate() external payable {
        // Nothing to do here, just receive the funds
    }

    /**
     * @notice Allows the contract owner to withdraw a specified amount of ETH from the contract.
     * @dev Only the contract owner can call this function.
     * @param amt The amount of ETH to withdraw.
     */
    function withdraw(uint256 amt) external onlyOwner {
        require(address(this).balance >= amt, "Insufficient balance");
        payable(_owner).transfer(amt);
    }

    /**
     * @notice Allows the contract owner to set the gas for the destination LayerZero receive function.
     * @dev Only the contract owner can call this function.
     * @param newVal The new gas value.
     */
    function setGasForDestinationLzReceive(uint256 newVal) external onlyOwner {
        gasForDestinationLzReceive = newVal;
    }

    /**
     * @notice Internal function to handle LayerZero messages.
     * @dev Decodes the payload and mints the NFT on the destination chain.
     * @param _srcChainId The source chain ID.
     * @param _srcAddress The source address.
     * @param _nonce The nonce of the message.
     * @param _payload The encoded payload.
     */
    function _LzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        // Decode payload
        (address toAddr, uint256 tokenId) = abi.decode(_payload, (address, uint256));
        
        // Mint the NFT to the original owner on the destination chain
        _safeMint(toAddr, tokenId);
    }

    /**
     * @notice Returns the base URI for the NFTs.
     * @dev Overrides the _baseURI function from ERC721.
     * @return The base URI.
     */
    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }
}
```

This implementation includes all the required functionality:
1. Constructor initializes the contract and mints 330 tokens to the owner
2. Mint function allows users to mint one token per transaction
3. TraverseChains function enables cross-chain NFT transfers using LayerZero
4. SetBaseURI function allows the owner to update the base URI
5. Donate function allows anyone to donate ETH
6. Withdraw function allows the owner to withdraw ETH
7. SetGasForDestinationLzReceive function allows the owner to adjust gas parameters
8. _LzReceive function handles incoming cross-chain messages
9. _baseURI function returns the base URI for token metadata

The contract follows the LayerZero cross-chain messaging pattern and implements proper ownership validation and security checks.