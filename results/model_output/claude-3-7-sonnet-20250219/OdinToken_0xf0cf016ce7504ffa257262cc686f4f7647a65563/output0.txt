I'll complete the OdinToken contract according to the provided context and description. Here's the implementation:

```solidity
/**
 * @notice OdinToken is an ERC20 token with additional features such as airdrop restrictions and owner-controlled whitelisting.
 * @dev This contract extends the ERC20Interface and Owned contracts, providing basic token functionality along with specific rules for airdropped tokens and whitelisting.
 */
contract OdinToken is ERC20Interface, Owned {

  using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint private _totalSupply;
    bool private _whitelistAll;

    struct balanceData {  
       bool locked;
       uint balance;
       uint airDropQty;
    }

    mapping(address => balanceData) balances;
    mapping(address => mapping(address => uint)) allowed;

  /**
  * @dev Constructor for Odin creation
  * @dev Initially assigns the totalSupply to the contract creator
  */
    function OdinToken() public {
        
        // owner of this contract
        owner = msg.sender;
        symbol = "ODIN";
        name = "ODIN Token";
        decimals = 18;
        _whitelistAll=false;
        _totalSupply = 100000000000000000000000;
        balances[owner].balance = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

  /**
  * @notice Returns the total supply of the token.
  * @return The total supply of the token.
  * @dev This function returns the total number of tokens in circulation.
  */
    function totalSupply() constant public returns (uint256 totalSupply) {
        return _totalSupply;
    }

  /**
  * @notice Whitelist an address to allow it to receive airdrops.
  * @param to The address to whitelist.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the airdrop quantity for the specified address to 0, effectively whitelisting it.
  */
    function whitelistAddress(address to) onlyOwner public returns (bool) {
        balances[to].airDropQty = 0;
        return true;
    }

  /**
  * @notice Whitelist all addresses early.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the `_whitelistAll` flag to true, allowing all addresses to be whitelisted.
  */
    function whitelistAllAddresses() onlyOwner public returns (bool) {
        _whitelistAll = true;
        return true;
    }

  /**
  * @notice Gets the balance of the specified address.
  * @param tokenOwner The address to query the balance of.
  * @return The amount owned by the passed address.
  * @dev This function returns the balance of the specified address.
  */
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner].balance;
    }

  /**
    * @dev Transfers tokens from sender to recipient with transfer restrictions.
    * 
    * Restrictions:
    * - Cannot send to self or address(0)
    * - Sender must have sufficient balance
    * - Air-dropped tokens have time-based transfer limits (if whitelistAll=false):
    *   - Before Sep 1 2018: Cannot transfer any air-dropped tokens
    *   - Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens
    *   - Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens
    *   - Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens
    *   - Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens
    *   - After Jun 30 2019: No restrictions
    * 
    * @param to Recipient address (cannot be zero address)
    * @param tokens Amount to transfer (must be â‰¤ sender's balance)
    * @return success Always returns true if transfer succeeds
    * 
    * @notice Emits Transfer event
    * @dev AirDropQty tracks air-dropped tokens for each account
    *      Owner transfers bypass air-drop restrictions
    */
    function transfer(address to, uint tokens) public returns (bool success) {
        require(to != address(0));
        require(to != msg.sender);
        require(tokens <= balances[msg.sender].balance);
        
        // Owner can transfer without restrictions
        if (msg.sender != owner && !_whitelistAll) {
            uint airDropTokens = balances[msg.sender].airDropQty;
            
            if (airDropTokens > 0) {
                uint now_ts = now;
                uint maxTransfer = 0;
                
                // Before Sep 1 2018: Cannot transfer any air-dropped tokens
                if (now_ts < 1535760000) { // Sep 1 2018 00:00:00 GMT
                    maxTransfer = 0;
                }
                // Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens
                else if (now_ts < 1538352000) { // Oct 1 2018 00:00:00 GMT
                    maxTransfer = airDropTokens.mul(10).div(100);
                }
                // Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens
                else if (now_ts < 1546300800) { // Jan 1 2019 00:00:00 GMT
                    maxTransfer = airDropTokens.mul(25).div(100);
                }
                // Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens
                else if (now_ts < 1554076800) { // Apr 1 2019 00:00:00 GMT
                    maxTransfer = airDropTokens.mul(50).div(100);
                }
                // Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens
                else if (now_ts < 1561939200) { // Jul 1 2019 00:00:00 GMT
                    maxTransfer = airDropTokens.mul(75).div(100);
                }
                // After Jun 30 2019: No restrictions
                else {
                    maxTransfer = airDropTokens;
                }
                
                // Ensure transfer doesn't exceed maximum allowed for airdropped tokens
                require(tokens <= maxTransfer);
            }
        }
        
        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

  /**
  * @notice Approve the spender to spend a specified amount of tokens.
  * @param spender The address that will spend the tokens.
  * @param tokens The amount of tokens to approve.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

  /**
  * @notice Transfer tokens from one address to another, using the allowance mechanism.
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param tokens The amount to be transferred.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(to != address(0));
        require(to != from);
        require(tokens <= balances[from].balance);
        require(tokens <= allowed[from][msg.sender]);
        
        balances[from].balance = balances[from].balance.sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        
        emit Transfer(from, to, tokens);
        return true;
    }

  /**
  * @notice Get the remaining number of tokens that `spender` is allowed to spend on behalf of `tokenOwner`.
  * @param tokenOwner The address that owns the tokens.
  * @param spender The address that will spend the tokens.
  * @return The remaining allowance.
  * @dev This function is not implemented in this contract.
  */
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

  /**
  * @notice Approve the spender to spend a specified amount of tokens and call a contract.
  * @param spender The address that will spend the tokens.
  * @param tokens The amount of tokens to approve.
  * @param data Extra data to send to the approved contract.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        // This function is not fully implemented as per the comments
        return true;
    }

  /**
  * @notice Burn a specified amount of tokens from the owner's balance.
  * @param tokens The amount of tokens to burn.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function burns a specified amount of tokens from the owner's balance, reducing the total supply.
  */
    function burn(uint256 tokens) onlyOwner public returns (bool) {
        require(tokens <= balances[owner].balance);
        
        balances[owner].balance = balances[owner].balance.sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        
        emit Burn(tokens);
        return true;
    }

    function () {
        //if ether is sent to this address, send it back.
        throw;
    }
}
```

This implementation follows the provided context and description, including:
1. ERC20 standard functionality
2. Airdrop restrictions with time-based transfer limits
3. Owner-controlled whitelisting
4. Burn functionality
5. All the required functions as specified in the comments

The contract uses SafeMath for arithmetic operations to prevent overflows and underflows, and implements the required events for ERC20 compliance.