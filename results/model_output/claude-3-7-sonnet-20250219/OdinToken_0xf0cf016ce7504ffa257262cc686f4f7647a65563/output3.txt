I'll complete the OdinToken contract with all the missing function implementations based on the provided context and descriptions.

```solidity
/**
 * @notice OdinToken is an ERC20 token with additional features such as airdrop restrictions and owner-controlled whitelisting.
 * @dev This contract extends the ERC20Interface and Owned contracts, providing basic token functionality along with specific rules for airdropped tokens and whitelisting.
 */
contract OdinToken is ERC20Interface, Owned {

  using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint private _totalSupply;
    bool private _whitelistAll;

    struct balanceData {  
       bool locked;
       uint balance;
       uint airDropQty;
    }

    mapping(address => balanceData) balances;
    mapping(address => mapping(address => uint)) allowed;

  /**
  * @dev Constructor for Odin creation
  * @dev Initially assigns the totalSupply to the contract creator
  */
    function OdinToken() public {
        
        // owner of this contract
        owner = msg.sender;
        symbol = "ODIN";
        name = "ODIN Token";
        decimals = 18;
        _whitelistAll=false;
        _totalSupply = 100000000000000000000000;
        balances[owner].balance = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

  /**
  * @notice Returns the total supply of the token.
  * @return The total supply of the token.
  * @dev This function returns the total number of tokens in circulation.
  */
    function totalSupply() constant public returns (uint256 totalSupply) {
        return _totalSupply;
    }

  /**
  * @notice Whitelist an address to allow it to receive airdrops.
  * @param to The address to whitelist.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the airdrop quantity for the specified address to 0, effectively whitelisting it.
  */
    function whitelistAddress(address to) onlyOwner public returns (bool) {
        balances[to].airDropQty = 0;
        return true;
    }

  /**
  * @notice Whitelist all addresses early.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the `_whitelistAll` flag to true, allowing all addresses to be whitelisted.
  */
    function whitelistAllAddresses() onlyOwner public returns (bool) {
        _whitelistAll = true;
        return true;
    }

  /**
  * @notice Gets the balance of the specified address.
  * @param tokenOwner The address to query the balance of.
  * @return The amount owned by the passed address.
  * @dev This function returns the balance of the specified address.
  */
    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner].balance;
    }

  /**
    * @dev Transfers tokens from sender to recipient with transfer restrictions.
    * 
    * Restrictions:
    * - Cannot send to self or address(0)
    * - Sender must have sufficient balance
    * - Air-dropped tokens have time-based transfer limits (if whitelistAll=false):
    *   - Before Sep 1 2018: Cannot transfer any air-dropped tokens
    *   - Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens
    *   - Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens
    *   - Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens
    *   - Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens
    *   - After Jun 30 2019: No restrictions
    * 
    * @param to Recipient address (cannot be zero address)
    * @param tokens Amount to transfer (must be â‰¤ sender's balance)
    * @return success Always returns true if transfer succeeds
    * 
    * @notice Emits Transfer event
    * @dev AirDropQty tracks air-dropped tokens for each account
    *      Owner transfers bypass air-drop restrictions
    */
    function transfer(address to, uint tokens) public returns (bool success) {
        // Cannot send to self or 0 address
        require(to != msg.sender && to != address(0));
        
        // Check if sender has enough balance
        require(balances[msg.sender].balance >= tokens);
        
        // If the sender is the owner, or whitelistAll is true, or no airdrop tokens, transfer without restriction
        if (msg.sender == owner || _whitelistAll || balances[msg.sender].airDropQty == 0) {
            balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
            balances[to].balance = balances[to].balance.add(tokens);
            emit Transfer(msg.sender, to, tokens);
            return true;
        }
        
        // Get current timestamp to check time-based restrictions
        uint256 currentTime = now;
        
        // Sep 1 2018: 1535760000
        // Oct 1 2018: 1538352000
        // Jan 1 2019: 1546300800
        // Apr 1 2019: 1554076800
        // Jul 1 2019: 1561939200
        
        uint256 maxTransfer;
        
        // Before Sep 1 2018: Cannot transfer any air-dropped tokens
        if (currentTime < 1535760000) {
            maxTransfer = 0;
        }
        // Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens
        else if (currentTime < 1538352000) {
            maxTransfer = balances[msg.sender].airDropQty.mul(10).div(100);
        }
        // Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens
        else if (currentTime < 1546300800) {
            maxTransfer = balances[msg.sender].airDropQty.mul(25).div(100);
        }
        // Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens
        else if (currentTime < 1554076800) {
            maxTransfer = balances[msg.sender].airDropQty.mul(50).div(100);
        }
        // Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens
        else if (currentTime < 1561939200) {
            maxTransfer = balances[msg.sender].airDropQty.mul(75).div(100);
        }
        // After Jun 30 2019: No restrictions
        else {
            maxTransfer = balances[msg.sender].balance;
        }
        
        // Calculate available tokens (total balance minus restricted airdropped tokens)
        uint256 availableTokens = balances[msg.sender].balance.sub(balances[msg.sender].airDropQty.sub(maxTransfer));
        
        // Check if transfer amount is within available tokens
        require(tokens <= availableTokens);
        
        // Perform the transfer
        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

  /**
  * @notice Approve the spender to spend a specified amount of tokens.
  * @param spender The address that will spend the tokens.
  * @param tokens The amount of tokens to approve.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

  /**
  * @notice Transfer tokens from one address to another, using the allowance mechanism.
  * @param from The address to transfer from.
  * @param to The address to transfer to.
  * @param tokens The amount to be transferred.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(to != address(0));
        require(tokens <= balances[from].balance);
        require(tokens <= allowed[from][msg.sender]);
        
        balances[from].balance = balances[from].balance.sub(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

  /**
  * @notice Get the remaining number of tokens that `spender` is allowed to spend on behalf of `tokenOwner`.
  * @param tokenOwner The address that owns the tokens.
  * @param spender The address that will spend the tokens.
  * @return The remaining allowance.
  * @dev This function is not implemented in this contract.
  */
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

  /**
  * @notice Approve the spender to spend a specified amount of tokens and call a contract.
  * @param spender The address that will spend the tokens.
  * @param tokens The amount of tokens to approve.
  * @param data Extra data to send to the approved contract.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function is not implemented in this contract.
  */
    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        
        // Call the spender contract's receiveApproval function
        // This is a standard pattern but requires the spender contract to implement this function
        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);
        return true;
    }

  /**
  * @notice Burn a specified amount of tokens from the owner's balance.
  * @param tokens The amount of tokens to burn.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function burns a specified amount of tokens from the owner's balance, reducing the total supply.
  */
    function burn(uint256 tokens) onlyOwner public returns (bool) {
        require(tokens <= balances[owner].balance);
        
        balances[owner].balance = balances[owner].balance.sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        emit Burn(tokens);
        return true;
    }

    function ()  {
        //if ether is sent to this address, send it back.
        throw;
    }
}

// Interface for the approveAndCall functionality
contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}
```

Note: I've implemented all the missing functions according to the provided context and descriptions. The implementation includes proper token transfer mechanics with airdrop restrictions based on time, whitelist functionality, and standard ERC20 functionality. I've also added an ApproveAndCallFallBack interface to support the approveAndCall function.