I'll implement the Okimi NFT contract according to the provided context, focusing on completing the missing function implementations while maintaining the contract structure.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/**
 * @title Okimi NFT Contract
 * @notice This contract implements an ERC721A NFT collection with a public sale mechanism, minting limits, and owner controls.
 * @dev Inherits from Ownable, ERC721A, and ReentrancyGuard to provide ownership, NFT, and reentrancy protection functionalities.
 */
contract Okimi is Ownable, ERC721A, ReentrancyGuard {
  uint256 public immutable maxPerAddressDuringMint;
  uint256 public immutable amountForDevs;
  uint256 public immutable amountForSaleAndDev;
  uint256 internal immutable collectionSize;
  uint256 internal immutable maxBatchSize;

  struct SaleConfig {
    uint32 publicSaleStartTime;
    uint64 publicPriceWei;
  }

  SaleConfig public saleConfig;
  string private _baseTokenURI;

  /**
   * @notice Initializes the contract with default values for the NFT collection.
   * @dev Sets the maximum per address during mint, batch size, collection size, and initial sale configuration.
   */
  constructor()
  ERC721A("Okimi", "OKM")
  {
    maxPerAddressDuringMint = 5;
    maxBatchSize = 5;
    collectionSize = amountForDevs = amountForSaleAndDev = 1500;
    saleConfig.publicPriceWei = 5 ether / 1000;  // 0.005 ETH
    saleConfig.publicSaleStartTime = uint32(block.timestamp);
  }

  /**
   * @notice Modifier to ensure that the caller is not another contract.
   * @dev Prevents contracts from calling the function, allowing only EOA (Externally Owned Accounts).
   */
  modifier callerIsUser() {
    require(tx.origin == msg.sender, "The caller is another contract");
    _;
  }

  /**
   * @notice Allows users to mint a specified quantity of NFTs.
   * @dev Checks if the sale is active, ensures the mint does not exceed the max supply or per-address limit, and mints the NFTs.
   * @param quantity The number of NFTs to mint.
   */
  function mint(uint256 quantity)
    external
    payable
    callerIsUser
  {
    SaleConfig memory config = saleConfig;
    require(isSaleOn(config.publicPriceWei, config.publicSaleStartTime), "Sale not active");
    require(quantity <= maxBatchSize, "Exceeds max batch size");
    require(totalMinted() + quantity <= collectionSize, "Exceeds collection size");
    
    uint256 numMinted = _numberMinted(msg.sender);
    require(numMinted + quantity <= maxPerAddressDuringMint, "Exceeds max per address");

    uint256 price = getPrice() * quantity;
    require(msg.value >= price, "Insufficient funds");
    
    _safeMint(msg.sender, quantity);
    refundIfOver(price);
  }

  /**
   * @notice Refunds the user if they sent more ETH than the required price.
   * @dev Ensures the user has sent at least the required amount and refunds any excess.
   * @param price The total price for the minted NFTs.
   */
  function refundIfOver(uint256 price)
    private
  {
    if (msg.value > price) {
      payable(msg.sender).transfer(msg.value - price);
    }
  }

  /**
   * @notice Checks if the sale is currently active.
   * @dev Returns true if the sale has started and the price is non-zero.
   * @param _price The public price of the NFT.
   * @param _startTime The start time of the public sale.
   * @return bool True if the sale is active, false otherwise.
   */
  function isSaleOn(uint256 _price, uint256 _startTime)
    public
    view
    returns (bool) 
  {
    return _price != 0 && _startTime <= block.timestamp;
  }

  /**
   * @notice Gets the current public price of the NFT.
   * @dev Converts the stored public price to a uint256 and returns it.
   * @return uint256 The current public price of the NFT.
   */
  function getPrice()
    public
    view
    returns (uint256)
  {
    return uint256(saleConfig.publicPriceWei);
  }

  /**
   * @notice Sets the public sale configuration.
   * @dev Allows the owner to set the public sale start time and price.
   * @param timestamp The new start time for the public sale.
   * @param price The new public price for the NFT.
   */
  function setPublicSaleConfig(uint32 timestamp, uint64 price)
    external
    onlyOwner 
  {
    saleConfig = SaleConfig(timestamp, price);
  }

  /**
   * @notice Reserves a specified quantity of NFTs for the owner.
   * @dev Ensures the total supply does not exceed the dev mint limit and mints in batches.
   * @param quantity The number of NFTs to reserve.
   */
  function reserve(uint256 quantity)
    external
    onlyOwner
  {
    require(totalMinted() + quantity <= amountForDevs, "Exceeds dev allocation");
    
    uint256 batchSize = maxBatchSize;
    uint256 numChunks = quantity / batchSize;
    uint256 remainder = quantity % batchSize;
    
    for (uint256 i = 0; i < numChunks; i++) {
      _safeMint(msg.sender, batchSize);
    }
    
    if (remainder > 0) {
      _safeMint(msg.sender, remainder);
    }
  }

  /**
   * @notice Sets the base URI for the NFT metadata.
   * @dev Allows the owner to set the base URI for the NFTs.
   * @param baseURI The new base URI for the NFT metadata.
   */
  function setBaseURI(string calldata baseURI)
    external
    onlyOwner 
  {
    _baseTokenURI = baseURI;
  }

  /**
   * @notice Base URI for computing the token URI.
   * @dev Override the base URI function from ERC721A to use the custom baseURI.
   * @return string The base URI for token metadata.
   */
  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  /**
   * @notice Withdraws the contract's balance to the owner's address.
   * @dev Uses the `call` method to send the entire contract balance to the owner, ensuring no reentrancy.
   */
  function withdraw()
    external
    onlyOwner
    nonReentrant 
  {
    (bool success, ) = msg.sender.call{value: address(this).balance}("");
    require(success, "Withdrawal failed");
  }

  /**
   * @notice Gets the number of NFTs minted by a specific address.
   * @dev Returns the number of NFTs minted by the given address.
   * @param owner The address to check.
   * @return uint256 The number of NFTs minted by the address.
   */
  function numberMinted(address owner)
    public
    view
    returns (uint256) 
  {
    return _numberMinted(owner);
  }

  /**
   * @notice Gets the ownership data for a specific NFT token.
   * @dev Returns the ownership data for the specified token ID.
   * @param tokenId The ID of the NFT token.
   * @return TokenOwnership The ownership data for the token.
   */
  function getOwnershipData(uint256 tokenId) 
    external
    view
    returns (TokenOwnership memory)
  {
    return _ownershipOf(tokenId);
  }

  /**
   * @notice Gets the total number of NFTs minted.
   * @dev Calculates the total number of NFTs minted by subtracting the start token ID from the current index.
   * @return uint256 The total number of NFTs minted.
   */
  function totalMinted()
    public
    view
    returns (uint256) 
  {
    return _totalMinted();
  }

  /**
   * @notice Receives Ether and does nothing.
   * @dev This function is used to receive Ether without reverting.
   */
  receive() external payable {}
}
```

This implementation completes the Okimi NFT contract with all the required functionality:

1. Public minting with quantity limits
2. Refund mechanism for excess payments
3. Sale status checking and pricing
4. Owner functions for configuration and withdrawal
5. Utility functions for querying NFT ownership and mint counts

The contract follows best practices for security by including reentrancy protection, access control, and proper validation of inputs.