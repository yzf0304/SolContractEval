I'll implement the Okimi NFT contract based on the provided context. I'll focus on completing the missing function implementations while following the ERC721A standard and maintaining the security and functionality requirements.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/**
 * @title Okimi NFT Contract
 * @notice This contract implements an ERC721A NFT collection with a public sale mechanism, minting limits, and owner controls.
 * @dev Inherits from Ownable, ERC721A, and ReentrancyGuard to provide ownership, NFT, and reentrancy protection functionalities.
 */
contract Okimi is Ownable, ERC721A, ReentrancyGuard {
  uint256 public immutable maxPerAddressDuringMint;
  uint256 public immutable amountForDevs;
  uint256 public immutable amountForSaleAndDev;
  uint256 internal immutable collectionSize;
  uint256 internal immutable maxBatchSize;

  struct SaleConfig {
    uint32 publicSaleStartTime;
    uint64 publicPriceWei;
  }

  SaleConfig public saleConfig;
  
  string private _baseTokenURI;

  /**
   * @notice Initializes the contract with default values for the NFT collection.
   * @dev Sets the maximum per address during mint, batch size, collection size, and initial sale configuration.
   */
  constructor()
  ERC721A("Okimi", "OKM")
  {
    maxPerAddressDuringMint = 5;
    maxBatchSize = 5;
    collectionSize = amountForDevs = amountForSaleAndDev = 1500;
    saleConfig.publicPriceWei = 5 ether / 1000;  // 0.005 ETH
    saleConfig.publicSaleStartTime = uint32(block.timestamp);
  }

  /**
   * @notice Modifier to ensure that the caller is not another contract.
   * @dev Prevents contracts from calling the function, allowing only EOA (Externally Owned Accounts).
   */
  modifier callerIsUser() {
    require(tx.origin == msg.sender, "The caller is another contract");
    _;
  }

  /**
   * @notice Allows users to mint a specified quantity of NFTs.
   * @dev Checks if the sale is active, ensures the mint does not exceed the max supply or per-address limit, and mints the NFTs.
   * @param quantity The number of NFTs to mint.
   */
  function mint(uint256 quantity)
    external
    payable
    callerIsUser
  {
    SaleConfig memory config = saleConfig;
    require(isSaleOn(config.publicPriceWei, config.publicSaleStartTime), "Public sale has not begun yet");
    require(quantity <= maxBatchSize, "Cannot mint more than maxBatchSize tokens at once");
    require(totalSupply() + quantity <= amountForSaleAndDev, "Would exceed max supply of NFTs");
    require(numberMinted(msg.sender) + quantity <= maxPerAddressDuringMint, "Would exceed max tokens per address");
    
    uint256 totalPrice = getPrice() * quantity;
    require(msg.value >= totalPrice, "Insufficient funds to mint");
    
    _safeMint(msg.sender, quantity);
    refundIfOver(totalPrice);
  }

  /**
   * @notice Refunds the user if they sent more ETH than the required price.
   * @dev Ensures the user has sent at least the required amount and refunds any excess.
   * @param price The total price for the minted NFTs.
   */
  function refundIfOver(uint256 price)
    private
  {
    if (msg.value > price) {
      payable(msg.sender).transfer(msg.value - price);
    }
  }

  /**
   * @notice Checks if the sale is currently active.
   * @dev Returns true if the sale has started and the price is non-zero.
   * @param _price The public price of the NFT.
   * @param _startTime The start time of the public sale.
   * @return bool True if the sale is active, false otherwise.
   */
  function isSaleOn(uint256 _price, uint256 _startTime)
    public
    view
    returns (bool) 
  {
    return _price != 0 && block.timestamp >= _startTime;
  }

  /**
   * @notice Gets the current public price of the NFT.
   * @dev Converts the stored public price to a uint256 and returns it.
   * @return uint256 The current public price of the NFT.
   */
  function getPrice()
    public
    view
    returns (uint256)
  {
    return uint256(saleConfig.publicPriceWei);
  }

  /**
   * @notice Sets the public sale configuration.
   * @dev Allows the owner to set the public sale start time and price.
   * @param timestamp The new start time for the public sale.
   * @param price The new public price for the NFT.
   */
  function setPublicSaleConfig(uint32 timestamp, uint64 price)
    external
    onlyOwner 
  {
    saleConfig.publicSaleStartTime = timestamp;
    saleConfig.publicPriceWei = price;
  }

  /**
   * @notice Reserves a specified quantity of NFTs for the owner.
   * @dev Ensures the total supply does not exceed the dev mint limit and mints in batches.
   * @param quantity The number of NFTs to reserve.
   */
  function reserve(uint256 quantity)
    external
    onlyOwner
  {
    require(totalSupply() + quantity <= amountForDevs, "Would exceed max supply of NFTs for devs");
    
    uint256 numChunks = quantity / maxBatchSize;
    uint256 remainder = quantity % maxBatchSize;
    
    for (uint256 i = 0; i < numChunks; i++) {
      _safeMint(msg.sender, maxBatchSize);
    }
    
    if (remainder > 0) {
      _safeMint(msg.sender, remainder);
    }
  }

  /**
   * @notice Sets the base URI for the NFT metadata.
   * @dev Allows the owner to set the base URI for the NFTs.
   * @param baseURI The new base URI for the NFT metadata.
   */
  function setBaseURI(string calldata baseURI)
    external
    onlyOwner 
  {
    _baseTokenURI = baseURI;
  }
  
  /**
   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
   * token will be the concatenation of the `baseURI` and the `tokenId`.
   */
  function _baseURI() internal view virtual override returns (string memory) {
    return _baseTokenURI;
  }

  /**
   * @notice Withdraws the contract's balance to the owner's address.
   * @dev Uses the `call` method to send the entire contract balance to the owner, ensuring no reentrancy.
   */
  function withdraw()
    external
    onlyOwner
    nonReentrant 
  {
    uint256 balance = address(this).balance;
    require(balance > 0, "No balance to withdraw");
    
    (bool success, ) = msg.sender.call{value: balance}("");
    require(success, "Withdrawal failed");
  }

  /**
   * @notice Gets the number of NFTs minted by a specific address.
   * @dev Returns the number of NFTs minted by the given address.
   * @param owner The address to check.
   * @return uint256 The number of NFTs minted by the address.
   */
  function numberMinted(address owner)
    public
    view
    returns (uint256) 
  {
    return _numberMinted(owner);
  }

  /**
   * @notice Gets the ownership data for a specific NFT token.
   * @dev Returns the ownership data for the specified token ID.
   * @param tokenId The ID of the NFT token.
   * @return TokenOwnership The ownership data for the token.
   */
  function getOwnershipData(uint256 tokenId) 
    external
    view
    returns (TokenOwnership memory)
  {
    return _ownershipOf(tokenId);
  }

  /**
   * @notice Gets the total number of NFTs minted.
   * @dev Calculates the total number of NFTs minted by subtracting the start token ID from the current index.
   * @return uint256 The total number of NFTs minted.
   */
  function totalMinted()
    public
    view
    returns (uint256) 
  {
    return _totalMinted();
  }

  /**
   * @notice Receives Ether and does nothing.
   * @dev This function is used to receive Ether without reverting.
   */
  receive() external payable {}
}
```

This implementation completes the Okimi NFT contract with all the required functions:

1. Public minting functionality with quantity limits
2. Price calculation and refunding excess ETH
3. Sale status checks and configuration
4. Owner functions for reserving tokens and managing the collection
5. Various view functions to query the contract state

The contract ensures:
- No more than the max supply can be minted
- Users cannot mint more than their allowed limit
- The public sale must be active for minting
- Only the owner can reserve NFTs, set base URI, and withdraw funds
- Security against reentrancy attacks using the nonReentrant modifier
- Only EOA accounts can mint tokens (preventing contract interactions)