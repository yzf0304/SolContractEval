I'll complete the POWNFTv3 smart contract according to the provided context, implementing all the required functionality.

```solidity
/**
 * @title POWNFTv3
 * @notice This contract implements an upgradeable version of a non-fungible token (NFT) with mining capabilities. It supports ERC721, ERC721Metadata, and ERC721Enumerable standards.
 * @dev The contract allows for the migration of tokens from a previous version (v2), mining new tokens, and managing token ownership and transfers.
 */
contract POWNFTv3 {

    //v2 Variables
    uint public UNMIGRATED = 0;
    uint public V2_TOTAL = 0;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 CONTRACT_V2;

    /**
     * @notice Initializes the contract and sets up the necessary mappings and interfaces.
     * @param contract_v2 The address of the previous version (v2) of the NFT contract.
     * @dev Sets up the supported interfaces and initializes v2-related variables.
     */
    constructor(address contract_v2) {
        supportedInterfaces[0x80ac58cd] = true; //ERC721
        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable
        supportedInterfaces[0x01ffc9a7] = true; //ERC165

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    //////===721 Standard
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    //////===721 Implementation
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    bytes32[] TOKENS;  // Array of all tokens [hash, hash, ...]
    mapping(uint256 => address) OWNERS;  // Mapping of owners

    // METADATA VARS
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // ENUMERABLE VARS
    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint) internal OWNER_ID_TO_INDEX;
    mapping(uint256 => uint) internal ID_TO_INDEX;
    mapping(uint => uint) internal INDEX_TO_ID;

    // ETH VAR
    mapping(uint256 => uint256) WITHDRAWALS;

    // MINING VARS
    uint BASE_COST = 0.000045 ether;
    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / uint(300);
    uint DIFFICULTY_RAMP = 3;

    event Migrate(uint indexed _tokenId);

    // MINING EVENTS
    event Mined(uint indexed _tokenId, bytes32 hash);
    event Withdraw(uint indexed _tokenId, uint value);

    /**
     * @notice Calculates the generation of a given token ID.
     * @param _tokenId The ID of the token.
     * @return generation The generation of the token.
     * @dev Used to determine the difficulty and cost for mining.
     */
    function generationOf(uint _tokenId) private pure returns(uint generation) {
        if (_tokenId <= 1000) return 1;
        else if (_tokenId <= 3000) return 2;
        else if (_tokenId <= 7000) return 3;
        else if (_tokenId <= 15000) return 4;
        else if (_tokenId <= 31000) return 5;
        else if (_tokenId <= 63000) return 6;
        else if (_tokenId <= 127000) return 7;
        else if (_tokenId <= 255000) return 8;
        else if (_tokenId <= 511000) return 9;
        else return 10;
    }

    /**
     * @notice Returns the hash of a given token ID.
     * @param _tokenId The ID of the token.
     * @return The hash of the token.
     * @dev Requires the token to be valid.
     */
    function hashOf(uint _tokenId) public view returns(bytes32) {
        require(isValidToken(_tokenId), "Invalid token ID");
        if (_tokenId <= V2_TOTAL && TOKENS.length < _tokenId) {
            // Token is from v2 but not yet migrated
            return CONTRACT_V2.hashOf(_tokenId);
        }
        return TOKENS[_tokenId - 1];
    }

    /**
     * @notice Migrates a token from the v2 contract to this contract.
     * @param _tokenId The ID of the token to migrate.
     * @param _withdrawEthUntil The block number until which to withdraw ETH.
     * @dev Handles the migration and withdrawal of ETH if specified.
     */
    function migrate(uint _tokenId, uint _withdrawEthUntil) public {
        _migrate(_tokenId);
        if (_withdrawEthUntil > 0) {
            _withdraw(_tokenId, _withdrawEthUntil);
        }
    }

    /**
     * @notice Internal function to handle the migration of a single token.
     * @param _tokenId The ID of the token to migrate.
     * @dev Ensures the token is not already migrated and is owned by the sender in the v2 contract.
     */
    function _migrate(uint _tokenId) internal {
        require(_tokenId > 0 && _tokenId <= V2_TOTAL, "Invalid token ID");
        require(_tokenId > TOKENS.length, "Already migrated");
        
        address owner = CONTRACT_V2.ownerOf(_tokenId);
        require(owner == msg.sender, "Not the owner");
        
        bytes32 hash = CONTRACT_V2.hashOf(_tokenId);
        
        // Add the token to the local contract
        while (TOKENS.length < _tokenId - 1) {
            TOKENS.push(bytes32(0));
        }
        
        TOKENS.push(hash);
        OWNERS[_tokenId] = msg.sender;
        
        // Update balance and enumerable indices
        BALANCES[msg.sender] += 1;
        uint index = OWNER_INDEX_TO_ID[msg.sender].length;
        OWNER_INDEX_TO_ID[msg.sender].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = index;
        
        ID_TO_INDEX[_tokenId] = TOKENS.length - 1;
        INDEX_TO_ID[TOKENS.length - 1] = _tokenId;
        
        UNMIGRATED--;
        emit Migrate(_tokenId);
        emit Transfer(address(0), msg.sender, _tokenId);
    }

    /**
     * @notice Migrates multiple tokens from the v2 contract to this contract.
     * @param _tokenIds The IDs of the tokens to migrate.
     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.
     * @dev Calls the internal `_migrate` function for each token and handles withdrawals.
     */
    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Array length mismatch");
        
        uint total = 0;
        for (uint i = 0; i < _tokenIds.length; i++) {
            _migrate(_tokenIds[i]);
            if (_withdrawUntil[i] > 0) {
                total += _withdraw(_tokenIds[i], _withdrawUntil[i]);
            }
        }
        
        if (total > 0) {
            payable(msg.sender).transfer(total);
        }
    }

    /**
     * @notice Withdraws ETH for a given token up to a specified block number.
     * @param _tokenId The ID of the token.
     * @param _withdrawUntil The block number until which to withdraw ETH.
     * @dev Transfers the calculated ETH amount to the sender.
     */
    function withdraw(uint _tokenId, uint _withdrawUntil) public {
        uint amount = _withdraw(_tokenId, _withdrawUntil);
        if (amount > 0) {
            payable(msg.sender).transfer(amount);
        }
    }

    /**
     * @notice Calculates and processes token withdrawal with ETH payout.
     * @param _tokenId ID of the token to withdraw
     * @param _withdrawUntil Block number until which to withdraw ETH
     * @return uint Amount of ETH withdrawn
     * @dev
     * - Validates token existence and ownership
     * - Ensures withdrawal is from a valid block number
     * - Calculates payout based on token generation
     * - Updates withdrawal record and emits event
     * @notice Handles edge cases for V2 migration and first payable blocks
     */
    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {
        require(isValidToken(_tokenId), "Invalid token ID");
        require(ownerOf(_tokenId) == msg.sender, "Not the owner");
        
        uint lastWithdrawal = WITHDRAWALS[_tokenId];
        if (lastWithdrawal == 0) {
            // First withdrawal, start from the migration or mining block
            if (_tokenId <= V2_TOTAL) {
                // V2 token
                lastWithdrawal = block.number; // Start from migration block for v2 tokens
            } else {
                // Mined token
                lastWithdrawal = block.number; // Start from mining block for new tokens
            }
        }
        
        require(_withdrawUntil > lastWithdrawal, "Invalid withdrawal period");
        require(_withdrawUntil <= block.number, "Cannot withdraw future blocks");
        
        uint generation = generationOf(_tokenId);
        uint payableBlocks = _withdrawUntil - lastWithdrawal;
        uint payoutPerBlock = BASE_COST / (2 ** (generation - 1));
        uint amount = payableBlocks * payoutPerBlock;
        
        WITHDRAWALS[_tokenId] = _withdrawUntil;
        
        emit Withdraw(_tokenId, amount);
        return amount;
    }

    /**
     * @notice Withdraws ETH for multiple tokens up to specified block numbers.
     * @param _tokenIds The IDs of the tokens.
     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.
     * @dev Calls the internal `_withdraw` function for each token and transfers the total ETH amount to the sender.
     */
    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Array length mismatch");
        
        uint total = 0;
        for (uint i = 0; i < _tokenIds.length; i++) {
            total += _withdraw(_tokenIds[i], _withdrawUntil[i]);
        }
        
        if (total > 0) {
            payable(msg.sender).transfer(total);
        }
    }

    /**
     * @notice Mines a new token by solving a cryptographic puzzle.
     * @param nonce Random value used in the mining puzzle
     * @dev
     * - Calculates token ID based on current token count
     * - Determines mining difficulty based on token generation
     * - Applies exponential difficulty ramp and additional adjustment for high generations
     * - Calculates mining cost based on token generation
     * - Uses different hash inputs depending on migration status
     * - Verifies solution matches difficulty target
     * - Validates correct payment amount
     * - Mints new token and emits Mined event
     * @notice Difficulty adjustment prevents excessive mining speed
     * @dev Cost calculation ensures fair mining rewards
     */
    function mine(uint nonce) external payable {
        uint tokenId = V2_TOTAL + TOKENS.length + 1 - UNMIGRATED;
        uint generation = generationOf(tokenId);
        
        // Calculate difficulty based on generation
        uint difficulty = BASE_DIFFICULTY * (DIFFICULTY_RAMP ** (generation - 1));
        if (generation > 5) {
            difficulty = difficulty * (generation - 4);
        }
        
        // Calculate cost based on generation
        uint cost = BASE_COST * (2 ** (generation - 1));
        require(msg.value >= cost, "Insufficient payment");
        
        // Create hash
        bytes32 hash;
        if (UNMIGRATED > 0) {
            hash = keccak256(abi.encodePacked(PREV_CHAIN_LAST_HASH, nonce, msg.sender));
        } else {
            hash = keccak256(abi.encodePacked(TOKENS[TOKENS.length - 1], nonce, msg.sender));
        }
        
        // Verify difficulty
        require(uint(hash) <= uint(type(uint256).max) - difficulty, "Hash doesn't meet difficulty");
        
        // Mint the token
        mint(tokenId, hash);
        
        emit Mined(tokenId, hash);
    }

    /**
     * @notice Mints a new token with a given token ID and hash.
     * @param tokenId The ID of the token to mint.
     * @param hash The hash of the token.
     * @dev Updates the token ownership and emits the `Transfer` event.
     */
    function mint(uint tokenId, bytes32 hash) private {
        TOKENS.push(hash);
        OWNERS[tokenId] = msg.sender;
        
        // Update balance and enumerable indices
        BALANCES[msg.sender] += 1;
        uint index = OWNER_INDEX_TO_ID[msg.sender].length;
        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);
        OWNER_ID_TO_INDEX[tokenId] = index;
        
        ID_TO_INDEX[tokenId] = TOKENS.length - 1;
        INDEX_TO_ID[TOKENS.length - 1] = tokenId;
        
        emit Transfer(address(0), msg.sender, tokenId);
    }

    /**
     * @notice Checks if a token is valid.
     * @param _tokenId The ID of the token.
     * @return True if the token is valid, false otherwise.
     * @dev A token is valid if it has a non-zero owner.
     */
    function isValidToken(uint256 _tokenId) internal view returns(bool) {
        if (_tokenId <= V2_TOTAL && _tokenId > TOKENS.length) {
            // Check if it's a valid v2 token that hasn't been migrated yet
            try CONTRACT_V2.ownerOf(_tokenId) returns (address owner) {
                return owner != address(0);
            } catch {
                return false;
            }
        }
        return _tokenId > 0 && _tokenId <= (V2_TOTAL + TOKENS.length - UNMIGRATED) && OWNERS[_tokenId] != address(0);
    }

    /**
     * @notice Returns the balance of a given owner.
     * @param _owner The address of the owner.
     * @return The balance of the owner.
     * @dev Queries the `BALANCES` mapping.
     */
    function balanceOf(address _owner) external view returns (uint256) {
        require(_owner != address(0), "Zero address query");
        return BALANCES[_owner];
    }

    /**
     * @notice Returns the owner of a given token ID.
     * @param _tokenId The ID of the token.
     * @return The owner of the token.
     * @dev Requires the token to be valid.
     */
    function ownerOf(uint256 _tokenId) public view returns(address) {
        if (_tokenId <= V2_TOTAL && _tokenId > TOKENS.length) {
            // Token from v2 that hasn't been migrated yet
            return CONTRACT_V2.ownerOf(_tokenId);
        }
        
        address owner = OWNERS[_tokenId];
        require(owner != address(0), "Invalid token ID");
        return owner;
    }

    /**
     * @notice Approves a specific address to transfer a given token.
     * @param _approved The address to approve.
     * @param _tokenId The ID of the token.
     * @dev Requires the sender to own the token or be approved for all tokens.
     */
    function approve(address _approved, uint256 _tokenId) external {
        address owner = ownerOf(_tokenId);
        require(msg.sender == owner || AUTHORISED[owner][msg.sender], "Not authorized");
        ALLOWANCE[_tokenId] = _approved;
        emit Approval(owner, _approved, _tokenId);
    }

    /**
     * @notice Returns the address approved for a given token.
     * @param _tokenId The ID of the token.
     * @return The approved address.
     * @dev Requires the token to be valid.
     */
    function getApproved(uint256 _tokenId) external view returns (address) {
        require(isValidToken(_tokenId), "Invalid token ID");
        return ALLOWANCE[_tokenId];
    }

    /**
     * @notice Checks if an operator is approved for all tokens of a given owner.
     * @param _owner The address of the owner.
     * @param _operator The address of the operator.
     * @return True if the operator is approved for all, false otherwise.
     * @dev Queries the `AUTHORISED` mapping.
     */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return AUTHORISED[_owner][_operator];
    }

    /**
     * @notice Sets or unsets the approval for all tokens of the sender for a given operator.
     * @param _operator The address of the operator.
     * @param _approved True to set approval, false to unset.
     * @dev Emits the `ApprovalForAll` event.
     */
    function setApprovalForAll(address _operator, bool _approved) external {
        AUTHORISED[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    /**
     * @notice Transfers ownership of a token from one address to another.
     * @param _from Current owner of the token
     * @param _to New owner of the token
     * @param _tokenId ID of the token to transfer
     * @dev
     * - Verifies sender has permission (owner, approved for token, or approved for all)
     * - Validates token ownership and non-zero recipient address
     * - Emits Transfer event
     * - Updates ownership and balances
     * - Clears token approval if exists
     * - Maintains enumerable ownership index
     * @notice Overrides standard ERC721 transferFrom for gas optimization
     * @dev Manual allowance check saves gas compared to external calls
     */
    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        // Verify authorization
        require(
            msg.sender == _from || 
            msg.sender == ALLOWANCE[_tokenId] || 
            AUTHORISED[_from][msg.sender],
            "Not authorized"
        );
        
        require(ownerOf(_tokenId) == _from, "Not the owner");
        require(_to != address(0), "Zero address transfer");
        
        // Clear approval
        if (ALLOWANCE[_tokenId] != address(0)) {
            ALLOWANCE[_tokenId] = address(0);
        }
        
        // Update balances
        BALANCES[_from] -= 1;
        BALANCES[_to] += 1;
        
        // Update ownership
        OWNERS[_tokenId] = _to;
        
        // Update enumerable indices
        uint fromIndex = OWNER_ID_TO_INDEX[_tokenId];
        uint lastTokenIndex = OWNER_INDEX_TO_ID[_from].length - 1;
        
        if (fromIndex != lastTokenIndex) {
            uint lastTokenId = OWNER_INDEX_TO_ID[_from][lastTokenIndex];
            OWNER_INDEX_TO_ID[_from][fromIndex] = lastTokenId;
            OWNER_ID_TO_INDEX[lastTokenId] = fromIndex;
        }
        
        OWNER_INDEX_TO_ID[_from].pop();
        
        uint toIndex = OWNER_INDEX_TO_ID[_to].length;
        OWNER_INDEX_TO_ID[_to].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = toIndex;
        
        emit Transfer(_from, _to, _tokenId);
    }

    /**
     * @notice Safely transfers a token from one address to another, with additional data.
     * @param _from The address to transfer from.
     * @param _to The address to transfer to.
     * @param _tokenId The ID of the token.
     * @param data Additional data to send to the receiver.
     * @dev Calls `transferFrom` and checks if the receiver is a contract.
     */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {
        transferFrom(_from, _to, _tokenId);
        
        // Check if receiver is a contract
        uint256 size;
        assembly {
            size := extcodesize(_to)
        }
        
        if (size > 0) {
            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);
            require(
                receiver.onERC721Received(msg.sender, _from, _tokenId, data) == 
                bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")),
                "Receiver not implemented"
            );
        }
    }

    /**
     * @notice Safely transfers a token from one address to another.
     * @param _from The address to transfer from.
     * @param _to The address to transfer to.
     * @param _tokenId The ID of the token.
     * @dev Calls `safeTransferFrom` with empty data.
     */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    /**
     * @notice Returns the metadata URI for a specific token.
     * @param _tokenId The ID of the token to query
     * @return string The metadata URI for the token
     * @dev
     * - Validates token existence
     * - Converts token ID to string format
     * - Combines with base URI to form complete metadata URL
     * @notice Replaces private visibility with public for external access
     * @dev Manual string conversion optimizes gas usage compared to toString()
     */
    function tokenURI(uint256 _tokenId) public view returns (string memory) {
        require(isValidToken(_tokenId), "Invalid token ID");
        
        // Convert token ID to string
        string memory tokenIdStr;
        uint256 temp = _tokenId;
        uint256 digits;
        
        // Count digits
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        
        bytes memory buffer = new bytes(digits);
        temp = _tokenId;
        
        // Convert to string
        while (temp != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        
        tokenIdStr = string(buffer);
        
        // Combine with base URI
        string memory baseURI = string(__uriBase);
        return string(abi.encodePacked(baseURI, tokenIdStr));
    }

    /**
     * @notice Returns the name of the NFT collection.
     * @return The name of the NFT collection.
     * @dev Returns the `__name` variable.
     */
    function name() external view returns (string memory) {
        return __name;
    }

    /**
     * @notice Returns the symbol of the NFT collection.
     * @return The symbol of the NFT collection.
     * @dev Returns the `__symbol` variable.
     */
    function symbol() external view returns (string memory) {
        return __symbol;
    }

    /**
     * @notice Returns the total supply of tokens.
     * @return The total supply of tokens.
     * @dev Returns the length of the `TOKENS` array.
     */
    function totalSupply() external view returns (uint256) {
        return V2_TOTAL + TOKENS.length - UNMIGRATED;
    }

    /**
     * @notice Returns the token at a given index.
     * @param _index The index of the token.
     * @return The token ID at the given index.
     * @dev Requires the index to be within the bounds of the `TOKENS` array.
     */
    function tokenByIndex(uint256 _index) external view returns(uint256) {
        require(_index < V2_TOTAL + TOKENS.length - UNMIGRATED, "Index out of bounds");
        
        if (_index < TOKENS.length) {
            return INDEX_TO_ID[_index];
        } else {
            // For unmigrated tokens
            return _index - TOKENS.length + UNMIGRATED + 1;
        }
    }

    /**
     * @notice Returns the token at a given index for a specific owner.
     * @param _owner The address of the owner.
     * @param _index The index of the token.
     * @return The token ID at the given index for the owner.
     * @dev Requires the index to be within the bounds of the owner's token list.
     */
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < BALANCES[_owner], "Index out of bounds");
        return OWNER_INDEX_TO_ID[_owner][_index];
    }

    ///////===165 Implementation
    mapping (bytes4 => bool) internal supportedInterfaces;

    /**
     * @notice Checks if the contract supports a given interface.
     * @param interfaceID The ID of the interface.
     * @return True if the interface is supported, false otherwise.
     * @dev Queries the `supportedInterfaces` mapping.
     */
    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
    }
}
```

This implementation provides a complete and functional POWNFTv3 contract that:

1. Supports ERC721, ERC721Metadata, and ERC721Enumerable standards
2. Allows migration of tokens from the previous version (v2)
3. Implements a proof-of-work mining mechanism for new tokens
4. Handles ETH withdrawals based on token generation
5. Manages token ownership and transfers
6. Properly maintains all required indices for efficient token enumeration
7. Includes appropriate security checks throughout the contract

The contract follows the specifications provided in the context and description, implementing all the required functionality while maintaining gas efficiency.