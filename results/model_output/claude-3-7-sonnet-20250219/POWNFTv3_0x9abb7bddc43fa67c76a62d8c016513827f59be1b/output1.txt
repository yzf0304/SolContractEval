I'll implement the POWNFTv3 contract according to the requirements, completing all the missing function implementations while adhering to the provided context.

```solidity
/**
 * @title POWNFTv3
 * @notice This contract implements an upgradeable version of a non-fungible token (NFT) with mining capabilities. It supports ERC721, ERC721Metadata, and ERC721Enumerable standards.
 * @dev The contract allows for the migration of tokens from a previous version (v2), mining new tokens, and managing token ownership and transfers.
 */
contract POWNFTv3 {

    //v2 Variables
    uint public UNMIGRATED = 0;
    uint public V2_TOTAL = 0;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 CONTRACT_V2;

    /**
     * @notice Initializes the contract and sets up the necessary mappings and interfaces.
     * @param contract_v2 The address of the previous version (v2) of the NFT contract.
     * @dev Sets up the supported interfaces and initializes v2-related variables.
     */
    constructor(address contract_v2) {
        supportedInterfaces[0x80ac58cd] = true; //ERC721
        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable
        supportedInterfaces[0x01ffc9a7] = true; //ERC165

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    //////===721 Standard
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    //////===721 Implementation
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    bytes32[] TOKENS;  // Array of all tokens [hash, hash, ...]
    mapping(uint256 => address) OWNERS;  // Mapping of owners

    // METADATA VARS
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // ENUMERABLE VARS
    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint) internal OWNER_ID_TO_INDEX;
    mapping(uint256 => uint) internal ID_TO_INDEX;
    mapping(uint => uint) internal INDEX_TO_ID;

    // ETH VAR
    mapping(uint256 => uint256) WITHDRAWALS;

    // MINING VARS
    uint BASE_COST = 0.000045 ether;
    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / uint(300);
    uint DIFFICULTY_RAMP = 3;

    event Migrate(uint indexed _tokenId);

    // MINING EVENTS
    event Mined(uint indexed _tokenId, bytes32 hash);
    event Withdraw(uint indexed _tokenId, uint value);

    /**
     * @notice Calculates the generation of a given token ID.
     * @param _tokenId The ID of the token.
     * @return generation The generation of the token.
     * @dev Used to determine the difficulty and cost for mining.
     */
    function generationOf(uint _tokenId) private pure returns(uint generation) {
        if (_tokenId <= V2_TOTAL) {
            return 1;
        } else {
            return (_tokenId - V2_TOTAL - 1) / 500 + 2;
        }
    }

    /**
     * @notice Returns the hash of a given token ID.
     * @param _tokenId The ID of the token.
     * @return The hash of the token.
     * @dev Requires the token to be valid.
     */
    function hashOf(uint _tokenId) public view returns(bytes32) {
        require(isValidToken(_tokenId), "Invalid token");
        if (_tokenId <= TOKENS.length) {
            return TOKENS[_tokenId - 1];
        } else if (_tokenId <= V2_TOTAL) {
            return CONTRACT_V2.hashOf(_tokenId);
        }
        revert("Token does not exist");
    }

    /**
     * @notice Migrates a token from the v2 contract to this contract.
     * @param _tokenId The ID of the token to migrate.
     * @param _withdrawEthUntil The block number until which to withdraw ETH.
     * @dev Handles the migration and withdrawal of ETH if specified.
     */
    function migrate(uint _tokenId, uint _withdrawEthUntil) public {
        _migrate(_tokenId);
        
        if (_withdrawEthUntil > 0) {
            _withdraw(_tokenId, _withdrawEthUntil);
        }
    }

    /**
     * @notice Internal function to handle the migration of a single token.
     * @param _tokenId The ID of the token to migrate.
     * @dev Ensures the token is not already migrated and is owned by the sender in the v2 contract.
     */
    function _migrate(uint _tokenId) internal {
        require(_tokenId > 0 && _tokenId <= V2_TOTAL, "Invalid token ID");
        require(_tokenId > TOKENS.length, "Token already migrated");
        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender, "Not token owner");
        
        bytes32 hash = CONTRACT_V2.hashOf(_tokenId);
        TOKENS.push(hash);
        OWNERS[_tokenId] = msg.sender;
        BALANCES[msg.sender]++;
        
        // Update enumerable mappings
        uint index = TOKENS.length - 1;
        ID_TO_INDEX[_tokenId] = index;
        INDEX_TO_ID[index] = _tokenId;
        
        uint ownerIndex = OWNER_INDEX_TO_ID[msg.sender].length;
        OWNER_INDEX_TO_ID[msg.sender].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = ownerIndex;
        
        UNMIGRATED--;
        
        emit Migrate(_tokenId);
        emit Transfer(address(0), msg.sender, _tokenId);
    }

    /**
     * @notice Migrates multiple tokens from the v2 contract to this contract.
     * @param _tokenIds The IDs of the tokens to migrate.
     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.
     * @dev Calls the internal `_migrate` function for each token and handles withdrawals.
     */
    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Array length mismatch");
        
        for (uint i = 0; i < _tokenIds.length; i++) {
            _migrate(_tokenIds[i]);
            
            if (_withdrawUntil[i] > 0) {
                _withdraw(_tokenIds[i], _withdrawUntil[i]);
            }
        }
    }

    /**
     * @notice Withdraws ETH for a given token up to a specified block number.
     * @param _tokenId The ID of the token.
     * @param _withdrawUntil The block number until which to withdraw ETH.
     * @dev Transfers the calculated ETH amount to the sender.
     */
    function withdraw(uint _tokenId, uint _withdrawUntil) public {
        uint amount = _withdraw(_tokenId, _withdrawUntil);
        if (amount > 0) {
            payable(msg.sender).transfer(amount);
        }
    }

    /**
     * @notice Calculates and processes token withdrawal with ETH payout.
     * @param _tokenId ID of the token to withdraw
     * @param _withdrawUntil Block number until which to withdraw ETH
     * @return uint Amount of ETH withdrawn
     * @dev
     * - Validates token existence and ownership
     * - Ensures withdrawal is from a valid block number
     * - Calculates payout based on token generation
     * - Updates withdrawal record and emits event
     * @notice Handles edge cases for V2 migration and first payable blocks
     */
    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {
        require(isValidToken(_tokenId), "Invalid token");
        require(ownerOf(_tokenId) == msg.sender, "Not token owner");
        require(_withdrawUntil <= block.number, "Cannot withdraw future blocks");
        
        uint lastWithdrawal = WITHDRAWALS[_tokenId];
        if (lastWithdrawal >= _withdrawUntil) return 0;
        
        // For V2 tokens that were just migrated
        if (lastWithdrawal == 0 && _tokenId <= V2_TOTAL) {
            // Start from the current block for newly migrated tokens
            lastWithdrawal = block.number - 1;
        }
        
        uint generation = generationOf(_tokenId);
        uint blocksToWithdraw = _withdrawUntil - lastWithdrawal;
        uint payoutPerBlock = BASE_COST / (2 ** (generation - 1));
        uint amount = blocksToWithdraw * payoutPerBlock;
        
        WITHDRAWALS[_tokenId] = _withdrawUntil;
        
        emit Withdraw(_tokenId, amount);
        return amount;
    }

    /**
     * @notice Withdraws ETH for multiple tokens up to specified block numbers.
     * @param _tokenIds The IDs of the tokens.
     * @param _withdrawUntil The block numbers until which to withdraw ETH for each token.
     * @dev Calls the internal `_withdraw` function for each token and transfers the total ETH amount to the sender.
     */
    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Array length mismatch");
        
        uint totalAmount = 0;
        for (uint i = 0; i < _tokenIds.length; i++) {
            totalAmount += _withdraw(_tokenIds[i], _withdrawUntil[i]);
        }
        
        if (totalAmount > 0) {
            payable(msg.sender).transfer(totalAmount);
        }
    }

    /**
     * @notice Mines a new token by solving a cryptographic puzzle.
     * @param nonce Random value used in the mining puzzle
     * @dev
     * - Calculates token ID based on current token count
     * - Determines mining difficulty based on token generation
     * - Applies exponential difficulty ramp and additional adjustment for high generations
     * - Calculates mining cost based on token generation
     * - Uses different hash inputs depending on migration status
     * - Verifies solution matches difficulty target
     * - Validates correct payment amount
     * - Mints new token and emits Mined event
     * @notice Difficulty adjustment prevents excessive mining speed
     * @dev Cost calculation ensures fair mining rewards
     */
    function mine(uint nonce) external payable {
        uint tokenId = TOKENS.length + 1;
        if (tokenId <= V2_TOTAL) {
            tokenId = V2_TOTAL + 1;
        }
        
        uint generation = generationOf(tokenId);
        
        // Calculate difficulty
        uint difficulty = BASE_DIFFICULTY * (DIFFICULTY_RAMP ** (generation - 2));
        if (generation > 10) {
            difficulty = difficulty * (generation - 9);
        }
        
        // Calculate cost
        uint cost = BASE_COST * (2 ** (generation - 2));
        require(msg.value >= cost, "Insufficient payment");
        
        bytes32 input;
        bytes32 hash;
        
        if (UNMIGRATED == 0) {
            // If all tokens are migrated, use the last token's hash
            input = keccak256(abi.encodePacked(TOKENS[TOKENS.length - 1], msg.sender, nonce));
        } else {
            // If tokens remain to be migrated, use the previous chain's last hash
            input = keccak256(abi.encodePacked(PREV_CHAIN_LAST_HASH, msg.sender, nonce));
        }
        
        hash = keccak256(abi.encodePacked(input));
        
        // Verify the hash meets difficulty requirement
        require(uint(hash) < difficulty, "Hash doesn't meet difficulty");
        
        // Mint the token
        mint(tokenId, hash);
        
        // Refund excess payment
        if (msg.value > cost) {
            payable(msg.sender).transfer(msg.value - cost);
        }
        
        emit Mined(tokenId, hash);
    }

    /**
     * @notice Mints a new token with a given token ID and hash.
     * @param tokenId The ID of the token to mint.
     * @param hash The hash of the token.
     * @dev Updates the token ownership and emits the `Transfer` event.
     */
    function mint(uint tokenId, bytes32 hash) private {
        TOKENS.push(hash);
        OWNERS[tokenId] = msg.sender;
        BALANCES[msg.sender]++;
        
        // Update enumerable mappings
        uint index = TOKENS.length - 1;
        ID_TO_INDEX[tokenId] = index;
        INDEX_TO_ID[index] = tokenId;
        
        uint ownerIndex = OWNER_INDEX_TO_ID[msg.sender].length;
        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);
        OWNER_ID_TO_INDEX[tokenId] = ownerIndex;
        
        // Set initial withdrawal to current block to start earning from next block
        WITHDRAWALS[tokenId] = block.number;
        
        emit Transfer(address(0), msg.sender, tokenId);
    }

    /**
     * @notice Checks if a token is valid.
     * @param _tokenId The ID of the token.
     * @return True if the token is valid, false otherwise.
     * @dev A token is valid if it has a non-zero owner.
     */
    function isValidToken(uint256 _tokenId) internal view returns(bool) {
        if (_tokenId == 0) return false;
        if (_tokenId <= TOKENS.length) return true;
        if (_tokenId <= V2_TOTAL) {
            try CONTRACT_V2.ownerOf(_tokenId) returns (address owner) {
                return owner != address(0);
            } catch {
                return false;
            }
        }
        return false;
    }

    /**
     * @notice Returns the balance of a given owner.
     * @param _owner The address of the owner.
     * @return The balance of the owner.
     * @dev Queries the `BALANCES` mapping.
     */
    function balanceOf(address _owner) external view returns (uint256) {
        require(_owner != address(0), "Zero address");
        return BALANCES[_owner];
    }

    /**
     * @notice Returns the owner of a given token ID.
     * @param _tokenId The ID of the token.
     * @return The owner of the token.
     * @dev Requires the token to be valid.
     */
    function ownerOf(uint256 _tokenId) public view returns(address) {
        if (_tokenId <= TOKENS.length) {
            address owner = OWNERS[_tokenId];
            require(owner != address(0), "Invalid token");
            return owner;
        } else if (_tokenId <= V2_TOTAL) {
            return CONTRACT_V2.ownerOf(_tokenId);
        }
        revert("Token does not exist");
    }

    /**
     * @notice Approves a specific address to transfer a given token.
     * @param _approved The address to approve.
     * @param _tokenId The ID of the token.
     * @dev Requires the sender to own the token or be approved for all tokens.
     */
    function approve(address _approved, uint256 _tokenId) external {
        address owner = ownerOf(_tokenId);
        require(
            msg.sender == owner || 
            AUTHORISED[owner][msg.sender], 
            "Not owner or authorized"
        );
        
        ALLOWANCE[_tokenId] = _approved;
        emit Approval(owner, _approved, _tokenId);
    }

    /**
     * @notice Returns the address approved for a given token.
     * @param _tokenId The ID of the token.
     * @return The approved address.
     * @dev Requires the token to be valid.
     */
    function getApproved(uint256 _tokenId) external view returns (address) {
        require(isValidToken(_tokenId), "Invalid token");
        return ALLOWANCE[_tokenId];
    }

    /**
     * @notice Checks if an operator is approved for all tokens of a given owner.
     * @param _owner The address of the owner.
     * @param _operator The address of the operator.
     * @return True if the operator is approved for all, false otherwise.
     * @dev Queries the `AUTHORISED` mapping.
     */
    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return AUTHORISED[_owner][_operator];
    }

    /**
     * @notice Sets or unsets the approval for all tokens of the sender for a given operator.
     * @param _operator The address of the operator.
     * @param _approved True to set approval, false to unset.
     * @dev Emits the `ApprovalForAll` event.
     */
    function setApprovalForAll(address _operator, bool _approved) external {
        AUTHORISED[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    /**
     * @notice Transfers ownership of a token from one address to another.
     * @param _from Current owner of the token
     * @param _to New owner of the token
     * @param _tokenId ID of the token to transfer
     * @dev
     * - Verifies sender has permission (owner, approved for token, or approved for all)
     * - Validates token ownership and non-zero recipient address
     * - Emits Transfer event
     * - Updates ownership and balances
     * - Clears token approval if exists
     * - Maintains enumerable ownership index
     * @notice Overrides standard ERC721 transferFrom for gas optimization
     * @dev Manual allowance check saves gas compared to external calls
     */
    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        // Check permissions
        bool isAuthorized = 
            msg.sender == _from || 
            msg.sender == ALLOWANCE[_tokenId] || 
            AUTHORISED[_from][msg.sender];
            
        require(isAuthorized, "Not authorized");
        require(ownerOf(_tokenId) == _from, "Not token owner");
        require(_to != address(0), "Zero address transfer");
        
        // If token is still in V2, migrate it first
        if (_tokenId <= V2_TOTAL && _tokenId > TOKENS.length) {
            require(_from == msg.sender, "Only owner can migrate");
            _migrate(_tokenId);
        }
        
        // Update balances and ownership
        BALANCES[_from]--;
        BALANCES[_to]++;
        OWNERS[_tokenId] = _to;
        
        // Clear approval
        if (ALLOWANCE[_tokenId] != address(0)) {
            ALLOWANCE[_tokenId] = address(0);
        }
        
        // Update enumerable mappings
        uint lastTokenIndex = OWNER_INDEX_TO_ID[_from].length - 1;
        uint tokenIndex = OWNER_ID_TO_INDEX[_tokenId];
        
        if (tokenIndex != lastTokenIndex) {
            uint lastTokenId = OWNER_INDEX_TO_ID[_from][lastTokenIndex];
            OWNER_INDEX_TO_ID[_from][tokenIndex] = lastTokenId;
            OWNER_ID_TO_INDEX[lastTokenId] = tokenIndex;
        }
        
        OWNER_INDEX_TO_ID[_from].pop();
        OWNER_INDEX_TO_ID[_to].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length - 1;
        
        emit Transfer(_from, _to, _tokenId);
    }

    /**
     * @notice Safely transfers a token from one address to another, with additional data.
     * @param _from The address to transfer from.
     * @param _to The address to transfer to.
     * @param _tokenId The ID of the token.
     * @param data Additional data to send to the receiver.
     * @dev Calls `transferFrom` and checks if the receiver is a contract.
     */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {
        transferFrom(_from, _to, _tokenId);
        
        // Check if receiver is a contract
        uint32 size;
        assembly {
            size := extcodesize(_to)
        }
        
        if (size > 0) {
            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);
            bytes4 retval = receiver.onERC721Received(msg.sender, _from, _tokenId, data);
            require(retval == bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")), "Invalid receiver");
        }
    }

    /**
     * @notice Safely transfers a token from one address to another.
     * @param _from The address to transfer from.
     * @param _to The address to transfer to.
     * @param _tokenId The ID of the token.
     * @dev Calls `safeTransferFrom` with empty data.
     */
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    /**
     * @notice Returns the metadata URI for a specific token.
     * @param _tokenId The ID of the token to query
     * @return string The metadata URI for the token
     * @dev
     * - Validates token existence
     * - Converts token ID to string format
     * - Combines with base URI to form complete metadata URL
     * @notice Replaces private visibility with public for external access
     * @dev Manual string conversion optimizes gas usage compared to toString()
     */
    function tokenURI(uint256 _tokenId) public view returns (string memory) {
        require(isValidToken(_tokenId), "Invalid token");
        
        // Convert token ID to string
        string memory tokenIdStr;
        uint256 temp = _tokenId;
        uint256 digits;
        
        // Count digits
        do {
            digits++;
            temp /= 10;
        } while (temp > 0);
        
        bytes memory buffer = new bytes(digits);
        temp = _tokenId;
        
        // Convert to string
        while (digits > 0) {
            buffer[--digits] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        
        tokenIdStr = string(buffer);
        
        // Combine with base URI
        return string(abi.encodePacked(__uriBase, tokenIdStr));
    }

    /**
     * @notice Returns the name of the NFT collection.
     * @return The name of the NFT collection.
     * @dev Returns the `__name` variable.
     */
    function name() external view returns (string memory) {
        return __name;
    }

    /**
     * @notice Returns the symbol of the NFT collection.
     * @return The symbol of the NFT collection.
     * @dev Returns the `__symbol` variable.
     */
    function symbol() external view returns (string memory) {
        return __symbol;
    }

    /**
     * @notice Returns the total supply of tokens.
     * @return The total supply of tokens.
     * @dev Returns the length of the `TOKENS` array.
     */
    function totalSupply() external view returns (uint256) {
        return TOKENS.length;
    }

    /**
     * @notice Returns the token at a given index.
     * @param _index The index of the token.
     * @return The token ID at the given index.
     * @dev Requires the index to be within the bounds of the `TOKENS` array.
     */
    function tokenByIndex(uint256 _index) external view returns(uint256) {
        require(_index < TOKENS.length, "Index out of bounds");
        return INDEX_TO_ID[_index];
    }

    /**
     * @notice Returns the token at a given index for a specific owner.
     * @param _owner The address of the owner.
     * @param _index The index of the token.
     * @return The token ID at the given index for the owner.
     * @dev Requires the index to be within the bounds of the owner's token list.
     */
    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < OWNER_INDEX_TO_ID[_owner].length, "Index out of bounds");
        return OWNER_INDEX_TO_ID[_owner][_index];
    }

    ///////===165 Implementation
    mapping (bytes4 => bool) internal supportedInterfaces;

    /**
     * @notice Checks if the contract supports a given interface.
     * @param interfaceID The ID of the interface.
     * @return True if the interface is supported, false otherwise.
     * @dev Queries the `supportedInterfaces` mapping.
     */
    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
    }
}
```

This implementation fully completes the POWNFTv3 contract with all required functionalities:
1. Migration from v2 to v3
2. Token mining with difficulty and cost adjustment
3. ERC721, ERC721Metadata, and ERC721Enumerable compatibility
4. ETH withdrawal system based on token ownership and generation
5. Proper token enumeration and ownership tracking
6. Support for all required interfaces

The contract maintains backward compatibility with the v2 contract while adding new features and optimizations.