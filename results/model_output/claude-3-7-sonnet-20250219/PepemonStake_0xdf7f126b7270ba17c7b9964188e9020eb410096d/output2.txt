Here's the completed PepemonStake contract with all the required functionality:

```solidity
/**
 * @title PepemonStake
 * @notice A smart contract for staking Pepemon cards, allowing users to participate in staking events and earn rewards.
 * @dev Inherits from Ownable, providing basic authorization control functions.
 */
contract PepemonStake is Ownable {
    using SafeMath for uint256;

    IPepemonFactory public pepemonFactory;

    /**
     * @notice Structure to hold the details of a staking event.
     * @dev Contains information about the cards required, reward, and staking duration.
     */
    struct StakingEvent {
        uint256[] cardIdList;
        uint256 cardAmountAny; // If this is > 0, cardAmountList will be ignored, and user will be able to stake multiple cards of any card accepted
        uint256[] cardAmountList; // Will be ignored if cardAmountAny > 0
        uint256 cardRewardId;
        uint256 blockStakeLength; // Amounts of blocks of staking required to complete the event
        uint256 blockEventClose; // Block at which this event will not accept any new stake
        uint256[] toBurnIdList; // Id list of cards to burn on completion of event
        uint256[] toBurnAmountList; // Amount list of cards to burn on completion of event
    }

    /**
     * @notice Structure to hold the user's staking information.
     * @dev Tracks whether the user has completed the event and the block at which the staking ends.
     */
    struct UserInfo {
        bool isCompleted;
        uint256 blockEnd; // Block at which user will have completed the event (If this is not 0, user is currently staking)
    }

    StakingEvent[] public stakingEvents;
    mapping (address => mapping(uint256 => UserInfo)) public userInfo;
    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) public cardsStaked; // address => eventId => cardId => amountStaked

    ////
    // Events
    ////

    /**
     * @notice Emitted when a new staking event is created.
     * @param eventId The ID of the newly created staking event.
     */
    event StakingEventCreated(uint256 eventId);

    /**
     * @notice Emitted when a user enters a staking event.
     * @param user The address of the user entering the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventEntered(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user completes a staking event.
     * @param user The address of the user completing the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCompleted(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user cancels their participation in a staking event.
     * @param user The address of the user canceling the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCancelled(address indexed user, uint256 eventId);

    //////////////

    constructor(IPepemonFactory _pepemonFactoryAddress) public {
        pepemonFactory = _pepemonFactoryAddress;
    }

    ////
    // View
    ////

    /**
     * @notice Returns the total number of staking events.
     * @return The length of the stakingEvents array.
     */
    function getStakingEventsLength() external view returns(uint256) {
        return stakingEvents.length;
    }

    /**
     * @notice Returns all staking events.
     * @return An array of all staking events.
     */
    function getAllEvents() public view returns(StakingEvent[] memory) {
        return stakingEvents;
    }

    /**
     * @notice Returns the IDs of all active staking events.
     * @return An array of IDs of active staking events.
     */
    function getActiveEvents() external view returns(uint256[] memory) {
        uint256 count = 0;
        
        // First, count the active events
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (stakingEvents[i].blockEventClose > block.number) {
                count++;
            }
        }
        
        // Then create and populate the array
        uint256[] memory activeEvents = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (stakingEvents[i].blockEventClose > block.number) {
                activeEvents[index] = i;
                index++;
            }
        }
        
        return activeEvents;
    }

    /**
     * @notice Returns the IDs of all closed staking events.
     * @return An array of IDs of closed staking events.
     */
    function getClosedEvents() external view returns(uint256[] memory) {
        uint256 count = 0;
        
        // First, count the closed events
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (stakingEvents[i].blockEventClose <= block.number) {
                count++;
            }
        }
        
        // Then create and populate the array
        uint256[] memory closedEvents = new uint256[](count);
        uint256 index = 0;
        
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (stakingEvents[i].blockEventClose <= block.number) {
                closedEvents[index] = i;
                index++;
            }
        }
        
        return closedEvents;
    }

    /**
     * @notice Returns the list of card IDs for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card IDs for the specified staking event.
     */
    function getCardIdListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "Event does not exist");
        return stakingEvents[_eventId].cardIdList;
    }

    /**
     * @notice Returns the list of card amounts for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card amounts for the specified staking event.
     */
    function getCardAmountListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "Event does not exist");
        return stakingEvents[_eventId].cardAmountList;
    }

    /**
     * @notice Returns the progress of a user towards completing a staking event.
     * @param _user The address of the user.
     * @param _eventId The ID of the staking event.
     * @return The progress as a percentage (100% = 1e5).
     */
    function getUserProgress(address _user, uint256 _eventId) external view returns(uint256) {
        require(_eventId < stakingEvents.length, "Event does not exist");
        UserInfo memory info = userInfo[_user][_eventId];
        
        if (info.isCompleted) {
            return 100000; // 100% = 1e5
        }
        
        if (info.blockEnd == 0) {
            return 0; // Not staking
        }
        
        uint256 blockStakeLength = stakingEvents[_eventId].blockStakeLength;
        uint256 blockStart = info.blockEnd.sub(blockStakeLength);
        
        if (block.number <= blockStart) {
            return 0;
        }
        
        if (block.number >= info.blockEnd) {
            return 100000; // 100% = 1e5
        }
        
        // Calculate progress: (current block - start block) / total blocks * 100%
        return (block.number.sub(blockStart)).mul(100000).div(blockStakeLength);
    }

    //////////////

    /**
     * @notice Creates a new staking event.
     * @param _cardIdList The list of card IDs required for the event.
     * @param _cardAmountAny The amount of any card required for the event.
     * @param _cardAmountList The list of card amounts required for the event.
     * @param _cardRewardId The ID of the card to be rewarded.
     * @param _blockStakeLength The number of blocks required to complete the event.
     * @param _blockEventClose The block at which the event will close.
     * @param _toBurnIdList The list of card IDs to be burned on completion.
     * @param _toBurnAmountList The list of card amounts to be burned on completion.
     */
    function createStakingEvent(
        uint256[] memory _cardIdList, 
        uint256 _cardAmountAny, 
        uint256[] memory _cardAmountList, 
        uint256 _cardRewardId,
        uint256 _blockStakeLength, 
        uint256 _blockEventClose, 
        uint256[] memory _toBurnIdList, 
        uint256[] memory _toBurnAmountList
    ) public onlyOwner {
        require(_cardIdList.length > 0, "Card ID list cannot be empty");
        require(_blockStakeLength > 0, "Staking length must be greater than 0");
        require(_blockEventClose > block.number, "Event close block must be in the future");
        
        if (_cardAmountAny == 0) {
            require(_cardIdList.length == _cardAmountList.length, "Card ID list and amount list must be the same length");
        }
        
        require(_toBurnIdList.length == _toBurnAmountList.length, "Burn ID list and amount list must be the same length");
        
        StakingEvent memory newEvent = StakingEvent({
            cardIdList: _cardIdList,
            cardAmountAny: _cardAmountAny,
            cardAmountList: _cardAmountList,
            cardRewardId: _cardRewardId,
            blockStakeLength: _blockStakeLength,
            blockEventClose: _blockEventClose,
            toBurnIdList: _toBurnIdList,
            toBurnAmountList: _toBurnAmountList
        });
        
        stakingEvents.push(newEvent);
        emit StakingEventCreated(stakingEvents.length - 1);
    }

    /**
     * @notice Closes a staking event prematurely.
     * @param _eventId The ID of the staking event to be closed.
     */
    function closeStakingEvent(uint256 _eventId) public onlyOwner {
        require(_eventId < stakingEvents.length, "Event does not exist");
        require(stakingEvents[_eventId].blockEventClose > block.number, "Event already closed");
        
        stakingEvents[_eventId].blockEventClose = block.number;
    }

    //////////////

    /**
     * @dev Stakes multiple cards for a staking event.
     * 
     * @param _eventId The ID of the staking event
     * @param _cardIdList List of card IDs to stake
     * @param _cardAmountList Corresponding amounts of each card
     * 
     * @return None
     * 
     * @notice Emits StakingEventEntered event
     * @dev
     * - Validates card acceptance and total amount
     * - Transfers cards via safeBatchTransferFrom
     * - Records staked cards in storage
     */
    function stakeAny(uint256 _eventId, uint256[] memory _cardIdList, uint256[] memory _cardAmountList) public {
        require(_eventId < stakingEvents.length, "Event does not exist");
        StakingEvent storage event_ = stakingEvents[_eventId];
        
        require(block.number < event_.blockEventClose, "Event has ended");
        require(event_.cardAmountAny > 0, "Event does not support staking any cards");
        require(_cardIdList.length == _cardAmountList.length, "Card ID list and amount list must be the same length");
        require(userInfo[msg.sender][_eventId].blockEnd == 0, "Already staking");
        
        uint256 totalAmount = 0;
        
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            require(_isInArray(_cardIdList[i], event_.cardIdList), "Card not accepted in this event");
            totalAmount = totalAmount.add(_cardAmountList[i]);
        }
        
        require(totalAmount >= event_.cardAmountAny, "Insufficient cards staked");
        
        // Transfer the cards to this contract
        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), _cardIdList, _cardAmountList, "");
        
        // Record the staked cards
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            cardsStaked[msg.sender][_eventId][_cardIdList[i]] = _cardAmountList[i];
        }
        
        // Set the user's staking information
        userInfo[msg.sender][_eventId].blockEnd = block.number.add(event_.blockStakeLength);
        
        emit StakingEventEntered(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to stake specific cards into a staking event.
     * @param _eventId The ID of the staking event.
     */
    function stake(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "Event does not exist");
        StakingEvent storage event_ = stakingEvents[_eventId];
        
        require(block.number < event_.blockEventClose, "Event has ended");
        require(event_.cardAmountAny == 0, "Use stakeAny for this event");
        require(userInfo[msg.sender][_eventId].blockEnd == 0, "Already staking");
        
        uint256[] memory cardIds = event_.cardIdList;
        uint256[] memory cardAmounts = event_.cardAmountList;
        
        // Check if user has enough cards
        for (uint256 i = 0; i < cardIds.length; i++) {
            require(pepemonFactory.balanceOf(msg.sender, cardIds[i]) >= cardAmounts[i], "Not enough cards");
        }
        
        // Transfer the cards to this contract
        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), cardIds, cardAmounts, "");
        
        // Record the staked cards
        for (uint256 i = 0; i < cardIds.length; i++) {
            cardsStaked[msg.sender][_eventId][cardIds[i]] = cardAmounts[i];
        }
        
        // Set the user's staking information
        userInfo[msg.sender][_eventId].blockEnd = block.number.add(event_.blockStakeLength);
        
        emit StakingEventEntered(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to claim their staked cards and the reward.
     * @param _eventId The ID of the staking event.
     */
    function claim(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "Event does not exist");
        UserInfo storage user = userInfo[msg.sender][_eventId];
        
        require(user.blockEnd > 0, "Not staking");
        require(block.number >= user.blockEnd, "Staking period not completed");
        require(!user.isCompleted, "Already claimed");
        
        StakingEvent storage event_ = stakingEvents[_eventId];
        
        // Burn cards if required
        _withdrawCardsStaked(_eventId, true);
        
        // Mint reward
        pepemonFactory.mint(msg.sender, event_.cardRewardId, 1, "");
        
        // Mark as completed
        user.isCompleted = true;
        
        emit StakingEventCompleted(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to cancel their participation in a staking event and withdraw their staked cards.
     * @param _eventId The ID of the staking event.
     */
    function cancel(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "Event does not exist");
        UserInfo storage user = userInfo[msg.sender][_eventId];
        
        require(user.blockEnd > 0, "Not staking");
        require(!user.isCompleted, "Already completed");
        
        // Return staked cards
        _withdrawCardsStaked(_eventId, false);
        
        // Reset user info
        user.blockEnd = 0;
        
        emit StakingEventCancelled(msg.sender, _eventId);
    }

    function _withdrawCardsStaked(uint256 _eventId, bool _burn) internal {
        StakingEvent storage event_ = stakingEvents[_eventId];
        
        // Handle regular cards
        uint256[] memory cardIds = new uint256[](event_.cardIdList.length);
        uint256[] memory amounts = new uint256[](event_.cardIdList.length);
        
        uint256 count = 0;
        for (uint256 i = 0; i < event_.cardIdList.length; i++) {
            uint256 cardId = event_.cardIdList[i];
            uint256 amount = cardsStaked[msg.sender][_eventId][cardId];
            
            if (amount > 0) {
                cardIds[count] = cardId;
                amounts[count] = amount;
                count++;
                
                // Clear staked amount
                cardsStaked[msg.sender][_eventId][cardId] = 0;
            }
        }
        
        // Resize arrays to actual count
        if (count < cardIds.length) {
            uint256[] memory actualCardIds = new uint256[](count);
            uint256[] memory actualAmounts = new uint256[](count);
            
            for (uint256 i = 0; i < count; i++) {
                actualCardIds[i] = cardIds[i];
                actualAmounts[i] = amounts[i];
            }
            
            cardIds = actualCardIds;
            amounts = actualAmounts;
        }
        
        // If burning is required, burn specified cards
        if (_burn && event_.toBurnIdList.length > 0) {
            for (uint256 i = 0; i < event_.toBurnIdList.length; i++) {
                uint256 burnId = event_.toBurnIdList[i];
                uint256 burnAmount = event_.toBurnAmountList[i];
                
                for (uint256 j = 0; j < cardIds.length; j++) {
                    if (cardIds[j] == burnId && amounts[j] >= burnAmount) {
                        amounts[j] = amounts[j].sub(burnAmount);
                        pepemonFactory.burn(address(this), burnId, burnAmount);
                        break;
                    }
                }
            }
        }
        
        // Return remaining cards to user
        if (cardIds.length > 0) {
            pepemonFactory.safeBatchTransferFrom(address(this), msg.sender, cardIds, amounts, "");
        }
    }

    function _isInArray(uint256 _value, uint256[] memory _array) internal pure returns(bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array[i] == _value) {
                return true;
            }
        }
        return false;
    }

    /////////
    /////////
    /////////

    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4) {
        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4) {
        return 0xbc197c81;
    }

    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).
        interfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) ^ bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`).
    }
}
```

This implementation includes all the required functionality as specified:
1. Creating and managing staking events
2. Allowing users to stake cards in different ways (specific cards or any accepted cards)
3. Tracking user progress in staking events
4. Allowing users to claim rewards or cancel their staking
5. Handling the burning of cards when required
6. Support for receiving ERC1155 tokens

The contract follows the design patterns from the provided context and includes all necessary error checks to ensure secure operation.