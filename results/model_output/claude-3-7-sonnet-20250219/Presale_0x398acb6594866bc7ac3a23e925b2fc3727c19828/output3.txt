```solidity
/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,
 *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {

  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;
  using SafeMath for uint256;

  /**
   * @notice Struct to store participant information.
   * @dev Contains whether the participant is authorized and their minimum tier.
   */
  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  /**************************************************************************
   * STORAGE / EVENTS
   *************************************************************************/

  SeeToken public token;
  Discounts.Collection discounts;
  Limits.Window cap;
  mapping (address => Participant) public participants;

  /**
   * @notice Emitted when a new tier is added.
   * @param discount The discount in basis points.
   * @param available The available supply at the tier.
   */
  event Tier(uint256 discount, uint256 available);

  /**************************************************************************
   * CONSTRUCTOR / LIFECYCLE
   *************************************************************************/

  function Presale(address _token)
    public
  {
    token = SeeToken(_token);
    paused = true;
  }

  /**
   * @notice Claims ownership of the token contract.
   * @dev This function should be called as part of the migration process.
   */
  function claimToken() public {
    token.claimOwnership();
  }

  /**
   * @notice Unpauses the contract, allowing purchases.
   * @dev Can only be called by the owner, and the contract must be paused, have a set rate, be capped, and own the token.
   */
  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  /**************************************************************************
   * ADMIN INTERFACE
   *************************************************************************/

  /**
   * @notice Sets the base purchase rate for the token.
   * @param _purchaseRate The number of tokens granted per wei.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    require(_purchaseRate > 0);
    discounts.baseRate = _purchaseRate;
  }

  /**
   * @notice Specifies purchasing limits for a single account.
   * @param _amount The limit of tokens that a participant may purchase.
   * @param _duration The duration in blocks over which the limit applies.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    require(_amount > 0);
    require(_duration > 0);
    cap.amount = _amount;
    cap.duration = _duration;
  }

  /**
   * @notice Adds a new tier with a given discount and available supply.
   * @param _discount The discount in basis points.
   * @param _available The available supply at the tier.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    require(_discount <= Discounts.MAX_DISCOUNT);
    require(_available > 0);
    discounts.addTier(_discount, _available);
    Tier(_discount, _available);
  }

  /**
   * @notice Authorizes a group of participants for a specific tier.
   * @param _minimumTier The minimum tier for the list of participants.
   * @param _authorized An array of addresses to be authorized.
   * @dev Can only be called by the owner.
   */
  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _authorized.length; i++) {
      participants[_authorized[i]] = Participant({
        authorized: true,
        minimumTier: _minimumTier
      });
    }
  }

  /**
   * @notice Withdraws the balance from the presale contract.
   * @dev Can only be called by the owner.
   */
  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(address(this).balance);
  }

  /**************************************************************************
   * PURCHASE INTERFACE
   *************************************************************************/

  /**
   * @notice Fallback function that forwards to `purchaseTokens()`.
   * @dev Accepts Ether and calls `purchaseTokens()`.
   */
  function ()
    public
    payable
  {
    purchaseTokens();
  }

  /**
   * @notice Public purchase interface for authorized participants.
   * @dev Purchases tokens starting from the authorized minimum tier.
   * Can only be called by an authorized participant and while the contract is not paused.
   */
  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    require(msg.value > 0);
    
    // Get participant details
    Participant storage participant = participants[msg.sender];
    uint256 minimumTier = participant.minimumTier;
    
    // Get the limit for the participant
    uint256 limit = cap.getLimit(msg.sender);
    require(limit > 0);
    
    // Purchase tokens using the Discounts library
    uint256 purchased;
    uint256 remaining;
    (purchased, remaining) = discounts.purchaseTokens(limit, msg.value, minimumTier);
    
    // Ensure we purchased some tokens
    require(purchased > 0);
    
    // Record the purchase against the cap
    cap.recordPurchase(msg.sender, purchased);
    
    // Issue the tokens to the purchaser
    token.issue(msg.sender, purchased);
    
    // Return any excess funds
    if (remaining > 0) {
      msg.sender.transfer(remaining);
    }
  }

  /**************************************************************************
   * PRICING / AVAILABILITY - VIEW INTERFACE
   *************************************************************************/

  /**
   * @notice Gets the terms for the purchasing limit window.
   * @return _amount The number of tokens allowed.
   * @return _duration The duration in blocks.
   */
  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    return (cap.amount, cap.duration);
  }

  /**
   * @notice Gets the tiers currently set up, with discounts and available supplies.
   * @return An array of tuples (discount, available).
   */
  function getTiers()
    public
    view
    returns (uint256[2][])
  {
    uint256 tiersCount = discounts.tiers.length;
    uint256[2][] memory result = new uint256[2][](tiersCount);
    
    for (uint256 i = 0; i < tiersCount; i++) {
      result[i][0] = discounts.tiers[i].discount;
      result[i][1] = discounts.tiers[i].available;
    }
    
    return result;
  }

  /**
   * @notice Gets the available supply for each tier for a given participant.
   * @param _participant The address of the participant.
   * @return An array of available supplies by tier index, zeroes for non-authorized participants.
   */
  function getAvailability(address _participant)
    public
    view
    returns (uint256[])
  {
    Participant memory participant = participants[_participant];
    
    if (!participant.authorized) {
      return new uint256[](0);
    }
    
    uint256 tiersCount = discounts.tiers.length;
    uint256[] memory result = new uint256[](tiersCount);
    
    for (uint256 i = 0; i < tiersCount; i++) {
      if (i >= participant.minimumTier) {
        result[i] = discounts.tiers[i].available;
      } else {
        result[i] = 0;
      }
    }
    
    return result;
  }

  /**************************************************************************
   * MODIFIERS
   *************************************************************************/

  /**
   * @dev Requires the participant to be whitelist-authorized.
   */
  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  /**
   * @dev Ensures the base rate is set (not zero).
   */
  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  /**
   * @dev Ensures the contract is capped (cap amount is not zero).
   */
  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  /**
   * @dev Ensures the contract owns the token.
   */
  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}
```