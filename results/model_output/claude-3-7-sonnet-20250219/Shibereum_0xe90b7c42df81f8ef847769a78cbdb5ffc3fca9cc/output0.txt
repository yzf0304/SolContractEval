# Completed Shibereum Contract

```solidity
/**
 * @notice Shibereum is an ERC20 token with additional features such as trading fees, anti-sniping, and swapback mechanisms.
 * @dev This contract implements the IERC20 interface and extends the Ownable contract for access control.
 */
contract Shibereum is IERC20, Ownable {       
    string private constant _name = "Shibereum.Ai";
    string private constant _symbol = "Shibereum";
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _blocked;

    mapping (address => uint256) private _lastTradeBlock;
    mapping (address => bool) private isContractExempt;
    uint256 private tradeCooldown = 1;
    
    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;
    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;
    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;

    struct TradingFees{
        uint256 buyTax;
        uint256 sellTax;
    }  

    TradingFees public tradingFees = TradingFees(10,45);
    uint256 public constant sniperTax = 49;

    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address private immutable ETH = uniswapRouter.WETH();
    address private immutable uniswapPair;

    address payable private immutable deployerAddress = payable(msg.sender);
    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);

    bool private tradingOpen = false;
    bool private swapping = false;
    bool private antiMEV = false;
    uint256 private startingBlock;
    uint private preLaunch;

    modifier swapLock {
        swapping = true;
        _;
        swapping = false;
    }

    modifier tradingLock(address sender) {
        require(tradingOpen || sender == deployerAddress || sender == devWallet);
        _;
    }

    constructor () {
        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);
        isContractExempt[address(this)] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    /**
     * @notice Returns the name of the token.
     * @dev The name is a constant string.
     * @return The name of the token.
     */
    function name() public pure returns (string memory) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @dev The symbol is a constant string.
     * @return The symbol of the token.
     */
    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    /**
     * @notice Returns the number of decimals used to get its user representation.
     * @dev The decimals are a constant value.
     * @return The number of decimals.
     */
    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    /**
     * @notice Returns the total supply of tokens in existence.
     * @dev The total supply is a constant value.
     * @return The total supply of tokens.
     */
    function totalSupply() public pure returns (uint256) {
        return _totalSupply;
    }

    /**
     * @notice Returns the balance of the specified address.
     * @param account The address to query the balance of.
     * @return The balance of the specified address.
     */
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    /**
     * @notice Transfers a specified amount of tokens from the caller's address to a recipient.
     * @param recipient The recipient address.
     * @param amount The amount of tokens to transfer.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    /**
     * @notice Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through `transferFrom`.
     * @param owner The address which owns the funds.
     * @param spender The address which will spend the funds.
     * @return The remaining allowance.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
     * @param spender The address which will spend the funds.
     * @param amount The amount of tokens to approve.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    /**
     * @notice Transfers a specified amount of tokens from one address to another, using the allowance mechanism.
     * @param sender The address to transfer from.
     * @param recipient The address to transfer to.
     * @param amount The amount of tokens to transfer.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        
        _transfer(sender, recipient, amount);
        
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    /**
     * @notice Internal function to set the allowance of `spender` over the `owner`'s tokens.
     * @param owner The address which owns the funds.
     * @param spender The address which will spend the funds.
     * @param amount The amount of tokens to approve.
     */
    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Transfers tokens between accounts with trading restrictions and fees.
     * @param from Source address (must not be zero address)
     * @param to Destination address (must not be zero address)
     * @param amount Transfer amount (must be > 0)
     * @dev
     * - Enforces zero address checks
     * - Handles anti-MEV measures for non-contract accounts
     * - Validates max wallet limits for transfers to/from uniswapPair
     * - Executes swapback if conditions are met
     * - Applies transaction fees and emits events
     * @notice Trading is locked during certain periods (via tradingLock modifier)
     */
    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!_blocked[from], "Sender is blocked from trading");
        
        if (antiMEV && !isContractExempt[from] && !isContractExempt[to]) {
            address human = ensureOneHuman(to, from);
            ensureMaxTxFrequency(human);
        }
        
        bool isSelling = to == uniswapPair;
        bool isBuying = from == uniswapPair;
        
        // Check for max wallet limit
        if ((isBuying || isSelling) && tradingOpen) {
            if (isBuying && to != address(uniswapRouter) && to != address(uniswapPair)) {
                require(balanceOf(to) + amount <= maxWalletAmount, "Max wallet limit exceeded");
            }
            
            // Execute swapback if needed
            if (shouldSwapback(from, amount) && isSelling) {
                uint256 swapAmount = getSwapAmount(amount);
                swapback(swapAmount);
            }
        }
        
        // Calculate fee
        uint256 feeAmount = 0;
        if ((isBuying || isSelling) && !swapping && tradingOpen) {
            feeAmount = takeFee(from, amount);
        }
        
        // Transfer tokens
        uint256 transferAmount = amount - feeAmount;
        _balances[from] -= amount;
        
        if (feeAmount > 0) {
            _balances[address(this)] += feeAmount;
        }
        
        _balances[to] += transferAmount;
        
        // Update last trade block
        if (tradingOpen && (isBuying || isSelling)) {
            if (isBuying) {
                _lastTradeBlock[to] = block.number;
            } else {
                _lastTradeBlock[from] = block.number;
            }
        }
        
        emit Transfer(from, to, transferAmount);
        if (feeAmount > 0) {
            emit Transfer(from, address(this), feeAmount);
        }
    }

    /**
     * @notice Swaps a specified amount of tokens for ETH and sends the ETH to the dev wallet.
     * @param tokenAmount The amount of tokens to swap.
     */
    function swapback(uint256 tokenAmount) private swapLock {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ETH;

        _approve(address(this), address(uniswapRouter), tokenAmount);

        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            devWallet,
            block.timestamp
        );
    }

    /**
     * @notice Determines if a swapback should occur based on the current conditions.
     * @param from The address sending the tokens.
     * @param tokenAmount The amount of tokens to check.
     * @return A boolean value indicating whether a swapback should occur.
     */
    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool) {
        uint256 contractTokenBalance = balanceOf(address(this));
        return (
            from != uniswapPair &&
            !swapping &&
            contractTokenBalance >= contractSwapLimit &&
            tokenAmount > 0
        );
    }

    /**
     * @notice Calculates the amount of tokens to swap, ensuring it does not exceed the maximum limit.
     * @param tokenAmount The amount of tokens to check.
     * @return The amount of tokens to swap.
     */
    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {
        uint256 contractTokenBalance = balanceOf(address(this));
        return contractTokenBalance > contractSwapMax ? contractSwapMax : contractTokenBalance;
    }

    /**
     * @notice Calculates the fee amount to be deducted from the transfer.
     * @param from The address sending the tokens.
     * @param amount The amount of tokens to transfer.
     * @return The fee amount.
     */
    function takeFee(address from, uint256 amount) private view returns (uint256) {
        uint256 feePercent;
        
        // Determine fee based on trade type
        if (from == uniswapPair) {
            // Buying
            feePercent = tradingFees.buyTax;
            
            // Apply sniper tax if within launch period
            if (tradingOpen && block.number <= startingBlock + preLaunch) {
                feePercent = sniperTax;
            }
        } else {
            // Selling
            feePercent = tradingFees.sellTax;
        }
        
        return amount * feePercent / 100;
    }

    /**
     * @notice Checks if the given address is a contract.
     * @param account The address to check.
     * @return A boolean value indicating whether the address is a contract.
     */
    function isContract(address account) private view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    /**
     * @notice Ensures that at least one of the addresses involved in the transaction is a human (not a contract).
     * @param _to The recipient address.
     * @param _from The sender address.
     * @return The address of the human.
     */
    function ensureOneHuman(address _to, address _from) private view returns (address) {
        bool toIsContract = isContract(_to);
        bool fromIsContract = isContract(_from);
        
        require(!toIsContract || !fromIsContract, "No contracts trading with contracts");
        
        return !toIsContract ? _to : _from;
    }

    /**
     * @notice Ensures that the transaction frequency does not exceed the allowed limit.
     * @param addr The address to check.
     */
    function ensureMaxTxFrequency(address addr) view private {
        require(block.number > _lastTradeBlock[addr] + tradeCooldown, "Trading too frequently");
    }

    /**
     * @notice Toggles the anti-MEV feature.
     * @param toggle The new state of the anti-MEV feature.
     */
    function toggleAntiMEV(bool toggle) external onlyOwner {
        antiMEV = toggle;
    }

    /**
     * @notice Sets the trade cooldown period.
     * @param newTradeCooldown The new trade cooldown period.
     */
    function setTradeCooldown(uint256 newTradeCooldown) external onlyOwner {
        tradeCooldown = newTradeCooldown;
    }

    /**
     * @notice Manually triggers a swapback for a specified percentage of the contract's token balance.
     * @param percent The percentage of the contract's token balance to swap.
     */
    function manualSwapback(uint256 percent) external onlyOwner {
        require(percent <= 100, "Percentage must be <= 100");
        uint256 contractTokenBalance = balanceOf(address(this));
        uint256 amountToSwap = contractTokenBalance * percent / 100;
        swapback(amountToSwap);
    }

    /**
     * @notice Sets the trading fees for buying and selling.
     * @param newBuyTax The new buy tax.
     * @param newSellTax The new sell tax.
     */
    function setFees(uint256 newBuyTax, uint256 newSellTax) external onlyOwner {
        require(newBuyTax <= 49, "Buy tax must be <= 49%");
        require(newSellTax <= 49, "Sell tax must be <= 49%");
        tradingFees = TradingFees(newBuyTax, newSellTax);
    }

    /**
     * @notice Sets the contract exemption status for a specified address.
     * @param account The address to set the exemption status for.
     * @param value The new exemption status.
     */
    function setContractExempt(address account, bool value) external onlyOwner {
        isContractExempt[account] = value;
    }

    /**
     * @notice Sets the bot blocking status for multiple addresses.
     * @param bots The list of addresses to set the bot blocking status for.
     * @param shouldBlock The new bot blocking status.
     */
    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {
        for (uint256 i = 0; i < bots.length; i++) {
            _blocked[bots[i]] = shouldBlock;
        }
    }

    /**
     * @notice Initializes the contract, allowing certain parameters to be set.
     */
    function initialize() external onlyOwner {
        isContractExempt[address(uniswapPair)] = true;
        isContractExempt[address(uniswapRouter)] = true;
        isContractExempt[address(this)] = true;
        isContractExempt[deployerAddress] = true;
        isContractExempt[devWallet] = true;
        preLaunch = 3;
    }

    /**
     * @notice Modifies the contract parameters, including the starting block.
     * @param param The parameters to modify.
     * @param nrBlocks The number of blocks to add to the starting block.
     */
    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {
        require(param.length >= 1, "Invalid parameters");
        antiMEV = param[0];
        if (nrBlocks > 0) {
            preLaunch = nrBlocks;
        }
    }

    /**
     * @notice Opens trading, setting the starting block and enabling trading.
     */
    function openTrading() external onlyOwner {
        require(!tradingOpen, "Trading is already open");
        tradingOpen = true;
        startingBlock = block.number;
    }
}
```