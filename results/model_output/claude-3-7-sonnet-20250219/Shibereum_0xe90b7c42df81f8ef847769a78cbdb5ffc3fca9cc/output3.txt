I'll implement the Shibereum contract based on the provided specifications and context.

```solidity
contract Shibereum is IERC20, Ownable {       
    string private constant _name = "Shibereum.Ai";
    string private constant _symbol = "Shibereum";
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _blocked;

    mapping (address => uint256) private _lastTradeBlock;
    mapping (address => bool) private isContractExempt;
    uint256 private tradeCooldown = 1;
    
    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;
    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;
    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;

    struct TradingFees{
        uint256 buyTax;
        uint256 sellTax;
    }  

    TradingFees public tradingFees = TradingFees(10,45);
    uint256 public constant sniperTax = 49;

    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address private immutable ETH = uniswapRouter.WETH();
    address private immutable uniswapPair;

    address payable private immutable deployerAddress = payable(msg.sender);
    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);

    bool private tradingOpen = false;
    bool private swapping = false;
    bool private antiMEV = false;
    uint256 private startingBlock;
    uint private preLaunch;

    modifier swapLock {
        swapping = true;
        _;
        swapping = false;
    }

    modifier tradingLock(address sender) {
        require(tradingOpen || sender == deployerAddress || sender == devWallet, "Trading not open");
        _;
    }

    constructor () {
        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);
        isContractExempt[address(this)] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, currentAllowance - amount);
        
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!_blocked[from] && !_blocked[to], "Blocked address");

        if (from != deployerAddress && to != deployerAddress && !swapping) {
            if (antiMEV && !isContractExempt[from] && !isContractExempt[to]) {
                address human = ensureOneHuman(to, from);
                ensureMaxTxFrequency(human);
                _lastTradeBlock[human] = block.number;
            }

            // Handle max wallet limit for transfers to/from pair
            if (to == uniswapPair || from == uniswapPair) {
                if (to != uniswapPair && !isContractExempt[to]) {
                    require(_balances[to] + amount <= maxWalletAmount, "Max wallet exceeded");
                }

                // Handle swapback on sells if conditions met
                if (to == uniswapPair && !swapping && shouldSwapback(from, amount)) {
                    uint256 swapAmount = getSwapAmount(amount);
                    swapback(swapAmount);
                }
            }
        }

        uint256 feeAmount = 0;
        if (!swapping && (from != deployerAddress && to != deployerAddress)) {
            feeAmount = takeFee(from, amount);
        }

        _balances[from] -= amount;
        
        uint256 transferAmount = amount - feeAmount;
        _balances[to] += transferAmount;
        
        if (feeAmount > 0) {
            _balances[address(this)] += feeAmount;
            emit Transfer(from, address(this), feeAmount);
        }
        
        emit Transfer(from, to, transferAmount);
    }

    function swapback(uint256 tokenAmount) private swapLock {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ETH;

        _approve(address(this), address(uniswapRouter), tokenAmount);

        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            devWallet,
            block.timestamp
        );
    }

    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool) {
        uint256 contractTokenBalance = _balances[address(this)];
        return 
            from != uniswapPair &&
            !isContractExempt[from] &&
            tradingOpen &&
            contractTokenBalance >= contractSwapLimit &&
            tokenAmount > 0;
    }

    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {
        uint256 contractTokenBalance = contractSwapLimit;
        if (contractTokenBalance > contractSwapMax) {
            contractTokenBalance = contractSwapMax;
        }
        return contractTokenBalance;
    }

    function takeFee(address from, uint256 amount) private view returns (uint256) {
        uint256 feeRate = 0;

        if (block.number <= startingBlock + preLaunch) {
            // Sniper tax during launch period
            feeRate = sniperTax;
        } else if (from == uniswapPair) {
            // Buy tax
            feeRate = tradingFees.buyTax;
        } else if (uniswapPair == address(0)) {
            // If pair not created yet
            feeRate = 0;
        } else {
            // Sell tax
            feeRate = tradingFees.sellTax;
        }

        return (amount * feeRate) / 100;
    }

    function isContract(address account) private view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    function ensureOneHuman(address _to, address _from) private view returns (address) {
        if (!isContract(_to) && !isContractExempt[_to]) {
            return _to;
        }
        if (!isContract(_from) && !isContractExempt[_from]) {
            return _from;
        }
        revert("No human detected in transaction");
    }

    function ensureMaxTxFrequency(address addr) view private {
        if (_lastTradeBlock[addr] > 0) {
            require(block.number - _lastTradeBlock[addr] >= tradeCooldown, "Transaction cooldown");
        }
    }

    function toggleAntiMEV(bool toggle) external onlyOwner {
        antiMEV = toggle;
    }

    function setTradeCooldown(uint256 newTradeCooldown) external onlyOwner {
        tradeCooldown = newTradeCooldown;
    }

    function manualSwapback(uint256 percent) external onlyOwner {
        require(percent > 0 && percent <= 100, "Percent out of range");
        uint256 tokenAmount = _balances[address(this)] * percent / 100;
        if (tokenAmount > 0) {
            swapback(tokenAmount);
        }
    }

    function setFees(uint256 newBuyTax, uint256 newSellTax) external onlyOwner {
        require(newBuyTax <= 49, "Buy tax too high");
        require(newSellTax <= 49, "Sell tax too high");
        tradingFees = TradingFees(newBuyTax, newSellTax);
    }

    function setContractExempt(address account, bool value) external onlyOwner {
        isContractExempt[account] = value;
    }

    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {
        for (uint256 i = 0; i < bots.length; i++) {
            _blocked[bots[i]] = shouldBlock;
        }
    }

    function initialize() external onlyOwner {
        require(preLaunch == 0, "Already initialized");
        preLaunch = 10; // Default: 10 blocks anti-sniper period
    }

    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {
        if (param.length > 0 && param[0]) {
            preLaunch = nrBlocks;
        }
    }

    function openTrading() external onlyOwner {
        require(!tradingOpen, "Trading already open");
        tradingOpen = true;
        startingBlock = block.number;
    }
}
```

This implementation provides a complete and functional Shibereum token contract according to the specifications. It includes:

1. Basic ERC20 functionality (name, symbol, decimals, totalSupply, balanceOf, etc.)
2. Trading control mechanisms (opening trading, anti-MEV, trade cooldown)
3. Fee handling with separate buy and sell taxes, plus sniper taxes
4. Swap functionality to convert collected fees to ETH
5. Wallet size limitations and bot blocking features
6. Owner-controlled settings for adjusting parameters

The contract ensures security by implementing appropriate checks on transfers, requiring trading to be open, and implementing measures against contract interactions where necessary.