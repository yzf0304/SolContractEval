Here's the completed TellorC contract according to the provided context and description:

```solidity
/**
 * @notice This contract interacts with the Tellor system, allowing for staking, withdrawing, and submitting mining solutions.
 * @dev The contract is designed to be controlled by an owner, who can change the miner, withdraw TRB and ETH, manage staking,
 * and submit mining solutions. It also allows forwarding calls to the Tellor contract under certain conditions.
 */
contract TellorC {
    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;

    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; // keccak256("slotProgress")
    address private owner;
    address private miner;
    
    /**
     * @notice Initializes the contract, setting the deployer as the owner.
     */
    constructor () public {
        owner = msg.sender;
    }
    
    /**
     * @notice Allows the owner to change the designated miner.
     * @dev Only the owner can call this function. The new miner's address is set.
     * @param _addr The new miner's address.
     */
    function changeMiner(address _addr) external {
        require(msg.sender == owner, "Not owner");
        miner = _addr;
    }

    /**
     * @notice Allows the owner to withdraw TRB tokens from the Tellor contract.
     * @dev Only the owner can call this function. The specified amount of TRB is transferred to the owner.
     * @param _amount The amount of TRB to withdraw.
     */
    function withdrawTrb(uint256 _amount) external {
        require(msg.sender == owner, "Not owner");
        TellorWrapper(tellor).transfer(owner, _amount);
    }

    /**
     * @notice Allows the owner to withdraw ETH from the contract.
     * @dev Only the owner can call this function. The specified amount of ETH is transferred to the owner.
     * @param _amount The amount of ETH to withdraw.
     */
    function withdrawEth(uint256 _amount) external {
        require(msg.sender == owner, "Not owner");
        require(_amount <= address(this).balance, "Insufficient balance");
        owner.transfer(_amount);
    }

    /**
     * @notice Allows the owner to deposit a stake in the Tellor contract.
     * @dev Only the owner can call this function. A stake is deposited in the Tellor contract.
     */
    function depositStake() external {
        require(msg.sender == owner, "Not owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("depositStake()"));
        require(success, "Deposit stake failed");
    }

    /**
     * @notice Allows the owner to request a staking withdrawal from the Tellor contract.
     * @dev Only the owner can call this function. A staking withdrawal request is made to the Tellor contract.
     */
    function requestStakingWithdraw() external {
        require(msg.sender == owner, "Not owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("requestStakingWithdraw()"));
        require(success, "Request staking withdraw failed");
    }

    /**
     * @notice Allows the owner to withdraw their stake from the Tellor contract.
     * @dev Only the owner can call this function. The stake is withdrawn from the Tellor contract.
     * Prefer using `finalize` if possible.
     */
    function withdrawStake() external {
        require(msg.sender == owner, "Not owner");
        TellorWrapper(tellor).withdrawStake();
    }

    /**
     * @notice Finalizes the contract, withdrawing the stake and transferring any remaining TRB to the owner before self-destructing.
     * @dev Only the owner can call this function. The stake is withdrawn, all TRB is transferred to the owner, and the contract is self-destructed.
     */
    function finalize() external {
        require(msg.sender == owner, "Not owner");
        TellorWrapper(tellor).withdrawStake();
        uint256 trbBalance = TellorWrapper(tellor).balanceOf(address(this));
        if (trbBalance > 0) {
            TellorWrapper(tellor).transfer(owner, trbBalance);
        }
        selfdestruct(address(uint160(owner)));
    }

    /**
     * @notice Submits a mining solution to the Tellor contract.
     * @dev Only the miner or the owner can call this function. The solution is submitted to the Tellor contract.
     * @param _nonce The nonce used for the mining solution.
     * @param _requestId Array of request IDs.
     * @param _value Array of values corresponding to the request IDs.
     */
    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {
        require(msg.sender == miner || msg.sender == owner, "Not authorized");
        (bool success, ) = tellor.call(abi.encodeWithSignature("submitMiningSolution(string,uint256[5],uint256[5])", _nonce, _requestId, _value));
        require(success, "Submit mining solution failed");
    }

    /**
     * @notice Fallback function that forwards calls to the Tellor contract.
     * @dev This function only allows view calls and ensures that the call is not from a non-zero address.
     */
    function() external {
        require(msg.sender == address(0), "Not allowed"); // Dont allow actual calls, only views
        
        address addr = tellor;
        bytes memory _calldata = msg.data;
        assembly {
            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.
            // if the call returned error data, forward it
            switch result
                case 0 {
                    revert(ptr, size)
                }
                default {
                    return(ptr, size)
                }
        }
    }
}
```

This implementation follows the provided context and description, including:
1. Owner-controlled functions for managing the miner, withdrawing funds, and handling staking
2. Interaction with the Tellor contract for staking and mining operations
3. A fallback function that forwards view calls to the Tellor contract
4. Proper access control for all functions
5. Self-destruction capability in the finalize function

The contract uses the TellorWrapper interface for direct interactions with the Tellor contract's functions.