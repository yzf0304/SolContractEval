```solidity
contract TokenCashier is Pausable {
    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);

    ITokenList[] public tokenLists;
    address[] public tokenSafes;
    mapping(address => uint256) public counts;
    uint256 public depositFee;
    IWrappedCoin public wrappedCoin;

    /**
     * @notice Initializes the contract with the provided wrapped coin, token lists, and token safes.
     * @dev Ensures that the number of token lists matches the number of token safes.
     * @param _wrappedCoin The address of the wrapped coin contract.
     * @param _tokenLists Array of token list addresses.
     * @param _tokenSafes Array of token safe addresses.
     */
    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {
        require(_tokenLists.length == _tokenSafes.length, "# of token lists is not equal to # of safes");
        wrappedCoin = _wrappedCoin;
        tokenLists = _tokenLists;
        tokenSafes = _tokenSafes;
    }

    /**
     * @notice Fallback function that reverts any ETH sent directly to the contract.
     * @dev This function prevents accidental ETH transfers to the contract.
     */
    function() external {
        revert();
    }

    /**
     * @notice Returns the count of transactions for a specific token.
     * @dev This function is used to track the number of times a token has been deposited.
     * @param _token The address of the token.
     * @return The count of transactions for the token.
     */
    function count(address _token) public view returns (uint256) {
        return counts[_token];
    }

    /**
     * @notice Sets the deposit fee for the contract.
     * @dev Only the contract owner can call this function.
     * @param _fee The new deposit fee.
     */
    function setDepositFee(uint256 _fee) public onlyOwner {
        depositFee = _fee;
    }

    /**
     * @notice Deposits tokens or native currency into the contract for further processing.
     * @param _token The address of the token to deposit (use address(0) for native currency).
     * @param _to The recipient address for the deposited amount (must not be zero).
     * @param _amount The amount of tokens or native currency to deposit.
     * @dev
     * - Validates the destination address is not zero.
     * - Handles both native currency and ERC20 tokens.
     * - Applies deposit fee and checks against minimum/maximum allowed amounts.
     * - Routes deposits to designated safes or burns tokens if no safe is configured.
     * - Emits a Receipt event upon successful deposit.
     */
    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {
        require(_to != address(0), "invalid destination");
        
        uint256 fee = depositFee;
        address safe;
        bool shouldBurn = true;

        for (uint256 i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                require(_amount >= tokenLists[i].minAmount(_token), "amount is too small");
                require(_amount <= tokenLists[i].maxAmount(_token), "amount is too large");
                safe = tokenSafes[i];
                shouldBurn = false;
                break;
            }
        }

        if (_token == address(0)) {
            require(msg.value == _amount + fee, "incorrect native token amount");
            if (fee > 0) {
                // fee stays in the contract
            }
            if (address(wrappedCoin) != address(0)) {
                wrappedCoin.deposit.value(_amount)();
                if (safe != address(0)) {
                    require(safeTransfer(address(wrappedCoin), safe, _amount), "safe transfer failed");
                } else {
                    // burn wrapped token if there's no safe
                    (bool success,) = address(wrappedCoin).call(abi.encodeWithSelector(0x42966c68, _amount));
                    require(success, "burn failed");
                }
            }
        } else {
            if (fee > 0) {
                require(msg.value == fee, "incorrect fee");
            }
            if (safe != address(0)) {
                require(safeTransferFrom(_token, msg.sender, safe, _amount), "safe transfer from failed");
            } else if (shouldBurn) {
                require(safeTransferFrom(_token, msg.sender, address(this), _amount), "transfer to burn failed");
                // burn token
                (bool success,) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));
                require(success, "burn failed");
            } else {
                revert("token not allowed");
            }
        }

        uint256 id = counts[_token]++;
        emit Receipt(_token, id, msg.sender, _to, _amount, fee);
    }

    /**
     * @notice Allows a user to deposit a specified amount of a token to themselves.
     * @dev This function is a convenience wrapper for `depositTo` where the recipient is the sender.
     * @param _token The address of the token to deposit.
     * @param _amount The amount of the token to deposit.
     */
    function deposit(address _token, uint256 _amount) public payable {
        depositTo(_token, msg.sender, _amount);
    }

    /**
     * @notice Allows the contract owner to withdraw all ETH from the contract.
     * @dev This function ensures that only the owner can withdraw funds.
     */
    function withdraw() external onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    /**
     * @notice Allows the contract owner to withdraw all tokens of a specified type.
     * @param _token The address of the token to withdraw.
     * @dev Uses the standard ERC20 balanceOf selector (0x70a08231) and transfer selector (0xa9059cbb)
     */
    function withdrawToken(address _token) public onlyOwner {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x70a08231, address(this)));
        require(success, "balanceOf failed");
        
        uint256 balance = abi.decode(data, (uint256));
        if (balance > 0) {
            require(safeTransfer(_token, owner, balance), "transfer failed");
        }
    }

    /**
     * @notice Safely transfers tokens from a specified address to another address.
     * @param _token The address of the token to transfer.
     * @param _from The address to transfer tokens from.
     * @param _to The address to transfer tokens to.
     * @param _amount The amount of tokens to transfer.
     * @return bool True if the transfer was successful, false otherwise.
     */
    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }

    /**
     * @notice Safely transfers tokens from the contract to a specified address.
     * @param _token The address of the token to transfer.
     * @param _to The address to transfer tokens to.
     * @param _amount The amount of tokens to transfer.
     * @return bool True if the transfer was successful, false otherwise.
     */
    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }
}
```