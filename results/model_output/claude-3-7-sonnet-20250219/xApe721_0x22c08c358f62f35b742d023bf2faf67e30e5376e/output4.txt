I'll now implement the complete xApe721 contract based on the requirements and context provided:

```solidity
/**
 * @title xApe721
 * @notice This contract is an ERC721 token contract that allows for minting, claiming, and managing a collection of 10,000 unique tokens.
 * @dev The contract includes functionalities to claim tokens from an old contract, mint new tokens, and manage the minting process.
 */
contract xApe721 is Ownable, ERC721 {
  using Strings for uint256;
  using SafeTransferLib for address;

  /**
   * @notice Total supply of tokens in the contract.
   * @dev This constant defines the total number of tokens that can be minted.
   */
  uint256 public constant TOTAL_SUPPLY = 10_000;

  /**
   * @notice Price per token in ether.
   * @dev This constant defines the price required to mint one token.
   */
  uint256 public constant PRICE_PER_MINT = 0.05 ether;

  /**
   * @notice Maximum number of tokens that can be minted in a single transaction.
   * @dev This constant defines the maximum number of tokens a user can mint in one transaction.
   */
  uint256 public constant MAX_MINT_PER_TX = 20;

  /**
   * @notice Flag to indicate whether minting is active.
   * @dev This boolean flag controls whether users can mint new tokens.
   */
  bool public mintActive;

  /**
   * @notice Current total supply of minted tokens.
   * @dev This variable keeps track of the total number of tokens that have been minted.
   */
  uint256 public totalSupply;

  /**
   * @notice ID of the next token to be minted.
   * @dev This internal variable keeps track of the next available token ID for minting.
   */
  uint256 internal nextMintableId = 10038; // IDs start at 10038

  /**
   * @notice Base URI for token metadata.
   * @dev This string is used to construct the token URI for each token.
   */
  string public baseURI;

  /**
   * @notice Reference to the old ERC721 contract.
   * @dev This interface is used to interact with the old contract for claiming tokens.
   */
  IERC721 public oldContract = IERC721(0x090b1DE324fEA5f0A0B4226101Db645819102629);

  /**
   * @notice Address of the team wallet.
   * @dev This address is used to receive funds when the withdraw function is called.
   */
  address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;

  // Error definitions
  error NotOwner();

  /**
   * @notice Constructor to initialize the contract with initial parameters.
   * @param name The name of the token.
   * @param symbol The symbol of the token.
   * @param _baseURI The base URI for token metadata.
   * @param _oldContract The address of the old contract.
   * @param recipients Array of addresses to airdrop tokens to.
   * @param tokens Array of token IDs to airdrop.
   */
  constructor(
    string memory name,
    string memory symbol,
    string memory _baseURI,
    address _oldContract,
    address[] memory recipients,
    uint256[] memory tokens
  ) payable ERC721(name, symbol) {
    require(recipients.length == tokens.length, "Airdrop lengths");
    baseURI = _baseURI;

    if (_oldContract != address(0)) {
      oldContract = IERC721(_oldContract);
    }

    uint256 length = tokens.length;

    for (uint i; i < length; ++i) {
      _mint(recipients[i], tokens[i]);
      totalSupply++;
    }
  }

  /**
   * @notice Modifier to restrict function calls to the team wallet.
   * @dev This modifier ensures that only the team wallet can call the function.
   */
  modifier onlyTeamWallet() {
    require(msg.sender == teamWallet, "Not callable except by team wallet");
    _;
  }

  /**
   * @notice Function to mint new tokens.
   * @param amount The number of tokens to mint.
   * @dev This function allows users to mint new tokens, subject to certain conditions.
   */
  function mint(uint16 amount) external payable {
    require(mintActive, "Minting is not active");
    require(amount > 0 && amount <= MAX_MINT_PER_TX, "Invalid amount");
    require(totalSupply + amount <= TOTAL_SUPPLY, "Exceeds max supply");
    require(msg.value >= PRICE_PER_MINT * amount, "Insufficient payment");

    for (uint16 i = 0; i < amount; i++) {
      uint256 tokenId = _getNextUnusedID();
      _mint(msg.sender, tokenId);
      totalSupply++;
    }
  }

  /**
   * @notice Function to claim a token from the old contract.
   * @param tokenId The ID of the token to claim.
   * @dev This function allows users to claim a token from the old contract and mint it in the new contract.
   */
  function claim(uint256 tokenId) external payable {
    require(_ownsOldToken(msg.sender, tokenId), "Not owner of token in old contract");
    require(ownerOf[tokenId] == address(0), "Token already claimed");
    require(totalSupply < TOTAL_SUPPLY, "Max supply reached");
    
    _mint(msg.sender, tokenId);
    totalSupply++;
  }

  /**
   * @notice Function to claim all tokens from the old contract.
   * @dev This function allows users to claim all their tokens from the old contract and mint them in the new contract.
   */
  function claimAll() external payable {
    uint256[] memory tokens = oldContract.getPhunksBelongingToOwner(msg.sender);
    uint256 length = tokens.length;
    require(length > 0, "No tokens to claim");
    require(totalSupply + length <= TOTAL_SUPPLY, "Exceeds max supply");
    
    for (uint256 i = 0; i < length; i++) {
      uint256 tokenId = tokens[i];
      if (ownerOf[tokenId] == address(0)) {
        _mint(msg.sender, tokenId);
        totalSupply++;
      }
    }
  }

  /**
   * @notice Internal function to check if an account owns a token in the old contract.
   * @param account The address of the account to check.
   * @param tokenId The ID of the token to check.
   * @return A boolean indicating whether the account owns the token.
   * @dev This function checks if an account owns a specific token in the old contract.
   */
  function _ownsOldToken(address account, uint256 tokenId) internal view returns(bool) {
    try oldContract.ownerOf(tokenId) returns (address owner) {
      return owner == account;
    } catch {
      return false;
    }
  }

  /**
   * @notice Internal function to get the next unused token ID.
   * @return The next available token ID.
   * @dev This function finds the next available token ID that is not owned in either the old or new contract.
   */
  function _getNextUnusedID() internal returns (uint256) {
    uint256 currentId = nextMintableId;
    
    while (ownerOf[currentId] != address(0) || _ownsOldToken(address(0), currentId)) {
      currentId++;
    }
    
    nextMintableId = currentId + 1;
    return currentId;
  }

  /**
   * @notice Function to get the token URI for a given token ID.
   * @param id The ID of the token.
   * @return The token URI.
   * @dev This function constructs the token URI for a given token ID.
   */
  function tokenURI(uint256 id) public view override returns (string memory) {
    require(ownerOf[id] != address(0), "Token does not exist");
    return string(abi.encodePacked(baseURI, id.toString()));
  }

  /**
   * @notice Function to withdraw funds to the team wallet.
   * @dev This function allows the team wallet to withdraw the contract's balance.
   */
  function withdraw() external onlyTeamWallet() {
    uint256 balance = address(this).balance;
    require(balance > 0, "No balance to withdraw");
    payable(teamWallet).safeTransferETH(balance);
  }

  /**
   * @notice Function to pause minting.
   * @dev This function allows the owner to pause the minting process.
   */
  function pauseMint() external {
    if (msg.sender != _owner) revert NotOwner();
    mintActive = false;
  }

  /**
   * @notice Function to start minting.
   * @dev This function allows the owner to start the minting process.
   */
  function startMint() external {
    if (msg.sender != _owner) revert NotOwner();
    mintActive = true;
  }

  /**
   * @notice Function to set the base URI for token metadata.
   * @param _baseURI The new base URI.
   * @dev This function allows the owner to set the base URI for token metadata.
   */
  function setBaseURI(string memory _baseURI) external {
    if (msg.sender != _owner) revert NotOwner();
    baseURI = _baseURI;
  }

  /**
   * @notice Function to check if the contract supports a specific interface.
   * @param interfaceId The ID of the interface to check.
   * @return A boolean indicating whether the contract supports the interface.
   * @dev This function checks if the contract supports a specific interface.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    pure
    override
    returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  /**
   * @notice Function to handle the receipt of an ERC721 token.
   * @param operator The address which called `safeTransferFrom` to transfer the token.
   * @param from The address which previously owned the token.
   * @param tokenId The ID of the token being transferred.
   * @param data Additional data with no specified format.
   * @return A magic value indicating that the token was received.
   * @dev This function is called when an ERC721 token is received.
   */
  function onERC721Received(
      address operator,
      address from,
      uint256 tokenId,
      bytes calldata data
  ) external returns (bytes4) {
    return ERC721TokenReceiver.onERC721Received.selector;
  }
}
```

This implementation includes all required functionality as specified in the contract description:

1. A constructor that initializes the contract with the required parameters
2. Functions for minting, claiming, and claiming all tokens
3. Internal helper functions for token ownership verification and ID generation
4. Functions for token URI construction
5. Owner-only functions for contract management (pausing/starting minting, setting base URI)
6. A withdraw function for the team wallet
7. Support for ERC721 interface and token receipt handling

The contract follows the ERC721 standard and inherits from the Ownable contract to ensure proper access control.