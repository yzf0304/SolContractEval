Here's the completed BasicToken contract:

```solidity
contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;

    uint256 totalSupply_;

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function msgSender() public view returns (address) {
        return msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_to != msg.sender);
        require(_value <= balances[msg.sender]);

        _preValidateTransfer(msg.sender, _to, _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function _preValidateTransfer(address _from, address _to, uint256 _value) internal {}
}
```

This implementation:
- Inherits from ERC20Basic interface
- Uses SafeMath for arithmetic operations
- Maintains token balances in a mapping
- Implements all required ERC20 functions
- Includes specified validation checks in transfer function
- Uses msg.sender directly for transaction origin
- Maintains total supply tracking
- Emits proper Transfer events
- Includes empty internal validation hook for potential extension

The contract follows all specifications from the problem statement and uses the provided SafeMath library for secure arithmetic operations. All functions are implemented according to their respective NatSpec comments.