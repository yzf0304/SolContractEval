Here is the complete implementation of the BasicToken contract based on the provided context and requirements:

```solidity
pragma solidity ^0.4.25;

contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;
    uint256 totalSupply_;

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function msgSender() public view returns (address) {
        return msg.sender;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != address(0));
        require(_to != msg.sender);

        _preValidateTransfer(msg.sender, _to, _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function _preValidateTransfer(address _from, address _to, uint256 _value) internal {
        // No additional validation in base implementation
    }
}
```

This implementation:
1. Returns total token supply through totalSupply()
2. Provides message sender address through msgSender()
3. Implements ERC20 transfer with SafeMath operations
4. Includes required validations from the problem description
5. Uses SafeMath for secure arithmetic operations
6. Maintains ERC20 compliance through the Transfer event
7. Follows Solidity 0.4.25 syntax and features

The contract assumes the total supply and initial balances will be set through a constructor (which is not shown here to match the original code structure provided). For full functionality, a constructor should be added to initialize the token supply in a real-world implementation.