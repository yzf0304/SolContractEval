To solve this problem, we need to create a smart contract that allows the owner to freeze and unfreeze specific addresses. This contract will inherit from the Ownable contract, ensuring that only the owner can perform these operations. The contract will also emit events when an address is frozen or unfrozen and provide a method to check the frozen status of an address.

### Approach
1. **Inheritance**: The Freezable contract inherits from the Ownable contract to leverage the ownership model provided by Ownable.
2. **State Management**: Use a mapping to track the frozen status of addresses.
3. **Modifiers**: Implement a modifier to check if an address is not frozen before allowing certain operations.
4. **Events**: Emit events when an address is frozen or unfrozen to provide transparency.
5. **Access Control**: Ensure that only the owner can call the freeze and unfreeze functions.
6. **Error Handling**: Include checks to prevent redundant state changes and provide meaningful error messages.

### Solution Code
```solidity
contract Freezable is Ownable {
    mapping(address => bool) private _frozen;

    event Freeze(address indexed target);
    event Unfreeze(address indexed target);

    modifier whenNotFrozen(address target) {
        require(!_frozen[target], "Freezable : target is frozen");
        _;
    }

    function freeze(address target) external onlyOwner returns (bool success) {
        require(!_frozen[target], "Freezable : target already frozen");
        _frozen[target] = true;
        emit Freeze(target);
        success = true;
    }

    function unFreeze(address target)
        external
        onlyOwner
        returns (bool success)
    {
        require(_frozen[target], "Freezable : target not frozen");
        _frozen[target] = false;
        emit Unfreeze(target);
        success = true;
    }

    function isFrozen(address target)
        external
        view
        returns (bool frozen)
    {
        frozen = _frozen[target];
    }
}
```

### Explanation
1. **Inheritance**: The contract `Freezable` inherits from `Ownable`, giving it access to the `onlyOwner` modifier and ownership management functions.
2. **State Management**: The `_frozen` mapping tracks whether each address is frozen (true) or not (false).
3. **Modifier**: `whenNotFrozen` checks if the target address is not frozen before proceeding with the function execution.
4. **Events**: `Freeze` and `Unfreeze` events are emitted when an address is frozen or unfrozen, respectively, providing a log of these actions.
5. **Freeze Function**: The `freeze` function allows the owner to set an address's frozen status to true if it is not already frozen, emitting a `Freeze` event.
6. **Unfreeze Function**: The `unFreeze` function allows the owner to set an address's frozen status to false if it is currently frozen, emitting an `Unfreeze` event.
7. **Check Function**: `isFrozen` allows any user to check if an address is frozen by querying the `_frozen` mapping.

This approach ensures that only the owner can freeze or unfreeze addresses, prevents redundant state changes, and maintains transparency through event logging.