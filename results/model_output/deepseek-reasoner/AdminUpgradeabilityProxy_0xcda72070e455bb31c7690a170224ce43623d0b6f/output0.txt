Here's the complete implementation of the `UpgradeabilityProxy` contract:

```solidity
contract UpgradeabilityProxy is Proxy {
  
  constructor(address _logic, bytes memory _data) public payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if(_data.length > 0) {
      (bool success,) = _logic.delegatecall(_data);
      require(success);
    }
  }

  event Upgraded(address indexed implementation);

  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  function _implementation() internal override view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  function _setImplementation(address newImplementation) internal {
    require(Address.isContract(newImplementation), "UpgradeabilityProxy: new implementation is not a contract");
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      sstore(slot, newImplementation)
    }
  }

  receive() external payable {}
}
```

This implementation:
1. Reads the implementation address from the EIP-1967 storage slot
2. Validates new implementations are contracts using the provided Address library
3. Properly stores implementation addresses using assembly-level storage operations
4. Emits upgrade events when implementations change
5. Maintains compatibility with the proxy pattern through proper inheritance and function overrides

The contract follows all EIP-1967 standards for upgradeable proxies and includes necessary safety checks while maintaining compatibility with Solidity 0.6.8.