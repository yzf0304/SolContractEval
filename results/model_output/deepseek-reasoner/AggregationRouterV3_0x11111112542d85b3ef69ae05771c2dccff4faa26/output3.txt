```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

contract AggregationRouterV3 is Ownable, UnoswapRouter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    using UniERC20 for IERC20;

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    function discountedSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft, uint256 chiSpent)
    {
        uint256 initialGas = gasleft();

        (returnAmount, gasLeft) = swap(caller, desc, data);

        uint256 gasUsed = initialGas - gasLeft;
        (IChi chi, uint256 amount) = caller.calculateGas(gasUsed, desc.flags, data);

        if (address(chi) != address(0) && amount > 0) {
            if (desc.flags & _BURN_FROM_TX_ORIGIN != 0) {
                chiSpent = chi.freeFromUpTo(tx.origin, amount);
            } else {
                chiSpent = chi.freeFromUpTo(msg.sender, amount);
            }
        }
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft)
    {
        require(desc.minReturnAmount > 0, "Min return should be > 0");
        require(desc.dstReceiver != address(0), "Invalid dstReceiver");

        _permit(desc.srcToken, desc.amount, desc.permit);

        uint256 initialSrcBalance;
        uint256 initialDstBalance = desc.dstToken.uniBalanceOf(address(this));

        if (desc.srcToken.isETH()) {
            if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
                require(msg.value >= desc.amount, "Insufficient ETH");
            } else {
                require(msg.value == desc.amount, "ETH amount mismatch");
            }
            if ((desc.flags & _PARTIAL_FILL) != 0) {
                initialSrcBalance = address(this).balance.sub(msg.value);
            }
        } else {
            require(msg.value == 0, "Msg.value not zero");
            initialSrcBalance = desc.srcToken.uniBalanceOf(address(this));
            desc.srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
            if ((desc.flags & _PARTIAL_FILL) != 0) {
                require(desc.srcReceiver == address(this), "Partial fill requires srcReceiver to be router");
            }
        }

        caller.callBytes{value: msg.value}(data);

        uint256 spentAmount = desc.amount;
        if ((desc.flags & _PARTIAL_FILL) != 0) {
            if (desc.srcToken.isETH()) {
                uint256 finalSrcBalance = address(this).balance;
                spentAmount = initialSrcBalance.add(msg.value).sub(finalSrcBalance);
                require(spentAmount <= desc.amount, "Spent too much");
                if (spentAmount < desc.amount) {
                    msg.sender.transfer(desc.amount - spentAmount);
                }
            } else {
                uint256 finalSrcBalance = desc.srcToken.uniBalanceOf(address(this));
                spentAmount = initialSrcBalance.add(desc.amount).sub(finalSrcBalance);
                require(spentAmount <= desc.amount, "Spent too much");
                if (spentAmount < desc.amount) {
                    desc.srcToken.uniTransfer(msg.sender, desc.amount - spentAmount);
                }
            }
        }

        returnAmount = desc.dstToken.uniBalanceOf(address(this)).sub(initialDstBalance);

        if ((desc.flags & _PARTIAL_FILL) != 0) {
            uint256 minReturn = desc.minReturnAmount.mul(spentAmount).div(desc.amount);
            require(returnAmount >= minReturn, "Return amount too low");
        } else {
            require(returnAmount >= desc.minReturnAmount, "Return amount not enough");
        }

        desc.dstToken.uniTransfer(desc.dstReceiver, returnAmount);

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            spentAmount,
            returnAmount
        );

        gasLeft = gasleft();
    }

    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {
        token.uniTransfer(msg.sender, amount);
    }

    function destroy() external onlyOwner {
        selfdestruct(payable(owner()));
    }
}
```