To solve this problem, we need to create a smart contract that facilitates token swaps and aggregations, leveraging existing libraries and interfaces for secure token operations. The contract should handle different swap scenarios, including ETH and ERC20 tokens, permit handling, gas discounts via CHI token burning, and fund rescue mechanisms. 

### Approach
The AggregationRouterV3 contract is designed to handle token swaps efficiently and securely. Key features include:
1. **Token Swaps**: Supports swapping ERC20 tokens and ETH, with optional permit handling for approvals.
2. **Gas Discounts**: Uses CHI tokens to reduce gas costs during swaps.
3. **Rescue and Destroy Functions**: Allows the owner to rescue funds and destroy the contract if necessary.

The contract uses the following steps:
1. **Input Validation**: Ensures valid input parameters for swaps.
2. **Permit Handling**: Uses EIP-2612 permits for token approvals if provided.
3. **Token Transfers**: Transfers the source token to the receiver, handling ETH and ERC20 tokens differently.
4. **Executor Call**: Executes the swap using the provided executor contract.
5. **Balance Checks**: Verifies the received amount meets the minimum required.
6. **CHI Burning**: Burns CHI tokens for gas discounts in discounted swaps.
7. **Fund Management**: Allows the owner to rescue funds and destroy the contract.

### Solution Code
```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.6.12;
pragma experimental ABIEncoderV2;

/**
 * @title AggregationRouterV3
 * @notice Facilitates token swaps with features like gas discounts and fund management.
 */
contract AggregationRouterV3 is Ownable, UnoswapRouter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    using UniERC20 for IERC20;

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    /**
     * @notice Executes a swap with gas discounts using CHI tokens.
     * @param caller The executor contract handling the swap.
     * @param desc Swap description including tokens, amounts, and flags.
     * @param data Calldata for the executor.
     * @return returnAmount Amount of dstToken received.
     * @return gasLeft Remaining gas after the swap.
     * @return chiSpent Amount of CHI tokens burned.
     */
    function discountedSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft, uint256 chiSpent)
    {
        uint256 initialGas = gasleft();

        (returnAmount, gasLeft) = swap(caller, desc, data);

        uint256 gasUsed = initialGas - gasLeft;
        (uint256 gasCost, uint16 discount) = caller.calculateGas(gasUsed);
        chiSpent = (gasCost * (10000 - discount)) / 10000;

        if (chiSpent > 0) {
            IChi chi = IChi(caller.chi());
            if (desc.flags & _BURN_FROM_MSG_SENDER != 0) {
                chi.freeFromUpTo(msg.sender, chiSpent);
            } else if (desc.flags & _BURN_FROM_TX_ORIGIN != 0) {
                chi.freeFromUpTo(tx.origin, chiSpent);
            } else {
                chi.free(chiSpent);
            }
        }
    }

    /**
     * @notice Executes a token swap.
     * @param caller The executor contract handling the swap.
     * @param desc Swap description including tokens, amounts, and flags.
     * @param data Calldata for the executor.
     * @return returnAmount Amount of dstToken received.
     * @return gasLeft Remaining gas after the swap.
     */
    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft)
    {
        require(desc.minReturnAmount > 0, "Min return must be >0");
        require(desc.amount > 0, "Amount must be >0");

        bool srcETH = desc.srcToken.isETH();
        if (srcETH) {
            if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
                require(msg.value > desc.amount, "Not enough ETH");
            } else {
                require(msg.value == desc.amount, "ETH amount mismatch");
            }
        } else {
            require(msg.value == 0, "ETH not required");
            if (desc.permit.length != 0) {
                _permit(desc.srcToken, desc.amount, desc.permit);
            }
        }

        if (srcETH) {
            desc.srcToken.uniTransfer(payable(desc.srcReceiver), desc.amount);
        } else if (desc.flags & _SHOULD_CLAIM != 0) {
            desc.srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, desc.amount);
        }

        uint256 initialDstBalance = desc.dstToken.uniBalanceOf(address(this));

        if (srcETH && (desc.flags & _REQUIRES_EXTRA_ETH != 0)) {
            uint256 ethRemaining = msg.value.sub(desc.amount);
            caller.callBytes{value: ethRemaining}(data);
        } else {
            caller.callBytes{value: 0}(data);
        }

        returnAmount = desc.dstToken.uniBalanceOf(address(this)).sub(initialDstBalance);

        if (desc.flags & _PARTIAL_FILL != 0) {
            require(returnAmount > 0, "Return amount is zero");
        } else {
            require(returnAmount >= desc.minReturnAmount, "Return amount not enough");
        }

        address dstReceiver = (desc.dstReceiver == address(0)) ? msg.sender : desc.dstReceiver;
        desc.dstToken.uniTransfer(payable(dstReceiver), returnAmount);

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            dstReceiver,
            desc.amount,
            returnAmount
        );

        gasLeft = gasleft();
    }

    /**
     * @notice Rescues funds from the contract.
     * @param token Token to rescue.
     * @param amount Amount to rescue.
     */
    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {
        token.uniTransfer(payable(msg.sender), amount);
    }

    /**
     * @notice Destroys the contract and sends remaining ETH to the owner.
     */
    function destroy() external onlyOwner {
        selfdestruct(payable(owner()));
    }
}
```

### Explanation
1. **Token Swaps**: The `swap` function handles transferring the source token, executing the swap via an executor, and ensuring the received amount meets the minimum requirement. It uses `uniTransfer` for safe token transfers and handles ETH conversions.
2. **Gas Discounts**: The `discountedSwap` function calculates gas usage and burns CHI tokens based on the executor's gas discount parameters, reducing transaction costs.
3. **Fund Management**: The `rescueFunds` and `destroy` functions allow the owner to manage funds and terminate the contract securely.

This approach ensures efficient and secure token swaps with flexible features for different use cases.