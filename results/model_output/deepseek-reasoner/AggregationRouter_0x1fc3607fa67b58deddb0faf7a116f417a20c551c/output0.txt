To solve this problem, we need to create a smart contract that aggregates and executes token swaps with various options. The contract should handle both ERC20 tokens and ETH, support permit-based approvals, manage partial fills, and allow for the rescue of funds by the owner. 

### Approach
1. **Input Validation**: Ensure that the minimum return amount is positive and that the data provided is non-empty.
2. **Handling Source Token**: Transfer the source token (either ETH or ERC20) from the user to the specified receiver. If the source token is an ERC20 token, handle permit-based approvals.
3. **Execute Swap**: Call the aggregator executor with the provided data and any remaining ETH.
4. **Calculate Return Amount**: Determine the amount of destination token received after the swap.
5. **Transfer Destination Token**: Send the received destination tokens to the specified receiver.
6. **Refund Remaining ETH**: Refund any leftover ETH to the user after the swap.
7. **Emit Events**: Emit events to log the swap details.
8. **Rescue Funds**: Allow the owner to rescue any tokens or ETH sent to the contract.

### Solution Code

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IERC20Permit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );
    event Exchange(address pair, uint256 amountOut, address output);

    constructor(address _WETH) public {
        WETH = _WETH;
    }

    receive() external payable {
        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "AggregationRouter: Invalid min return");
        require(data.length > 0, "AggregationRouter: Empty data");

        uint256 initialSrcBalance = getBalance(desc.srcToken, msg.sender);
        uint256 initialDstBalance = getBalance(desc.dstToken, address(this));

        if (isETH(desc.srcToken)) {
            require(msg.value >= desc.amount, "AggregationRouter: Insufficient ETH");
            TransferHelper.safeTransferETH(desc.srcReceiver, desc.amount);
        } else {
            if (desc.permit.length != 0) {
                _permit(desc.srcToken, desc.amount, desc.permit);
            }
            TransferHelper.safeTransferFrom(
                address(desc.srcToken),
                msg.sender,
                desc.srcReceiver,
                desc.amount
            );
        }

        if (desc.flags & _REQUIRES_EXTRA_ETH != 0) {
            require(msg.value > 0, "AggregationRouter: Extra ETH required");
        }

        uint256 remainingEth = address(this).balance;
        caller.callBytes{value: remainingEth}(data);

        uint256 dstBalance = getBalance(desc.dstToken, address(this));
        returnAmount = dstBalance.sub(initialDstBalance);

        require(returnAmount >= desc.minReturnAmount, "AggregationRouter: Return amount is less than min");

        if (isETH(desc.dstToken)) {
            TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);
        } else {
            TransferHelper.safeTransfer(address(desc.dstToken), desc.dstReceiver, returnAmount);
        }

        uint256 finalSrcBalance = getBalance(desc.srcToken, msg.sender);
        uint256 spentAmount = initialSrcBalance.sub(finalSrcBalance);

        uint256 remaining = address(this).balance;
        if (remaining > 0) {
            TransferHelper.safeTransferETH(msg.sender, remaining);
        }

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            spentAmount,
            returnAmount
        );

        return returnAmount;
    }

    function getBalance(IERC20 token, address account) internal view returns (uint256) {
        if (isETH(token)) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return (address(token) == ETH_ADDRESS);
    }

    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == ETH_ADDRESS) {
            TransferHelper.safeTransferETH(msg.sender, amount);
        } else {
            TransferHelper.safeTransfer(token, msg.sender, amount);
        }
    }
}
```

### Explanation
1. **Input Validation**: The swap function checks that the minimum return amount is positive and that the data is not empty.
2. **Handling Source Token**: If the source token is ETH, it ensures sufficient ETH is sent and transfers it. For ERC20 tokens, it handles permit-based approvals and transfers the tokens from the user.
3. **Execute Swap**: The aggregator executor is called with any remaining ETH to perform the swap.
4. **Calculate Return Amount**: The balance of the destination token before and after the swap is used to determine the return amount.
5. **Transfer Destination Token**: The received tokens are sent to the specified receiver.
6. **Refund Remaining ETH**: Any leftover ETH is refunded to the user.
7. **Emit Events**: The Swapped event logs the details of the swap.
8. **Rescue Funds**: The owner can rescue any tokens or ETH sent to the contract in case of errors.

This approach ensures that the contract handles various swap scenarios efficiently, including partial fills, permit approvals, and refunds, while maintaining security and correctness.