To solve this problem, we need to create a smart contract that aggregates and executes token swaps efficiently. The contract should handle both ERC20 tokens and ETH, support permit-based approvals, allow partial fills, and manage refunds of any leftover ETH. The solution must ensure security, efficiency, and compliance with the provided interface and context.

### Approach
1. **Input Validation**: Ensure the minimum return amount is positive and that swap data is provided.
2. **Handling ETH/WETH Conversion**: Convert ETH to WETH (Wrapped ETH) if the source token is ETH, ensuring proper handling of ETH sent with the transaction.
3. **Permit Handling**: Use permit signatures for ERC20 token approvals to avoid separate approval transactions.
4. **Token Transfers**: Transfer tokens from the appropriate sender (either `msg.sender` or `tx.origin`) based on the specified flags.
5. **Execute Swap**: Use the provided executor to perform the actual token swap, forwarding any necessary ETH.
6. **Calculate Return Amount**: Determine the amount of destination tokens received after the swap.
7. **Refund Leftover ETH**: Refund any remaining ETH to the user after the swap.
8. **Event Emission**: Emit events to log the swap details for transparency.

### Solution Code
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
    function totalSupply() external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 value) external returns (bool);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
}

interface IERC20Permit {
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
}

library TransferHelper {
    function safeApprove(address token, address to, uint256 value) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: APPROVE_FAILED");
    }

    function safeTransfer(address token, address to, uint256 value) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FAILED");
    }

    function safeTransferFrom(address token, address from, address to, uint256 value) internal {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FROM_FAILED");
    }

    function safeTransferETH(address to, uint256 value) internal {
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(success, "TransferHelper: ETH_TRANSFER_FAILED");
    }
}

library SafeMath {
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x, "ds-math-add-overflow");
    }

    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x, "ds-math-sub-underflow");
    }

    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b > 0, "ds-math-division-by-zero");
        c = a / b;
    }
}

library RevertReasonParser {
    function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {
        if (data.length >= 68 && data[0] == "\x08" && data[1] == "\xc3" && data[2] == "\x79" && data[3] == "\xa0") {
            string memory reason;
            assembly {
                reason := add(data, 68)
            }
            require(data.length >= 68 + bytes(reason).length, "Invalid revert reason");
            return string(abi.encodePacked(prefix, "Error(", reason, ")"));
        } else if (data.length == 36 && data[0] == "\x4e" && data[1] == "\x48" && data[2] == "\x7b" && data[3] == "\x71") {
            uint256 code;
            assembly {
                code := mload(add(data, 36))
            }
            return string(abi.encodePacked(prefix, "Panic(", _toHex(code), ")"));
        }
        return string(abi.encodePacked(prefix, "Unknown(", _toHex(data), ")"));
    }

    function _toHex(uint256 value) private pure returns (string memory) {
        return _toHex(abi.encodePacked(value));
    }

    function _toHex(bytes memory data) private pure returns (string memory) {
        bytes16 alphabet = 0x30313233343536373839616263646566;
        bytes memory str = new bytes(2 + data.length * 2);
        str[0] = "0";
        str[1] = "x";
        for (uint256 i = 0; i < data.length; i++) {
            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];
            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];
        }
        return string(str);
    }
}

contract Permitable {
    event Error(string reason);

    function _permit(IERC20 token, uint256 amount, bytes calldata permit) internal {
        if (permit.length == 32 * 7) {
            (bool success, bytes memory result) = address(token).call(abi.encodePacked(IERC20Permit.permit.selector, permit));
            if (!success) {
                string memory reason = RevertReasonParser.parse(result, "Permit call failed: ");
                if (token.allowance(msg.sender, address(this)) < amount) {
                    revert(reason);
                } else {
                    emit Error(reason);
                }
            }
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_msgSender() == _owner, "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IAggregationExecutor {
    function callBytes(bytes calldata data) external payable;
}

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    event Exchange(address pair, uint256 amountOut, address output);

    constructor(address _WETH) {
        WETH = _WETH;
    }

    receive() external payable {
        require(msg.sender == WETH, "Router: NOT_WETH");
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "Min return must be >0");
        require(data.length > 0, "Data must be provided");

        uint256 flags = desc.flags;
        bool isSrcETH = isETH(desc.srcToken);
        uint256 msgValue = msg.value;

        if (isSrcETH) {
            if (flags & _REQUIRES_EXTRA_ETH != 0) {
                require(msgValue >= desc.amount, "Insufficient ETH");
            } else {
                require(msgValue == desc.amount, "ETH amount mismatch");
            }
            IWETH(WETH).deposit{value: desc.amount}();
            TransferHelper.safeTransfer(WETH, desc.srcReceiver, desc.amount);
        } else {
            if (flags & _REQUIRES_EXTRA_ETH == 0) {
                require(msgValue == 0, "ETH not required");
            }
            if (desc.permit.length != 0) {
                _permit(desc.srcToken, desc.amount, desc.permit);
            }
            address from = (flags & _BURN_FROM_TX_ORIGIN) != 0 ? tx.origin : msg.sender;
            TransferHelper.safeTransferFrom(address(desc.srcToken), from, desc.srcReceiver, desc.amount);
        }

        uint256 initialDstBalance = getBalance(desc.dstToken, address(this));
        uint256 ethValueToSend = isSrcETH ? msgValue.sub(desc.amount) : msgValue;

        caller.callBytes{value: ethValueToSend}(data);

        returnAmount = getBalance(desc.dstToken, address(this)).sub(initialDstBalance);
        require(returnAmount >= desc.minReturnAmount, "Return amount too low");

        if (isETH(desc.dstToken)) {
            TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);
        } else {
            TransferHelper.safeTransfer(address(desc.dstToken), desc.dstReceiver, returnAmount);
        }

        uint256 leftoverEth = address(this).balance;
        if (leftoverEth > 0) {
            TransferHelper.safeTransferETH(msg.sender, leftoverEth);
        }

        emit Swapped(msg.sender, desc.srcToken, desc.dstToken, desc.dstReceiver, desc.amount, returnAmount);
    }

    function getBalance(IERC20 token, address account) internal view returns (uint256) {
        return isETH(token) ? account.balance : token.balanceOf(account);
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == ETH_ADDRESS) {
            TransferHelper.safeTransferETH(msg.sender, amount);
        } else {
            TransferHelper.safeTransfer(token, msg.sender, amount);
        }
    }
}
```

### Explanation
1. **Input Validation**: The swap function checks that the minimum return amount is positive and that swap data is provided to ensure valid inputs.
2. **ETH/WETH Handling**: If the source token is ETH, it converts ETH to WETH and transfers it to the source receiver. This allows the contract to interact seamlessly with ERC20-based swaps.
3. **Permit Handling**: The contract uses the `_permit` function to handle ERC20 token approvals via signatures, reducing the need for separate transactions.
4. **Token Transfers**: Tokens are transferred from either `msg.sender` or `tx.origin` based on the specified flags, allowing flexibility in token sourcing.
5. **Execute Swap**: The provided executor contract is called with the necessary ETH value, forwarding any required ETH for the swap.
6. **Return Amount Calculation**: The contract calculates the received amount of the destination token and ensures it meets the minimum required.
7. **Refund Leftover ETH**: Any leftover ETH after the swap is refunded to the user, ensuring no ETH is unnecessarily locked in the contract.
8. **Events**: The `Swapped` event logs the details of the swap for transparency and tracking purposes.

This approach ensures that the contract efficiently handles token swaps with various configurations while maintaining security and flexibility.