To solve this problem, we need to create a smart contract that aggregates and executes token swaps with various options, including handling ETH, ERC20 tokens, partial fills, and permit-based transfers. The contract should also allow the owner to rescue funds if necessary.

### Approach
1. **Permit Handling**: Use the `Permitable` contract to handle ERC20 permit functionality, allowing users to approve token transfers via signatures.
2. **Token Transfers**: Transfer ERC20 tokens using `safeTransferFrom` and handle ETH transfers directly. The `BURN_FROM` flags determine the source of the tokens (either `msg.sender` or `tx.origin`).
3. **Swap Execution**: Execute the swap via an aggregator executor contract, sending the required ETH along with the call.
4. **Balance Calculation**: Calculate the return amount by comparing the contract's balance before and after the swap. For ETH, unwrap any WETH received during the swap.
5. **Refunds**: Refund any remaining ETH to the user after the swap.
6. **Events**: Emit events to log successful swaps and allow tracking of transactions.
7. **Rescue Function**: Enable the contract owner to rescue any ERC20 tokens or ETH stuck in the contract.

### Solution Code
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.7.6;

interface IERC20Permit {
    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
}

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    event Exchange(address pair, uint256 amountOut, address output);

    constructor(address _WETH) public {
        WETH = _WETH;
    }

    receive() external payable {
        require(msg.sender != tx.origin, "ETH deposit rejected");
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "Min return should be > 0");
        require(data.length > 0, "Data should not be empty");

        uint256 flags = desc.flags;

        if (!isETH(desc.srcToken)) {
            if (desc.permit.length != 0) {
                _permit(desc.srcToken, desc.amount, desc.permit);
            }
            address from = (flags & _BURN_FROM_TX_ORIGIN) != 0 ? tx.origin : msg.sender;
            TransferHelper.safeTransferFrom(
                address(desc.srcToken),
                from,
                desc.srcReceiver,
                desc.amount
            );
        } else {
            require(msg.value >= desc.amount, "Insufficient ETH");
        }

        uint256 ethAmount;
        if (flags & _REQUIRES_EXTRA_ETH != 0) {
            ethAmount = msg.value;
            if (isETH(desc.srcToken)) {
                require(msg.value >= desc.amount, "Insufficient ETH including extra");
            }
        } else {
            ethAmount = isETH(desc.srcToken) ? desc.amount : 0;
            if (isETH(desc.srcToken)) {
                require(msg.value == desc.amount, "ETH amount mismatch");
            }
        }

        uint256 initialEthBalance;
        uint256 initialDstBalance;

        if (isETH(desc.dstToken)) {
            initialEthBalance = address(this).balance;
        } else {
            initialDstBalance = getBalance(desc.dstToken, address(this));
        }

        caller.callBytes{value: ethAmount}(data);

        if (isETH(desc.dstToken)) {
            uint256 wethBalance = IERC20(WETH).balanceOf(address(this));
            if (wethBalance > 0) {
                (bool success, ) = WETH.call(abi.encodeWithSelector(0x2e1a7d4d, wethBalance));
                require(success, "WETH withdraw failed");
            }
            uint256 currentEthBalance = address(this).balance;
            returnAmount = currentEthBalance + ethAmount - initialEthBalance;
        } else {
            returnAmount = getBalance(desc.dstToken, address(this)) - initialDstBalance;
        }

        require(returnAmount >= desc.minReturnAmount, "Return amount is too low");

        if (isETH(desc.dstToken)) {
            TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);
        } else {
            TransferHelper.safeTransfer(address(desc.dstToken), desc.dstReceiver, returnAmount);
        }

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            isETH(desc.srcToken) ? ethAmount : desc.amount,
            returnAmount
        );

        uint256 refundAmount = address(this).balance;
        if (refundAmount > 0) {
            TransferHelper.safeTransferETH(msg.sender, refundAmount);
        }

        return returnAmount;
    }

    function getBalance(IERC20 token, address account) internal view returns (uint256) {
        if (isETH(token)) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            TransferHelper.safeTransferETH(msg.sender, amount);
        } else {
            TransferHelper.safeTransfer(token, msg.sender, amount);
        }
    }
}
```

### Explanation
1. **Permit Handling**: The contract uses the `_permit` function from `Permitable` to handle ERC20 token approvals via signatures, reducing the need for separate transactions.
2. **Token Transfers**: Depending on whether the token is ETH or an ERC20, the contract either checks the sent ETH value or transfers the ERC20 tokens using `safeTransferFrom`.
3. **Swap Execution**: The contract calls the executor's `callBytes` function with the necessary ETH value, which performs the actual swap logic.
4. **Balance Calculation**: The return amount is calculated by comparing the contract's balance before and after the swap. For ETH, any WETH received is unwrapped to ETH.
5. **Refunds**: Any remaining ETH after the swap is refunded to the user.
6. **Events**: The `Swapped` event logs the details of each successful swap for transparency and tracking.
7. **Rescue Function**: The owner can rescue any stuck funds, ensuring the contract can recover from unexpected issues.

This approach ensures efficient and secure token swaps with flexibility for various swap parameters and conditions.