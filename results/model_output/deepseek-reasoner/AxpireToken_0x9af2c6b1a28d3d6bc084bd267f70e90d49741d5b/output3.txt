To complete the AxpireToken contract, we need to integrate both ERC20 and ERC223 standards. Here's the final implementation:

```solidity
pragma solidity ^0.4.20;

contract AxpireToken is ERC223, ERC20 {
    uint256 initialSupply = 350000000 * 10**8;
    string tokenName = "aXpire Token";
    string tokenSymbol = "AXP";
    uint8 decimalUnits = 8;

    function AxpireToken() public 
    ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol) 
    {
        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;
        balances[owner] = initialSupply;
        totalSupply = initialSupply;
    }

    // ERC223 Transfer functions
    function transfer(address to, uint256 value, bytes data) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data);
    }

    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data, true, customFallback);
    }

    // Override ERC20 transferFrom for SafeMath operations
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowed[_from][msg.sender] >= _value);
        bool _success = transferInternal(_from, _to, _value);
        require(_success);
        allowed[_from][msg.sender] -= _value;
        return true;
    }

    // Internal transfer handlers with ERC223 logic
    function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool) {
        bool transferSuccess = super.transferInternal(from, to, value);
        require(transferSuccess);
        emit Transfer(from, to, value, data);
        handleContractRecipient(to, from, value, data, false, "");
        return true;
    }

    function transferInternal(
        address from,
        address to,
        uint256 value,
        bytes data,
        bool useCustomFallback,
        string customFallback
    ) internal returns (bool) {
        bool transferSuccess = super.transferInternal(from, to, value);
        require(transferSuccess);
        emit Transfer(from, to, value, data);
        handleContractRecipient(to, from, value, data, useCustomFallback, customFallback);
        return true;
    }

    // Maintain original ERC20 transfer functionality
    function transferInternal(address from, address to, uint256 value) internal returns (bool) {
        return super.transferInternal(from, to, value);
    }

    // Contract detection and fallback handling
    function handleContractRecipient(
        address to,
        address from,
        uint256 value,
        bytes data,
        bool useCustom,
        string customFallback
    ) private {
        if (!isContract(to)) return;
        
        if (useCustom) {
            bytes memory payload = abi.encodeWithSignature(customFallback, from, value, data);
            require(to.call.gas(50000)(payload));
        } else {
            ContractReceiver receiver = ContractReceiver(to);
            receiver.tokenFallback(from, value, data);
        }
    }

    function isContract(address _addr) private view returns (bool) {
        uint256 codeSize;
        assembly { codeSize := extcodesize(_addr) }
        return codeSize > 0;
    }
}
```

### Key Features:
1. **Dual Standard Compliance**: Implements both ERC20 and ERC223 standards for maximum compatibility.
2. **Safe Transfers**: Uses SafeMath for arithmetic operations to prevent overflows/underflows.
3. **Contract Detection**: Automatically detects contract addresses and executes appropriate fallback functions.
4. **Custom Fallbacks**: Supports both standard tokenFallback and custom-named fallback functions.
5. **Gas Efficiency**: Limits gas for fallback execution to prevent out-of-gas attacks (50000 gas limit).
6. **Backwards Compatibility**: Maintains original ERC20 functionality while adding ERC223 features.

The contract maintains full compatibility with existing ERC20 wallets and exchanges while adding the enhanced functionality of ERC223 for safer contract interactions.