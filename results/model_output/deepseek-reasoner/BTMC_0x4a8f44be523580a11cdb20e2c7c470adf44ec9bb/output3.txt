Here is the complete implementation of the BTMC contract based on the provided context and requirements:

```solidity
pragma solidity ^0.4.22;

contract BTMC is ERC20, Ownable, Pausable {
    using SafeMath for uint256;

    string public constant name = "MinerCoin";
    string public constant symbol = "BTMC";
    string public constant version = "1.0";
    uint256 public constant decimals = 18;

    uint256 public constant INIT_SUPPLY = 100000000 * 10**decimals;
    uint256 public constant MINING_SUPPLY = 500000000 * 10**decimals;
    uint256 public constant MAX_FUNDING_SUPPLY = 200000000 * 10**decimals;
    uint256 public constant TEAM_KEEPING = 200000000 * 10**decimals;
    uint256 public constant MAX_SUPPLY = INIT_SUPPLY + MINING_SUPPLY + MAX_FUNDING_SUPPLY + TEAM_KEEPING;

    uint256 public totalFundingSupply;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public rate;

    uint256 public constant TEAM_UNFREEZE = 40000000 * 10**decimals;
    bool public hasOneStepWithdraw;
    bool public hasTwoStepWithdraw;
    bool public hasThreeStepWithdraw;
    bool public hasFourStepWithdraw;
    bool public hasFiveStepWithdraw;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function BTMC() public {
        totalSupply = INIT_SUPPLY;
        balances[msg.sender] = INIT_SUPPLY;
        emit Transfer(address(0), msg.sender, INIT_SUPPLY);
        totalFundingSupply = 0;
        startTime = 1524499199;
        endTime = 1526313600;
        rate = 5000;
        hasOneStepWithdraw = false;
        hasTwoStepWithdraw = false;
        hasThreeStepWithdraw = false;
        hasFourStepWithdraw = false;
        hasFiveStepWithdraw = false;
    }

    event CreateBTMC(address indexed _to, uint256 _value);

    modifier notReachTotalSupply(uint256 _value, uint256 _rate) {
        require(MAX_SUPPLY >= totalSupply.add(_value.mul(_rate)));
        _;
    }

    modifier notReachFundingSupply(uint256 _value, uint256 _rate) {
        require(MAX_FUNDING_SUPPLY >= totalFundingSupply.add(_value.mul(_rate)));
        _;
    }

    modifier assertFalse(bool withdrawStatus) {
        require(!withdrawStatus);
        _;
    }

    modifier notBeforeTime(uint256 targetTime) {
        require(now > targetTime);
        _;
    }

    modifier notAfterTime(uint256 targetTime) {
        require(now <= targetTime);
        _;
    }

    function etherProceeds() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    function processFunding(address receiver, uint256 _value, uint256 _rate) internal notReachTotalSupply(_value, _rate) {
        uint256 tokens = _value.mul(_rate);
        totalSupply = totalSupply.add(tokens);
        balances[receiver] = balances[receiver].add(tokens);
        emit CreateBTMC(receiver, tokens);
        emit Transfer(address(0), receiver, tokens);
    }

    function funding(address receiver, uint256 _value, uint256 _rate) internal notReachFundingSupply(_value, _rate) {
        uint256 tokens = _value.mul(_rate);
        totalFundingSupply = totalFundingSupply.add(tokens);
    }

    function () payable external notBeforeTime(startTime) notAfterTime(endTime) {
        require(msg.value > 0);
        funding(msg.sender, msg.value, rate);
        processFunding(msg.sender, msg.value, rate);
    }

    function withdrawForOneStep() external onlyOwner assertFalse(hasOneStepWithdraw) notBeforeTime(1587571200) {
        hasOneStepWithdraw = true;
        processFunding(owner, TEAM_UNFREEZE, 1);
    }

    function withdrawForTwoStep() external onlyOwner assertFalse(hasTwoStepWithdraw) notBeforeTime(1603382400) {
        hasTwoStepWithdraw = true;
        processFunding(owner, TEAM_UNFREEZE, 1);
    }

    function withdrawForThreeStep() external onlyOwner assertFalse(hasThreeStepWithdraw) notBeforeTime(1619107200) {
        hasThreeStepWithdraw = true;
        processFunding(owner, TEAM_UNFREEZE, 1);
    }

    function withdrawForFourStep() external onlyOwner assertFalse(hasFourStepWithdraw) notBeforeTime(1634918400) {
        hasFourStepWithdraw = true;
        processFunding(owner, TEAM_UNFREEZE, 1);
    }

    function withdrawForFiveStep() external onlyOwner assertFalse(hasFiveStepWithdraw) notBeforeTime(1650643200) {
        hasFiveStepWithdraw = true;
        processFunding(owner, TEAM_UNFREEZE, 1);
    }

    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function setupFundingRate(uint256 _rate) external onlyOwner {
        rate = _rate;
    }

    function setupFundingTime(uint256 _startTime, uint256 _endTime) external onlyOwner {
        startTime = _startTime;
        endTime = _endTime;
    }
}
```

This implementation includes:
1. ERC20 standard functions with SafeMath operations
2. Funding system with supply checks and time constraints
3. Team token vesting with time-locked withdrawals
4. Pausable functionality inherited from parent contracts
5. Ownership management with transfer capabilities
6. Proper event emissions for all token transfers and creations
7. Supply management through modifiers and constants
8. ETH withdrawal functionality for contract owner

The contract follows Solidity 0.4.22 syntax and maintains all specified constants and requirements from the problem statement.