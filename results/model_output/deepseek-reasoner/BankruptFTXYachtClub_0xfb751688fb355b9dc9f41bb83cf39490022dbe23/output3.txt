Here's the completed smart contract for BankruptFTXYachtClub:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;
    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    mapping(address => uint8) public NFTPerPublicAddress;

    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Contract is paused");
        require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, "Invalid mint amount");
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");

        uint8 freeAvailable = 0;
        if (maxFreeMintAmountPerWallet > NFTPerPublicAddress[msg.sender]) {
            freeAvailable = maxFreeMintAmountPerWallet - NFTPerPublicAddress[msg.sender];
        }

        if (freeAvailable > 0) {
            uint8 freeMints = _mintAmount > freeAvailable ? freeAvailable : _mintAmount;
            uint8 paidMints = _mintAmount - freeMints;
            require(msg.value >= paidMints * cost, "Insufficient funds");
            NFTPerPublicAddress[msg.sender] += freeMints;
        } else {
            require(msg.value >= _mintAmount * cost, "Insufficient funds");
        }

        _safeMint(msg.sender, _mintAmount);
    }

    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");
        _safeMint(_receiver, _mintAmount);
    }

    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        uint256 total = uint256(_amountPerAddress) * addresses.length;
        require(totalSupply() + total <= maxSupply, "Exceeds max supply");
        for (uint256 i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        require(_maxSupply >= totalSupply(), "New max supply lower than current supply");
        maxSupply = _maxSupply;
    }

    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");
        
        if (!reveal) return hiddenURL;
        
        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 
            ? string(abi.encodePacked(baseURI, _tokenId.toString(), uriSuffix))
            : "";
    }

    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        hiddenURL = _uriPrefix;
    }

    function setPaused() external onlyOwner {
        paused = !paused;
    }

    function setCost(uint256 _cost) external onlyOwner {
        cost = _cost;
    }

    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    function withdraw() external onlyOwner {
        (bool success, ) = owner().call{value: address(this).balance}("");
        require(success, "Withdraw failed");
    }

    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    receive() external payable {}
}
```

This implementation includes all the required functionality while maintaining security and efficiency. Key features include:

1. ERC721A standard implementation for gas-efficient batch minting
2. Free mint allowance per wallet with configurable limits
3. Owner-only functions for reserving and airdropping NFTs
4. Reveal mechanics with hidden metadata
5. Flexible configuration of minting parameters
6. Withdraw functionality for collected funds
7. Pausable contract state
8. Supply management with maximum limits

The contract maintains compatibility with OpenZeppelin's ERC721 standard while adding optimizations from the ERC721A implementation for reduced gas costs during batch minting operations.