```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "./Context.sol";
import "./Ownable.sol";
import "./SafeMath.sol";
import "./IUniswapV2Pair.sol";

contract LeveragePool is Ownable {
    using SafeMath for uint256;

    enum LPTOKENTYPE { ETH, USDT, USDC, SHIB, DOGE }

    mapping(address => uint256) _ethPool;
    mapping(address => uint256) _usdtPool;
    mapping(address => uint256) _usdcPool;
    mapping(address => uint256) _shibPool;
    mapping(address => uint256) _dogePool;

    IUniswapV2Pair _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Pair _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);
    IUniswapV2Pair _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);

    constructor() {}

    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {
        return (
            _ethPool[account],
            _usdtPool[account],
            _usdcPool[account],
            _shibPool[account],
            _dogePool[account]
        );
    }

    function getUsdtPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _usdtEth.getReserves();
        return (uint256(reserve1) * 1e6 / uint256(reserve0);
    }

    function getUsdcPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _usdcEth.getReserves();
        return (uint256(reserve1) * 1e6 / uint256(reserve0);
    }

    function getShibPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _shibEth.getReserves();
        return (uint256(reserve1) * 1e18 / uint256(reserve0));
    }

    function getDogePrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _dogeEth.getReserves();
        return (uint256(reserve1) * 1e8 / uint256(reserve0));
    }

    function depositEth(address player, uint256 amount) external onlyOwner {
        _ethPool[player] += amount;
    }

    function depositErc20(address player, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.USDT) {
            _usdtPool[player] += amount;
        } else if (token == LPTOKENTYPE.USDC) {
            _usdcPool[player] += amount;
        } else if (token == LPTOKENTYPE.SHIB) {
            _shibPool[player] += amount;
        } else if (token == LPTOKENTYPE.DOGE) {
            _dogePool[player] += amount;
        } else {
            revert("Invalid token");
        }
    }

    function withdraw(address player, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.ETH) {
            require(_ethPool[player] >= amount, "Insufficient ETH");
            _ethPool[player] -= amount;
        } else if (token == LPTOKENTYPE.USDT) {
            require(_usdtPool[player] >= amount, "Insufficient USDT");
            _usdtPool[player] -= amount;
        } else if (token == LPTOKENTYPE.USDC) {
            require(_usdcPool[player] >= amount, "Insufficient USDC");
            _usdcPool[player] -= amount;
        } else if (token == LPTOKENTYPE.SHIB) {
            require(_shibPool[player] >= amount, "Insufficient SHIB");
            _shibPool[player] -= amount;
        } else if (token == LPTOKENTYPE.DOGE) {
            require(_dogePool[player] >= amount, "Insufficient DOGE");
            _dogePool[player] -= amount;
        } else {
            revert("Invalid token");
        }
    }

    function lock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        require(_ethPool[player] >= ethAmount, "Insufficient ETH");
        require(_usdtPool[player] >= usdtAmount, "Insufficient USDT");
        require(_usdcPool[player] >= usdcAmount, "Insufficient USDC");
        require(_shibPool[player] >= shibAmount, "Insufficient SHIB");
        require(_dogePool[player] >= dogeAmount, "Insufficient DOGE");
        
        _ethPool[player] -= ethAmount;
        _usdtPool[player] -= usdtAmount;
        _usdcPool[player] -= usdcAmount;
        _shibPool[player] -= shibAmount;
        _dogePool[player] -= dogeAmount;
    }

    function unlock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        _ethPool[player] += ethAmount;
        _usdtPool[player] += usdtAmount;
        _usdcPool[player] += usdcAmount;
        _shibPool[player] += shibAmount;
        _dogePool[player] += dogeAmount;
    }

    function withdrawFromContract(address owner, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.ETH) {
            _ethPool[owner] = _ethPool[owner] >= amount ? _ethPool[owner] - amount : 0;
        } else if (token == LPTOKENTYPE.USDT) {
            _usdtPool[owner] = _usdtPool[owner] >= amount ? _usdtPool[owner] - amount : 0;
        } else if (token == LPTOKENTYPE.USDC) {
            _usdcPool[owner] = _usdcPool[owner] >= amount ? _usdcPool[owner] - amount : 0;
        } else if (token == LPTOKENTYPE.SHIB) {
            _shibPool[owner] = _shibPool[owner] >= amount ? _shibPool[owner] - amount : 0;
        } else if (token == LPTOKENTYPE.DOGE) {
            _dogePool[owner] = _dogePool[owner] >= amount ? _dogePool[owner] - amount : 0;
        } else {
            revert("Invalid token");
        }
    }

    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {
        uint256 totalWei = _ethPool[player];
        totalWei += (_usdtPool[player] * getUsdtPrice()) / 1e6;
        totalWei += (_usdcPool[player] * getUsdcPrice()) / 1e6;
        totalWei += (_shibPool[player] * getShibPrice()) / 1e18;
        totalWei += (_dogePool[player] * getDogePrice()) / 1e8;
        return totalWei / 1e18;
    }

    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (uint256, uint256, uint256, uint256, uint256) {
        uint256 remaining = etherAmount * 1e18;
        uint256 ethUsed = 0;
        uint256 usdtUsed = 0;
        uint256 usdcUsed = 0;
        uint256 shibUsed = 0;
        uint256 dogeUsed = 0;

        ethUsed = _ethPool[player] <= remaining ? _ethPool[player] : remaining;
        remaining -= ethUsed;

        if (remaining > 0) {
            uint256 usdtAvailable = _usdtPool[player];
            uint256 usdtPrice = getUsdtPrice();
            require(usdtPrice > 0, "USDT price error");
            uint256 usdtValue = (usdtAvailable * usdtPrice) / 1e6;
            uint256 usdtValueUsed = usdtValue <= remaining ? usdtValue : remaining;
            usdtUsed = (usdtValueUsed * 1e6) / usdtPrice;
            remaining -= usdtValueUsed;
        }

        if (remaining > 0) {
            uint256 usdcAvailable = _usdcPool[player];
            uint256 usdcPrice = getUsdcPrice();
            require(usdcPrice > 0, "USDC price error");
            uint256 usdcValue = (usdcAvailable * usdcPrice) / 1e6;
            uint256 usdcValueUsed = usdcValue <= remaining ? usdcValue : remaining;
            usdcUsed = (usdcValueUsed * 1e6) / usdcPrice;
            remaining -= usdcValueUsed;
        }

        if (remaining > 0) {
            uint256 shibAvailable = _shibPool[player];
            uint256 shibPrice = getShibPrice();
            require(shibPrice > 0, "SHIB price error");
            uint256 shibValue = (shibAvailable * shibPrice) / 1e18;
            uint256 shibValueUsed = shibValue <= remaining ? shibValue : remaining;
            shibUsed = (shibValueUsed * 1e18) / shibPrice;
            remaining -= shibValueUsed;
        }

        if (remaining > 0) {
            uint256 dogeAvailable = _dogePool[player];
            uint256 dogePrice = getDogePrice();
            require(dogePrice > 0, "DOGE price error");
            uint256 dogeValue = (dogeAvailable * dogePrice) / 1e8;
            uint256 dogeValueUsed = dogeValue <= remaining ? dogeValue : remaining;
            dogeUsed = (dogeValueUsed * 1e8) / dogePrice;
            remaining -= dogeValueUsed;
        }

        require(remaining == 0, "Insufficient collateral");
        return (ethUsed, usdtUsed, usdcUsed, shibUsed, dogeUsed);
    }
}
```