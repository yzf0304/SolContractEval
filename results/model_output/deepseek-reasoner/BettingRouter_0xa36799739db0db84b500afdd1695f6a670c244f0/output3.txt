```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

contract LeveragePool is Ownable {
    using SafeMath for uint256;

    enum LPTOKENTYPE { USDT, USDC, SHIB, DOGE }

    mapping(address => uint256) _ethPool;
    mapping(address => uint256) _usdtPool;
    mapping(address => uint256) _usdcPool;
    mapping(address => uint256) _shibPool;
    mapping(address => uint256) _dogePool;

    IUniswapV2Pair _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Pair _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);
    IUniswapV2Pair _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);

    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {
        return (
            _ethPool[account],
            _usdtPool[account],
            _usdcPool[account],
            _shibPool[account],
            _dogePool[account]
        );
    }

    function getUsdtPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _usdtEth.getReserves();
        return uint256(reserve0).mul(1e18).div(uint256(reserve1));
    }

    function getUsdcPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _usdcEth.getReserves();
        return uint256(reserve0).mul(1e18).div(uint256(reserve1));
    }

    function getShibPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _shibEth.getReserves();
        return uint256(reserve0).mul(1e18).div(uint256(reserve1));
    }

    function getDogePrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1, ) = _dogeEth.getReserves();
        return uint256(reserve0).mul(1e18).div(uint256(reserve1));
    }

    function depositEth(address player, uint256 amount) external onlyOwner {
        _ethPool[player] = _ethPool[player].add(amount);
    }

    function depositErc20(address player, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.USDT) {
            _usdtPool[player] = _usdtPool[player].add(amount);
        } else if (token == LPTOKENTYPE.USDC) {
            _usdcPool[player] = _usdcPool[player].add(amount);
        } else if (token == LPTOKENTYPE.SHIB) {
            _shibPool[player] = _shibPool[player].add(amount);
        } else if (token == LPTOKENTYPE.DOGE) {
            _dogePool[player] = _dogePool[player].add(amount);
        }
    }

    function withdraw(address player, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.USDT) {
            _usdtPool[player] = _usdtPool[player].sub(amount, "Insufficient USDT balance");
        } else if (token == LPTOKENTYPE.USDC) {
            _usdcPool[player] = _usdcPool[player].sub(amount, "Insufficient USDC balance");
        } else if (token == LPTOKENTYPE.SHIB) {
            _shibPool[player] = _shibPool[player].sub(amount, "Insufficient SHIB balance");
        } else if (token == LPTOKENTYPE.DOGE) {
            _dogePool[player] = _dogePool[player].sub(amount, "Insufficient DOGE balance");
        } else {
            revert("Invalid token type");
        }
    }

    function lock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        if (ethAmount > 0) {
            _ethPool[player] = _ethPool[player].sub(ethAmount, "Insufficient ETH balance");
        }
        if (usdtAmount > 0) {
            _usdtPool[player] = _usdtPool[player].sub(usdtAmount, "Insufficient USDT balance");
        }
        if (usdcAmount > 0) {
            _usdcPool[player] = _usdcPool[player].sub(usdcAmount, "Insufficient USDC balance");
        }
        if (shibAmount > 0) {
            _shibPool[player] = _shibPool[player].sub(shibAmount, "Insufficient SHIB balance");
        }
        if (dogeAmount > 0) {
            _dogePool[player] = _dogePool[player].sub(dogeAmount, "Insufficient DOGE balance");
        }
    }

    function unlock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        if (ethAmount > 0) {
            _ethPool[player] = _ethPool[player].add(ethAmount);
        }
        if (usdtAmount > 0) {
            _usdtPool[player] = _usdtPool[player].add(usdtAmount);
        }
        if (usdcAmount > 0) {
            _usdcPool[player] = _usdcPool[player].add(usdcAmount);
        }
        if (shibAmount > 0) {
            _shibPool[player] = _shibPool[player].add(shibAmount);
        }
        if (dogeAmount > 0) {
            _dogePool[player] = _dogePool[player].add(dogeAmount);
        }
    }

    function withdrawFromContract(address owner, LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == LPTOKENTYPE.USDT) {
            if (_usdtPool[owner] >= amount) {
                _usdtPool[owner] = _usdtPool[owner].sub(amount);
            } else {
                _usdtPool[owner] = 0;
            }
        } else if (token == LPTOKENTYPE.USDC) {
            if (_usdcPool[owner] >= amount) {
                _usdcPool[owner] = _usdcPool[owner].sub(amount);
            } else {
                _usdcPool[owner] = 0;
            }
        } else if (token == LPTOKENTYPE.SHIB) {
            if (_shibPool[owner] >= amount) {
                _shibPool[owner] = _shibPool[owner].sub(amount);
            } else {
                _shibPool[owner] = 0;
            }
        } else if (token == LPTOKENTYPE.DOGE) {
            if (_dogePool[owner] >= amount) {
                _dogePool[owner] = _dogePool[owner].sub(amount);
            } else {
                _dogePool[owner] = 0;
            }
        } else {
            revert("Invalid token type");
        }
    }

    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {
        uint256 totalEth = _ethPool[player];
        totalEth = totalEth.add(_usdtPool[player].div(getUsdtPrice()));
        totalEth = totalEth.add(_usdcPool[player].div(getUsdcPrice()));
        totalEth = totalEth.add(_shibPool[player].div(getShibPrice()));
        totalEth = totalEth.add(_dogePool[player].div(getDogePrice()));
        return totalEth;
    }

    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (uint256, uint256, uint256, uint256, uint256) {
        uint256 remaining = etherAmount;
        uint256 ethUsed = Math.min(_ethPool[player], remaining);
        remaining = remaining.sub(ethUsed);

        uint256 usdtUsedEth = 0;
        if (remaining > 0) {
            uint256 usdtValueEth = _usdtPool[player].div(getUsdtPrice());
            usdtUsedEth = Math.min(usdtValueEth, remaining);
            remaining = remaining.sub(usdtUsedEth);
        }

        uint256 usdcUsedEth = 0;
        if (remaining > 0) {
            uint256 usdcValueEth = _usdcPool[player].div(getUsdcPrice());
            usdcUsedEth = Math.min(usdcValueEth, remaining);
            remaining = remaining.sub(usdcUsedEth);
        }

        uint256 shibUsedEth = 0;
        if (remaining > 0) {
            uint256 shibValueEth = _shibPool[player].div(getShibPrice());
            shibUsedEth = Math.min(shibValueEth, remaining);
            remaining = remaining.sub(shibUsedEth);
        }

        uint256 dogeUsedEth = 0;
        if (remaining > 0) {
            uint256 dogeValueEth = _dogePool[player].div(getDogePrice());
            dogeUsedEth = Math.min(dogeValueEth, remaining);
            remaining = remaining.sub(dogeUsedEth);
        }

        require(remaining == 0, "Insufficient collateral");

        return (
            ethUsed,
            usdtUsedEth.mul(getUsdtPrice()),
            usdcUsedEth.mul(getUsdcPrice()),
            shibUsedEth.mul(getShibPrice()),
            dogeUsedEth.mul(getDogePrice())
        );
    }
}
```