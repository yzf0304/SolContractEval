Here's the completed Solidity contract based on the provided context and requirements:

```solidity
pragma solidity 0.6.12;

interface marketManagerInterface {}
interface interestModelInterface {}
interface marketHandlerDataStorageInterface {}
interface marketSIHandlerDataStorageInterface {}

contract proxy  {
    address payable owner;
    uint256 handlerID;
    string tokenName = "ether";
    uint256 constant unifiedPoint = 10 ** 18;
    marketManagerInterface marketManager;
    interestModelInterface interestModelInstance;
    marketHandlerDataStorageInterface handlerDataStorage;
    marketSIHandlerDataStorageInterface SIHandlerDataStorage;
    address public handler;
    address public SI;
    
    string DEPOSIT = "deposit(uint256,bool)";
    string REDEEM = "withdraw(uint256,bool)";
    string BORROW = "borrow(uint256,bool)";
    string REPAY = "repay(uint256,bool)";

    modifier onlyOwner {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    modifier onlyMarketManager {
        address msgSender = msg.sender;
        require((msgSender == address(marketManager)) || (msgSender == owner), "onlyMarketManager function");
        _;
    }

    constructor () public {
        owner = msg.sender;
    }

    function ownershipTransfer(address _owner) onlyOwner external returns (bool) {
        owner = payable(_owner);
        return true;
    }

    function initialize(uint256 _handlerID, address handlerAddr, address marketManagerAddr, address interestModelAddr, address marketDataStorageAddr, address siHandlerAddr, address SIHandlerDataStorageAddr) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        handler = handlerAddr;
        marketManager = marketManagerInterface(marketManagerAddr);
        interestModelInstance = interestModelInterface(interestModelAddr);
        handlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);
        SI = siHandlerAddr;
        SIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);
        return true;
    }

    function setHandlerID(uint256 _handlerID) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        return true;
    }

    function setHandlerAddr(address handlerAddr) onlyOwner public returns (bool) {
        handler = handlerAddr;
        return true;
    }

    function setSiHandlerAddr(address siHandlerAddr) onlyOwner public returns (bool) {
        SI = siHandlerAddr;
        return true;
    }

    function getHandlerID() public view returns (uint256) {
        return handlerID;
    }

    function getHandlerAddr() public view returns (address) {
        return handler;
    }

    function getSiHandlerAddr() public view returns (address) {
        return SI;
    }

    function migration(address payable target) onlyOwner public returns (bool) {
        target.transfer(address(this).balance);
        return true;
    }

    fallback () external payable {
        require(msg.value > 0, "Zero Ether sent");
    }

    function deposit(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(DEPOSIT, unifiedTokenAmount, flag));
        require(success, "Deposit failed");
        return success;
    }

    function withdraw(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(REDEEM, unifiedTokenAmount, flag));
        require(success, "Withdraw failed");
        return success;
    }

    function borrow(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(BORROW, unifiedTokenAmount, flag));
        require(success, "Borrow failed");
        return success;
    }

    function repay(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(REPAY, unifiedTokenAmount, flag));
        require(success, "Repay failed");
        return success;
    }

    function handlerProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = handler.delegatecall(data);
        return (success, returnData);
    }

    function handlerViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = handler.delegatecall(data);
        return (success, returnData);
    }

    function siProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = SI.delegatecall(data);
        return (success, returnData);
    }

    function siViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = SI.delegatecall(data);
        return (success, returnData);
    }
}
```

This implementation includes:
1. Proper ownership management with transfer functionality
2. Initialization and configuration of handler addresses and related components
3. Delegatecall-based proxy functionality for both regular and view operations
4. Core financial operations (deposit, withdraw, borrow, repay) using delegatecall to handler
5. Strict access control modifiers for owner and market manager
6. Fallback function with ETH value validation
7. Migration function for contract upgrades
8. Compliance with Solidity 0.6.12 syntax and features
9. State variable management and getter functions

The contract maintains the required security controls while enabling flexible interaction with handler contracts through delegatecall patterns.