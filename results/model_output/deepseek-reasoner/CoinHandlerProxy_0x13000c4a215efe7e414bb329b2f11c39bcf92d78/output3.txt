Here's the complete and functional implementation of the proxy contract based on the provided context and requirements:

```solidity
pragma solidity 0.6.12;

interface marketManagerInterface {}
interface interestModelInterface {}
interface marketHandlerDataStorageInterface {}
interface marketSIHandlerDataStorageInterface {}

contract proxy  {
    address payable owner;
    uint256 handlerID;
    string tokenName = "ether";
    uint256 constant unifiedPoint = 10 ** 18;
    
    marketManagerInterface marketManager;
    interestModelInterface interestModelInstance;
    marketHandlerDataStorageInterface handlerDataStorage;
    marketSIHandlerDataStorageInterface SIHandlerDataStorage;
    
    address public handler;
    address public SI;
    
    string DEPOSIT = "deposit(uint256,bool)";
    string REDEEM = "withdraw(uint256,bool)";
    string BORROW = "borrow(uint256,bool)";
    string REPAY = "repay(uint256,bool)";

    modifier onlyOwner {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    modifier onlyMarketManager {
        address msgSender = msg.sender;
        require((msgSender == address(marketManager)) || (msgSender == owner), "onlyMarketManager function");
        _;
    }

    constructor () public {
        owner = msg.sender;
    }

    function ownershipTransfer(address _owner) onlyOwner external returns (bool) {
        require(_owner != address(0), "Invalid owner address");
        owner = payable(_owner);
        return true;
    }

    function initialize(uint256 _handlerID, address handlerAddr, address marketManagerAddr, address interestModelAddr, address marketDataStorageAddr, address siHandlerAddr, address SIHandlerDataStorageAddr) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        handler = handlerAddr;
        marketManager = marketManagerInterface(marketManagerAddr);
        interestModelInstance = interestModelInterface(interestModelAddr);
        handlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);
        SI = siHandlerAddr;
        SIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);
        return true;
    }

    function setHandlerID(uint256 _handlerID) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        return true;
    }

    function setHandlerAddr(address handlerAddr) onlyOwner public returns (bool) {
        handler = handlerAddr;
        return true;
    }

    function setSiHandlerAddr(address siHandlerAddr) onlyOwner public returns (bool) {
        SI = siHandlerAddr;
        return true;
    }

    function getHandlerID() public view returns (uint256) {
        return handlerID;
    }

    function getHandlerAddr() public view returns (address) {
        return handler;
    }

    function getSiHandlerAddr() public view returns (address) {
        return SI;
    }

    function migration(address payable target) onlyOwner public returns (bool) {
        uint256 balance = address(this).balance;
        target.transfer(balance);
        return true;
    }

    fallback () external payable {
        require(msg.value > 0, "No Ether sent");
    }

    function deposit(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        bytes memory data = abi.encodeWithSignature(DEPOSIT, unifiedTokenAmount, flag);
        (bool success, ) = handler.delegatecall(data);
        require(success, "Deposit failed");
        return true;
    }

    function withdraw(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        bytes memory data = abi.encodeWithSignature(REDEEM, unifiedTokenAmount, flag);
        (bool success, ) = handler.delegatecall(data);
        require(success, "Withdraw failed");
        return true;
    }

    function borrow(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        bytes memory data = abi.encodeWithSignature(BORROW, unifiedTokenAmount, flag);
        (bool success, ) = handler.delegatecall(data);
        require(success, "Borrow failed");
        return true;
    }

    function repay(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        bytes memory data = abi.encodeWithSignature(REPAY, unifiedTokenAmount, flag);
        (bool success, ) = handler.delegatecall(data);
        require(success, "Repay failed");
        return true;
    }

    function handlerProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory result) = handler.delegatecall(data);
        return (success, result);
    }

    function handlerViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory result) = handler.delegatecall(data);
        return (success, result);
    }

    function siProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory result) = SI.delegatecall(data);
        return (success, result);
    }

    function siViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory result) = SI.delegatecall(data);
        return (success, result);
    }
}
```

This implementation:
1. Implements all required proxy functionality using delegatecall
2. Includes proper access control with onlyOwner and onlyMarketManager modifiers
3. Handles ETH transfers in deposit/repay functions and fallback
4. Implements initialization and configuration functions
5. Follows the specified compiler version (0.6.12) requirements
6. Maintains all interface dependencies without introducing new contracts
7. Includes proper error handling and input validation