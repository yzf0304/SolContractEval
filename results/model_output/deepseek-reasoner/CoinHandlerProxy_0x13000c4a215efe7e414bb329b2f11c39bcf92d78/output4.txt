Here is the completed Solidity smart contract proxy based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

interface marketManagerInterface {}
interface interestModelInterface {}
interface marketHandlerDataStorageInterface {}
interface marketSIHandlerDataStorageInterface {}

contract proxy {
    address payable owner;
    uint256 handlerID;
    string tokenName = "ether";
    uint256 constant unifiedPoint = 10 ** 18;
    
    marketManagerInterface marketManager;
    interestModelInterface interestModelInstance;
    marketHandlerDataStorageInterface handlerDataStorage;
    marketSIHandlerDataStorageInterface SIHandlerDataStorage;
    
    address public handler;
    address public SI;
    
    string DEPOSIT = "deposit(uint256,bool)";
    string REDEEM = "withdraw(uint256,bool)";
    string BORROW = "borrow(uint256,bool)";
    string REPAY = "repay(uint256,bool)";

    modifier onlyOwner {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    modifier onlyMarketManager {
        address msgSender = msg.sender;
        require((msgSender == address(marketManager)) || (msgSender == owner), "onlyMarketManager function");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function ownershipTransfer(address _owner) external onlyOwner returns (bool) {
        owner = payable(_owner);
        return true;
    }

    function initialize(
        uint256 _handlerID,
        address handlerAddr,
        address marketManagerAddr,
        address interestModelAddr,
        address marketDataStorageAddr,
        address siHandlerAddr,
        address SIHandlerDataStorageAddr
    ) public onlyOwner returns (bool) {
        handlerID = _handlerID;
        handler = handlerAddr;
        marketManager = marketManagerInterface(marketManagerAddr);
        interestModelInstance = interestModelInterface(interestModelAddr);
        handlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);
        SI = siHandlerAddr;
        SIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);
        return true;
    }

    function setHandlerID(uint256 _handlerID) public onlyOwner returns (bool) {
        handlerID = _handlerID;
        return true;
    }

    function setHandlerAddr(address handlerAddr) public onlyOwner returns (bool) {
        handler = handlerAddr;
        return true;
    }

    function setSiHandlerAddr(address siHandlerAddr) public onlyOwner returns (bool) {
        SI = siHandlerAddr;
        return true;
    }

    function getHandlerID() public view returns (uint256) {
        return handlerID;
    }

    function getHandlerAddr() public view returns (address) {
        return handler;
    }

    function getSiHandlerAddr() public view returns (address) {
        return SI;
    }

    function migration(address payable target) public onlyOwner returns (bool) {
        target.transfer(address(this).balance);
        return true;
    }

    fallback() external payable {
        require(msg.value > 0, "No ether sent");
    }

    function deposit(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        (bool success, bytes memory data) = handler.delegatecall(
            abi.encodeWithSignature(DEPOSIT, unifiedTokenAmount, flag)
        );
        require(success, string(data));
        return abi.decode(data, (bool));
    }

    function withdraw(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, bytes memory data) = handler.delegatecall(
            abi.encodeWithSignature(REDEEM, unifiedTokenAmount, flag)
        );
        require(success, string(data));
        return abi.decode(data, (bool));
    }

    function borrow(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, bytes memory data) = handler.delegatecall(
            abi.encodeWithSignature(BORROW, unifiedTokenAmount, flag)
        );
        require(success, string(data));
        return abi.decode(data, (bool));
    }

    function repay(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        (bool success, bytes memory data) = handler.delegatecall(
            abi.encodeWithSignature(REPAY, unifiedTokenAmount, flag)
        );
        require(success, string(data));
        return abi.decode(data, (bool));
    }

    function handlerProxy(bytes memory data) external onlyMarketManager returns (bool, bytes memory) {
        (bool success, bytes memory returndata) = handler.delegatecall(data);
        return (success, returndata);
    }

    function handlerViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returndata) = handler.delegatecall(data);
        return (success, returndata);
    }

    function siProxy(bytes memory data) external onlyMarketManager returns (bool, bytes memory) {
        (bool success, bytes memory returndata) = SI.delegatecall(data);
        return (success, returndata);
    }

    function siViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returndata) = SI.delegatecall(data);
        return (success, returndata);
    }
}
```

This implementation:
1. Maintains all specified access controls with modifiers
2. Implements proper state variable management
3. Uses delegatecall for handler/SI interactions
4. Includes required error handling and value checks
5. Maintains compatibility with Solidity 0.6.12
6. Follows the exact interface and functionality described in the problem statement

The contract includes all specified proxy functionality while maintaining security through access controls and proper error checking.