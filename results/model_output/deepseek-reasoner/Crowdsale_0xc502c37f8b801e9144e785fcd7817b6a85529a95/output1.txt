```solidity
pragma solidity ^0.4.18;

contract Crowdsale is Ownable {
  using SafeMath for uint256;

  DragonToken public token;
  address public tokenReserve;
  uint256 public startTime;
  uint256 public endTime;
  address public wallet;
  uint256 public rate;
  uint256 public weiRaised;
  uint256 public tokensSold;

  mapping(address => uint256) public balances;
  mapping(address => uint256) public releaseTime;

  function Crowdsale() public {
    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e; 
    startTime = now;
    endTime = 1521187200;
    rate = 5000000000000000; 
    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
  }

  function () external payable {
    buyTokens(msg.sender);
  }

  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());
    uint256 weiAmount = msg.value;
    uint256 tokens = getTokenAmount(weiAmount);
    require(tokens > 0);
    
    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokens);
    
    uint256 rTime = assignTokens(beneficiary, tokens);
    emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, rTime);
    forwardFunds();
  }

  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.div(rate);
  }

  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  function updateEndTime(uint256 newTime) onlyOwner external {
    require(newTime > startTime);
    endTime = newTime;
    emit EndTimeUpdated();
  }

  function updateDragonPrice(uint256 weiAmount) onlyOwner external {
    require(weiAmount > 0);
    rate = weiAmount;
    emit DragonPriceUpdated();
  }

  function assignTokens(address beneficiary, uint256 amount) private returns(uint256 lockedFor) {
    lockedFor = now.add(90 days);
    releaseTime[beneficiary] = lockedFor;
    balances[beneficiary] = balances[beneficiary].add(amount);
    require(token.transferFrom(tokenReserve, address(this), amount));
    return lockedFor;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function unlockTime(address _owner) public view returns (uint256 time) {
    return releaseTime[_owner];
  }

  function releaseDragonTokens() public {
    require(now >= releaseTime[msg.sender]);
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    balances[msg.sender] = 0;
    require(token.transfer(msg.sender, amount));
    emit TokenReleased(msg.sender, amount);
  }
}
```