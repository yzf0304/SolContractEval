Here is the complete implementation of the ProxyRegistry contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.4;

contract ProxyRegistry is Ownable {
    address public delegateProxyImplementation;
    mapping(address => OwnableDelegateProxy) public proxies;
    mapping(address => uint256) public pending;
    mapping(address => bool) public contracts;
    uint256 public DELAY_PERIOD = 7 days;

    event RegisterProxy(address indexed sender, address proxyAddr);
    event AuthenticationOperation(address indexed addr, bool opt);

    function startGrantAuthentication(address addr) public onlyOwner {
        pending[addr] = block.timestamp + DELAY_PERIOD;
    }

    function endGrantAuthentication(address addr) public onlyOwner {
        require(pending[addr] != 0, "Address not pending");
        require(block.timestamp >= pending[addr], "Delay period active");
        contracts[addr] = true;
        delete pending[addr];
        emit AuthenticationOperation(addr, true);
    }

    function revokeAuthentication(address addr) public onlyOwner {
        contracts[addr] = false;
        if (pending[addr] != 0) delete pending[addr];
        emit AuthenticationOperation(addr, false);
    }

    function registerProxy() public returns (OwnableDelegateProxy proxy) {
        require(address(proxies[msg.sender]) == address(0), "Proxy exists");
        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation);
        proxies[msg.sender] = proxy;
        emit RegisterProxy(msg.sender, address(proxy));
        return proxy;
    }
}

abstract contract OwnableDelegateProxy {}
```

Key implementation details:
1. Access control uses OpenZeppelin's Ownable pattern
2. Authentication grants use a 7-day delay with pending timestamps
3. Users can create exactly one proxy contract through registerProxy()
4. Explicit cleanup of pending state during revoke operations
5. Strict checks for existing proxies and valid authentication timing
6. Event emission for all critical operations

The contract maintains security by:
- Using a delay period for contract authorization
- Requiring explicit owner actions for access control
- Preventing proxy duplication per address
- Cleaning state properly during revocations