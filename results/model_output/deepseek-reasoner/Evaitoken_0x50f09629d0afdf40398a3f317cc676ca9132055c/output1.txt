```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.6.10;

/**
 * @title Evaitoken
 * @notice This contract implements the ERC20 token standard with additional functionalities like profit tracking and token burning.
 * @dev The contract uses SafeMath for arithmetic operations to prevent overflows and underflows.
 */
contract Evaitoken is ERC20Interface, SafeMath {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;
    uint256 public _totalSupply;
    address public owner;
    uint256 public totalProfit;
    uint256 public profit;

    mapping(address => uint256) internal balances;
    mapping(address => mapping(address => uint256)) internal allowed;

    constructor() public {
        name = "EVAI.IO";
        symbol = "EVAI";
        decimals = 8;
        _totalSupply = 1000000000 * 10**uint256(decimals);
        initialSupply = _totalSupply;
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() external view override returns (uint256) {
        return initialSupply - balances[address(0)];
    }

    function balanceOf(address tokenOwner) external view override returns (uint256 getBalance) {
        return balances[tokenOwner];
    }

    function allowance(address tokenOwner, address spender) external view override returns (uint256 remaining) {
        return allowed[tokenOwner][spender];
    }

    function approve(address spender, uint256 tokens) external override returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transfer(address to, uint256 tokens) external override returns (bool success) {
        require(balances[msg.sender] >= tokens, "Insufficient balance");
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens) external override returns (bool success) {
        require(allowed[from][msg.sender] >= tokens, "Allowance exceeded");
        require(balances[from] >= tokens, "Insufficient balance");
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[from] = safeSub(balances[from], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function buy(address to, uint256 tokens) external override returns (bool success) {
        require(balances[owner] >= tokens, "Insufficient owner balance");
        balances[owner] = safeSub(balances[owner], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(owner, to, tokens);
        return true;
    }

    function operationProfit(uint256 _profit) external override returns (bool success) {
        require(msg.sender == owner, "Only owner can update profit");
        profit = _profit;
        totalProfit = safeAdd(totalProfit, _profit);
        emit Profit(msg.sender, _profit, totalProfit);
        return true;
    }

    function burn(uint256 tokens) external override returns (bool success) {
        require(msg.sender == owner, "Only owner can burn");
        require(balances[msg.sender] >= tokens, "Insufficient balance");
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[address(0)] = safeAdd(balances[address(0)], tokens);
        emit Burn(msg.sender, address(0), tokens);
        return true;
    }

    receive() external payable {}
}
```

### Key Features and Implementation Details

**Token Basics:**
- Implements ERC20 standard with additional burn and profit tracking features
- Fixed supply of 1,000,000,000 tokens with 8 decimal precision
- Initial supply allocated to contract deployer

**Core Functionality:**
1. **Supply Tracking:**
   - `totalSupply()` dynamically calculates circulating supply by subtracting burned tokens (balance of zero address) from initial supply

2. **Advanced Functions:**
   - `buy()`: Allows token distribution from owner's balance
   - `operationProfit()`: Owner-only profit tracking with event logging
   - `burn()`: Secure token burning mechanism that sends tokens to zero address

3. **Security Measures:**
   - Owner-restricted access for sensitive operations (profit updates, burning)
   - SafeMath library prevents arithmetic overflows
   - Strict balance checks for all transfer operations

**Technical Specifications:**
- Fully compliant with Solidity 0.6.10
- Explicit visibility modifiers for all functions
- Comprehensive event emission for all state changes
- Optimized gas usage through direct balance management

The contract maintains ERC20 compliance while adding custom business logic for profit tracking and secure token management, following strict security practices and the provided specifications.