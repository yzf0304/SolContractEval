Here is the completed EverMigrate smart contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping(address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId = 0;
    mapping(address => mapping(address => Transaction[])) private _userTxns;

    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(sourceToken != address(0), "Invalid source token");
        require(targetToken != address(0), "Invalid target token");
        require(devAddress != address(0), "Invalid dev address");
        require(ratio > 0, "Ratio must be positive");
        require(!_tokenList[sourceToken].isPresent, "Token already added");

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });

        _allTokens.push(sourceToken);
        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {
        require(supportsToken(sourceToken), "Token not supported");
        TokenDetails storage details = _tokenList[sourceToken];

        IERC20(sourceToken).transferFrom(_msgSender(), details.devAddress, amount);
        
        uint256 targetAmount = amount.mul(details.ratio);
        require(
            IERC20(details.targetToken).transfer(toAddress, targetAmount),
            "Target transfer failed"
        );

        _userTxns[sourceToken][_msgSender()].push(Transaction(
            amount,
            block.timestamp,
            _txnId
        ));
        _txnId++;
        
        emit TokensMigrated(sourceToken, details.targetToken, amount, targetAmount);
    }

    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {
        return _userTxns[sourceToken][userAddress].length;
    }

    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {
        Transaction storage txn = _userTxns[sourceToken][userAddress][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {
        require(supportsToken(sourceToken), "Token not supported");
        address targetToken = _tokenList[sourceToken].targetToken;
        
        require(
            IERC20(targetToken).transfer(toAddress, amount),
            "Return transfer failed"
        );
        emit TokensReturned(sourceToken, toAddress, amount);
    }

    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {
        require(_tokenList[sourceToken].isPresent, "Token not supported");
        return (_tokenList[sourceToken].targetToken, _tokenList[sourceToken].ratio);
    }

    function allSupportedTokens() external view returns (address[] memory) {
        return _allTokens;
    }

    function allSupportedTokensLength() external view returns (uint256) {
        return _allTokens.length;
    }

    function supportsToken(address sourceToken) public view returns (bool) {
        return _tokenList[sourceToken].isPresent;
    }
}
```

Key implementation details:
1. **addTokenDetails** validates inputs and stores new token pairs
2. **migrateTokens** handles token conversion with SafeMath operations and transaction tracking
3. **returnTokens** allows owner to reclaim target tokens
4. **tokenMigrateDetails** provides conversion info for supported tokens
5. **userTransaction** methods enable transaction history lookup
6. Uses SafeMath for arithmetic operations to prevent overflows
7. Strict access control with OnlyOwner modifier where required
8. Emits proper events for all key operations
9. Maintains list of all supported tokens for enumeration

The contract implements all specified functionality while maintaining security checks and proper access control throughout.