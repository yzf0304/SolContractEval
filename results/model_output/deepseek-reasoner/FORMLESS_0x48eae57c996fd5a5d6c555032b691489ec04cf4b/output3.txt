Here is the completed smart contract based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract FORMLESS is Ownable, ERC721A, ReentrancyGuard {
    using Strings for uint256;

    uint256 public MAX_PER_Transtion = 1;
    uint256 public MAX_PER_Address = 1;
    uint256 public PRICE = 0.069 ether;
    uint256 private TotalCollectionSize_ = 500;
    uint256 private constant MaxMintPerBatch_ = 1;
    mapping(address => bool) private whitelistedAddressesForMint;
    string private _baseTokenURI;
    uint public status = 0;

    constructor() ERC721A("FORMLESS", "FORMLESS", MaxMintPerBatch_, TotalCollectionSize_) {
        _baseTokenURI = "https://gateway.pinata.cloud/ipfs/QmWT2u6UEeXJs5MWcSTQhHFyYC9wKevQNjXC4J3k67ymtQ/";
    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function mint(uint256 quantity) external payable callerIsUser {
        require(status != 0, "Sale paused");
        if(status == 1) {
            require(whitelistedAddressesForMint[msg.sender], "Not whitelisted");
        }
        require(quantity > 0, "Invalid quantity");
        require(quantity <= MAX_PER_Transtion, "Exceeds transaction limit");
        require(_numberMinted(msg.sender) + quantity <= MAX_PER_Address, "Exceeds wallet limit");
        require(totalSupply() + quantity <= TotalCollectionSize_, "Exceeds supply");
        require(msg.value >= PRICE * quantity, "Insufficient payment");

        _safeMint(msg.sender, quantity);
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "Nonexistent token");
        return string(abi.encodePacked(_baseTokenURI, tokenId.toString()));
    }

    function isWhitelistedForMint(address _user) public view returns (bool) {
        return whitelistedAddressesForMint[_user];
    }

    function addNewWhitelistUserForMint(address[] calldata _users) public onlyOwner {
        for(uint256 i = 0; i < _users.length; i++) {
            whitelistedAddressesForMint[_users[i]] = true;
        }
    }

    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return _numberMinted(owner);
    }

    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
        return ownershipOf(tokenId);
    }

    function withdrawMoney() external onlyOwner nonReentrant {
        (bool success, ) = owner().call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }

    function changeMAX_PER_Address(uint256 q) external onlyOwner {
        MAX_PER_Address = q;
    }

    function reserve(address _address, uint256 quantity) public onlyOwner {
        require(totalSupply() + quantity <= TotalCollectionSize_, "Exceeds supply");
        _safeMint(_address, quantity);
    }

    function changeMintPrice(uint256 _newPrice) external onlyOwner {
        PRICE = _newPrice;
    }

    function changeCollectionSize(uint256 _collectionSize) external onlyOwner {
        TotalCollectionSize_ = _collectionSize;
    }

    function changeMAX_PER_Transtion(uint256 q) external onlyOwner {
        MAX_PER_Transtion = q;
    }

    function giveaway(address a, uint q) public onlyOwner {
        require(totalSupply() + q <= TotalCollectionSize_, "Exceeds supply");
        _safeMint(a, q);
    }

    function setStatus(uint256 s) external onlyOwner {
        status = s;
    }

    function getStatus() public view returns (uint) {
        return status;
    }

    function getcollectionSize() public view returns (uint) {
        return TotalCollectionSize_;
    }
}
```

This implementation includes:

1. Safe minting functionality with whitelist and public sale phases
2. Proper access control using OpenZeppelin's Ownable
3. Reentrancy protection for withdrawals
4. Flexible collection parameters that can be updated by the owner
5. ERC721A standard implementation for efficient batch minting
6. Whitelist management functions
7. Proper URI handling for NFT metadata
8. Withdrawal functionality for collected funds
9. Comprehensive safety checks for all operations

The contract maintains all specified requirements while optimizing for gas efficiency and security. Key features include batch minting capabilities, adjustable collection parameters, and robust access control mechanisms.