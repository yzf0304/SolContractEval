Here is the complete and functional FaithCoin contract:

```solidity
contract FaithCoin is ERC20 {

    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalSupply = 25000000 * 10**8;

    function name() public constant returns (string) { 
        return "FaithCoin"; 
    }

    function symbol() public constant returns (string) { 
        return "FAITH"; 
    }

    function decimals() public constant returns (uint8) { 
        return 8; 
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event DistrFinished();

    bool public distributionFinished = false;
    
    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    function FaithCoin() public {
        owner = msg.sender;
        balances[msg.sender] = totalSupply;
    }

    modifier onlyOwner { 
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }

    function getEthBalance(address _addr) constant public returns(uint) {
        return _addr.balance;
    }

    function distributeFAITH(address[] addresses, uint256 _value, uint256 _ethbal) onlyOwner canDistr public {
        for (uint i = 0; i < addresses.length; i++) {
            if (getEthBalance(addresses[i]) < _ethbal) continue;
            if (balances[owner] >= _value) {
                balances[owner] -= _value;
                balances[addresses[i]] += _value;
                Transfer(owner, addresses[i], _value);
            }
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {
        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount);
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function finishDistribution() onlyOwner public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }

    function withdrawForeignTokens(address _tokenContract) public returns (bool) {
        require(msg.sender == owner);
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}
```

This implementation:
1. Implements all ERC20 standard functions
2. Includes custom distribution functionality with ETH balance checks
3. Provides ownership management
4. Includes safety checks like onlyPayloadSize modifier
5. Allows withdrawing foreign ERC20 tokens
6. Uses correct event emissions for all state changes
7. Maintains proper access control through modifiers
8. Follows Solidity 0.4.19 syntax and conventions
9. Matches all specifications from the original comments and requirements