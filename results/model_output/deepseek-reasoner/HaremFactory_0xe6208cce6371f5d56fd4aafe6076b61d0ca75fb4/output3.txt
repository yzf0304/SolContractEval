Here's the complete implementation of the HaremFactory contract based on the provided context and requirements:

```solidity
pragma solidity 0.5.0;

contract HaremFactory is Ownable {
    using SafeMath for uint256;

    // Info of each user.
    struct UserInfo {
        uint256 amount;     // How many tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 token;            // Address of token contract.
        uint256 haremsPerDay;    // The amount of Harems per day generated for each token staked.
        uint256 maxStake;        // The maximum amount of tokens which can be staked in this pool.
        uint256 lastUpdateTime;  // Last timestamp that Harems distribution occurs.
        uint256 accHaremPerShare; // Accumulated Harems per share, times 1e12.
    }

    address public treasuryAddr;
    PoolInfo[] public poolInfo;
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    mapping(address => uint256) public tokenPID;

    HaremNonTradable public Harem;

    constructor(HaremNonTradable _haremAddress, address _treasuryAddr) public {
        Harem = _haremAddress;
        treasuryAddr = _treasuryAddr;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    function add(IERC20 _token, uint256 _haremsPerDay, uint256 _maxStake) public onlyOwner {
        require(address(_token) != address(0), "Invalid token");
        require(tokenPID[address(_token)] == 0, "Token already added");
        
        poolInfo.push(PoolInfo({
            token: _token,
            haremsPerDay: _haremsPerDay,
            maxStake: _maxStake,
            lastUpdateTime: block.timestamp,
            accHaremPerShare: 0
        }));
        tokenPID[address(_token)] = poolInfo.length;
    }

    function setMaxStake(uint256 pid, uint256 amount) public onlyOwner {
        require(pid < poolInfo.length, "Invalid pool");
        poolInfo[pid].maxStake = amount;
    }

    function setHaremsPerDay(uint256 pid, uint256 amount) public onlyOwner {
        require(pid < poolInfo.length, "Invalid pool");
        poolInfo[pid].haremsPerDay = amount;
    }

    function pendingHarem(uint256 _pid, address _user) public view returns (uint256) {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accHaremPerShare = pool.accHaremPerShare;
        
        if (block.timestamp > pool.lastUpdateTime) {
            uint256 timeDelta = block.timestamp.sub(pool.lastUpdateTime);
            accHaremPerShare = accHaremPerShare.add(
                timeDelta.mul(pool.haremsPerDay).mul(1e12).div(86400)
            );
        }
        return user.amount.mul(accHaremPerShare).div(1e12).sub(user.rewardDebt);
    }

    function totalPendingHarem(address _user) public view returns (uint256) {
        uint256 total = 0;
        for (uint256 pid = 0; pid < poolInfo.length; pid++) {
            total = total.add(pendingHarem(pid, _user));
        }
        return total;
    }

    function pendingHaremOfPool(uint256 _pid) public view returns (uint256) {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.timestamp <= pool.lastUpdateTime) return 0;
        uint256 timeDelta = block.timestamp.sub(pool.lastUpdateTime);
        return timeDelta.mul(pool.haremsPerDay).div(86400);
    }

    function rugPull(uint256[] memory _pids) public {
        for (uint256 i = 0; i < _pids.length; i++) {
            uint256 pid = _pids[i];
            updatePool(pid);
            UserInfo storage user = userInfo[pid][msg.sender];
            
            uint256 pending = user.amount.mul(poolInfo[pid].accHaremPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                safeHaremTransfer(msg.sender, pending);
                user.rewardDebt = user.amount.mul(poolInfo[pid].accHaremPerShare).div(1e12);
            }
        }
    }

    function rugPullAll() public {
        for (uint256 pid = 0; pid < poolInfo.length; pid++) {
            updatePool(pid);
            UserInfo storage user = userInfo[pid][msg.sender];
            
            uint256 pending = user.amount.mul(poolInfo[pid].accHaremPerShare).div(1e12).sub(user.rewardDebt);
            if (pending > 0) {
                safeHaremTransfer(msg.sender, pending);
                user.rewardDebt = user.amount.mul(poolInfo[pid].accHaremPerShare).div(1e12);
            }
        }
    }

    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.timestamp <= pool.lastUpdateTime) return;
        
        uint256 timeDelta = block.timestamp.sub(pool.lastUpdateTime);
        uint256 haremReward = timeDelta.mul(pool.haremsPerDay).mul(1e12).div(86400);
        pool.accHaremPerShare = pool.accHaremPerShare.add(haremReward);
        pool.lastUpdateTime = block.timestamp;
    }

    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        
        if (user.amount > 0) {
            uint256 pending = user.amount.mul(pool.accHaremPerShare).div(1e12).sub(user.rewardDebt);
            safeHaremTransfer(msg.sender, pending);
        }
        
        pool.token.transferFrom(msg.sender, address(this), _amount);
        user.amount = user.amount.add(_amount);
        require(user.amount <= pool.maxStake, "Exceeds max stake");
        user.rewardDebt = user.amount.mul(pool.accHaremPerShare).div(1e12);
        emit Deposit(msg.sender, _pid, _amount);
    }

    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, "Insufficient balance");
        updatePool(_pid);
        
        uint256 pending = user.amount.mul(pool.accHaremPerShare).div(1e12).sub(user.rewardDebt);
        if (pending > 0) {
            safeHaremTransfer(msg.sender, pending);
        }
        
        user.amount = user.amount.sub(_amount);
        pool.token.transfer(msg.sender, _amount);
        user.rewardDebt = user.amount.mul(pool.accHaremPerShare).div(1e12);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        uint256 amount = user.amount;
        user.amount = 0;
        user.rewardDebt = 0;
        pool.token.transfer(msg.sender, amount);
        emit EmergencyWithdraw(msg.sender, _pid, amount);
    }

    function safeHaremTransfer(address _to, uint256 _amount) internal {
        if (_amount > 0) {
            Harem.mint(_to, _amount);
        }
    }

    function treasury(address _treasuryAddr) public {
        require(msg.sender == treasuryAddr, "Not treasury");
        treasuryAddr = _treasuryAddr;
    }
}
```

This implementation:
1. Maintains pool information and user staking positions
2. Calculates rewards based on time-weighted stake amounts
3. Implements proper access control for owner-only functions
4. Handles token transfers and reward distribution
5. Includes emergency withdrawal functionality
6. Uses SafeMath for all arithmetic operations
7. Follows the exact specifications and context provided in the problem statement

The contract assumes the Harem token contract has properly granted minter privileges to this factory contract. All reward calculations are done using fixed-point arithmetic to maintain precision, and the contract strictly follows the ERC20 standard for token interactions.