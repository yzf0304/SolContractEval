Here's the complete implementation of the ICSTCrowSale contract:

```solidity
contract ICSTCrowSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalFundingSupply;
    ERC20 public token;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public airdropSupply;
    uint256 public rate;

    event Wasted(address to, uint256 value, uint256 date);

    function ICSTCrowSale() public {
        rate = 0;
        startTime = 0;
        endTime = 0;
        airdropSupply = 0;
        totalFundingSupply = 0;
        token = ERC20(0xe6bc60a00b81c7f3cbc8f4ef3b0a6805b6851753);
    }

    function () payable external {
        require(now > startTime && now <= endTime);
        uint256 amount = msg.value.mul(rate);
        processFunding(msg.sender, msg.value, rate);
        totalFundingSupply = totalFundingSupply.add(amount);
    }

    function withdrawCoinToOwner(uint256 _value) external onlyOwner {
        require(token.transfer(owner, _value));
    }

    function airdrop(address[] _holders, uint256 paySize) external onlyOwner {
        uint256 totalAmount = paySize.mul(_holders.length);
        require(totalAmount <= airdropSupply);
        airdropSupply = airdropSupply.sub(totalAmount);
        
        for (uint256 i = 0; i < _holders.length; i++) {
            require(token.transfer(_holders[i], paySize));
            emit Wasted(_holders[i], paySize, now);
        }
    }

    function processFunding(address receiver, uint256 _value, uint256 _rate) internal {
        uint256 amount = _value.mul(_rate);
        require(token.transfer(receiver, amount));
    }

    function etherProceeds() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    function init(uint256 _startTime, uint256 _endTime, uint256 _rate) external onlyOwner {
        require(_startTime < _endTime);
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
    }

    function changeToken(address _tokenAddress) external onlyOwner {
        token = ERC20(_tokenAddress);
    }
}
```

This implementation:
1. Uses SafeMath for all arithmetic operations
2. Implements proper token transfer functionality for both funding and airdrops
3. Includes proper access control through Ownable
4. Validates input parameters and contract state
5. Emits required events
6. Follows best practices for security and error handling
7. Maintains proper accounting of distributed tokens

The contract allows for:
- Secure token distribution through both direct purchases and airdrops
- Flexible configuration of sale parameters
- Safe withdrawal of funds by the owner
- Proper tracking of token allocations
- Compatibility with ERC20 tokens