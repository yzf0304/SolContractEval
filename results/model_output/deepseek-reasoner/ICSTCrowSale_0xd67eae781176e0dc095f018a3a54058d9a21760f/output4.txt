Here is the completed code for the ICSTCrowSale contract:

```solidity
pragma solidity ^0.4.21;

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Ownable {
  address public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract ICSTCrowSale is Ownable {
    using SafeMath for uint256;

    uint256 public totalFundingSupply;
    ERC20 public token;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public airdropSupply;
    uint256 public rate;

    event Wasted(address to, uint256 value, uint256 date);

    function ICSTCrowSale() public {
        rate = 0;
        startTime = 0;
        endTime = 0;
        airdropSupply = 0;
        totalFundingSupply = 0;
        token = ERC20(0xe6bc60a00b81c7f3cbc8f4ef3b0a6805b6851753);
    }

    function () payable external {
        require(now >= startTime && now <= endTime);
        uint256 amount = msg.value.mul(rate);
        processFunding(msg.sender, amount);
        totalFundingSupply = totalFundingSupply.add(amount);
    }

    function withdrawCoinToOwner(uint256 _value) external onlyOwner {
        require(token.transfer(owner, _value));
    }

    function airdrop(address[] _holders, uint256 paySize) external onlyOwner {
        require(_holders.length > 0 && paySize > 0);
        uint256 totalAmount = _holders.length.mul(paySize);
        require(airdropSupply >= totalAmount);
        airdropSupply = airdropSupply.sub(totalAmount);
        
        for (uint256 i = 0; i < _holders.length; i++) {
            require(token.transfer(_holders[i], paySize));
            emit Wasted(_holders[i], paySize, now);
        }
    }

    function processFunding(address receiver, uint256 amount) internal {
        require(token.transfer(receiver, amount));
    }

    function etherProceeds() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    function init(uint256 _startTime, uint256 _endTime, uint256 _rate) external onlyOwner {
        require(_startTime < _endTime);
        startTime = _startTime;
        endTime = _endTime;
        rate = _rate;
    }

    function changeToken(address _tokenAddress) external onlyOwner {
        require(_tokenAddress != address(0));
        token = ERC20(_tokenAddress);
    }
}
```

Key points implemented:
1. Completed all function bodies according to specifications
2. Used SafeMath for arithmetic operations
3. Added proper access control with onlyOwner modifier
4. Implemented time checks for crowdsale period
5. Added token transfer safety checks
6. Properly emits Wasted event during airdrops
7. Ensured contract follows ERC20 token standards
8. Implemented proper ether withdrawal functionality
9. Added input validations for critical parameters
10. Maintained compatibility with Solidity 0.4.21 syntax and features