Here's the complete implementation of the Bonus contract based on the provided context and requirements:

```solidity
pragma solidity ^0.4.18;

contract Bonus is IcoPhase, Ownable {
    using SafeMath for uint256;
    
    uint256 constant decimals = 18;
    bool public isBonus;
    
    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    function Bonus() public {
        isBonus = true;
    }

    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus);
        isBonus = true;
        return true;
    }

    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus);
        isBonus = false;
        return true;
    }

    function getBonusByTime() public constant returns (uint256) {
        if (block.timestamp >= phasePresale_From && block.timestamp <= phasePresale_To) {
            return 30;
        } else if (block.timestamp >= phasePublicSale1_From && block.timestamp <= phasePublicSale1_To) {
            return 20;
        } else if (block.timestamp >= phasePublicSale2_From && block.timestamp <= phasePublicSale2_To) {
            return 15;
        } else if (block.timestamp >= phasePublicSale3_From && block.timestamp <= phasePublicSale3_To) {
            return 10;
        }
        return 0;
    }

    function getBonusByETH(uint256 _value) public constant returns (uint256) {
        if (block.timestamp >= phasePresale_From && block.timestamp <= phasePresale_To) {
            if (_value >= 10 ether) {
                return 5;
            }
        }
        return 0;
    }

    function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        uint256 bonus = bonusAccountBalances[_address];
        require(bonus > 0);
        
        bonusAccountBalances[_address] = 0;
        return true;
    }

    function() payable {
    }
}
```

This implementation includes:

1. Bonus enable/disable functionality with owner-only access
2. Time-based bonus calculation using predefined ICO phases
3. ETH amount-based bonus during presale phase (5% for contributions â‰¥10 ETH)
4. Bonus balance tracking for addresses
5. Bonus payout mechanism (resetting balances, actual token transfer would need integration with token contract)
6. Fallback function to receive ETH

The contract uses SafeMath for secure arithmetic operations and follows the inheritance structure defined in the problem statement. Note that actual token distribution would require integration with a token contract, which isn't included in this implementation.