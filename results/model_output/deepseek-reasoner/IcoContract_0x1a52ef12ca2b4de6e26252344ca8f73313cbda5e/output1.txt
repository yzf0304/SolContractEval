Here is the complete and functional implementation of the Bonus contract:

```solidity
pragma solidity ^0.4.18;

contract Bonus is IcoPhase, Ownable {
    using SafeMath for uint256;

    uint256 constant decimals = 18;
    bool public isBonus;
    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    function Bonus() public {
        isBonus = true;
    }

    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus);
        isBonus = true;
        return true;
    }

    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus);
        isBonus = false;
        return true;
    }

    function getBonusByTime() public constant returns (uint256) {
        if (now >= phasePresale_From && now <= phasePresale_To) {
            return 30;
        } else if (now >= phasePublicSale1_From && now <= phasePublicSale1_To) {
            return 20;
        } else if (now >= phasePublicSale2_From && now <= phasePublicSale2_To) {
            return 15;
        } else if (now >= phasePublicSale3_From && now <= phasePublicSale3_To) {
            return 10;
        } else {
            return 0;
        }
    }

    function getBonusByETH(uint256 _value) public constant returns (uint256) {
        if (_value >= 100 ether) {
            return 5;
        } else if (_value >= 50 ether) {
            return 3;
        } else if (_value >= 10 ether) {
            return 1;
        } else {
            return 0;
        }
    }

    function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        require(bonusAccountBalances[_address] > 0);
        bonusAccountBalances[_address] = 0;
        return true;
    }

    function() public payable {
        require(isBonus);
        
        uint256 timeBonus = getBonusByTime();
        uint256 ethBonus = getBonusByETH(msg.value);
        uint256 totalBonus = timeBonus.add(ethBonus);

        if (totalBonus > 0) {
            if (bonusAccountBalances[msg.sender] == 0) {
                bonusAccountIndex[bonusAccountCount] = msg.sender;
                bonusAccountCount = bonusAccountCount.add(1);
            }
            bonusAccountBalances[msg.sender] = bonusAccountBalances[msg.sender].add(totalBonus);
        }
    }
}
```

This implementation:
1. Manages bonus activation state with enable/disable functions
2. Calculates time-based bonuses using ICO phase timestamps
3. Provides ETH amount-based bonus tiers
4. Tracks bonus balances and participant addresses
5. Allows bonus redemption clearing via payBonusToAddress
6. Automatically calculates and stores bonuses when receiving ETH (while bonuses are active)
7. Uses SafeMath for secure arithmetic operations
8. Maintains compatibility with Solidity 0.4.18 syntax and features

The contract handles both time-based and amount-based bonuses, stores them for each participant, and allows the owner to manage bonus distribution while maintaining a registry of all bonus participants.