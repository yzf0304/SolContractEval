Here is the completed Kubera smart contract:

```solidity
contract Kubera is SafeMath {

    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Kubera token';
    string public symbol = 'KBR';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    address public owner;
    uint public tokensSoldToInvestors = 0;
    uint public maxGoalInICO = 2100000000;
    uint256 public startTime = 1510325999;
    bool public burned;
    bool public hasICOStarted;
    address public tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event TransferToReferral(address indexed referralAddress, uint256 value);
    event Approval(address indexed Owner, address indexed spender, uint256 value);
    event Burned(uint amount);

    function Kubera() {
        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;
        balanceOf[owner] = 2205000000;
        totalSupply = 2205000000;
    }

    function transfer(address _to, uint256 _value) returns(bool success) {
        if (block.timestamp < startTime) {
            require(msg.sender == owner);
        }
        
        if (msg.sender == owner && block.timestamp < startTime) {
            uint newSold = safeAdd(tokensSoldToInvestors, _value);
            require(newSold <= maxGoalInICO);
            tokensSoldToInvestors = newSold;
        }

        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {
        if (block.timestamp < startTime) {
            require(_from == owner);
        }

        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);
        
        if (_from == owner && block.timestamp < startTime) {
            uint newSold = safeAdd(tokensSoldToInvestors, _value);
            require(newSold <= maxGoalInICO);
            tokensSoldToInvestors = newSold;
        }

        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn() {
        require(!burned);
        require(msg.sender == owner);
        require(block.timestamp >= startTime);
        
        uint remaining = balanceOf[owner];
        require(remaining >= 105000000);
        
        balanceOf[tokensHolder] = safeAdd(balanceOf[tokensHolder], 105000000);
        balanceOf[owner] = safeSub(remaining, 105000000);
        Transfer(owner, tokensHolder, 105000000);
        
        uint burnAmount = balanceOf[owner];
        totalSupply = safeSub(totalSupply, burnAmount);
        balanceOf[owner] = 0;
        burned = true;
        Burned(burnAmount);
    }
}
```

This implementation:
1. Uses SafeMath for all arithmetic operations
2. Enforces ICO transfer restrictions (only owner can transfer before startTime)
3. Tracks tokens sold during ICO and enforces maximum goal
4. Implements ERC20 standard functions (transfer, approve, transferFrom)
5. Includes burn functionality to handle unsold tokens post-ICO
6. Maintains all original variables and events from the provided context
7. Uses proper checks for transfer permissions and timing constraints
8. Follows Solidity 0.4.11 syntax and conventions

The contract maintains the original token economics while implementing security best practices through SafeMath usage and proper access controls.