Here is the complete implementation of the Kubera contract:

```solidity
contract Kubera is SafeMath {

    /* Public variables of the token */
    string public standard = 'ERC20';
    string public name = 'Kubera token';
    string public symbol = 'KBR';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    address public owner;
    uint public tokensSoldToInvestors = 0;
    uint public maxGoalInICO = 2100000000;
    uint256 public startTime = 1510325999;
    bool public burned;
    address public tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed Owner, address indexed spender, uint256 value);
    event Burned(uint amount);

    function Kubera() {
        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;
        balanceOf[owner] = 2205000000;
        totalSupply = 2205000000;
    }

    function transfer(address _to, uint256 _value) returns(bool success) {
        if (now < startTime) {
            require(msg.sender == owner);
            uint remaining = safeSub(maxGoalInICO, tokensSoldToInvestors);
            if (_value > remaining) {
                _value = remaining;
            }
            tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value);
        }
        
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {
        if (now < startTime) {
            require(_from == owner);
            uint remaining = safeSub(maxGoalInICO, tokensSoldToInvestors);
            if (_value > remaining) {
                _value = remaining;
            }
            tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value);
        }
        
        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);
        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn() {
        require(!burned);
        require(now >= startTime);
        burned = true;

        uint ownerBalance = balanceOf[owner];
        uint amountToHolder = 105000000;
        require(ownerBalance >= amountToHolder);

        uint amountToBurn = safeSub(ownerBalance, amountToHolder);
        balanceOf[owner] = safeSub(balanceOf[owner], ownerBalance);
        balanceOf[tokensHolder] = safeAdd(balanceOf[tokensHolder], amountToHolder);
        totalSupply = safeSub(totalSupply, amountToBurn);
        
        Burned(amountToBurn);
        Transfer(owner, tokensHolder, amountToHolder);
    }
}
```

This implementation:
1. Enforces ICO timing restrictions using startTime
2. Tracks and limits token sales during ICO using maxGoalInICO
3. Implements ERC20 transfer/approve/transferFrom with SafeMath checks
4. Includes burn functionality that transfers 105 million tokens to tokensHolder and burns the remaining supply
5. Maintains backward compatibility with Solidity 0.4.11
6. Uses the provided SafeMath library for all arithmetic operations
7. Follows the exact specifications and addresses from the original code context