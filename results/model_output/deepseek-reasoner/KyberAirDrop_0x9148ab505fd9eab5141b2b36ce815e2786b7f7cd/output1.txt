Here is the complete and functional contract code for KyberGenesisToken:

```solidity
contract KyberGenesisToken is Ownable {
  string  public  constant name     = "Kyber Genesis Token";
  string  public  constant symbol   = "KGT";
  uint    public  constant decimals = 0;

  uint                   public totalSupply = 0;
  mapping(address=>uint) public balanceOf;

  function KyberGenesisToken( address minter ) {
    transferOwnership(minter);
  }

  event Transfer(address indexed _from, address indexed _to, uint _value);
  event EndMinting( uint timestamp );

  function mint( address[] recipients ) onlyOwner {
    for (uint i = 0; i < recipients.length; i++) {
      address recipient = recipients[i];
      if (balanceOf[recipient] == 0) {
        balanceOf[recipient] = 1;
        totalSupply += 1;
        Transfer(address(0), recipient, 1);
      }
    }
  }

  function endMinting() onlyOwner {
    transferOwnership(address(0xdead));
    EndMinting(block.timestamp);
  }

  function burn() {
    require(balanceOf[msg.sender] == 1);
    balanceOf[msg.sender] = 0;
    totalSupply -= 1;
    Transfer(msg.sender, address(0), 1);
  }

  function emergencyERC20Drain( ERC20Interface token, uint amount ){
    require(token.transfer(owner, amount));
  }

  function transfer(address _to, uint _value) returns (bool){
    revert();
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool){
    revert();
  }

  function approve(address _spender, uint _value) returns (bool){
    revert();
  }

  function allowance(address _owner, address _spender) constant returns (uint){
    return 0;
  }

  event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

**Key Implementation Details:**

1. **Minting Logic:**
   - Only owner can mint tokens
   - Iterates through recipient array and mints 1 token per address
   - Ensures each address can only hold one token through balance check
   - Updates total supply and emits Transfer event from address(0)

2. **Burn Function:**
   - Users can destroy their own token
   - Verifies sender has exactly 1 token
   - Updates balance and total supply
   - Emits Transfer event to address(0)

3. **End Minting:**
   - Transfers ownership to a dead address (0xdead)
   - Prevents further minting by removing owner privileges
   - Emits EndMinting event

4. **ERC20 Compliance:**
   - Implements required ERC20 functions but reverts on transfers
   - Allows for proper interface recognition while maintaining token non-transferability

5. **Emergency Drain:**
   - Allows recovery of ERC20 tokens sent to contract
   - Transfers tokens to current owner address
   - Uses require to validate transfer success

6. **Ownership Management:**
   - Inherits from Ownable with modified constructor
   - Initial ownership transferred to specified minter during deployment

The contract strictly follows the requirements of fixed supply (1 token per address), owner-controlled minting, and user-controlled burning while maintaining compatibility with ERC20 interfaces.