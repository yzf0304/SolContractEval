To complete the `KyberContributorWhitelist` contract based on the provided context and requirements, we need to implement the functions to manage contributor addresses and their caps while ensuring only the owner can modify these settings. Here's the step-by-step solution:

```solidity
/**
 * @title KyberContributorWhitelist
 * @notice A smart contract for managing a whitelist of contributors, allowing the owner to set and manage contribution caps.
 * @dev This contract extends the Ownable contract, providing ownership control over the whitelisting and cap setting functionalities.
 */
contract KyberContributorWhitelist is Ownable {
    uint public slackUsersCap = 7;
    mapping(address => uint) public addressCap;

    function KyberContributorWhitelist() {}

    event ListAddress(address _user, uint _cap, uint _time);

    function listAddress(address _user, uint _cap) onlyOwner {
        addressCap[_user] = _cap;
        emit ListAddress(_user, _cap, now);
    }

    function listAddresses(address[] _users, uint[] _cap) onlyOwner {
        require(_users.length == _cap.length);
        for (uint i = 0; i < _users.length; i++) {
            addressCap[_users[i]] = _cap[i];
            emit ListAddress(_users[i], _cap[i], now);
        }
    }

    function setSlackUsersCap(uint _cap) onlyOwner {
        slackUsersCap = _cap;
    }

    function getCap(address _user) constant returns (uint) {
        uint cap = addressCap[_user];
        return cap == 1 ? slackUsersCap : cap;
    }

    function destroy() onlyOwner {
        selfdestruct(owner);
    }
}
```

**Step-by-Step Explanation:**

1. **Constructor:**
   - The constructor `KyberContributorWhitelist()` is empty as no additional initialization is needed beyond the Ownable setup (handled by the parent contract).

2. **listAddress Function:**
   - Sets the contribution cap for a single address and emits an event with the address, cap, and current timestamp.
   - Uses the `onlyOwner` modifier to restrict access.

3. **listAddresses Function:**
   - Processes arrays of addresses and their corresponding caps.
   - Checks that both arrays have the same length to avoid mismatches.
   - Iterates through each address, setting their cap and emitting an event for each entry.

4. **setSlackUsersCap Function:**
   - Allows the owner to update the global cap (`slackUsersCap`) used for addresses with a cap value of 1.

5. **getCap Function:**
   - Returns the cap for a given address. If the address's cap is 1, it returns the `slackUsersCap`; otherwise, it returns the specific cap stored in `addressCap`.

6. **destroy Function:**
   - Enables the owner to self-destruct the contract, sending any remaining Ether to the owner's address.

This implementation adheres to the provided specifications and ensures proper access control through the inherited Ownable functionalities.