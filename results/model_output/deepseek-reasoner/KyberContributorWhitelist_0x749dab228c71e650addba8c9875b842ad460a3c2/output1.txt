Here is the completed KyberContributorWhitelist contract:

```solidity
contract KyberContributorWhitelist is Ownable {
    uint public slackUsersCap = 7;
    mapping(address => uint) public addressCap;

    function KyberContributorWhitelist() {}

    event ListAddress(address _user, uint _cap, uint _time);

    function listAddress(address _user, uint _cap) onlyOwner {
        addressCap[_user] = _cap;
        ListAddress(_user, _cap, now);
    }

    function listAddresses(address[] _users, uint[] _cap) onlyOwner {
        require(_users.length == _cap.length);
        for (uint i = 0; i < _users.length; i++) {
            addressCap[_users[i]] = _cap[i];
            ListAddress(_users[i], _cap[i], now);
        }
    }

    function setSlackUsersCap(uint _cap) onlyOwner {
        slackUsersCap = _cap;
    }

    function getCap(address _user) constant returns (uint) {
        uint cap = addressCap[_user];
        return cap == 1 ? slackUsersCap : cap;
    }

    function destroy() onlyOwner {
        selfdestruct(owner);
    }
}
```

This implementation:
1. Maintains a mapping of address caps and global slack cap
2. Allows owner to list/delist addresses with caps 
3. Implements batch listing for efficiency
4. Returns appropriate cap values (global slack cap for addresses with cap=1)
5. Includes selfdestruct functionality for contract cleanup
6. Follows Solidity 0.4.13 syntax and conventions
7. Maintains all ownership controls through the Ownable parent contract