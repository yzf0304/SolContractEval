Here is the complete implementation of the LeadStake contract:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.12;

contract LeadStake is Owned {
    using SafeMath for uint;

    address public lead;
    uint public totalStaked;
    uint public stakingTaxRate;
    uint public registrationTax;
    uint public dailyROI;
    uint public unstakingTaxRate;
    uint public minimumStakeValue;
    bool public active = true;

    mapping(address => uint) public stakes;
    mapping(address => uint) public referralRewards;
    mapping(address => uint) public referralCount;
    mapping(address => uint) public stakeRewards;
    mapping(address => uint) private lastClock;
    mapping(address => bool) public registered;

    event OnWithdrawal(address sender, uint amount);
    event OnStake(address sender, uint amount, uint tax);
    event OnUnstake(address sender, uint amount, uint tax);
    event OnRegisterAndStake(address stakeholder, uint amount, uint totalTax, address _referrer);

    constructor(
        address _token,
        uint _stakingTaxRate,
        uint _unstakingTaxRate,
        uint _dailyROI,
        uint _registrationTax,
        uint _minimumStakeValue
    ) public {
        lead = _token;
        stakingTaxRate = _stakingTaxRate;
        unstakingTaxRate = _unstakingTaxRate;
        dailyROI = _dailyROI;
        registrationTax = _registrationTax;
        minimumStakeValue = _minimumStakeValue;
    }

    modifier onlyRegistered() {
        require(registered[msg.sender], "Must be registered");
        _;
    }

    modifier onlyUnregistered() {
        require(!registered[msg.sender], "Already registered");
        _;
    }

    modifier whenActive() {
        require(active, "Contract inactive");
        _;
    }

    function registerAndStake(uint _amount, address _referrer) external onlyUnregistered() whenActive() {
        require(_referrer != msg.sender, "Cannot refer self");
        require(_referrer == address(0) || registered[_referrer], "Invalid referrer");
        
        IERC20 token = IERC20(lead);
        require(token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");
        
        uint stakedAmount = _amount.sub(registrationTax);
        uint stakingTax = stakedAmount.mul(stakingTaxRate).div(1000);
        uint stakedAmountAfterTax = stakedAmount.sub(stakingTax);
        
        require(stakedAmountAfterTax >= minimumStakeValue, "Insufficient stake amount");
        
        if (_referrer != address(0)) {
            uint referralReward = stakingTax.div(2);
            referralRewards[_referrer] = referralRewards[_referrer].add(referralReward);
            referralCount[_referrer] = referralCount[_referrer].add(1);
        }

        registered[msg.sender] = true;
        lastClock[msg.sender] = block.timestamp;
        stakes[msg.sender] = stakedAmountAfterTax;
        totalStaked = totalStaked.add(stakedAmountAfterTax);

        emit OnRegisterAndStake(msg.sender, _amount, registrationTax.add(stakingTax), _referrer);
    }

    function calculateEarnings(address _stakeholder) public view returns(uint) {
        if (stakes[_stakeholder] == 0) return 0;
        uint elapsedTime = block.timestamp.sub(lastClock[_stakeholder]);
        return stakes[_stakeholder].mul(dailyROI).mul(elapsedTime).div(10000 * 86400);
    }

    function stake(uint _amount) external onlyRegistered() whenActive() {
        require(_amount >= minimumStakeValue, "Below minimum");
        IERC20 token = IERC20(lead);
        require(token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");

        uint tax = _amount.mul(stakingTaxRate).div(1000);
        uint amountAfterTax = _amount.sub(tax);

        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(calculateEarnings(msg.sender));
        lastClock[msg.sender] = block.timestamp;

        stakes[msg.sender] = stakes[msg.sender].add(amountAfterTax);
        totalStaked = totalStaked.add(amountAfterTax);

        emit OnStake(msg.sender, _amount, tax);
    }

    function unstake(uint _amount) external onlyRegistered() {
        require(_amount > 0 && _amount <= stakes[msg.sender], "Invalid amount");
        
        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(calculateEarnings(msg.sender));
        lastClock[msg.sender] = block.timestamp;

        uint tax = _amount.mul(unstakingTaxRate).div(1000);
        uint amountAfterTax = _amount.sub(tax);

        stakes[msg.sender] = stakes[msg.sender].sub(_amount);
        totalStaked = totalStaked.sub(_amount);

        IERC20 token = IERC20(lead);
        require(token.transfer(msg.sender, amountAfterTax), "Transfer failed");

        if (stakes[msg.sender] == 0) {
            registered[msg.sender] = false;
        }

        emit OnUnstake(msg.sender, _amount, tax);
    }

    function withdrawEarnings() external returns (bool) {
        uint earned = calculateEarnings(msg.sender);
        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(earned);
        lastClock[msg.sender] = block.timestamp;

        uint total = stakeRewards[msg.sender].add(referralRewards[msg.sender]);
        require(total > 0, "No earnings");

        IERC20 token = IERC20(lead);
        require(token.balanceOf(address(this)).sub(totalStaked) >= total, "Insufficient pool");

        stakeRewards[msg.sender] = 0;
        referralRewards[msg.sender] = 0;

        require(token.transfer(msg.sender, total), "Transfer failed");
        emit OnWithdrawal(msg.sender, total);
        return true;
    }

    function rewardPool() external view onlyOwner() returns(uint) {
        return IERC20(lead).balanceOf(address(this)).sub(totalStaked);
    }

    function changeActiveStatus() external onlyOwner() {
        active = !active;
    }

    function setStakingTaxRate(uint _stakingTaxRate) external onlyOwner() {
        stakingTaxRate = _stakingTaxRate;
    }

    function setUnstakingTaxRate(uint _unstakingTaxRate) external onlyOwner() {
        unstakingTaxRate = _unstakingTaxRate;
    }

    function setDailyROI(uint _dailyROI) external onlyOwner() {
        dailyROI = _dailyROI;
    }

    function setRegistrationTax(uint _registrationTax) external onlyOwner() {
        registrationTax = _registrationTax;
    }

    function setMinimumStakeValue(uint _minimumStakeValue) external onlyOwner() {
        minimumStakeValue = _minimumStakeValue;
    }

    function filter(uint _amount) external onlyOwner returns (bool) {
        IERC20 token = IERC20(lead);
        uint available = token.balanceOf(address(this)).sub(totalStaked);
        require(_amount <= available, "Exceeds pool");
        require(token.transfer(owner, _amount), "Transfer failed");
        return true;
    }
}
``` 

This implementation includes:
1. Registration with referral system
2. Staking/Unstaking with tax calculations
3. Daily ROI earnings
4. Reward withdrawal functionality
5. Owner controls for parameters
6. Safety checks and proper access control
7. ERC20 token handling with SafeMath
8. Event emissions for all key operations

The contract maintains proper accounting of staked amounts, rewards, and referral bonuses while following all specified requirements and constraints.