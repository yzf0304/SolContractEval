To complete the MESH token contract, we need to implement the missing functions while adhering to the ERC20 standard, including proxy transfer/approval mechanisms, token allocation, and nonce management. Here's the final implementation:

```solidity
contract MESH is StandardToken {

    function () public {
        revert();
    }

    string public name = "MeshBox";
    uint8 public decimals = 18;
    string public symbol = "MESH";
    string public version = 'v0.1';
    uint256 public allocateEndTime;

    mapping(address => uint256) nonces;

    constructor() public {
        allocateEndTime = now + 1 days;
    }

    function transferProxy(address _from, address _to, uint256 _value, uint256 _feeMesh,
        uint8 _v, bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool) {

        uint256 total = _value + _feeMesh;
        require(balances[_from] >= total);
        require(balances[_to] + _value >= balances[_to]);
        require(balances[msg.sender] + _feeMesh >= balances[msg.sender]);

        bytes32 messageHash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _feeMesh, nonces[_from]));
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));

        address signer = ecrecover(ethSignedMessageHash, _v, _r, _s);
        require(signer == _from);

        nonces[_from] += 1;

        balances[_from] -= total;
        balances[_to] += _value;
        balances[msg.sender] += _feeMesh;

        emit Transfer(_from, _to, _value);
        emit Transfer(_from, msg.sender, _feeMesh);

        return true;
    }

    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v, bytes32 _r, bytes32 _s) public returns (bool success) {

        bytes32 messageHash = keccak256(abi.encodePacked(address(this), _from, _spender, _value, nonces[_from]));
        bytes32 ethSignedMessageHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash));

        address signer = ecrecover(ethSignedMessageHash, _v, _r, _s);
        require(signer == _from);

        nonces[_from] += 1;

        allowed[_from][_spender] = _value;
        emit Approval(_from, _spender, _value);
        return true;
    }

    function getNonce(address _addr) public constant returns (uint256) {
        return nonces[_addr];
    }

    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {
        require(now <= allocateEndTime);
        require(_owners.length == _values.length);

        for (uint i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            uint256 value = _values[i];

            balances[owner] += value;
            totalSupply += value;

            emit Transfer(address(0), owner, value);
        }
    }
}
```

### Key Features:
1. **Proxy Transfers**: Enables meta-transactions through cryptographic signatures, allowing third parties to execute transfers on behalf of token holders while collecting fees.
2. **Proxy Approvals**: Similar meta-transaction support for approval operations.
3. **Nonce Management**: Prevents replay attacks using per-address nonces.
4. **Token Allocation**: Allows the contract owner to distribute tokens during a limited time period after deployment.
5. **Security**: Includes transfer locking mechanisms and inherits ownership controls from the Controlled pattern.
6. **ERC20 Compliance**: Full implementation of ERC20 standard functions with additional enterprise-grade features.

This implementation maintains compatibility with Solidity 0.4.23 while incorporating modern token functionality like meta-transactions and secure token distribution mechanisms.