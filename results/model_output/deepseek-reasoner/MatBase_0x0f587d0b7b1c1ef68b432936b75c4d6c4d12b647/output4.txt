Here is the completed `MatBase` contract based on the provided context and requirements:

```solidity
pragma solidity ^0.4.17;

contract MatBase is Ownable, MatToken, MatBonus {
    using SafeMath for uint256;

    uint256 public constant _START_DATE = 1508284800;
    uint256 public constant _END_DATE = 1513641600;
    uint256 public constant CROWDSALE_PRICE = 100;
    address public constant ICO_ADDRESS = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;
    address public constant PARTNERS_WALLET = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;
    address public constant TEAM_WALLET = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;
    address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;

    uint256 public startTime;
    uint256 public endTime;
    address public wallet;
    address public p_wallet;
    address public t_wallet;
    uint256 public totalCollected;
    uint256 public rate;
    bool public isWhitelistOn;
    uint256 public whiteListLimit;

    enum WLS { notlisted, listed, fulfilled }
    struct FundReservation {
        WLS status;
        uint256 reserved;
    }
    mapping (address => FundReservation) public whitelist;

    event Mint(address indexed purchaser, uint256 amount);
    event Bonus(address indexed purchaser, uint256 amount);
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amountTokens, string referral);
    event White(address indexed to, uint256 reservation);

    function MatBase() public {
        startTime = _START_DATE;
        endTime = _END_DATE;
        wallet = ICO_ADDRESS;
        rate = CROWDSALE_PRICE;
        p_wallet = PARTNERS_WALLET;
        t_wallet = TEAM_WALLET;
        balances[p_wallet] = MAT_PARTNERS_SUPPLY_LIMIT;
        balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;
        totalSupply = MAT_PARTNERS_SUPPLY_LIMIT.add(MAT_TEAM_SUPPLY_LIMIT);
        whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;
    }

    function setStartTime(uint256 _startTime) public onlyOwner {
        startTime = _startTime;
    }

    function setEndTime(uint256 _endTime) public onlyOwner {
        endTime = _endTime;
    }

    function hasEnded() public view returns (bool) {
        return block.timestamp > endTime;
    }

    function mint(address _to, uint256 _tokens) internal returns (bool) {
        require(_to != address(0));
        require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);

        totalSupply = totalSupply.add(_tokens);
        balances[_to] = balances[_to].add(_tokens);
        emit Mint(_to, _tokens);
        return true;
    }

    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function validPurchase() internal view returns (bool) {
        bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;
        bool nonZeroPurchase = msg.value != 0;
        return withinPeriod && nonZeroPurchase;
    }

    function () public payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(rate);
        uint256 bonus = calcBonus(tokens);
        uint256 totalTokens = tokens.add(bonus);

        if (isWhitelistOn) {
            require(buyTokenWL(beneficiary, totalTokens));
        }

        require(mint(beneficiary, totalTokens));

        if (bonus > 0) {
            emit Bonus(beneficiary, bonus);
        }

        forwardFunds();
        totalCollected = totalCollected.add(weiAmount);

        emit TokenPurchase(msg.sender, beneficiary, weiAmount, totalTokens, "");
    }

    function buyTokensReferral(address beneficiary, string referral) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(rate);
        uint256 bonus = calcBonus(tokens);
        uint256 totalTokens = tokens.add(bonus);

        if (isWhitelistOn) {
            require(buyTokenWL(beneficiary, totalTokens));
        }

        require(mint(beneficiary, totalTokens));

        if (bonus > 0) {
            emit Bonus(beneficiary, bonus);
        }

        forwardFunds();
        totalCollected = totalCollected.add(weiAmount);

        emit TokenPurchase(msg.sender, beneficiary, weiAmount, totalTokens, referral);
    }

    function stopWhitelistReservetion() public onlyOwner {
        whiteListLimit = 0;
    }

    function setWhiteListStatus(bool _isWhitelistOn) public onlyOwner {
        isWhitelistOn = _isWhitelistOn;
    }

    function buyTokenWL(address beneficiary, uint256 tokens) internal returns (bool) {
        FundReservation storage reservation = whitelist[beneficiary];
        require(reservation.status == WLS.listed);
        require(reservation.reserved >= tokens);

        reservation.reserved = reservation.reserved.sub(tokens);
        if (reservation.reserved == 0) {
            reservation.status = WLS.fulfilled;
        }
        return true;
    }

    function regWL(address wlmember, uint256 reservation) public onlyOwner returns (bool) {
        require(wlmember != address(0));
        require(reservation > 0);
        require(whiteListLimit >= reservation);
        require(whitelist[wlmember].status != WLS.fulfilled);

        whiteListLimit = whiteListLimit.sub(reservation);

        if (whitelist[wlmember].status == WLS.notlisted) {
            whitelist[wlmember].status = WLS.listed;
            whitelist[wlmember].reserved = reservation;
        } else {
            whitelist[wlmember].reserved = whitelist[wlmember].reserved.add(reservation);
        }

        emit White(wlmember, reservation);
        return true;
    }

    function convert(address _to, uint256 _pretokens, uint256 _tokens) public onlyOwner returns (bool) {
        require(_to != address(0));
        require(mint(_to, _tokens));
        return true;
    }
}
```

This contract includes all the required functionalities such as token minting, whitelist management, referral purchases, and presale conversions while adhering to the specified constraints and using SafeMath for arithmetic operations. The code is compatible with Solidity 0.4.17 and strictly follows the provided context and requirements.