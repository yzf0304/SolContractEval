To solve this problem, we need to create a smart contract that allows users to claim ERC20 tokens based on a Merkle tree proof. This contract will efficiently track which claims have been processed using a bitmask and ensure that only valid claims are processed using Merkle proofs.

### Approach
1. **Merkle Tree Verification**: Use a Merkle tree to verify the validity of claims. Each leaf in the Merkle tree is a hash of the claim's index, the recipient's address, and the token amount. This ensures that only valid claims can be processed.
2. **Bitmask Tracking**: Use a bitmask (a packed array of booleans) to efficiently track which claims have been processed. Each bit in the bitmask represents whether a specific index has been claimed.
3. **Token Transfer**: Once a valid claim is verified, the contract transfers the specified amount of tokens to the claimant's address.

### Solution Code
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.6.11;

contract MerkleDistributor is IMerkleDistributor {
    address public immutable override token;
    bytes32 public immutable override merkleRoot;

    mapping(uint256 => uint256) private claimedBitMap;

    constructor(address token_, bytes32 merkleRoot_) public {
        token = token_;
        merkleRoot = merkleRoot_;
    }

    function isClaimed(uint256 index) public view override returns (bool) {
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        uint256 mask = uint256(1) << bitIndex;
        uint256 word = claimedBitMap[wordIndex];
        return (word & mask) != 0;
    }

    function _setClaimed(uint256 index) private {
        uint256 wordIndex = index / 256;
        uint256 bitIndex = index % 256;
        claimedBitMap[wordIndex] = claimedBitMap[wordIndex] | (uint256(1) << bitIndex;
    }

    function claim(uint256 index, address account, uint256 amount, bytes32[] calldata merkleProof) external override {
        require(!isClaimed(index), "MerkleDistributor: Drop already claimed.");

        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(MerkleProof.verify(merkleProof, merkleRoot, node), "MerkleDistributor: Invalid proof.");

        _setClaimed(index);
        require(IERC20(token).transfer(account, amount), "MerkleDistributor: Transfer failed.");

        emit Claimed(index, account, amount);
    }
}
```

### Explanation
1. **Initialization**: The contract is initialized with the token address and Merkle root. The token address is the ERC20 token to be distributed, and the Merkle root is used to verify claims.
2. **Check Claim Status**: The `isClaimed` function checks if a specific index has been claimed using a bitmask. Each index is mapped to a bit in a 256-bit word, allowing efficient storage and lookup.
3. **Set Claim Status**: The `_setClaimed` function marks an index as claimed by setting the corresponding bit in the bitmask.
4. **Claim Tokens**: The `claim` function verifies the Merkle proof, checks if the claim is valid and unclaimed, marks it as claimed, and transfers the tokens. If any step fails (e.g., invalid proof, already claimed), the transaction is reverted.

This approach ensures that only valid claims are processed, efficiently tracks claimed indices, and securely transfers tokens using the ERC20 standard.