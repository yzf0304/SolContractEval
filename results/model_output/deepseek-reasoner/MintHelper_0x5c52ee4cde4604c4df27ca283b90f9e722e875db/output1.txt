Here is the complete and functional implementation of the `MintHelper` contract based on the provided requirements:

```solidity
pragma solidity 0.5.10;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        return c;
    }
}

contract ERC20Interface {
    function transfer(address to, uint tokens) public returns (bool success);
}

contract ERC918Interface {
    function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);
}

contract MintHelper is Ownable {
    using SafeMath for uint;

    string public name;
    address public mintableToken;
    mapping(bytes32 => bool) public successfulPayments;

    constructor(address mToken, string memory mName) public {
        mintableToken = mToken;
        name = mName;
    }

    function setMintableToken(address mToken) public onlyOwner returns (bool) {
        mintableToken = mToken;
        return true;
    }

    function paymentSuccessful(bytes32 paymentId) public view returns (bool) {
        return successfulPayments[paymentId];
    }

    function proxyMint(uint256 nonce, bytes32 challenge_digest) public returns (bool) {
        require(mintableToken != address(0), "Mintable token not set");
        bool success = ERC918Interface(mintableToken).mint(nonce, challenge_digest);
        require(success, "Minting failed");
        return true;
    }

    function withdraw() public onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function send(address _tokenAddr, address dest, uint value) public onlyOwner returns (bool) {
        bool success = ERC20Interface(_tokenAddr).transfer(dest, value);
        require(success, "Transfer failed");
        return true;
    }

    function multisend(address _tokenAddr, bytes32 paymentId, address[] memory dests, uint256[] memory values) public onlyOwner returns (uint256) {
        require(!successfulPayments[paymentId], "Payment ID already used");
        require(dests.length == values.length, "Array length mismatch");

        ERC20Interface token = ERC20Interface(_tokenAddr);
        for (uint i = 0; i < dests.length; i++) {
            require(token.transfer(dests[i], values[i]), "Transfer failed");
        }

        successfulPayments[paymentId] = true;
        return dests.length;
    }
}
```

This implementation:
1. Inherits from the provided Ownable contract
2. Uses SafeMath for arithmetic operations
3. Implements all specified functions with proper access control
4. Maintains payment tracking with a mapping
5. Handles ETH and token withdrawals safely
6. Includes proper error handling and input validation
7. Uses compiler version 0.5.10 compatible syntax
8. Maintains strict adherence to the problem requirements without extra dependencies