Here is the completed Solidity smart contract for MoneroGold:

```solidity
pragma solidity ^0.4.18;

/**
 * @title MoneroGold
 * @notice A simple ERC20-like token contract for Monero Gold (XMRG).
 * @dev This contract includes basic token functionalities such as transfer, transferFrom, and approve.
 * It also includes owner-specific functions to set the token name and burn tokens.
 */
contract MoneroGold {

    string public name = "Monero Gold";
    string public symbol = "XMRG";
    uint256 public decimals = 8;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    uint256 public totalSupply = 21000000 * (10**decimals);
    address public owner;

    modifier isOwner {
        require(owner == msg.sender);
        _;
    }

    function MoneroGold() public {
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(allowance[_from][msg.sender] >= _value);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function setName(string _name) public isOwner {
        name = _name;
    }

    function burnSupply(uint256 _amount) public isOwner {
        require(balanceOf[owner] >= _amount);
        balanceOf[owner] -= _amount;
        totalSupply -= _amount;
        SupplyBurn(_amount);
    }

    function burnTotalSupply(uint256 _amount) public isOwner {
        require(totalSupply >= _amount);
        totalSupply -= _amount;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event SupplyBurn(uint256 _amount);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
```

Key implementation details:
1. Used `require()` statements for input validation
2. Implemented ERC20-like transfer logic with balance checks and overflow protection
3. Added allowance management with security checks in approve()
4. Implemented owner-only functions for burning tokens and managing supply
5. Used proper event emission syntax for Solidity 0.4.18
6. Maintained compatibility with specified compiler version through syntax choices
7. Included all required safety checks and state modifications described in the specification