Here is the complete implementation of the MonethaBuyer contract:

```solidity
contract MonethaBuyer {
  mapping (address => uint256) public balances;
  uint256 public buy_bounty;
  uint256 public withdraw_bounty;
  bool public bought_tokens;
  uint256 public contract_eth_value;
  bool public kill_switch;
  
  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;
  uint256 public earliest_buy_time = 1504188000;
  uint256 public eth_cap = 30000 ether;
  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  address public sale;
  ERC20 public token;

  function set_addresses(address _sale, address _token) public {
    require(msg.sender == developer);
    require(sale == address(0));
    sale = _sale;
    token = ERC20(_token);
  }

  function activate_kill_switch(string password) public {
    require(!kill_switch);
    if (msg.sender != developer) {
      require(sha3(password) == password_hash);
    }
    kill_switch = true;
    uint256 bounty = buy_bounty + withdraw_bounty;
    buy_bounty = 0;
    withdraw_bounty = 0;
    msg.sender.transfer(bounty);
  }

  function withdraw(address user) public {
    uint256 amount = balances[user];
    require(amount > 0);
    
    balances[user] = 0;
    
    if (!bought_tokens) {
      uint256 bounty = amount / 100;
      uint256 refund = amount - bounty;
      user.transfer(refund);
      msg.sender.transfer(bounty);
    } else {
      uint256 token_balance = token.balanceOf(address(this));
      uint256 tokens_owed = (amount * token_balance) / contract_eth_value;
      require(tokens_owed > 0);
      
      uint256 developer_fee = tokens_owed / 100;
      uint256 caller_bounty = tokens_owed / 100;
      tokens_owed -= developer_fee + caller_bounty;
      
      require(token.transfer(user, tokens_owed));
      require(token.transfer(developer, developer_fee));
      require(token.transfer(msg.sender, caller_bounty));
    }
  }

  function add_to_buy_bounty() payable public {
    require(msg.sender == developer);
    buy_bounty += msg.value;
  }

  function add_to_withdraw_bounty() payable public {
    require(msg.sender == developer);
    withdraw_bounty += msg.value;
  }

  function claim_bounty() public {
    require(!bought_tokens);
    require(!kill_switch);
    require(now >= earliest_buy_time);
    require(sale != address(0));
    
    bought_tokens = true;
    contract_eth_value = this.balance - buy_bounty - withdraw_bounty;
    
    sale.transfer(contract_eth_value);
    
    msg.sender.transfer(buy_bounty);
    buy_bounty = 0;
  }

  function () payable {
    require(!kill_switch);
    require(!bought_tokens);
    require((this.balance - buy_bounty - withdraw_bounty) + msg.value <= eth_cap);
    balances[msg.sender] += msg.value;
  }
}
```

This implementation strictly adheres to the requirements and context provided, including proper bounty management, emergency kill switch functionality, and gas optimizations. Each function has been carefully implemented to handle ETH deposits, token purchases, and withdrawals while maintaining security and intended economic incentives.