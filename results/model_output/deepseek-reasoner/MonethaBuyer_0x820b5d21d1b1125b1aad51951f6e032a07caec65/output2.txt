```solidity
contract MonethaBuyer {
  mapping (address => uint256) public balances;
  uint256 public buy_bounty;
  uint256 public withdraw_bounty;
  bool public bought_tokens;
  uint256 public contract_eth_value;
  bool public kill_switch;
  
  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;
  uint256 public earliest_buy_time = 1504188000;
  uint256 public eth_cap = 30000 ether;
  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  address public sale;
  ERC20 public token;

  function set_addresses(address _sale, address _token) {
    require(msg.sender == developer);
    require(sale == address(0));
    sale = _sale;
    token = ERC20(_token);
  }

  function activate_kill_switch(string password) {
    require(!kill_switch);
    if (msg.sender != developer) {
      require(sha3(password) == password_hash);
    }
    kill_switch = true;
    uint256 total_bounty = buy_bounty + withdraw_bounty;
    buy_bounty = 0;
    withdraw_bounty = 0;
    msg.sender.transfer(total_bounty);
  }

  function withdraw(address user) {
    uint256 user_balance = balances[user];
    require(user_balance > 0);
    
    uint256 current_withdraw_bounty = withdraw_bounty;
    withdraw_bounty = 0;
    if (current_withdraw_bounty > 0) {
      msg.sender.transfer(current_withdraw_bounty);
    }
    
    balances[user] = 0;
    
    if (!bought_tokens || kill_switch) {
      uint256 caller_bounty = user_balance / 100;
      uint256 developer_fee = user_balance / 100;
      uint256 user_refund = user_balance - caller_bounty - developer_fee;
      
      user.transfer(user_refund);
      developer.transfer(developer_fee);
      msg.sender.transfer(caller_bounty);
    } else {
      uint256 token_balance = token.balanceOf(address(this));
      uint256 user_share = (user_balance * token_balance) / contract_eth_value;
      uint256 caller_bounty = user_share / 100;
      uint256 developer_fee = user_share / 100;
      uint256 user_amount = user_share - caller_bounty - developer_fee;
      
      require(token.transfer(developer, developer_fee));
      require(token.transfer(msg.sender, caller_bounty));
      require(token.transfer(user, user_amount));
    }
  }

  function add_to_buy_bounty() payable {
    require(msg.sender == developer);
    buy_bounty += msg.value;
  }

  function add_to_withdraw_bounty() payable {
    require(msg.sender == developer);
    withdraw_bounty += msg.value;
  }

  function claim_bounty() {
    require(!bought_tokens);
    require(now >= earliest_buy_time);
    require(!kill_switch);
    require(sale != address(0));
    
    bought_tokens = true;
    uint256 current_buy_bounty = buy_bounty;
    buy_bounty = 0;
    
    contract_eth_value = this.balance - current_buy_bounty;
    sale.transfer(contract_eth_value);
    
    msg.sender.transfer(current_buy_bounty);
  }

  function () payable {
    require(!kill_switch);
    require(!bought_tokens);
    require(this.balance <= eth_cap);
    balances[msg.sender] += msg.value;
  }
}
```