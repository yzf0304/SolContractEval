Here's the complete implementation of the MoonCatKeyVote contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.1;

/**
 * @title MoonCatKeyVote
 * @notice This contract allows for a community vote to decide whether the MoonCatRescue developers should destroy their private key, preventing the release of future Genesis MoonCats.
 * @dev The contract uses a Merkle tree to verify voter eligibility. The vote is open for 48 hours once started and can be cancelled by the owner before it starts.
 */
contract MoonCatKeyVote {
    event VoteSubmitted(address voter, bool vote);

    uint public voteStartTime = 0;
    bool public voteCancelled = false;
    mapping(address => bool) public hasVoted;
    uint32 public yesVotes = 0;
    uint32 public noVotes = 0;
    bytes32 public immutable merkleRoot;
    address public immutable owner;
    uint24 empty = 0;

    modifier onlyOwner {
        require(msg.sender == owner, "Owner Only");
        _;
    }

    modifier voteContractIsPending {
        require(!voteCancelled, "Vote Contract Cancelled");
        require(voteStartTime == 0, "Vote Already Started");
        _;
    }

    modifier voteContractIsActive {
        require(!voteCancelled, "Vote Contract Cancelled");
        require(voteStartTime > 0, "Vote Not Started");
        require(block.timestamp < (voteStartTime + 48 hours), "Vote Ended");
        _;
    }

    modifier voteContractIsComplete {
        require(!voteCancelled, "Vote Contract Cancelled");
        require(voteStartTime > 0, "Vote Not Started");
        require(block.timestamp > (voteStartTime + 48 hours), "Vote Not Ended");
        _;
    }

    constructor(bytes32 merkleRoot_) {
        merkleRoot = merkleRoot_;
        owner = msg.sender;
    }

    function startVote() public onlyOwner voteContractIsPending {
        voteStartTime = block.timestamp;
    }

    function cancelVote() public onlyOwner voteContractIsPending {
        voteCancelled = true;
    }

    function getResult() public view voteContractIsComplete returns (bool) {
        return yesVotes > noVotes;
    }

    function submitVote(bytes32[] calldata eligibilityProof, bool vote) public voteContractIsActive {
        require(!hasVoted[msg.sender], "Already voted");
        
        bytes32 computedHash = keccak256(abi.encodePacked(msg.sender));
        for (uint256 i = 0; i < eligibilityProof.length; i++) {
            bytes32 proofElement = eligibilityProof[i];
            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        require(computedHash == merkleRoot, "Invalid proof");
        
        hasVoted[msg.sender] = true;
        if (vote) {
            yesVotes++;
        } else {
            noVotes++;
        }
        emit VoteSubmitted(msg.sender, vote);
    }
}
```

This implementation includes:
1. Proper vote state management with start/cancel functionality
2. Merkle proof verification for voter eligibility
3. Time-bound voting period (48 hours)
4. Vote result calculation
5. Prevention of duplicate voting
6. Event emission for vote tracking
7. All required modifiers for access control and state management

The contract follows all specified requirements and uses the correct Merkle proof verification implementation to ensure only eligible voters can participate.