Here is the complete implementation of the StandardToken contract:

```solidity
contract StandardToken is SafeMath {
  uint256 public totalSupply;
  mapping(address => uint) balances;
  mapping (address => mapping (address => uint)) allowed;

  event Transfer(address indexed from, address indexed to, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);

  modifier onlyPayloadSize(uint256 size) {
    require(msg.data.length == size + 4);
    _;
  }

  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) {
    balances[msg.sender] = safeSub(balances[msg.sender], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
    balances[_from] = safeSub(balances[_from], _value);
    balances[_to] = safeAdd(balances[_to], _value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function addApproval(address _spender, uint256 _addedValue) onlyPayloadSize(2 * 32) public returns (bool success) {
    allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function subApproval(address _spender, uint256 _subtractedValue) onlyPayloadSize(2 * 32) public returns (bool success) {
    allowed[msg.sender][_spender] = safeSub(allowed[msg.sender][_spender], _subtractedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }
}
```

This implementation:
1. Uses SafeMath for all arithmetic operations to prevent overflows/underflows
2. Implements ERC20 standard functions (transfer, transferFrom, balanceOf, approve, allowance)
3. Includes additional atomic approval adjustment functions (addApproval, subApproval)
4. Uses onlyPayloadSize modifier to prevent ERC20 short address attacks
5. Follows compiler version 0.4.19 requirements
6. Maintains strict visibility (public/view) for functions according to their purpose
7. Emits appropriate events for all state-changing operations
8. Handles allowance management securely through atomic increment/decrement operations