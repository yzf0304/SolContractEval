Here's the complete implementation of the OMNIDOORS contract based on the provided requirements and context:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract OMNIDOORS is Ownable, ERC721, NonblockingReceiver {
    address public _owner;
    string private baseURI;
    uint256 nextTokenId = 5900;
    uint256 MAX_NETWORK_MINT = 9300;
    uint256 gasForDestinationLzReceive = 350000;

    constructor(string memory baseURI_, address _layerZeroEndpoint)
        ERC721("Omni Doors", "odoors")
    {
        _owner = msg.sender;
        endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);
        baseURI = baseURI_;
        for (uint256 i = 0; i < 330; i++) {
            _safeMint(_owner, ++nextTokenId);
        }
    }

    function mint(uint8 numTokens) external payable {
        require(numTokens == 1, "Only 1 per transaction");
        require(nextTokenId + numTokens <= MAX_NETWORK_MINT, "Max supply reached");
        _safeMint(msg.sender, ++nextTokenId);
    }

    function traverseChains(uint16 _chainId, uint256 tokenId) public payable {
        require(ownerOf(tokenId) == msg.sender, "You must own the token to traverse");
        require(trustedRemoteLookup[_chainId].length != 0, "Chain unavailable");

        _burn(tokenId);

        bytes memory payload = abi.encode(msg.sender, tokenId);
        bytes memory adapterParams = abi.encodePacked(uint16(1), gasForDestinationLzReceive);

        (uint256 nativeFee, ) = endpoint.estimateFees(
            _chainId,
            address(this),
            payload,
            false,
            adapterParams
        );

        require(msg.value >= nativeFee, "Insufficient fee");

        _lzSend(
            _chainId,
            payload,
            payable(msg.sender),
            address(0x0),
            adapterParams
        );
    }

    function setBaseURI(string memory URI) external onlyOwner {
        baseURI = URI;
    }

    function donate() external payable {}

    function withdraw(uint256 amt) external onlyOwner {
        require(amt <= address(this).balance, "Insufficient balance");
        payable(owner()).transfer(amt);
    }

    function setGasForDestinationLzReceive(uint256 newVal) external onlyOwner {
        gasForDestinationLzReceive = newVal;
    }

    function _LzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal override {
        (address to, uint256 tokenId) = abi.decode(_payload, (address, uint256));
        _safeMint(to, tokenId);
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }
}
```

Key features of this implementation:

1. **Cross-chain Functionality**:
   - Uses LayerZero's NonblockingReceiver for cross-chain communication
   - Implements `traverseChains` to burn NFTs on source chain and send message to destination chain
   - Handles incoming messages in `_LzReceive` to mint NFTs on destination chain

2. **Minting Logic**:
   - Initial mint of 330 tokens to owner during deployment
   - Public minting limited to 1 token per transaction
   - Enforces maximum supply of 9300 tokens across network

3. **Ownership & Management**:
   - Inherits OpenZeppelin's Ownable for access control
   - Allows owner to set base URI and adjust gas parameters
   - Includes withdrawal function for collected fees

4. **ERC721 Compliance**:
   - Implements standard ERC721 metadata and transfer functionality
   - Uses safe minting practices with `_safeMint`

The contract maintains security by:
- Validating ownership before transfers
- Checking LayerZero trusted remotes
- Using safe minting and burning patterns
- Properly handling cross-chain message payloads
- Implementing withdrawal pattern for funds management

Note: This implementation assumes proper LayerZero endpoint configuration and requires setting trusted remotes for each supported chain after deployment.