Here is the complete and functional OdinToken contract:

```solidity
contract OdinToken is ERC20Interface, Owned {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint private _totalSupply;
    bool private _whitelistAll;

    struct balanceData {  
        bool locked;
        uint balance;
        uint airDropQty;
    }

    mapping(address => balanceData) balances;
    mapping(address => mapping(address => uint)) allowed;

    function OdinToken() public {
        owner = msg.sender;
        symbol = "ODIN";
        name = "ODIN Token";
        decimals = 18;
        _whitelistAll = false;
        _totalSupply = 100000000000000000000000;
        balances[owner].balance = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function whitelistAddress(address to) onlyOwner public returns (bool) {
        balances[to].airDropQty = 0;
        return true;
    }

    function whitelistAllAddresses() onlyOwner public returns (bool) {
        _whitelistAll = true;
        return true;
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner].balance;
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        require(to != msg.sender && to != address(0));
        require(balances[msg.sender].balance >= tokens);

        if (msg.sender != owner && !_whitelistAll) {
            uint currentTime = now;
            uint airdropAllowed;

            if (currentTime < 1535760000) {
                airdropAllowed = 0;
            } else if (currentTime <= 1538351999) {
                airdropAllowed = balances[msg.sender].airDropQty.mul(10).div(100);
            } else if (currentTime <= 1546300799) {
                airdropAllowed = balances[msg.sender].airDropQty.mul(25).div(100);
            } else if (currentTime <= 1554076799) {
                airdropAllowed = balances[msg.sender].airDropQty.mul(50).div(100);
            } else if (currentTime <= 1561939199) {
                airdropAllowed = balances[msg.sender].airDropQty.mul(75).div(100);
            } else {
                airdropAllowed = balances[msg.sender].airDropQty;
            }

            uint nonAirdropBalance = balances[msg.sender].balance.sub(balances[msg.sender].airDropQty);
            uint maxTransfer = nonAirdropBalance.add(airdropAllowed);
            require(tokens <= maxTransfer);

            uint airdropUsed = tokens > nonAirdropBalance ? tokens.sub(nonAirdropBalance) : 0;
            balances[msg.sender].airDropQty = balances[msg.sender].airDropQty.sub(airdropUsed);
        }

        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);

        if (msg.sender == owner) {
            balances[to].airDropQty = balances[to].airDropQty.add(tokens);
        }

        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(allowed[from][msg.sender] >= tokens);
        require(balances[from].balance >= tokens);
        require(to != address(0) && to != from);

        if (from != owner && !_whitelistAll) {
            uint currentTime = now;
            uint airdropAllowed;

            if (currentTime < 1535760000) {
                airdropAllowed = 0;
            } else if (currentTime <= 1538351999) {
                airdropAllowed = balances[from].airDropQty.mul(10).div(100);
            } else if (currentTime <= 1546300799) {
                airdropAllowed = balances[from].airDropQty.mul(25).div(100);
            } else if (currentTime <= 1554076799) {
                airdropAllowed = balances[from].airDropQty.mul(50).div(100);
            } else if (currentTime <= 1561939199) {
                airdropAllowed = balances[from].airDropQty.mul(75).div(100);
            } else {
                airdropAllowed = balances[from].airDropQty;
            }

            uint nonAirdropBalance = balances[from].balance.sub(balances[from].airDropQty);
            uint maxTransfer = nonAirdropBalance.add(airdropAllowed);
            require(tokens <= maxTransfer);

            uint airdropUsed = tokens > nonAirdropBalance ? tokens.sub(nonAirdropBalance) : 0;
            balances[from].airDropQty = balances[from].airDropQty.sub(airdropUsed);
        }

        balances[from].balance = balances[from].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        if (from == owner) {
            balances[to].airDropQty = balances[to].airDropQty.add(tokens);
        }

        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function burn(uint256 tokens) onlyOwner public returns (bool) {
        require(balances[owner].balance >= tokens);
        balances[owner].balance = balances[owner].balance.sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        emit Burn(tokens);
        return true;
    }

    function () {
        revert();
    }
}
```

Key features implemented:
- ERC20 compliance with SafeMath operations
- Time-based transfer restrictions for airdropped tokens
- Owner-controlled whitelisting functions
- Proper airdrop quantity tracking
- Burn functionality for the owner
- Fallback function to reject Ether transfers

The contract uses precise Unix timestamps for the airdrop restriction periods and implements all described functionality while maintaining compatibility with Solidity 0.4.21.