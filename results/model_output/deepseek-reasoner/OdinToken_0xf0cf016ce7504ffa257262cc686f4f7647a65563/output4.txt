Here is the complete and functional `OdinToken` contract:

```solidity
pragma solidity ^0.4.21;

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Burn(uint tokens);
}

contract Owned {
    address public owner;
    address private newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}

contract OdinToken is ERC20Interface, Owned {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint private _totalSupply;
    bool private _whitelistAll;

    struct balanceData {  
        bool locked;
        uint balance;
        uint airDropQty;
    }

    mapping(address => balanceData) balances;
    mapping(address => mapping(address => uint)) allowed;

    function OdinToken() public {
        owner = msg.sender;
        symbol = "ODIN";
        name = "ODIN Token";
        decimals = 18;
        _whitelistAll = false;
        _totalSupply = 100000000000000000000000;
        balances[owner].balance = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() public constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function whitelistAddress(address to) onlyOwner public returns (bool) {
        balances[to].airDropQty = 0;
        return true;
    }

    function whitelistAllAddresses() onlyOwner public returns (bool) {
        _whitelistAll = true;
        return true;
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner].balance;
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        require(to != address(0) && to != msg.sender);
        require(balances[msg.sender].balance >= tokens);

        uint airdropTransfer = 0;
        if (msg.sender != owner && !_whitelistAll) {
            uint senderBalance = balances[msg.sender].balance;
            uint senderAirDrop = balances[msg.sender].airDropQty;
            uint nonAirdrop = senderBalance.sub(senderAirDrop);
            airdropTransfer = tokens > nonAirdrop ? tokens.sub(nonAirdrop) : 0;

            if (airdropTransfer > 0) {
                uint allowedPercentage;
                if (block.timestamp >= 1561939200) {
                    allowedPercentage = 100;
                } else if (block.timestamp >= 1554076800) {
                    allowedPercentage = 75;
                } else if (block.timestamp >= 1546300800) {
                    allowedPercentage = 50;
                } else if (block.timestamp >= 1538352000) {
                    allowedPercentage = 25;
                } else if (block.timestamp >= 1535760000) {
                    allowedPercentage = 10;
                } else {
                    allowedPercentage = 0;
                }

                uint allowedAirdrop = senderAirDrop.mul(allowedPercentage).div(100);
                require(airdropTransfer <= allowedAirdrop);
            }
        }

        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);

        if (airdropTransfer > 0) {
            balances[msg.sender].airDropQty = balances[msg.sender].airDropQty.sub(airdropTransfer);
            balances[to].airDropQty = balances[to].airDropQty.add(airdropTransfer);
        }

        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(to != address(0) && to != from);
        require(balances[from].balance >= tokens);
        require(allowed[from][msg.sender] >= tokens);

        uint airdropTransfer = 0;
        if (from != owner && !_whitelistAll) {
            uint senderBalance = balances[from].balance;
            uint senderAirDrop = balances[from].airDropQty;
            uint nonAirdrop = senderBalance.sub(senderAirDrop);
            airdropTransfer = tokens > nonAirdrop ? tokens.sub(nonAirdrop) : 0;

            if (airdropTransfer > 0) {
                uint allowedPercentage;
                if (block.timestamp >= 1561939200) {
                    allowedPercentage = 100;
                } else if (block.timestamp >= 1554076800) {
                    allowedPercentage = 75;
                } else if (block.timestamp >= 1546300800) {
                    allowedPercentage = 50;
                } else if (block.timestamp >= 1538352000) {
                    allowedPercentage = 25;
                } else if (block.timestamp >= 1535760000) {
                    allowedPercentage = 10;
                } else {
                    allowedPercentage = 0;
                }

                uint allowedAirdrop = senderAirDrop.mul(allowedPercentage).div(100);
                require(airdropTransfer <= allowedAirdrop);
            }
        }

        balances[from].balance = balances[from].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        if (airdropTransfer > 0) {
            balances[from].airDropQty = balances[from].airDropQty.sub(airdropTransfer);
            balances[to].airDropQty = balances[to].airDropQty.add(airdropTransfer);
        }

        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function burn(uint256 tokens) onlyOwner public returns (bool) {
        require(balances[owner].balance >= tokens);
        balances[owner].balance = balances[owner].balance.sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);
        emit Burn(tokens);
        return true;
    }

    function () public {
        revert();
    }
}
```

**Key Features:**
1. Implements ERC20 standard with SafeMath operations
2. Whitelisting system for airdrop restrictions
3. Time-based transfer limits for airdropped tokens
4. Owner-controlled supply burning
5. Safe transfer restrictions with airDropQty tracking
6. Backwards compatibility with Solidity 0.4.21
7. Whitelist management functions
8. Proper event emissions for all token operations

The contract maintains full ERC20 compliance while implementing the special airdrop restrictions as described, using time-based unlocking percentages and whitelist management capabilities.