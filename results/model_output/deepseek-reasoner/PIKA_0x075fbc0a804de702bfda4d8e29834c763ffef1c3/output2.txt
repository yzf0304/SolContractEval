Here is the complete and functional implementation of the PIKA contract based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.7.6;

contract PIKA is Context, Owned, ERC20 {
    using SafeMath for uint256;

    uint256 public _taxFee;
    uint256 public totalSupply;
    string public symbol;
    string public name;
    uint8 public decimals;
    uint256 private _taxFeepercent = 225;
    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;
    mapping (address => bool) private _isExcludedFromFee;
    uint256 public ContractDeployed;
    address oldPika = 0xE09fB60E8D6e7E1CEbBE821bD5c3FC67a40F86bF;
    uint256 public oldPika_amount;
    uint256 private minamountTakenOut = 1000000 * 10**9 * 10**9;  
    uint256 private MinimumSupply = 100000000 * 10**9 * 10**9;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    event TransferFee(address indexed _from, address indexed _to, uint256 _value);

    function balanceOf(address _owner) public view override returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public override returns (bool) {
        _transfer(_msgSender(), _to, _amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        uint256 currentAllowance = allowed[sender][_msgSender()];
        require(currentAllowance >= amount, "ERC20: transfer exceeds allowance");
        _approve(sender, _msgSender(), currentAllowance.sub(amount));
        _transfer(sender, recipient, amount);
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from zero");
        require(recipient != address(0), "ERC20: transfer to zero");
        require(amount > 0, "Transfer amount must be positive");

        uint256 senderBalance = balances[sender];
        require(senderBalance >= amount, "ERC20: insufficient balance");

        bool takeFee = !(_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]);

        if (takeFee) {
            uint256 feeAmount = amount.mul(_taxFeepercent).div(10000);
            uint256 transferAmount = amount.sub(feeAmount);

            balances[sender] = senderBalance.sub(amount);
            balances[recipient] = balances[recipient].add(transferAmount);
            balances[address(this)] = balances[address(this)].add(feeAmount);
            _taxFee = _taxFee.add(feeAmount);

            emit Transfer(sender, recipient, transferAmount);
            emit Transfer(sender, address(this), feeAmount);
        } else {
            balances[sender] = senderBalance.sub(amount);
            balances[recipient] = balances[recipient].add(amount);
            emit Transfer(sender, recipient, amount);
        }
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from zero");
        require(spender != address(0), "ERC20: approve to zero");

        allowed[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function allowance(address _owner, address _spender) public view override returns (uint256) {
        return allowed[_owner][_spender];
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from zero");
        uint256 accountBalance = balances[account];
        require(accountBalance >= amount, "ERC20: burn exceeds balance");

        balances[account] = accountBalance.sub(amount);
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function viewMinExtractAmt() public view returns (uint256) {
        return minamountTakenOut;
    }

    function setMinExtractAmt(uint256 _amount) public onlyOwner() {
        minamountTakenOut = _amount;
    }

    function viewFee() public view returns (uint256) {
        return _taxFeepercent;
    }

    function exchnagePika(uint256 tokens) external {
        require(block.timestamp <= ContractDeployed.add(4 days), "Exchange period ended");
        require(ERC20(oldPika).transferFrom(_msgSender(), address(this), tokens), "Transfer failed");

        uint256 cust;
        if (tokens < 1e12 * 10**9) {
            cust = 50000;
        } else if (tokens < 1e13 * 10**9) {
            cust = 25000;
        } else {
            cust = 10000;
        }

        uint256 newTokens = calSwapToken(tokens, cust);
        require(balances[address(this)] >= newTokens, "Insufficient reserves");
        _transfer(address(this), _msgSender(), newTokens);
        oldPika_amount = oldPika_amount.add(tokens);
    }

    function extractOldPIKA() external onlyOwner() {
        uint256 amount = oldPika_amount;
        oldPika_amount = 0;
        require(ERC20(oldPika).transfer(owner, amount), "Transfer failed");
    }

    function extractfee() external onlyOwner() {
        uint256 feeAmount = _taxFee;
        _taxFee = 0;
        _transfer(address(this), owner, feeAmount);
    }

    function calSwapToken(uint256 _tokens, uint256 cust) internal virtual returns (uint256) {
        return _tokens.mul(cust).div(10000);
    }

    function burn(uint256 value) public returns (bool) {
        _burn(_msgSender(), value);
        return true;
    }

    function viewMinSupply() public view returns (uint256) {
        return MinimumSupply;
    }

    function changeMinSupply(uint256 newMinSupply) public onlyOwner() {
        MinimumSupply = newMinSupply;
    }

    function addLiquidity(uint256 tokenAmount) public payable onlyOwner() {
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.addLiquidityETH{value: msg.value}(
            address(this),
            tokenAmount,
            0,
            0,
            owner,
            block.timestamp
        );
    }

    constructor() {
        symbol = "PIKA";
        name = "PIKA";
        decimals = 18;
        totalSupply = 50000000000000 * 10**9 * 10**9;
        owner = _msgSender();
        balances[owner] = totalSupply;
        _isExcludedFromFee[owner] = true;
        _isExcludedFromFee[address(this)] = true;
        
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        ContractDeployed = block.timestamp;
    }

    receive() payable external {
        require(msg.value > 0);
        owner.transfer(msg.value);
    }
}
```

This implementation:
1. Adheres to ERC20 standard with tax fee mechanism
2. Includes swap and liquidity management with Uniswap V2
3. Implements bonus token exchange system for old PIKA holders
4. Uses SafeMath for secure arithmetic operations
5. Includes owner controls for fee extraction and supply management
6. Maintains compatibility with Solidity 0.7.6
7. Follows all specified requirements from the problem statement

The contract maintains security best practices including:
- SafeMath usage for all arithmetic operations
- Owner-controlled administrative functions
- Fee exclusion for specific addresses
- Time-limited token exchange period
- Proper allowance management for ERC20 transfers