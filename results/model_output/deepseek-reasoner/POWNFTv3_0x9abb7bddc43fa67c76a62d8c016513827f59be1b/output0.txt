Here is the completed implementation of the POWNFTv3 contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

contract POWNFTv3 {
    //v2 Variables
    uint public UNMIGRATED = 0;
    uint public V2_TOTAL = 0;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 CONTRACT_V2;

    constructor(address contract_v2) {
        supportedInterfaces[0x80ac58cd] = true; //ERC721
        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable
        supportedInterfaces[0x01ffc9a7] = true; //ERC165

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    //////===721 Standard
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    //////===721 Implementation
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    bytes32[] TOKENS;
    mapping(uint256 => address) OWNERS;

    // METADATA VARS
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // ENUMERABLE VARS
    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint) internal OWNER_ID_TO_INDEX;
    mapping(uint256 => uint) internal ID_TO_INDEX;
    mapping(uint => uint) internal INDEX_TO_ID;

    // ETH VAR
    mapping(uint256 => uint256) WITHDRAWALS;

    // MINING VARS
    uint BASE_COST = 0.000045 ether;
    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / uint(300);
    uint DIFFICULTY_RAMP = 3;

    event Migrate(uint indexed _tokenId);
    event Mined(uint indexed _tokenId, bytes32 hash);
    event Withdraw(uint indexed _tokenId, uint value);

    function generationOf(uint _tokenId) private pure returns(uint) {
        return _tokenId / 300;
    }

    function hashOf(uint _tokenId) public view returns(bytes32) {
        require(_tokenId < TOKENS.length, "Invalid token");
        return TOKENS[_tokenId];
    }

    function migrate(uint _tokenId, uint _withdrawEthUntil) public {
        _migrate(_tokenId);
        if(_withdrawEthUntil > 0) {
            uint amount = _withdraw(_tokenId, _withdrawEthUntil);
            payable(msg.sender).transfer(amount);
        }
    }

    function _migrate(uint _tokenId) internal {
        require(_tokenId < V2_TOTAL, "Invalid token");
        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender, "Not owner");
        require(OWNERS[_tokenId] == address(0), "Already migrated");
        
        while(TOKENS.length <= _tokenId) TOKENS.push(bytes32(0));
        TOKENS[_tokenId] = CONTRACT_V2.hashOf(_tokenId);
        
        OWNERS[_tokenId] = msg.sender;
        BALANCES[msg.sender]++;
        
        uint ownerIndex = BALANCES[msg.sender] - 1;
        OWNER_INDEX_TO_ID[msg.sender].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = ownerIndex;
        ID_TO_INDEX[_tokenId] = TOKENS.length - 1;
        INDEX_TO_ID[TOKENS.length - 1] = _tokenId;
        
        emit Migrate(_tokenId);
        UNMIGRATED--;
    }

    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Length mismatch");
        for(uint i = 0; i < _tokenIds.length; i++) {
            _migrate(_tokenIds[i]);
            if(_withdrawUntil[i] > 0) {
                uint amount = _withdraw(_tokenIds[i], _withdrawUntil[i]);
                payable(msg.sender).transfer(amount);
            }
        }
    }

    function withdraw(uint _tokenId, uint _withdrawUntil) public {
        uint amount = _withdraw(_tokenId, _withdrawUntil);
        payable(msg.sender).transfer(amount);
    }

    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {
        require(OWNERS[_tokenId] == msg.sender, "Not owner");
        require(_withdrawUntil <= block.number, "Future block");
        uint lastWithdraw = WITHDRAWALS[_tokenId];
        require(lastWithdraw < _withdrawUntil, "Already withdrawn");
        
        uint startBlock = lastWithdraw == 0 ? 
            (_tokenId < V2_TOTAL ? 1 : 0) : 
            lastWithdraw + 1;
        require(startBlock <= _withdrawUntil, "Invalid range");
        
        uint blocks = _withdrawUntil - startBlock + 1;
        uint gen = generationOf(_tokenId);
        uint amount = blocks * (BASE_COST * (2 ** gen));
        
        WITHDRAWALS[_tokenId] = _withdrawUntil;
        emit Withdraw(_tokenId, amount);
        return amount;
    }

    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Length mismatch");
        uint total;
        for(uint i = 0; i < _tokenIds.length; i++) {
            total += _withdraw(_tokenIds[i], _withdrawUntil[i]);
        }
        payable(msg.sender).transfer(total);
    }

    function mine(uint nonce) external payable {
        uint tokenId = TOKENS.length;
        uint gen = generationOf(tokenId);
        uint difficulty = BASE_DIFFICULTY;
        
        for(uint i = 0; i < gen; i++) difficulty /= DIFFICULTY_RAMP;
        
        bytes32 prevHash = tokenId == V2_TOTAL ? 
            PREV_CHAIN_LAST_HASH : 
            TOKENS[tokenId - 1];
            
        bytes32 hash = keccak256(abi.encodePacked(prevHash, nonce, msg.sender));
        require(uint(hash) <= difficulty, "Difficulty not met");
        
        uint cost = BASE_COST * (2 ** gen);
        require(msg.value == cost, "Incorrect value");
        
        mint(tokenId, hash);
        emit Mined(tokenId, hash);
    }

    function mint(uint tokenId, bytes32 hash) private {
        TOKENS.push(hash);
        OWNERS[tokenId] = msg.sender;
        BALANCES[msg.sender]++;
        
        uint ownerIndex = BALANCES[msg.sender] - 1;
        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);
        OWNER_ID_TO_INDEX[tokenId] = ownerIndex;
        ID_TO_INDEX[tokenId] = tokenId;
        INDEX_TO_ID[tokenId] = tokenId;
        
        emit Transfer(address(0), msg.sender, tokenId);
    }

    function isValidToken(uint256 _tokenId) internal view returns(bool) {
        return OWNERS[_tokenId] != address(0);
    }

    function balanceOf(address _owner) external view returns (uint256) {
        return BALANCES[_owner];
    }

    function ownerOf(uint256 _tokenId) public view returns(address) {
        require(isValidToken(_tokenId), "Invalid token");
        return OWNERS[_tokenId];
    }

    function approve(address _approved, uint256 _tokenId) external {
        address owner = OWNERS[_tokenId];
        require(owner == msg.sender || AUTHORISED[owner][msg.sender], "Unauthorized");
        ALLOWANCE[_tokenId] = _approved;
        emit Approval(owner, _approved, _tokenId);
    }

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(isValidToken(_tokenId), "Invalid token");
        return ALLOWANCE[_tokenId];
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return AUTHORISED[_owner][_operator];
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        AUTHORISED[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_to != address(0), "Invalid address");
        require(OWNERS[_tokenId] == _from, "Not owner");
        require(
            msg.sender == _from ||
            msg.sender == ALLOWANCE[_tokenId] ||
            AUTHORISED[_from][msg.sender],
            "Unauthorized"
        );
        
        BALANCES[_from]--;
        BALANCES[_to]++;
        OWNERS[_tokenId] = _to;
        
        if(ALLOWANCE[_tokenId] != address(0)) ALLOWANCE[_tokenId] = address(0);
        
        uint fromIndex = OWNER_ID_TO_INDEX[_tokenId];
        uint lastToken = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];
        OWNER_INDEX_TO_ID[_from][fromIndex] = lastToken;
        OWNER_ID_TO_INDEX[lastToken] = fromIndex;
        OWNER_INDEX_TO_ID[_from].pop();
        
        OWNER_INDEX_TO_ID[_to].push(_tokenId);
        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length - 1;
        
        emit Transfer(_from, _to, _tokenId);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {
        transferFrom(_from, _to, _tokenId);
        if(_to.code.length > 0) {
            bytes4 result = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data);
            require(result == 0x150b7a02, "Receiver rejected");
        }
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    function tokenURI(uint256 _tokenId) public view returns (string memory) {
        require(isValidToken(_tokenId), "Invalid token");
        bytes memory buffer = new bytes(32);
        uint length;
        uint temp = _tokenId;
        while(temp != 0) {
            buffer[length++] = bytes1(uint8(48 + temp % 10));
            temp /= 10;
        }
        bytes memory idStr = new bytes(length);
        for(uint i = 0; i < length; i++) {
            idStr[i] = buffer[length - 1 - i];
        }
        return string(abi.encodePacked(__uriBase, idStr));
    }

    function name() external view returns (string memory) {
        return __name;
    }

    function symbol() external view returns (string memory) {
        return __symbol;
    }

    function totalSupply() external view returns (uint256) {
        return TOKENS.length;
    }

    function tokenByIndex(uint256 _index) external view returns(uint256) {
        require(_index < TOKENS.length, "Invalid index");
        return _index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < BALANCES[_owner], "Invalid index");
        return OWNER_INDEX_TO_ID[_owner][_index];
    }

    ///////===165 Implementation
    mapping (bytes4 => bool) internal supportedInterfaces;

    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
    }
}
```

This implementation:
1. Maintains ERC721 compliance with metadata and enumerable extensions
2. Implements migration logic from v2 to v3
3. Handles POW mining with difficulty adjustments
4. Manages token withdrawals and ETH distributions
5. Includes proper ownership tracking and transfer functionality
6. Uses gas-optimized storage patterns and manual string conversion
7. Maintains compatibility with previous contract versions through explicit migration paths
8. Implements all required interfaces (ERC721, ERC721Metadata, ERC721Enumerable, ERC165)

The contract strictly follows the provided specifications and interfaces while maintaining compatibility with the original v2 contract's data structure and functionality.