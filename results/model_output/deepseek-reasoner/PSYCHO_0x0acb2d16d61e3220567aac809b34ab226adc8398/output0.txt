Here is the completed PSYCHO smart contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract PSYCHO is Ownable, ERC721A {
    uint256 public maxSupply = 8888;
    uint256 public maxFreeSupply = 8888;
    uint256 public maxPerTxDuringMint = 20;
    uint256 public maxPerAddressDuringMint = 21;
    uint256 public maxPerAddressDuringFreeMint = 1;
    uint256 public price = 0.003 ether;
    bool public saleIsActive = true;
    bool public revealed = false;

    address constant internal TEAM_ADDRESS = 0x06C8033719b4fa22DE97d4632b4120D2F429c538;
    string public baseURI = "";
    string public constant baseExtension = "";
    string public hiddenMetadataUri;
    
    mapping(address => uint256) public freeMintedAmount;
    mapping(address => uint256) public mintedAmount;

    constructor() ERC721A("PSYCHO", "PSYCHO") {
        _safeMint(msg.sender, 1);
        setHiddenMetadataUri("https://gateway.pinata.cloud/ipfs/QmcJ9dJMmgNiUD9oSASjgxhbuqam7y2WVSxDKLuX3GFyz5");
    }

    modifier mintCompliance() {
        require(saleIsActive, "Sale is not active yet.");
        require(tx.origin == msg.sender, "Wrong Caller");
        _;
    }

    function mint(uint256 _quantity) external payable mintCompliance() {
        require(totalSupply() + _quantity <= maxSupply, "Exceeds max supply");
        require(_quantity <= maxPerTxDuringMint, "Exceeds max per transaction");
        require(mintedAmount[msg.sender] + _quantity <= maxPerAddressDuringMint, "Exceeds max per address");
        require(msg.value >= price * _quantity, "Insufficient funds");

        mintedAmount[msg.sender] += _quantity;
        _safeMint(msg.sender, _quantity);
    }

    function freeMint(uint256 _quantity) external mintCompliance() {
        require(totalSupply() + _quantity <= maxFreeSupply, "Exceeds free supply");
        require(freeMintedAmount[msg.sender] + _quantity <= maxPerAddressDuringFreeMint, "Exceeds free per address");

        freeMintedAmount[msg.sender] += _quantity;
        _safeMint(msg.sender, _quantity);
    }

    function setPrice(uint256 _price) external onlyOwner {
        price = _price;
    }

    function setMaxPerTx(uint256 _amount) external onlyOwner {
        maxPerTxDuringMint = _amount;
    }

    function setMaxPerAddress(uint256 _amount) external onlyOwner {
        maxPerAddressDuringMint = _amount;
    }

    function setMaxFreePerAddress(uint256 _amount) external onlyOwner {
        maxPerAddressDuringFreeMint = _amount;
    }

    function flipSale() public onlyOwner {
        saleIsActive = !saleIsActive;
    }

    function setMaxSupply(uint256 newSupply) public onlyOwner {
        require(newSupply >= totalSupply(), "New supply too low");
        maxSupply = newSupply;
    }

    function cutMaxSupply(uint256 _amount) public onlyOwner {
        require(maxSupply - _amount >= totalSupply(), "New supply too low");
        maxSupply -= _amount;
    }

    function setRevealed(bool _state) public onlyOwner {
        revealed = _state;
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setHiddenMetadataUri(string memory _hiddenMetadataUri) public onlyOwner {
        hiddenMetadataUri = _hiddenMetadataUri;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        if (!_exists(_tokenId)) revert URIQueryForNonexistentToken();
        if (!revealed) {
            return hiddenMetadataUri;
        }
        string memory base = _baseURI();
        return bytes(base).length != 0 ? 
            string(abi.encodePacked(base, _toString(_tokenId), baseExtension)) : 
            "";
    }

    function withdrawBalance() external onlyOwner {
        (bool success, ) = payable(TEAM_ADDRESS).call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }
}
```

This implementation includes:
1. ERC721A NFT standard implementation with gas-efficient batch minting
2. Dual minting system (paid and free mints) with separate limits
3. Comprehensive administrative controls for supply management
4. Reveal mechanism for NFT metadata
5. Security features including tx.origin check to prevent contract calls
6. Withdrawal function to send funds to a predefined team address
7. Full compliance with the provided specifications and context