Here is the complete and functional smart contract code for PepeYogaClub:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "./ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract PepeYogaClub is ERC721A, Ownable {
    using Strings for uint256;

    string public baseURI = "ipfs://QmTLWN9WPq5L9eS9EKcTn2rqUCzr9QK5sd8DYVkkL7yguL/";
    string public contractURI = "ipfs://QmUvB8sKL4XFTxbMkL9FykiqLgrXeBV1mUkdzWMWhachvD";

    uint256 public MAX_PER_WALLET = 11;
    uint256 public constant MAX_SUPPLY = 2069;
    uint256 public price = 0.0069 ether;

    bool public paused = true;

    constructor() ERC721A("PepeYogaClub", "PYC") {}

    function mint(uint256 _amount) external payable {
        require(!paused, "Minting is paused");
        require(_amount > 0, "Amount must be positive");
        require(totalSupply() + _amount <= MAX_SUPPLY, "Exceeds max supply");
        require(_numberMinted(msg.sender) + _amount <= MAX_PER_WALLET, "Exceeds max per wallet");
        require(msg.value >= price * _amount, "Insufficient ETH sent");

        _mint(msg.sender, _amount);
    }

    function _startTokenId() internal override view virtual returns (uint256) {
        return 1;
    }

    function minted(address _owner) public view returns (uint256) {
        return _numberMinted(_owner);
    }

    function withdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    function teamMint(address[] memory _to, uint256[] memory _amount) external onlyOwner {
        require(_to.length == _amount.length, "Arrays length mismatch");
        uint256 totalAmount = 0;
        for (uint256 i = 0; i < _to.length; i++) {
            totalAmount += _amount[i];
        }
        require(totalSupply() + totalAmount <= MAX_SUPPLY, "Exceeds max supply");
        for (uint256 i = 0; i < _to.length; i++) {
            _mint(_to[i], _amount[i]);
        }
    }

    function setMaxPerWallet(uint256 _max) external onlyOwner {
        MAX_PER_WALLET = _max;
    }

    function setPrice(uint256 _price) external onlyOwner {
        price = _price;
    }

    function toggleMint() external onlyOwner {
        paused = !paused;
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setContractURI(string memory _contractURI) external onlyOwner {
        contractURI = _contractURI;
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "Token does not exist");
        return string(abi.encodePacked(baseURI, _tokenId.toString()));
    }
}
```

This implementation includes all required features:
1. ERC721A standard compliance with gas-efficient batch minting
2. Configurable mint price and wallet limits
3. Pausable minting functionality
4. Team minting capability for reserved NFTs
5. Proper metadata handling with configurable base URI
6. Withdrawal functionality for contract funds
7. OpenZeppelin Ownable for access control
8. Supply limit enforcement
9. ERC721 metadata compliance with proper token URI construction

The contract uses the latest Solidity version (0.8.15) and follows best practices for security and efficiency, including proper input validation and state management.