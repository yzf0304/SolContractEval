Here is the completed code for the PepemonStake contract:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.6.6;

contract PepemonStake is Ownable {
    using SafeMath for uint256;

    IPepemonFactory public pepemonFactory;
    StakingEvent[] public stakingEvents;
    mapping(address => mapping(uint256 => UserInfo)) public userInfo;
    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) public cardsStaked;

    constructor(IPepemonFactory _pepemonFactoryAddress) public {
        pepemonFactory = _pepemonFactoryAddress;
    }

    function getStakingEventsLength() external view returns (uint256) {
        return stakingEvents.length;
    }

    function getAllEvents() public view returns (StakingEvent[] memory) {
        return stakingEvents;
    }

    function getActiveEvents() external view returns (uint256[] memory) {
        uint256 count;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (block.number < stakingEvents[i].blockEventClose) count++;
        }
        uint256[] memory active = new uint256[](count);
        uint256 index;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (block.number < stakingEvents[i].blockEventClose) {
                active[index++] = i;
            }
        }
        return active;
    }

    function getClosedEvents() external view returns (uint256[] memory) {
        uint256 count;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (block.number >= stakingEvents[i].blockEventClose) count++;
        }
        uint256[] memory closed = new uint256[](count);
        uint256 index;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (block.number >= stakingEvents[i].blockEventClose) {
                closed[index++] = i;
            }
        }
        return closed;
    }

    function getCardIdListOfEvent(uint256 _eventId) external view returns (uint256[] memory) {
        return stakingEvents[_eventId].cardIdList;
    }

    function getCardAmountListOfEvent(uint256 _eventId) external view returns (uint256[] memory) {
        return stakingEvents[_eventId].cardAmountList;
    }

    function getUserProgress(address _user, uint256 _eventId) external view returns (uint256) {
        UserInfo storage user = userInfo[_user][_eventId];
        if (user.blockEnd == 0 || user.isCompleted) return 0;
        
        StakingEvent storage evt = stakingEvents[_eventId];
        uint256 startBlock = user.blockEnd.sub(evt.blockStakeLength);
        uint256 currentBlock = block.number;
        
        if (currentBlock >= user.blockEnd) return 1e5;
        return currentBlock.sub(startBlock).mul(1e5).div(evt.blockStakeLength);
    }

    function createStakingEvent(
        uint256[] memory _cardIdList,
        uint256 _cardAmountAny,
        uint256[] memory _cardAmountList,
        uint256 _cardRewardId,
        uint256 _blockStakeLength,
        uint256 _blockEventClose,
        uint256[] memory _toBurnIdList,
        uint256[] memory _toBurnAmountList
    ) public onlyOwner {
        require(_cardIdList.length == _cardAmountList.length || _cardAmountAny > 0, "Invalid card config");
        require(_toBurnIdList.length == _toBurnAmountList.length, "Burn config mismatch");
        
        stakingEvents.push(StakingEvent({
            cardIdList: _cardIdList,
            cardAmountAny: _cardAmountAny,
            cardAmountList: _cardAmountList,
            cardRewardId: _cardRewardId,
            blockStakeLength: _blockStakeLength,
            blockEventClose: _blockEventClose,
            toBurnIdList: _toBurnIdList,
            toBurnAmountList: _toBurnAmountList
        }));
        emit StakingEventCreated(stakingEvents.length - 1);
    }

    function closeStakingEvent(uint256 _eventId) public onlyOwner {
        StakingEvent storage evt = stakingEvents[_eventId];
        evt.blockEventClose = block.number;
    }

    function stakeAny(uint256 _eventId, uint256[] memory _cardIdList, uint256[] memory _cardAmountList) public {
        require(_cardIdList.length == _cardAmountList.length, "Array length mismatch");
        StakingEvent storage evt = stakingEvents[_eventId];
        UserInfo storage user = userInfo[msg.sender][_eventId];
        
        require(block.number < evt.blockEventClose, "Event closed");
        require(evt.cardAmountAny > 0, "Use stake() instead");
        require(user.blockEnd == 0, "Already participating");

        uint256 total;
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            require(_isInArray(_cardIdList[i], evt.cardIdList), "Invalid card ID");
            total = total.add(_cardAmountList[i]);
        }
        require(total >= evt.cardAmountAny, "Insufficient total");

        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), _cardIdList, _cardAmountList, "");
        
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            cardsStaked[msg.sender][_eventId][_cardIdList[i]] = cardsStaked[msg.sender][_eventId][_cardIdList[i]].add(_cardAmountList[i]);
        }
        
        user.blockEnd = block.number.add(evt.blockStakeLength);
        emit StakingEventEntered(msg.sender, _eventId);
    }

    function stake(uint256 _eventId) public {
        StakingEvent storage evt = stakingEvents[_eventId];
        UserInfo storage user = userInfo[msg.sender][_eventId];
        
        require(block.number < evt.blockEventClose, "Event closed");
        require(evt.cardAmountAny == 0, "Use stakeAny() instead");
        require(user.blockEnd == 0, "Already participating");

        uint256[] memory cardIds = evt.cardIdList;
        uint256[] memory amounts = evt.cardAmountList;
        
        for (uint256 i = 0; i < cardIds.length; i++) {
            require(pepemonFactory.balanceOf(msg.sender, cardIds[i]) >= amounts[i], "Insufficient balance");
        }

        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), cardIds, amounts, "");
        
        for (uint256 i = 0; i < cardIds.length; i++) {
            cardsStaked[msg.sender][_eventId][cardIds[i]] = amounts[i];
        }
        
        user.blockEnd = block.number.add(evt.blockStakeLength);
        emit StakingEventEntered(msg.sender, _eventId);
    }

    function claim(uint256 _eventId) public {
        UserInfo storage user = userInfo[msg.sender][_eventId];
        StakingEvent storage evt = stakingEvents[_eventId];
        
        require(user.blockEnd != 0, "Not participating");
        require(!user.isCompleted, "Already claimed");
        require(block.number >= user.blockEnd, "Staking ongoing");

        if (evt.toBurnIdList.length > 0) {
            for (uint256 i = 0; i < evt.toBurnIdList.length; i++) {
                uint256 id = evt.toBurnIdList[i];
                uint256 amount = evt.toBurnAmountList[i];
                cardsStaked[msg.sender][_eventId][id] = cardsStaked[msg.sender][_eventId][id].sub(amount);
                pepemonFactory.burn(address(this), id, amount);
            }
        }

        _withdrawCardsStaked(_eventId, false);
        pepemonFactory.mint(msg.sender, evt.cardRewardId, 1, "");
        
        user.isCompleted = true;
        emit StakingEventCompleted(msg.sender, _eventId);
    }

    function cancel(uint256 _eventId) public {
        UserInfo storage user = userInfo[msg.sender][_eventId];
        StakingEvent storage evt = stakingEvents[_eventId];
        
        require(user.blockEnd != 0, "Not participating");
        require(block.number < evt.blockEventClose, "Event closed");

        _withdrawCardsStaked(_eventId, false);
        user.blockEnd = 0;
        emit StakingEventCancelled(msg.sender, _eventId);
    }

    function _withdrawCardsStaked(uint256 _eventId, bool _burn) internal {
        StakingEvent storage evt = stakingEvents[_eventId];
        for (uint256 i = 0; i < evt.cardIdList.length; i++) {
            uint256 cardId = evt.cardIdList[i];
            uint256 amount = cardsStaked[msg.sender][_eventId][cardId];
            if (amount > 0) {
                if (_burn) {
                    pepemonFactory.burn(address(this), cardId, amount);
                } else {
                    pepemonFactory.safeTransferFrom(address(this), msg.sender, cardId, amount, "");
                }
                cardsStaked[msg.sender][_eventId][cardId] = 0;
            }
        }
    }

    function _isInArray(uint256 _value, uint256[] memory _array) internal pure returns (bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array[i] == _value) return true;
        }
        return false;
    }

    // ERC1155 Receiver implementation
    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external override returns(bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external override returns(bytes4) {
        return this.onERC1155BatchReceived.selector;
    }

    function supportsInterface(bytes4) external override view returns (bool) {
        return true;
    }
}
```

Note: The code assumes the proper interface definitions for ERC1155 and uses the correct SafeMath operations. Make sure to verify the interface IDs and function selectors for the specific version of Solidity and dependencies being used.