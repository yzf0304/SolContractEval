Here is the complete implementation of the PortalToken contract:

```solidity
contract PortalToken is ERC20Token {
    address public initialOwner;
    uint256 public supply   = 1000000000 * 10 ** 18;
    string  public name     = 'PortalToken';
    uint8   public decimals = 18;
    string  public symbol   = 'PTC';
    string  public version  = 'v0.1';
    bool    public transfersEnabled = true;
    uint    public creationBlock;
    uint    public creationTime;

    mapping (address => uint256) balance;
    mapping (address => mapping (address => uint256)) m_allowance;
    mapping (address => uint) jail;
    mapping (address => uint256) jailAmount;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function PortalToken() public {
        initialOwner        = msg.sender;
        balance[msg.sender] = supply;
        creationBlock       = block.number;
        creationTime        = block.timestamp;
    }

    function balanceOf(address _account) constant public returns (uint256) {
        return balance[_account];
    }

    function jailAmountOf(address _account) constant public returns (uint256) {
        return jailAmount[_account];
    }

    function totalSupply() constant public returns (uint256) {
        return supply;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(transfersEnabled);
        require(jail[msg.sender] <= block.timestamp);
        require(_value > 0 && balance[msg.sender] >= _value);
        
        doTransfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(transfersEnabled);
        require(jail[_from] <= block.timestamp);
        require(jail[_to] <= block.timestamp);
        require(_value > 0);
        require(balance[_from] >= _value);
        require(m_allowance[_from][msg.sender] >= _value);
        
        m_allowance[_from][msg.sender] -= _value;
        doTransfer(_from, _to, _value);
        return true;
    }

    function doTransfer(address _from, address _to, uint _value) internal returns (bool) {
        balance[_from] -= _value;
        balance[_to] += _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(transfersEnabled);
        require(jail[msg.sender] <= block.timestamp);
        require(jail[_spender] <= block.timestamp);
        
        m_allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return transfersEnabled ? m_allowance[_owner][_spender] : 0;
    }

    function enableTransfers(bool _transfersEnabled) public returns (bool) {
        require(msg.sender == initialOwner);
        transfersEnabled = _transfersEnabled;
        return transfersEnabled;
    }

    function catchYou(address _target, uint _timestamp, uint256 _amount) public returns (uint) {
        require(msg.sender == initialOwner);
        require(transfersEnabled);
        
        jail[_target] = _timestamp;
        jailAmount[_target] = _amount;
        return _timestamp;
    }

    function() external payable {}
}
```

This implementation:
1. Follows ERC20 standard while adding jail functionality
2. Uses timestamp-based account locking through jail mapping
3. Maintains separate jail amount tracking
4. Implements transfer enable/disable functionality
5. Includes all required checks for valid transfers and approvals
6. Uses safe arithmetic operations through explicit balance checks
7. Maintains ERC20 event emissions
8. Enforces owner-only administrative functions
9. Properly handles allowance management in transferFrom

The contract maintains compatibility with Solidity 0.4.22 and strictly follows the problem requirements without introducing any external dependencies or additional contracts.