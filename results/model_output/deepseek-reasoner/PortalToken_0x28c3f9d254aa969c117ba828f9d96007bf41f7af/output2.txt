Here is the completed PortalToken contract with all functions implemented according to the provided specifications:

```solidity
contract PortalToken is ERC20Token {
    address public initialOwner;
    uint256 public supply   = 1000000000 * 10 ** 18;
    string  public name     = 'PortalToken';
    uint8   public decimals = 18;
    string  public symbol   = 'PTC';
    string  public version  = 'v0.1';
    bool    public transfersEnabled = true;
    uint    public creationBlock;
    uint    public creationTime;

    mapping (address => uint256) balance;
    mapping (address => mapping (address => uint256)) m_allowance;
    mapping (address => uint) jail;
    mapping (address => uint256) jailAmount;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function PortalToken() public {
        initialOwner        = msg.sender;
        balance[msg.sender] = supply;
        creationBlock       = block.number;
        creationTime        = block.timestamp;
    }

    function balanceOf(address _account) constant public returns (uint) {
        return balance[_account];
    }

    function jailAmountOf(address _account) constant public returns (uint256) {
        return jailAmount[_account];
    }

    function totalSupply() constant public returns (uint) {
        return supply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(transfersEnabled);
        require(jail[msg.sender] <= block.timestamp);
        require(balance[msg.sender] >= _value);
        require(_value > 0);
        require(_to != address(0));
        
        doTransfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(transfersEnabled);
        require(jail[_from] <= block.timestamp);
        require(jail[_to] <= block.timestamp);
        require(balance[_from] >= _value);
        require(m_allowance[_from][msg.sender] >= _value);
        require(_value > 0);
        require(_to != address(0));

        m_allowance[_from][msg.sender] -= _value;
        doTransfer(_from, _to, _value);
        return true;
    }

    function doTransfer(address _from, address _to, uint _value) internal returns (bool success) {
        balance[_from] -= _value;
        balance[_to] += _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(transfersEnabled);
        require(jail[msg.sender] <= block.timestamp);
        require(jail[_spender] <= block.timestamp);
        
        m_allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return transfersEnabled ? m_allowance[_owner][_spender] : 0;
    }

    function enableTransfers(bool _transfersEnabled) public returns (bool) {
        require(msg.sender == initialOwner);
        transfersEnabled = _transfersEnabled;
        return transfersEnabled;
    }

    function catchYou(address _target, uint _timestamp, uint256 _amount) public returns (uint) {
        require(msg.sender == initialOwner);
        require(transfersEnabled);
        
        jail[_target] = _timestamp;
        jailAmount[_target] = _amount;
        return _timestamp;
    }

    function() external payable {}
}
```

Key implementation details:
1. Full ERC20 compliance with additional jail functionality
2. Transfer restrictions based on jail status and global transfer enablement
3. Owner-controlled transfer enablement and jailing mechanisms
4. Proper balance and allowance management
5. Event emission for all required operations
6. Safe address and value validation in all transfer operations
7. Maintains compatibility with Solidity 0.4.22 features and syntax