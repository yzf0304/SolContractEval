```solidity
pragma solidity ^0.4.18;

/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,
 *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {

  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;

  /**
   * @notice Struct to store participant information.
   * @dev Contains whether the participant is authorized and their minimum tier.
   */
  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  SeeToken public token;
  Discounts.Collection public discounts;
  Limits.Window public cap;
  mapping (address => Participant) public participants;

  event Tier(uint256 discount, uint256 available);

  function Presale(address _token) public {
    token = SeeToken(_token);
    paused = true;
  }

  function claimToken() public {
    token.claimOwnership();
  }

  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    discounts.baseRate = _purchaseRate;
  }

  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    cap.amount = _amount;
    cap.duration = _duration;
  }

  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    require(_discount < Discounts.MAX_DISCOUNT, "Discount too high");
    discounts.addTier(_discount, _available);
    Tier(_discount, _available);
  }

  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    for (uint i = 0; i < _authorized.length; i++) {
      address addr = _authorized[i];
      participants[addr].authorized = true;
      participants[addr].minimumTier = _minimumTier;
    }
  }

  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(address(this).balance);
  }

  function () public payable {
    purchaseTokens();
  }

  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    require(msg.value > 0, "No funds sent");
    Participant storage participant = participants[msg.sender];
    uint256 minTier = participant.minimumTier;

    uint256 allowed = cap.getLimit(msg.sender);
    require(allowed > 0, "No tokens available in cap");

    (uint256 purchased, uint256 remaining) = discounts.purchaseTokens(allowed, msg.value, minTier);
    require(purchased > 0, "No tokens purchased");

    cap.recordPurchase(msg.sender, purchased);
    token.issue(msg.sender, purchased);

    if (remaining > 0) {
      msg.sender.transfer(remaining);
    }
  }

  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    _amount = cap.amount;
    _duration = cap.duration;
  }

  function getTiers()
    public
    view
    returns (uint256[2][])
  {
    uint256 length = discounts.tiers.length;
    uint256[2][] memory tiers = new uint256[2][](length);
    for (uint i = 0; i < length; i++) {
      tiers[i][0] = discounts.tiers[i].discount;
      tiers[i][1] = discounts.tiers[i].available;
    }
    return tiers;
  }

  function getAvailability(address _participant)
    public
    view
    returns (uint256[])
  {
    uint256 tiersLength = discounts.tiers.length;
    uint256[] memory availability = new uint256[](tiersLength);
    if (!participants[_participant].authorized) {
      return availability;
    }
    uint256 minTier = participants[_participant].minimumTier;
    for (uint i = 0; i < tiersLength; i++) {
      if (i >= minTier) {
        availability[i] = discounts.tiers[i].available;
      } else {
        availability[i] = 0;
      }
    }
    return availability;
  }

  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}
```