To solve this problem, we need to create a smart contract that manages investments, dividends, and referrals. The contract should allow users to invest ETH, earn daily dividends, and receive referral bonuses. It should also handle administrative tasks such as commission distribution and transitioning between payment modes.

### Approach
1. **Investment Handling**: Users can invest a minimum of 0.01 ETH. The contract distributes 17% of the investment to administrators and marketers, and the remaining 83% is allocated to the investor's balance for dividends.
2. **Referral System**: Investors can refer others using up to three referral addresses. Each valid referral earns the referrer a 3% bonus from the investment amount.
3. **Dividend Distribution**: Investors can claim dividends daily, which are calculated as 3.33% of their investment balance. The contract supports both pull (investor-initiated) and push (admin-initiated) payment modes.
4. **Wave System**: If the contract balance is insufficient to pay dividends, it transitions to a new wave, pausing investments for a period and resetting certain parameters.
5. **Admin Functions**: Administrators can change payment modes, update admin and payer addresses, and distribute dividends in push mode.

### Solution Code
```solidity
pragma solidity ^0.4.24;

contract Revolution is Accessibility, PaymentSystem {
    using Percent for Percent.percent;
    using SafeMath for uint;
    using Zero for *;
    using ToAddress for *;

    InvestorsStorage private m_investors;
    mapping(address => bool) private m_referrals;
    bool private m_nextWave;

    address public adminAddr;
    address public payerAddr;
    uint public waveStartup;
    uint public investmentsNum;
    uint public constant minInvesment = 10 finney;
    uint public constant maxBalance = 333e5 ether;
    uint public constant pauseOnNextWave = 168 hours;

    Percent.percent private m_dividendsPercent = Percent.percent(333, 10000);
    Percent.percent private m_adminPercent = Percent.percent(1, 10);
    Percent.percent private m_payerPercent = Percent.percent(7, 100);
    Percent.percent private m_refPercent = Percent.percent(3, 100);

    event LogNewInvestor(address indexed addr, uint when, uint value);
    event LogNewInvesment(address indexed addr, uint when, uint value);
    event LogNewReferral(address indexed addr, uint when, uint value);
    event LogPayDividends(address indexed addr, uint when, uint value);
    event LogPayReferrerBonus(address indexed addr, uint when, uint value);
    event LogBalanceChanged(uint when, uint balance);
    event LogAdminAddrChanged(address indexed addr, uint when);
    event LogPayerAddrChanged(address indexed addr, uint when);
    event LogNextWave(uint when);

    modifier balanceChanged {
        _;
        emit LogBalanceChanged(now, address(this).balance);
    }

    modifier notOnPause() {
        require(waveStartup + pauseOnNextWave <= now, "pause on next wave not expired");
        _;
    }

    constructor() public {
        adminAddr = msg.sender;
        emit LogAdminAddrChanged(msg.sender, now);

        payerAddr = msg.sender;
        emit LogPayerAddrChanged(msg.sender, now);

        nextWave();
        waveStartup = waveStartup.sub(pauseOnNextWave);
    }

    function investorsNumber() public view returns(uint) {
        return m_investors.size() - 1;
    }

    function balanceETH() public view returns(uint) {
        return address(this).balance;
    }

    function payerPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);
    }

    function dividendsPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);
    }

    function adminPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);
    }

    function referrerPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_refPercent.num, m_refPercent.den);
    }

    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {
        (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);
        isReferral = m_referrals[addr];
    }

    function latestPayout() public view returns(uint timestamp) {
        timestamp = m_paysys.latestTime;
    }

    function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {
        require(m_investors.contains(msg.sender), "not an investor");
        (uint value, uint paymentTime, uint refBonus) = m_investors.investorBaseInfo(msg.sender);
        require(now >= paymentTime.add(24 hours), "too soon");

        uint daysPassed = (now.sub(paymentTime)).div(1 days);
        require(daysPassed > 0, "no days passed");

        uint dividends = m_dividendsPercent.mul(value).mul(daysPassed);
        uint totalAmount = dividends.add(refBonus);
        require(totalAmount > 0, "no dividends or bonus");

        if (address(this).balance < totalAmount) {
            nextWave();
            return;
        }

        m_investors.setPaymentTime(msg.sender, now);
        if (refBonus > 0) {
            m_investors.setRefBonus(msg.sender, 0);
            sendDividendsWithRefBonus(msg.sender, dividends, refBonus);
        } else {
            sendDividends(msg.sender, dividends);
        }
    }

    function doInvest(address[3] refs) public payable notOnPause balanceChanged {
        require(msg.value >= minInvesment, "investment too small");
        require(address(this).balance <= maxBalance, "max balance exceeded");
        require(!m_referrals[msg.sender], "already a referral");

        uint totalReferralBonuses;
        for (uint i = 0; i < refs.length; i++) {
            address ref = refs[i];
            if (notZeroNotSender(ref) && m_investors.contains(ref)) {
                uint bonus = m_refPercent.mul(msg.value);
                totalReferralBonuses = totalReferralBonuses.add(bonus);
                m_investors.addRefBonus(ref, bonus);
                emit LogNewReferral(ref, now, bonus);

                if (i == 0) {
                    m_referrals[msg.sender] = true;
                }
            }
        }

        uint adminCommission = m_adminPercent.mul(msg.value);
        uint payerCommission = m_payerPercent.mul(msg.value);
        uint investmentNet = msg.value.sub(adminCommission).sub(payerCommission).sub(totalReferralBonuses);

        adminAddr.transfer(adminCommission);
        payerAddr.transfer(payerCommission);

        if (m_investors.contains(msg.sender)) {
            m_investors.addValue(msg.sender, investmentNet);
        } else {
            m_investors.insert(msg.sender, investmentNet);
            emit LogNewInvestor(msg.sender, now, investmentNet);
        }

        investmentsNum = investmentsNum.add(1);
        emit LogNewInvesment(msg.sender, now, investmentNet);

        if (m_paysys.mode == Paymode.Pull) {
            m_investors.setPaymentTime(msg.sender, now);
        }
    }

    function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {
        require(now >= m_paysys.latestTime.add(12 hours), "too soon");
        if (address(this).balance == 0) {
            nextWave();
            return;
        }

        uint gasLimit = gasleft();
        uint investorsCount = m_investors.size();
        uint currentKeyIndex = m_paysys.latestKeyIndex;

        for (uint i = currentKeyIndex; i < investorsCount; i++) {
            address addr = m_investors.keyFromIndex(i + 1);
            (uint value, uint paymentTime, uint refBonus) = m_investors.investorBaseInfo(addr);
            uint daysPassed = (now.sub(paymentTime)).div(1 days);
            if (daysPassed == 0) continue;

            uint dividends = m_dividendsPercent.mul(value).mul(daysPassed);
            uint total = dividends.add(refBonus);

            if (address(this).balance < total) {
                nextWave();
                break;
            }

            sendDividendsWithRefBonus(addr, dividends, refBonus);
            m_investors.setPaymentTime(addr, now);
            m_investors.setRefBonus(addr, 0);

            m_paysys.latestKeyIndex = i + 1;
            m_paysys.latestTime = now;

            if (gasleft() < gasLimit.div(20)) {
                break;
            }
        }

        if (m_paysys.latestKeyIndex >= investorsCount) {
            m_paysys.latestKeyIndex = 0;
        }
    }

    function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {
        adminAddr = addr;
        emit LogAdminAddrChanged(addr, now);
    }

    function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {
        payerAddr = addr;
        emit LogPayerAddrChanged(addr, now);
    }

    function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {
        changePaymode(Paymode.Pull);
    }

    function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {
        (uint keyIndex, uint value, uint paymentTime, uint refBonus) = m_investors.investorFullInfo(addr);
        return InvestorsStorage.investor(keyIndex, value, paymentTime, refBonus);
    }

    function notZeroNotSender(address addr) internal view returns(bool) {
        return addr.notZero() && addr != msg.sender;
    }

    function sendDividends(address addr, uint value) private {
        addr.transfer(value);
        emit LogPayDividends(addr, now, value);
    }

    function sendDividendsWithRefBonus(address addr, uint value, uint refBonus) private {
        addr.transfer(value.add(refBonus));
        emit LogPayDividends(addr, now, value);
        emit LogPayReferrerBonus(addr, now, refBonus);
    }

    function nextWave() private {
        m_nextWave = true;
        waveStartup = now;
        investmentsNum = 0;
        changePaymode(Paymode.Pull);
        m_paysys.latestKeyIndex = 0;
        m_paysys.latestTime = 0;
        emit LogNextWave(now);
    }
}
```

### Explanation
1. **Investment Handling**: Users send ETH to the contract, which deducts commissions (17%) and adds the remainder to their investment balance. Referral bonuses are distributed to valid referrers.
2. **Dividend Calculation**: Investors earn 3.33% daily dividends on their balance. They can claim these dividends manually (pull mode) or wait for admin distribution (push mode).
3. **Referral System**: Up to three referrals can be specified, each earning 3% of the investment. Referrers must be existing investors.
4. **Wave System**: If the contract balance is too low to pay dividends, a new wave starts, pausing investments for 168 hours and resetting parameters.
5. **Admin Functions**: Admins can change addresses, switch payment modes, and trigger dividend distribution in push mode, ensuring efficient gas usage by processing investors in batches.

This approach ensures transparency, security, and efficiency, adhering to the specified requirements and constraints.