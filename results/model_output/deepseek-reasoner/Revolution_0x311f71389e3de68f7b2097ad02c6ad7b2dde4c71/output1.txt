Here is the completed Revolution contract:

```solidity
contract Revolution is Accessibility, PaymentSystem {
    // ... (existing code remains unchanged)

    function investorsNumber() public view returns(uint) {
        return m_investors.size() - 1;
    }

    function balanceETH() public view returns(uint) {
        return address(this).balance;
    }

    function payerPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_payerPercent.num, m_payerPercent.den);
    }

    function dividendsPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_dividendsPercent.num, m_dividendsPercent.den);
    }

    function adminPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_adminPercent.num, m_adminPercent.den);
    }

    function referrerPercent() public view returns(uint numerator, uint denominator) {
        (numerator, denominator) = (m_refPercent.num, m_refPercent.den);
    }

    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {
        (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);
        isReferral = m_referrals[addr];
    }

    function latestPayout() public view returns(uint timestamp) {
        return m_paysys.latestTime;
    }

    function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {
        require(m_investors.contains(msg.sender), "sender is not investor");
        InvestorsStorage.investor memory investor = getMemInvestor(msg.sender);
        
        uint daysPassed = (now - investor.paymentTime) / 1 days;
        require(daysPassed > 0, "no dividends available");
        
        uint value = investor.value.mul(m_dividendsPercent.mul(daysPassed));
        uint refBonus = investor.refBonus;
        uint total = value.add(refBonus);
        
        require(address(this).balance >= total, "insufficient balance");
        
        m_investors.setPaymentTime(msg.sender, now);
        m_investors.setRefBonus(msg.sender, 0);
        
        if (refBonus > 0) {
            sendDividendsWithRefBonus(msg.sender, value, refBonus);
        } else {
            sendDividends(msg.sender, total);
        }
    }

    function doInvest(address[3] refs) public payable notOnPause balanceChanged {
        require(msg.value >= minInvesment, "investment too small");
        require(address(this).balance <= maxBalance, "max balance exceeded");
        
        uint adminCommission = m_adminPercent.mul(msg.value);
        uint payerCommission = m_payerPercent.mul(msg.value);
        adminAddr.transfer(adminCommission);
        payerAddr.transfer(payerCommission);
        
        uint investment = msg.value.sub(adminCommission).sub(payerCommission);
        
        for (uint i = 0; i < refs.length; i++) {
            address ref = refs[i];
            if (notZeroNotSender(ref) && m_investors.contains(ref)) {
                uint bonus = m_refPercent.mul(investment);
                m_investors.addRefBonus(ref, bonus);
                investment = investment.sub(bonus);
                emit LogNewReferral(ref, now, bonus);
            }
        }
        
        if (m_investors.contains(msg.sender)) {
            m_investors.addValue(msg.sender, investment);
        } else {
            m_investors.insert(msg.sender, investment);
            m_referrals[msg.sender] = (refs[0] != address(0));
            emit LogNewInvestor(msg.sender, now, investment);
        }
        
        if (m_paysys.mode == Paymode.Pull) {
            m_investors.setPaymentTime(msg.sender, now);
        }
        
        investmentsNum++;
        emit LogNewInvesment(msg.sender, now, investment);
    }

    function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {
        if (address(this).balance < 1 ether) {
            nextWave();
            return;
        }
        
        require(now >= m_paysys.latestTime + 12 hours, "payout too frequent");
        
        uint gas = gasleft();
        uint iter = m_paysys.latestKeyIndex;
        uint size = m_investors.size();
        
        while (iter < size && gas > 100000) {
            address addr = m_investors.keyFromIndex(iter);
            InvestorsStorage.investor memory inv = getMemInvestor(addr);
            
            uint daysPassed = (now - inv.paymentTime) / 1 days;
            if (daysPassed == 0) {
                iter++;
                continue;
            }
            
            uint value = inv.value.mul(m_dividendsPercent.mul(daysPassed));
            uint total = value.add(inv.refBonus);
            
            if (address(this).balance < total) {
                nextWave();
                return;
            }
            
            m_investors.setPaymentTime(addr, now);
            m_investors.setRefBonus(addr, 0);
            
            if (inv.refBonus > 0) {
                sendDividendsWithRefBonus(addr, value, inv.refBonus);
            } else {
                sendDividends(addr, total);
            }
            
            iter++;
            gas = gasleft();
        }
        
        m_paysys.latestKeyIndex = iter;
        m_paysys.latestTime = now;
    }

    function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {
        addr.requireNotZero();
        adminAddr = addr;
        emit LogAdminAddrChanged(addr, now);
    }

    function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {
        addr.requireNotZero();
        payerAddr = addr;
        emit LogPayerAddrChanged(addr, now);
    }

    function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {
        changePaymode(Paymode.Pull);
    }

    function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {
        (uint value, uint paymentTime, uint refBonus) = m_investors.investorBaseInfo(addr);
        return InvestorsStorage.investor(0, value, paymentTime, refBonus);
    }

    function notZeroNotSender(address addr) internal view returns(bool) {
        return addr.notZero() && addr != msg.sender;
    }

    function sendDividends(address addr, uint value) private {
        if (addr.send(value)) {
            emit LogPayDividends(addr, now, value);
        } else {
            m_investors.addRefBonus(addr, value);
        }
    }

    function sendDividendsWithRefBonus(address addr, uint value, uint refBonus) private {
        if (addr.send(value + refBonus)) {
            emit LogPayDividends(addr, now, value);
            emit LogPayReferrerBonus(addr, now, refBonus);
        } else {
            m_investors.addRefBonus(addr, value + refBonus);
        }
    }

    function nextWave() private {
        m_investors = new InvestorsStorage();
        investmentsNum = 0;
        m_nextWave = true;
        waveStartup = now;
        changePaymode(Paymode.Push);
        emit LogNextWave(now);
    }
}
```

This implementation:
1. Completes all function stubs according to the specifications
2. Uses SafeMath for arithmetic operations
3. Properly handles referral bonuses and payment modes
4. Implements both push and pull payout mechanisms
5. Maintains proper access control
6. Follows the 3.33% daily return structure
7. Includes proper event emissions
8. Handles contract state transitions between waves
9. Includes proper referral system implementation up to 3 levels
10. Uses the correct percentage allocations for different roles

The code maintains compatibility with Solidity 0.4.24 and follows the patterns established in the provided contract structure.