Here's the complete implementation of the ScammerGold contract based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.6;

contract ScammerGold is Context, Ownable, ERC20 {
    address public slootContractAddress = 0xb12F78434AE7D12Ae548c51A5cb734Ecc4536594;
    IERC721Enumerable public slootContract;

    uint256 public scammerGoldPerTokenId = 10000 * (10**decimals());
    uint256 public tokenIdStart = 1;
    uint256 public tokenIdEnd = 8000;
    uint256 public season = 0;

    mapping(uint256 => mapping(uint256 => bool)) public seasonClaimedByTokenId;

    constructor() Ownable() ERC20("Scammer Gold", "SGLD") {
        transferOwnership(0x0000000000000000000000000000000000000000);
        slootContract = IERC721Enumerable(slootContractAddress);
    }

    function claimById(uint256 tokenId) external {
        require(tokenId >= tokenIdStart && tokenId <= tokenIdEnd, "Token ID not eligible");
        address tokenOwner = slootContract.ownerOf(tokenId);
        require(tokenOwner == _msgSender(), "Not the owner");
        require(!seasonClaimedByTokenId[season][tokenId], "Already claimed");
        _claim(tokenId, tokenOwner);
    }

    function claimAllForOwner() external {
        address sender = _msgSender();
        uint256 balance = slootContract.balanceOf(sender);
        
        for (uint256 i = 0; i < balance; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(sender, i);
            if (tokenId >= tokenIdStart && tokenId <= tokenIdEnd && !seasonClaimedByTokenId[season][tokenId]) {
                _claim(tokenId, sender);
            }
        }
    }

    function claimRangeForOwner(uint256 ownerIndexStart, uint256 ownerIndexEnd) external {
        address sender = _msgSender();
        uint256 balance = slootContract.balanceOf(sender);
        require(ownerIndexStart <= ownerIndexEnd, "Invalid range");
        require(ownerIndexEnd < balance, "End index exceeds balance");

        for (uint256 i = ownerIndexStart; i <= ownerIndexEnd; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(sender, i);
            if (tokenId >= tokenIdStart && tokenId <= tokenIdEnd && !seasonClaimedByTokenId[season][tokenId]) {
                _claim(tokenId, sender);
            }
        }
    }

    function _claim(uint256 tokenId, address tokenOwner) internal {
        require(slootContract.ownerOf(tokenId) == tokenOwner, "Ownership changed");
        require(!seasonClaimedByTokenId[season][tokenId], "Already claimed");

        seasonClaimedByTokenId[season][tokenId] = true;
        _mint(tokenOwner, scammerGoldPerTokenId);
    }

    function daoMint(uint256 amountDisplayValue) external onlyOwner {
        uint256 amount = amountDisplayValue * (10**decimals());
        _mint(owner(), amount);
    }

    function daoSetLootContractAddress(address slootContractAddress_) external onlyOwner {
        slootContractAddress = slootContractAddress_;
        slootContract = IERC721Enumerable(slootContractAddress_);
    }

    function daoSetTokenIdRange(uint256 tokenIdStart_, uint256 tokenIdEnd_) external onlyOwner {
        tokenIdStart = tokenIdStart_;
        tokenIdEnd = tokenIdEnd_;
    }

    function daoSetSeason(uint256 season_) public onlyOwner {
        season = season_;
    }

    function daoSetScammerGoldPerTokenId(uint256 scammerGoldDisplayValue) public onlyOwner {
        scammerGoldPerTokenId = scammerGoldDisplayValue * (10**decimals());
    }

    function daoSetSeasonAndScammerGoldPerTokenID(
        uint256 season_,
        uint256 scammerGoldDisplayValue
    ) external onlyOwner {
        daoSetSeason(season_);
        daoSetScammerGoldPerTokenId(scammerGoldDisplayValue);
    }

    receive() external payable {}
}

interface IERC721 {
    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);
}

interface IERC721Enumerable is IERC721 {
    function totalSupply() external view returns (uint256);
    function tokenByIndex(uint256 index) external view returns (uint256);
}
```

Key implementation details:

1. **Claim Functions**:
   - `claimById()`: Validates ownership and eligibility before minting
   - `claimAllForOwner()`: Iterates through all owned tokens with gas considerations
   - `claimRangeForOwner()`: Processes a specific range of token indices
   - Internal `_claim()` handles core validation and minting logic

2. **DAO Functions**:
   - Protected by `onlyOwner` modifier (though ownership is burned in constructor)
   - Allow configuration of contract parameters and token minting

3. **Safety Checks**:
   - Token ID range validation
   - Ownership verification in both external and internal functions
   - Season-based claiming system to prevent duplicate claims

4. **ERC20 Compliance**:
   - Proper decimals handling (18 decimals)
   - Uses OpenZeppelin-inspired ERC20 implementation from provided context

5. **Compatibility**:
   - Written for Solidity 0.8.6 with overflow protections
   - Maintains compatibility with sLoot NFT contract interface

Note: The ownership transfer to zero address in the constructor effectively makes the DAO functions unusable after deployment, as specified in the original code context.