Here is the complete implementation of the Shibereum contract based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.8.17;

contract Shibereum is IERC20, Ownable {       
    string private constant _name = "Shibereum.Ai";
    string private constant _symbol = "Shibereum";
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _blocked;

    mapping (address => uint256) private _lastTradeBlock;
    mapping (address => bool) private isContractExempt;
    uint256 private tradeCooldown = 1;
    
    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;
    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;
    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;

    struct TradingFees{
        uint256 buyTax;
        uint256 sellTax;
    }  

    TradingFees public tradingFees = TradingFees(10,45);
    uint256 public constant sniperTax = 49;

    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address private immutable ETH = uniswapRouter.WETH();
    address private immutable uniswapPair;

    address payable private immutable deployerAddress = payable(msg.sender);
    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);

    bool private tradingOpen = false;
    bool private swapping = false;
    bool private antiMEV = false;
    uint256 private startingBlock;
    uint256 private preLaunch;

    modifier swapLock {
        swapping = true;
        _;
        swapping = false;
    }

    modifier tradingLock(address sender) {
        require(tradingOpen || sender == deployerAddress || sender == devWallet, "Trading not open");
        _;
    }

    constructor () {
        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);
        isContractExempt[address(this)] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    function name() public pure returns (string memory) {
        return _name;
    }

    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!_blocked[from] && !_blocked[to], "Address blocked");

        if (to != uniswapPair && !isContractExempt[to]) {
            require(_balances[to] + amount <= maxWalletAmount, "Exceeds max wallet");
        }

        if (antiMEV) {
            address human = ensureOneHuman(to, from);
            ensureMaxTxFrequency(human);
        }

        uint256 fee = 0;
        if (!swapping) {
            fee = takeFee(from, to, amount);
        }

        uint256 transferAmount = amount - fee;
        _balances[from] -= amount;
        _balances[to] += transferAmount;

        if (fee > 0) {
            _balances[address(this)] += fee;
            emit Transfer(from, address(this), fee);
        }

        emit Transfer(from, to, transferAmount);

        if (shouldSwapback(from)) {
            swapback(getSwapAmount(_balances[address(this)]));
        }
    }

    function swapback(uint256 tokenAmount) private swapLock {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ETH;
        _approve(address(this), address(uniswapRouter), tokenAmount);
        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            devWallet,
            block.timestamp
        );
    }

    function shouldSwapback(address from) private view returns (bool) {
        return from != uniswapPair && !swapping && _balances[address(this)] >= contractSwapLimit;
    }

    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {
        return tokenAmount > contractSwapMax ? contractSwapMax : tokenAmount;
    }

    function takeFee(address from, address to, uint256 amount) private view returns (uint256) {
        if (block.number < startingBlock + preLaunch) {
            return (amount * sniperTax) / 100;
        }

        if (from == uniswapPair) {
            return (amount * tradingFees.buyTax) / 100;
        } else if (to == uniswapPair) {
            return (amount * tradingFees.sellTax) / 100;
        }
        return 0;
    }

    function isContract(address account) private view returns (bool) {
        uint32 size;
        assembly {
            size := extcodesize(account)
        }
        return (size > 0);
    }

    function ensureOneHuman(address _to, address _from) private view returns (address) {
        require(!isContract(_to) || !isContract(_from), "No contracts");
        return isContract(_to) ? _from : _to;
    }

    function ensureMaxTxFrequency(address addr) private view {
        require(_lastTradeBlock[addr] + tradeCooldown < block.number, "Max tx frequency exceeded");
    }

    function toggleAntiMEV(bool toggle) external onlyOwner {
        antiMEV = toggle;
    }

    function setTradeCooldown(uint256 newTradeCooldown) external onlyOwner {
        tradeCooldown = newTradeCooldown;
    }

    function manualSwapback(uint256 percent) external {
        require(msg.sender == deployerAddress || msg.sender == devWallet, "Not authorized");
        uint256 contractBalance = _balances[address(this)];
        uint256 swapAmount = contractBalance * percent / 100;
        swapback(swapAmount);
    }

    function setFees(uint256 newBuyTax, uint256 newSellTax) external onlyOwner {
        tradingFees.buyTax = newBuyTax;
        tradingFees.sellTax = newSellTax;
    }

    function setContractExempt(address account, bool value) external onlyOwner {
        isContractExempt[account] = value;
    }

    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {
        for (uint i = 0; i < bots.length; i++) {
            _blocked[bots[i]] = shouldBlock;
        }
    }

    function initialize() external onlyOwner {
        require(preLaunch == 0, "Already initialized");
        preLaunch = 7;
    }

    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {
        startingBlock += nrBlocks;
    }

    function openTrading() external onlyOwner {
        require(!tradingOpen, "Trading already open");
        tradingOpen = true;
        startingBlock = block.number;
    }
}
```

This implementation includes:
- ERC20 standard functions with fee calculations
- Automated swapback mechanism for fee collection
- Anti-MEV and transaction frequency controls
- Max wallet protection
- Sniper tax during initial trading blocks
- Owner-controlled parameters for fees and contract configuration
- Proper integration with Uniswap V2 for liquidity operations

The contract maintains all specified requirements including trading restrictions, fee structures, and swap mechanisms while adhering to the ERC20 standard and compiler version 0.8.17.