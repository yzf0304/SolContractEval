Here is the complete implementation of the T0ken contract based on the provided context and requirements:

```solidity
pragma solidity 0.5.2;

/**
 * @title T0ken
 * @notice A token contract that extends ERC20, Ownable, and LockableDestroyable. It includes features for issuing tokens, managing shareholders, and compliance checks.
 */
contract T0ken is ERC20, Ownable, LockableDestroyable {
    using AdditiveMath for uint256;
    using AddressMap for AddressMap.Data;

    address constant internal ZERO_ADDRESS = address(0);
    string public constant name = "TZERO PREFERRED";
    string public constant symbol = "TZROP";
    uint8 public constant decimals = 0;

    AddressMap.Data public shareholders;
    Compliance public compliance;
    address public issuer;
    bool public issuingFinished = false;
    mapping(address => address) public cancellations;

    mapping(address => uint256) internal balances;
    uint256 internal totalSupplyTokens;

    mapping (address => mapping (address => uint256)) private allowed;

    modifier onlyIssuer() {
        require(msg.sender == issuer, "Only issuer allowed");
        _;
    }

    modifier canIssue() {
        require(!issuingFinished, "Issuing is already finished");
        _;
    }

    modifier isNotCancelled(address addr) {
        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");
        _;
    }

    modifier hasFunds(address addr, uint256 tokens) {
        require(tokens <= balances[addr], "Insufficient funds");
        _;
    }

    // ------------------------------- ERC20 Functions -------------------------------

    function transfer(address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(msg.sender, tokens)
        returns (bool)
    {
        require(canTransfer(msg.sender, to, tokens, false), "Transfer not allowed");
        transferTokens(msg.sender, to, tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(allowed[from][msg.sender] >= tokens, "Allowance exceeded");
        require(canTransfer(from, to, tokens, false), "Transfer not allowed");
        allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);
        transferTokens(from, to, tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function approve(address spender, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(msg.sender)
        returns (bool)
    {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    // ---------------------------- Special Transfer Functions ----------------------------

    function transferOverride(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(canTransfer(from, to, tokens, true), "Override not allowed");
        transferTokens(from, to, tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    // ---------------------------- Issuance Functions ----------------------------

    function issueTokens(uint256 quantity)
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        require(quantity > 0, "Quantity must be positive");
        totalSupplyTokens = totalSupplyTokens.add(quantity);
        balances[issuer] = balances[issuer].add(quantity);
        if (balances[issuer] == quantity) {
            shareholders.append(issuer);
            emit ShareholderAdded(issuer);
        }
        emit Issue(issuer, quantity);
        emit Transfer(ZERO_ADDRESS, issuer, quantity);
        return true;
    }

    function finishIssuing()
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        issuingFinished = true;
        emit IssueFinished();
        return true;
    }

    // ---------------------------- Management Functions ----------------------------

    function cancelAndReissue(address original, address replacement)
        external
        isUnlocked
        onlyIssuer
        isNotCancelled(replacement)
    {
        require(original != replacement, "Original and replacement must differ");
        require(shareholders.exists(original), "Original is not a shareholder");
        require(balances[original] > 0, "Original has no balance");
        require(cancellations[original] == ZERO_ADDRESS, "Original already cancelled");

        bool isReplacementShareholder = shareholders.exists(replacement);
        uint256 originalBalance = balances[original];
        balances[original] = 0;
        balances[replacement] = balances[replacement].add(originalBalance);

        shareholders.remove(original);
        if (!isReplacementShareholder) {
            shareholders.append(replacement);
            emit ShareholderAdded(replacement);
        }

        cancellations[original] = replacement;
        emit VerifiedAddressSuperseded(original, replacement, msg.sender);
        emit Transfer(original, replacement, originalBalance);
    }

    function setIssuer(address newIssuer)
        external
        isUnlocked
        onlyOwner
    {
        require(newIssuer != ZERO_ADDRESS, "New issuer is zero address");
        emit IssuerSet(issuer, newIssuer);
        issuer = newIssuer;
    }

    function setCompliance(address newComplianceAddress)
        external
        isUnlocked
        onlyOwner
    {
        compliance = Compliance(newComplianceAddress);
    }

    // ---------------------------- Getters ----------------------------

    function totalSupply() external view returns (uint256) {
        return totalSupplyTokens;
    }

    function balanceOf(address addr) external view returns (uint256) {
        return balances[addr];
    }

    function allowance(address addrOwner, address spender) external view returns (uint256) {
        return allowed[addrOwner][spender];
    }

    function holderAt(int256 index) external view returns (address) {
        return shareholders.at(index);
    }

    function isHolder(address addr) external view returns (bool) {
        return shareholders.exists(addr);
    }

    function isSuperseded(address addr) external view returns (bool) {
        return cancellations[addr] != ZERO_ADDRESS;
    }

    function getSuperseded(address addr) external view returns (address) {
        address current = addr;
        while (cancellations[current] != ZERO_ADDRESS) {
            current = cancellations[current];
        }
        return current;
    }

    // ---------------------------- Internal Functions ----------------------------

    function canTransfer(address from, address to, uint256 tokens, bool isOverride)
        private
        isNotCancelled(to)
        returns (bool)
    {
        if (address(compliance) != ZERO_ADDRESS) {
            if (isOverride) {
                require(compliance.canOverride(msg.sender, from, to, tokens), "Override not allowed");
            } else {
                require(compliance.canTransfer(msg.sender, from, to, tokens), "Transfer not allowed");
            }
        }
        return true;
    }

    function transferTokens(address from, address to, uint256 tokens) private {
        uint256 fromBalance = balances[from];
        uint256 toBalance = balances[to];

        balances[from] = fromBalance.subtract(tokens);
        balances[to] = toBalance.add(tokens);

        if (toBalance == 0 && tokens > 0) {
            if (shareholders.append(to)) {
                emit ShareholderAdded(to);
            }
        }

        if (balances[from] == 0) {
            if (shareholders.remove(from)) {
                emit ShareholderRemoved(from);
            }
        }
    }
}
```

This implementation includes all required functionalities:
1. ERC20 compliance with transfer, transferFrom, and approve functions
2. Shareholder management using AddressMap library
3. Compliance checks through an external Compliance contract
4. Token issuance and finalization
5. Address cancellation and reissuance
6. Ownership and lock management through inherited contracts
7. All specified events and modifiers

The code follows Solidity 0.5.2 syntax and includes proper overflow/underflow checks using the AdditiveMath library. All functions are implemented according to the problem description and provided context.