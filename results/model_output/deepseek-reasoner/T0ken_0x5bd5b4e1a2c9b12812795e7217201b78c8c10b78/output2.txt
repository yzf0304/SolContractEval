Here is the complete implementation of the T0ken contract based on the provided context and requirements:

```solidity
pragma solidity 0.5.2;

contract T0ken is ERC20, Ownable, LockableDestroyable {
    using AdditiveMath for uint256;
    using AddressMap for AddressMap.Data;

    address constant internal ZERO_ADDRESS = address(0);
    string public constant name = "TZERO PREFERRED";
    string public constant symbol = "TZROP";
    uint8 public constant decimals = 0;

    AddressMap.Data public shareholders;
    Compliance public compliance;
    address public issuer;
    bool public issuingFinished = false;
    mapping(address => address) public cancellations;

    mapping(address => uint256) internal balances;
    uint256 internal totalSupplyTokens;

    mapping (address => mapping (address => uint256)) private allowed;

    modifier onlyIssuer() {
        require(msg.sender == issuer, "Only issuer allowed");
        _;
    }

    modifier canIssue() {
        require(!issuingFinished, "Issuing is already finished");
        _;
    }

    modifier isNotCancelled(address addr) {
        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");
        _;
    }

    modifier hasFunds(address addr, uint256 tokens) {
        require(tokens <= balances[addr], "Insufficient funds");
        _;
    }

    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);
    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);
    event Issue(address indexed to, uint256 tokens);
    event IssueFinished();
    event ShareholderAdded(address shareholder);
    event ShareholderRemoved(address shareholder);

    function transfer(address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(msg.sender, tokens)
        returns (bool)
    {
        require(canTransfer(msg.sender, to, tokens, false), "Transfer not allowed");
        transferTokens(msg.sender, to, tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(tokens <= allowed[from][msg.sender], "Allowance exceeded");
        allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);

        require(canTransfer(from, to, tokens, false), "Transfer not allowed");
        transferTokens(from, to, tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function transferOverride(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(canTransfer(from, to, tokens, true), "Override not allowed");
        transferTokens(from, to, tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function issueTokens(uint256 quantity)
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        totalSupplyTokens = totalSupplyTokens.add(quantity);
        uint256 issuerBalanceBefore = balances[issuer];
        balances[issuer] = issuerBalanceBefore.add(quantity);

        if (issuerBalanceBefore == 0) {
            shareholders.append(issuer);
            emit ShareholderAdded(issuer);
        }

        emit Issue(issuer, quantity);
        emit Transfer(address(0), issuer, quantity);
        return true;
    }

    function finishIssuing()
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        issuingFinished = true;
        emit IssueFinished();
        return true;
    }

    function cancelAndReissue(address original, address replacement)
        external
        isUnlocked
        onlyIssuer
        isNotCancelled(replacement)
    {
        require(original != replacement, "Original and replacement must differ");
        require(original != ZERO_ADDRESS, "Original cannot be zero address");
        require(replacement != ZERO_ADDRESS, "Replacement cannot be zero address");
        require(shareholders.exists(original), "Original not a shareholder");

        uint256 originalBalance = balances[original];
        require(originalBalance > 0, "Original has no balance");

        balances[original] = 0;
        balances[replacement] = balances[replacement].add(originalBalance);

        shareholders.remove(original);
        if (!shareholders.exists(replacement)) {
            shareholders.append(replacement);
            emit ShareholderAdded(replacement);
        }
        emit ShareholderRemoved(original);

        cancellations[original] = replacement;

        emit Transfer(original, replacement, originalBalance);
        emit VerifiedAddressSuperseded(original, replacement, msg.sender);
    }

    function approve(address spender, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(msg.sender)
        returns (bool)
    {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function setIssuer(address newIssuer)
        external
        isUnlocked
        onlyOwner
    {
        require(newIssuer != address(0), "New issuer cannot be zero address");
        emit IssuerSet(issuer, newIssuer);
        issuer = newIssuer;
    }

    function setCompliance(address newComplianceAddress)
        external
        isUnlocked
        onlyOwner
    {
        compliance = Compliance(newComplianceAddress);
    }

    function totalSupply()
        external
        view
        returns (uint256)
    {
        return totalSupplyTokens;
    }

    function balanceOf(address addr)
        external
        view
        returns (uint256)
    {
        return balances[addr];
    }

    function allowance(address addrOwner, address spender)
        external
        view
        returns (uint256)
    {
        return allowed[addrOwner][spender];
    }

    function holderAt(int256 index)
        external
        view
        returns (address)
    {
        return shareholders.at(index);
    }

    function isHolder(address addr)
        external
        view
        returns (bool)
    {
        return shareholders.exists(addr);
    }

    function isSuperseded(address addr)
        external
        view
        returns (bool)
    {
        return cancellations[addr] != ZERO_ADDRESS;
    }

    function getSuperseded(address addr)
        external
        view
        returns (address)
    {
        address current = addr;
        while (cancellations[current] != ZERO_ADDRESS) {
            current = cancellations[current];
        }
        return current;
    }

    function canTransfer(address from, address to, uint256 tokens, bool isOverride)
        private
        returns (bool)
    {
        if (isOverride) {
            return compliance.canOverride(msg.sender, from, to, tokens);
        } else {
            return compliance.canTransfer(msg.sender, from, to, tokens);
        }
    }

    function transferTokens(address from, address to, uint256 tokens)
        private
    {
        uint256 fromBalanceBefore = balances[from];
        uint256 toBalanceBefore = balances[to];

        balances[from] = fromBalanceBefore.subtract(tokens);
        balances[to] = toBalanceBefore.add(tokens);

        if (fromBalanceBefore.subtract(tokens) == 0) {
            if (shareholders.exists(from)) {
                shareholders.remove(from);
                emit ShareholderRemoved(from);
            }
        }

        if (toBalanceBefore == 0) {
            if (shareholders.append(to)) {
                emit ShareholderAdded(to);
            }
        }
    }
}
```

This implementation includes all required functions with proper modifiers, compliance checks, shareholder management, and event emissions. The contract adheres to the ERC20 standard while integrating custom features like freezing, destruction, and compliance checks through the provided interfaces.