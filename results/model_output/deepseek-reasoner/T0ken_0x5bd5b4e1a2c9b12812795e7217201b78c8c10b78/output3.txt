Here's the complete and functional implementation of the T0ken contract:

```solidity
pragma solidity 0.5.2;

contract T0ken is ERC20, Ownable, LockableDestroyable {
    using AdditiveMath for uint256;
    using AddressMap for AddressMap.Data;

    address constant internal ZERO_ADDRESS = address(0);
    string public constant name = "TZERO PREFERRED";
    string public constant symbol = "TZROP";
    uint8 public constant decimals = 0;

    AddressMap.Data public shareholders;
    Compliance public compliance;
    address public issuer;
    bool public issuingFinished = false;
    mapping(address => address) public cancellations;

    mapping(address => uint256) internal balances;
    uint256 internal totalSupplyTokens;

    mapping (address => mapping (address => uint256)) private allowed;

    modifier onlyIssuer() {
        require(msg.sender == issuer, "Only issuer allowed");
        _;
    }

    modifier canIssue() {
        require(!issuingFinished, "Issuing is already finished");
        _;
    }

    modifier isNotCancelled(address addr) {
        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");
        _;
    }

    modifier hasFunds(address addr, uint256 tokens) {
        require(tokens <= balances[addr], "Insufficient funds");
        _;
    }

    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);
    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);
    event Issue(address indexed to, uint256 tokens);
    event IssueFinished();
    event ShareholderAdded(address shareholder);
    event ShareholderRemoved(address shareholder);

    function transfer(address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(msg.sender, tokens)
        returns (bool)
    {
        require(canTransfer(msg.sender, to, tokens, false), "Transfer not allowed");
        transferTokens(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(allowed[from][msg.sender] >= tokens, "Allowance exceeded");
        allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);
        require(canTransfer(from, to, tokens, false), "Transfer not allowed");
        transferTokens(from, to, tokens);
        return true;
    }

    function transferOverride(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        require(canTransfer(from, to, tokens, true), "Override not allowed");
        transferTokens(from, to, tokens);
        return true;
    }

    function issueTokens(uint256 quantity)
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        balances[issuer] = balances[issuer].add(quantity);
        totalSupplyTokens = totalSupplyTokens.add(quantity);

        bool added = shareholders.append(issuer);
        if (added) emit ShareholderAdded(issuer);
        
        emit Issue(issuer, quantity);
        emit Transfer(address(0), issuer, quantity);
        return true;
    }

    function finishIssuing()
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        issuingFinished = true;
        emit IssueFinished();
        return true;
    }

    function cancelAndReissue(address original, address replacement)
        external
        isUnlocked
        onlyIssuer
        isNotCancelled(replacement)
    {
        require(shareholders.exists(original), "Original not shareholder");
        require(cancellations[original] == ZERO_ADDRESS, "Already cancelled");

        uint256 balance = balances[original];
        cancellations[original] = replacement;

        balances[original] = 0;
        balances[replacement] = balances[replacement].add(balance);

        shareholders.remove(original);
        shareholders.append(replacement);

        emit VerifiedAddressSuperseded(original, replacement, msg.sender);
        emit Transfer(original, replacement, balance);
    }

    function approve(address spender, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(msg.sender)
        returns (bool)
    {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function setIssuer(address newIssuer)
        external
        isUnlocked
        onlyOwner
    {
        emit IssuerSet(issuer, newIssuer);
        issuer = newIssuer;
    }

    function setCompliance(address newComplianceAddress)
        external
        isUnlocked
        onlyOwner
    {
        compliance = Compliance(newComplianceAddress);
    }

    function totalSupply() external view returns (uint256) {
        return totalSupplyTokens;
    }

    function balanceOf(address addr) external view returns (uint256) {
        return balances[addr];
    }

    function allowance(address addrOwner, address spender) external view returns (uint256) {
        return allowed[addrOwner][spender];
    }

    function holderAt(int256 index) external view returns (address) {
        return shareholders.at(index);
    }

    function isHolder(address addr) external view returns (bool) {
        return shareholders.exists(addr);
    }

    function isSuperseded(address addr) external view returns (bool) {
        return cancellations[addr] != ZERO_ADDRESS;
    }

    function getSuperseded(address addr) external view returns (address) {
        address replacement = cancellations[addr];
        while (replacement != ZERO_ADDRESS && cancellations[replacement] != ZERO_ADDRESS) {
            replacement = cancellations[replacement];
        }
        return replacement;
    }

    function canTransfer(address from, address to, uint256 tokens, bool isOverride)
        private
        returns (bool)
    {
        if (address(compliance) != ZERO_ADDRESS) {
            bool allowed;
            if (isOverride) {
                allowed = compliance.canOverride(msg.sender, from, to, tokens);
            } else {
                allowed = compliance.canTransfer(msg.sender, from, to, tokens);
            }
            require(allowed, "Compliance check failed");
        }
        return true;
    }

    function transferTokens(address from, address to, uint256 tokens) private {
        balances[from] = balances[from].subtract(tokens);
        balances[to] = balances[to].add(tokens);

        bool added = shareholders.append(to);
        if (added) emit ShareholderAdded(to);

        if (balances[from] == 0) {
            bool removed = shareholders.remove(from);
            if (removed) emit ShareholderRemoved(from);
        }

        emit Transfer(from, to, tokens);
    }
}
```

This implementation:
1. Implements all ERC20 functions with proper compliance checks
2. Maintains shareholder list through balance changes
3. Handles token issuance and cancellation/reissuance
4. Integrates with the provided compliance interface
5. Uses safe math operations through AdditiveMath
6. Follows the 0.5.2 Solidity version requirements
7. Maintains proper access control through modifiers
8. Emits all required events for state changes
9. Handles contract locking and destruction functionality