To complete the `CrowdsaleToken` contract, we need to implement each function by interacting with the `TokenLib` library, which handles the token's storage and logic. Each function in the contract serves as a wrapper that either returns data from the token storage or delegates operations to the corresponding library function.

```solidity
contract CrowdsaleToken {
  using TokenLib for TokenLib.TokenStorage;
  TokenLib.TokenStorage public token;

  function CrowdsaleToken(address owner,
                          string memory name,
                          string memory symbol,
                          uint8 decimals,
                          uint256 initialSupply,
                          bool allowMinting) public {
    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);
  }

  function name() public view returns (string memory) {
    return token.name;
  }

  function symbol() public view returns (string memory) {
    return token.symbol;
  }

  function decimals() public view returns (uint8) {
    return token.decimals;
  }

  function totalSupply() public view returns (uint256) {
    return token.totalSupply;
  }

  function initialSupply() public view returns (uint256) {
    return token.initialSupply;
  }

  function balanceOf(address who) public view returns (uint256) {
    return token.balanceOf(who);
  }

  function allowance(address owner, address spender) public view returns (uint256) {
    return token.allowance(owner, spender);
  }

  function transfer(address to, uint256 value) public returns (bool ok) {
    return token.transfer(to, value);
  }

  function transferFrom(address from, address to, uint value) public returns (bool ok) {
    return token.transferFrom(from, to, value);
  }

  function approve(address spender, uint256 value) public returns (bool ok) {
    return token.approve(spender, value);
  }

  function approveChange(address spender, uint256 valueChange, bool increase) public returns (bool) {
    return token.approveChange(spender, valueChange, increase);
  }

  function changeOwner(address newOwner) public returns (bool ok) {
    return token.changeOwner(newOwner);
  }

  function burnToken(uint256 amount) public returns (bool ok) {
    return token.burnToken(amount);
  }
}
```

**Step-by-Step Explanation:**

1. **State Variable and Library Usage:**
   - The contract uses `TokenLib` for managing the token's storage and logic via `TokenLib.TokenStorage`.

2. **Constructor:**
   - Initializes the token using `token.init`, setting initial parameters like owner, name, symbol, etc.

3. **View Functions (name, symbol, decimals, totalSupply, initialSupply):**
   - Directly return the corresponding values from the `token` storage struct.

4. **balanceOf and allowance:**
   - Delegate to `token.balanceOf` and `token.allowance` library functions to retrieve balances and allowances.

5. **Transfer Functions (transfer, transferFrom):**
   - Call the respective `token.transfer` and `token.transferFrom` functions from the library to handle token transfers.

6. **Approval Functions (approve, approveChange):**
   - Use `token.approve` to set an allowance and `token.approveChange` to modify existing allowances.

7. **Owner Management and Burning Tokens:**
   - `changeOwner` updates the token's owner via `token.changeOwner`.
   - `burnToken` reduces the caller's balance and total supply through `token.burnToken`.

Each function ensures the CrowdsaleToken leverages the existing logic in `TokenLib`, providing a secure and efficient ERC20 token implementation suitable for crowdsales.