Here is the completed TellorC contract based on the provided context and requirements:

```solidity
pragma solidity 0.5.17;

contract TellorWrapper {
    function balanceOf(address _user) external view returns (uint256);
    function transfer(address _to, uint256 _amount) external returns (bool);
    function withdrawStake() external;
    function getUintVar(bytes32 _data) public view returns (uint256);
}

contract TellorC {
    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;
    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a;
    address private owner;
    address private miner;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function changeMiner(address _addr) external {
        require(msg.sender == owner, "Only owner");
        miner = _addr;
    }

    function withdrawTrb(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        require(TellorWrapper(tellor).transfer(owner, _amount), "Transfer failed");
    }

    function withdrawEth(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        require(address(this).balance >= _amount, "Insufficient ETH");
        address(uint160(owner)).transfer(_amount);
    }

    function depositStake() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("depositStake()"));
        require(success, "Deposit failed");
    }

    function requestStakingWithdraw() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("requestStakingWithdraw()"));
        require(success, "Request failed");
    }

    function withdrawStake() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
    }

    function finalize() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
        uint256 balance = TellorWrapper(tellor).balanceOf(address(this));
        if (balance > 0) {
            require(TellorWrapper(tellor).transfer(owner, balance), "Transfer failed");
        }
        selfdestruct(address(uint160(owner)));
    }

    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {
        require(msg.sender == miner || msg.sender == owner, "Unauthorized");
        (bool success, ) = tellor.call(abi.encodeWithSignature("submitMiningSolution(string,uint256[5],uint256[5])", _nonce, _requestId, _value));
        require(success, "Submit failed");
    }

    function() external {
        require(msg.sender == address(0), "Not allowed");
        address addr = tellor;
        bytes memory _calldata = msg.data;
        assembly {
            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
                case 0 { revert(ptr, size) }
                default { return(ptr, size) }
        }
    }
}
```

Key features:
1. Maintains strict ownership controls with require statements checking `msg.sender == owner`
2. Uses TellorWrapper interface for verified functions (transfer, balanceOf, withdrawStake)
3. Uses low-level calls for Tellor-specific functions not in the wrapper interface
4. Implements complete lifecycle management including staking, mining, and contract finalization
5. Maintains compatibility with Solidity 0.5.17 syntax and patterns
6. Includes fallback function for view calls to the Tellor contract
7. Properly handles ETH and TRB withdrawals with safety checks
8. Implements miner management with changeMiner function

The contract follows all specified requirements while maintaining security checks and proper error handling throughout.