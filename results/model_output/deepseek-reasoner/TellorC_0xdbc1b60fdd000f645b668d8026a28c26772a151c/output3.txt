Here is the complete implementation of the TellorC contract based on the provided context and requirements:

```solidity
pragma solidity 0.5.17;

contract TellorWrapper {
    function balanceOf(address _user) external view returns (uint256);
    function transfer(address _to, uint256 _amount) external returns (bool);
    function withdrawStake() external;
    function getUintVar(bytes32 _data) public view returns (uint256);
}

contract TellorC {
    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;
    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a;
    address private owner;
    address private miner;
    
    constructor() public {
        owner = msg.sender;
    }
    
    function changeMiner(address _addr) external {
        require(msg.sender == owner, "Only owner");
        miner = _addr;
    }

    function withdrawTrb(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        require(TellorWrapper(tellor).transfer(owner, _amount), "Transfer failed");
    }

    function withdrawEth(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        require(address(this).balance >= _amount, "Insufficient ETH");
        msg.sender.transfer(_amount);
    }

    function depositStake() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("depositStake()"));
        require(success, "Deposit failed");
    }

    function requestStakingWithdraw() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("requestStakingWithdraw()"));
        require(success, "Request failed");
    }

    function withdrawStake() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
    }

    function finalize() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
        uint256 trbBalance = TellorWrapper(tellor).balanceOf(address(this));
        if (trbBalance > 0) {
            require(TellorWrapper(tellor).transfer(owner, trbBalance), "Transfer failed");
        }
        selfdestruct(msg.sender);
    }

    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {
        require(msg.sender == miner || msg.sender == owner, "Not miner or owner");
        bytes memory data = abi.encodeWithSignature(
            "submitMiningSolution(string,uint256[5],uint256[5])",
            _nonce,
            _requestId,
            _value
        );
        (bool success, ) = tellor.call(data);
        require(success, "Submit failed");
    }

    function() external {
        require(msg.sender == address(0), "Not allowed");
        address addr = tellor;
        bytes memory _calldata = msg.data;
        assembly {
            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
                case 0 { revert(ptr, size) }
                default { return(ptr, size) }
        }
    }
}
```

Key implementation details:
1. **Access Control**: All administrative functions use `require(msg.sender == owner)` for authorization
2. **Tellor Interactions**: Uses both direct TellorWrapper calls and low-level calls for functions not in the wrapper interface
3. **Staking Management**: Implements full staking lifecycle from deposit to withdrawal
4. **Asset Withdrawals**: Handles both TRB and ETH withdrawals with balance checks
5. **Mining Solution Submission**: Uses low-level call to interact with Tellor's mining function
6. **Safe Contract Finalization**: Withdraws remaining assets before self-destructing

The implementation strictly follows the provided context while maintaining compatibility with Solidity 0.5.17 and the specified contract architecture.