Here's the completed TellorC contract:

```solidity
pragma solidity 0.5.17;

contract TellorWrapper {
    function balanceOf(address _user) external view returns (uint256);
    function transfer(address _to, uint256 _amount) external returns (bool);
    function withdrawStake() external;
    function getUintVar(bytes32 _data) public view returns (uint256);
}

contract TellorC {
    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;
    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a;
    address private owner;
    address private miner;
    
    constructor() public {
        owner = msg.sender;
    }
    
    function changeMiner(address _addr) external {
        require(msg.sender == owner, "Only owner");
        miner = _addr;
    }

    function withdrawTrb(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        bool success = TellorWrapper(tellor).transfer(owner, _amount);
        require(success, "Transfer failed");
    }

    function withdrawEth(uint256 _amount) external {
        require(msg.sender == owner, "Only owner");
        require(address(this).balance >= _amount, "Insufficient ETH");
        msg.sender.transfer(_amount);
    }

    function depositStake() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("depositStake()"));
        require(success, "Deposit failed");
    }

    function requestStakingWithdraw() external {
        require(msg.sender == owner, "Only owner");
        (bool success, ) = tellor.call(abi.encodeWithSignature("requestStakingWithdraw()"));
        require(success, "Request failed");
    }

    function withdrawStake() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
    }

    function finalize() external {
        require(msg.sender == owner, "Only owner");
        TellorWrapper(tellor).withdrawStake();
        uint256 trbBalance = TellorWrapper(tellor).balanceOf(address(this));
        if (trbBalance > 0) {
            bool success = TellorWrapper(tellor).transfer(owner, trbBalance);
            require(success, "TRB transfer failed");
        }
        selfdestruct(address(uint160(owner)));
    }

    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {
        require(msg.sender == miner || msg.sender == owner, "Unauthorized");
        (bool success, ) = tellor.call(abi.encodeWithSignature("submitMiningSolution(string,uint256[5],uint256[5])", _nonce, _requestId, _value));
        require(success, "Submit failed");
    }

    function() external {
        require(msg.sender == address(0), "Not allowed");
        address addr = tellor;
        bytes memory _calldata = msg.data;
        assembly {
            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
                case 0 { revert(ptr, size) }
                default { return(ptr, size) }
        }
    }
}
```

This implementation:
1. Enforces ownership checks for sensitive functions
2. Uses low-level calls for Tellor contract interactions where needed
3. Implements proper error handling with require statements
4. Follows the 0.5.17 Solidity version requirements
5. Maintains the fallback function for view operations
6. Properly handles TRB and ETH withdrawals
7. Implements selfdestruct with proper address conversion in finalize()
8. Maintains the original contract structure while adding required functionality