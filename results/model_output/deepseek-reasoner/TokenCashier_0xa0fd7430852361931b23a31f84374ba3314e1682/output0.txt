```solidity
pragma solidity 0.5.12;

contract TokenCashier is Pausable {
    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);

    ITokenList[] public tokenLists;
    address[] public tokenSafes;
    mapping(address => uint256) public counts;
    uint256 public depositFee;
    IWrappedCoin public wrappedCoin;

    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {
        require(_tokenLists.length == _tokenSafes.length, "# of token lists is not equal to # of safes");
        wrappedCoin = _wrappedCoin;
        tokenLists = _tokenLists;
        tokenSafes = _tokenSafes;
    }

    function() external {
        revert();
    }

    function count(address _token) public view returns (uint256) {
        return counts[_token];
    }

    function setDepositFee(uint256 _fee) public onlyOwner {
        depositFee = _fee;
    }

    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {
        require(_to != address(0), "invalid recipient");
        
        bool allowed = false;
        for (uint i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                allowed = true;
                break;
            }
        }
        require(allowed, "token not allowed");
        
        uint256 maxMin = 0;
        uint256 minMax = type(uint256).max;
        for (uint i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                uint256 currentMin = tokenLists[i].minAmount(_token);
                uint256 currentMax = tokenLists[i].maxAmount(_token);
                if (currentMin > maxMin) maxMin = currentMin;
                if (currentMax < minMax) minMax = currentMax;
            }
        }
        require(_amount >= maxMin, "amount below min");
        require(_amount <= minMax, "amount exceeds max");
        
        if (_token == address(0)) {
            require(msg.value == _amount + depositFee, "ETH value mismatch");
            wrappedCoin.deposit.value(_amount)();
            
            address safe = address(0);
            for (uint i = 0; i < tokenLists.length; i++) {
                if (tokenLists[i].isAllowed(_token)) {
                    safe = tokenSafes[i];
                    break;
                }
            }
            
            if (safe != address(0)) {
                require(safeTransfer(address(wrappedCoin), safe, _amount), "WETH transfer failed");
            } else {
                (bool success, ) = address(wrappedCoin).call(abi.encodeWithSelector(0x42966c68, _amount));
                require(success, "WETH burn failed");
            }
        } else {
            require(msg.value == depositFee, "exact fee required");
            require(safeTransferFrom(_token, msg.sender, address(this), _amount), "transferFrom failed");
            
            address safe = address(0);
            for (uint i = 0; i < tokenLists.length; i++) {
                if (tokenLists[i].isAllowed(_token)) {
                    safe = tokenSafes[i];
                    break;
                }
            }
            
            if (safe != address(0)) {
                require(safeTransfer(_token, safe, _amount), "transfer to safe failed");
            } else {
                (bool success, ) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));
                require(success, "token burn failed");
            }
        }
        
        counts[_token] += 1;
        emit Receipt(_token, counts[_token], msg.sender, _to, _amount, depositFee);
    }

    function deposit(address _token, uint256 _amount) public payable {
        depositTo(_token, msg.sender, _amount);
    }

    function withdraw() external onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function withdrawToken(address _token) public onlyOwner {
        (bool successBalance, bytes memory dataBalance) = _token.call(abi.encodeWithSelector(0x70a08231, address(this)));
        require(successBalance, "balanceOf failed");
        uint256 balance = abi.decode(dataBalance, (uint256));
        require(balance > 0, "no balance");
        require(safeTransfer(_token, owner, balance), "transfer failed");
    }

    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));
        if (!success) return false;
        return (data.length == 0 || abi.decode(data, (bool)));
    }

    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));
        if (!success) return false;
        return (data.length == 0 || abi.decode(data, (bool)));
    }
}
```