Here's the completed TokenReclaim contract following all requirements and specifications:

```solidity
pragma solidity 0.4.23;

contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (bytes32 => string) internal _accountToPubKey;

    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    function register(string memory name, string memory pubKey) public {
        bytes memory nameBytes = bytes(name);
        bytes memory pubKeyBytes = bytes(pubKey);
        
        // Validate name length
        require(nameBytes.length >= 3 && nameBytes.length <= 16, "Invalid name length");
        
        // Validate name format
        require(_isValidName(nameBytes), "Invalid name format");
        
        // Validate public key length
        require(pubKeyBytes.length >= 50 && pubKeyBytes.length <= 64, "Invalid pubKey length");
        
        // Check address registration
        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address already registered");
        
        // Check name availability
        bytes32 nameHash = keccak256(abi.encodePacked(name));
        require(bytes(_accountToPubKey[nameHash]).length == 0, "Name already taken");

        // Store mappings
        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[nameHash] = pubKey;

        emit AccountRegister(msg.sender, name, pubKey);
    }

    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    function keys(address addr) public view returns (string memory) {
        string memory sphtxName = _ethToSphtx[addr];
        if (bytes(sphtxName).length == 0) {
            return "";
        }
        bytes32 nameHash = keccak256(abi.encodePacked(sphtxName));
        return _accountToPubKey[nameHash];
    }

    function nameAvailable(string memory name) public view returns (bool) {
        bytes memory nameBytes = bytes(name);
        if (nameBytes.length < 3 || nameBytes.length > 16) {
            return false;
        }
        if (!_isValidName(nameBytes)) {
            return false;
        }
        bytes32 nameHash = keccak256(abi.encodePacked(name));
        return bytes(_accountToPubKey[nameHash]).length == 0;
    }

    function _isValidName(bytes memory nameBytes) private pure returns (bool) {
        // Check first character
        if (!(nameBytes[0] >= 0x30 && nameBytes[0] <= 0x39) && // 0-9
            !(nameBytes[0] >= 0x61 && nameBytes[0] <= 0x7a)) { // a-z
            return false;
        }

        // Check remaining characters
        for (uint i = 1; i < nameBytes.length; i++) {
            byte c = nameBytes[i];
            if (!(c >= 0x30 && c <= 0x39) && // 0-9
                !(c >= 0x61 && c <= 0x7a) && // a-z
                c != 0x2d && // -
                c != 0x2e) { // .
                return false;
            }
        }
        return true;
    }
}
```

Key features of the implementation:
1. Uses bytes32 mapping keys with keccak256 hashes for secure storage
2. Implements all specified validation checks for names and public keys
3. Maintains strict one-time registration per address
4. Uses helper function `_isValidName` for code reuse
5. Follows Solidity 0.4.23 syntax requirements
6. Includes all specified view functions for data retrieval
7. Properly handles empty string returns for unregistered addresses
8. Implements gas-efficient character validation using byte comparisons

The contract enforces all specified requirements while maintaining compatibility with the older Solidity version through careful use of fundamental operations and storage optimizations.