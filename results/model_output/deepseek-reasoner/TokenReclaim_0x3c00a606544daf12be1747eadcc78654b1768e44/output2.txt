pragma solidity 0.4.23;
pragma experimental ABIEncoderV2;

contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    function register(string memory name, string memory pubKey) public {
        require(validateName(name), "Invalid name format");
        require(bytes(pubKey).length >= 50 && bytes(pubKey).length <= 64, "Invalid pubkey length");
        require(keccak256(_ethToSphtx[msg.sender]) == keccak256(""), "Address already registered");
        require(keccak256(_accountToPubKey[name]) == keccak256(""), "Name already taken");

        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;
        emit AccountRegister(msg.sender, name, pubKey);
    }

    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    function keys(address addr) public view returns (string memory) {
        return _accountToPubKey[_ethToSphtx[addr]];
    }

    function nameAvailable(string memory name) public view returns (bool) {
        if (!validateName(name)) return false;
        return keccak256(_accountToPubKey[name]) == keccak256("");
    }

    function validateName(string memory name) internal pure returns (bool) {
        bytes memory b = bytes(name);
        if (b.length < 3 || b.length > 16) return false;
        if (!(b[0] >= 0x30 && b[0] <= 0x39) && !(b[0] >= 0x61 && b[0] <= 0x7A)) return false;
        
        for (uint i = 1; i < b.length; i++) {
            bytes1 char = b[i];
            if (!(char >= 0x30 && char <= 0x39) && 
                !(char >= 0x61 && char <= 0x7A) && 
                char != 0x2D && 
                char != 0x2E) {
                return false;
            }
        }
        return true;
    }
}