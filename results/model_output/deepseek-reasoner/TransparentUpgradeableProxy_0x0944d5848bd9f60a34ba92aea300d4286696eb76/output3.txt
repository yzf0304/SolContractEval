Here is the complete and functional `TransparentUpgradeableProxy` contract based on the provided context and requirements:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.6.12;

/**
 * @notice A TransparentUpgradeableProxy contract that allows for upgrading the implementation of a proxy, with an admin
 *         to manage the upgrades and admin changes.
 * @dev This contract extends UpgradeableProxy and adds functionality to change the admin and upgrade the implementation.
 */
contract TransparentUpgradeableProxy is UpgradeableProxy {
    /**
     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.
     */
    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        _setAdmin(_admin);
    }

    /**
     * @dev Emitted when the admin account has changed.
     */
    event AdminChanged(address previousAdmin, address newAdmin);

    /**
     * @dev Storage slot with the admin of the contract.
     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.
     */
    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @notice Returns the current admin.
     */
    function admin() external ifAdmin returns (address) {
        return _admin();
    }

    /**
     * @notice Returns the current implementation.
     */
    function implementation() external ifAdmin returns (address) {
        return _implementation();
    }

    /**
     * @notice Changes the admin of the proxy.
     * @dev Emits an {AdminChanged} event. Only the admin can call this function.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    /**
     * @notice Upgrades the implementation of the proxy.
     * @dev Only the admin can call this function.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @notice Upgrades the implementation of the proxy, and then calls a function from the new implementation.
     * @dev Only the admin can call this function.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {
        _upgradeTo(newImplementation);
        (bool success,) = newImplementation.delegatecall{value: msg.value}(data);
        require(success, "TransparentUpgradeableProxy: call failed");
    }

    /**
     * @dev Returns the current admin.
     */
    function _admin() internal view returns (address adm) {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Stores a new address in the EIP1967 admin slot.
     */
    function _setAdmin(address newAdmin) private {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Prevents the admin from accessing the fallback function.
     */
    function _beforeFallback() internal override virtual {
        require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");
        super._beforeFallback();
    }

    /**
     * @dev Fallback function that delegates calls to the current implementation.
     */
    receive() external payable {
        _fallback();
    }
}
```

This implementation:
1. Maintains the transparent proxy pattern by restricting admin access to proxy functions only
2. Implements all required admin functionality (changeAdmin, upgradeTo, etc.)
3. Properly handles ETH forwarding in upgradeToAndCall
4. Prevents admins from accidentally calling through to the implementation
5. Uses the correct storage slots for both implementation and admin addresses
6. Maintains compatibility with Solidity 0.6.12 as specified

The contract follows best practices for upgradeable proxies while strictly adhering to the provided context and requirements.