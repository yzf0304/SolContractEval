Here is the complete implementation of the TransparentUpgradeableProxy contract:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.6.12;

contract TransparentUpgradeableProxy is UpgradeableProxy {
    constructor(address _logic, address _admin, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1);
        _setAdmin(_admin);
    }

    event AdminChanged(address previousAdmin, address newAdmin);

    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    function admin() external ifAdmin returns (address) {
        return _admin();
    }

    function implementation() external ifAdmin returns (address) {
        return _implementation();
    }

    function changeAdmin(address newAdmin) external ifAdmin {
        require(newAdmin != address(0), "TransparentUpgradeableProxy: new admin is the zero address");
        emit AdminChanged(_admin(), newAdmin);
        _setAdmin(newAdmin);
    }

    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {
        _upgradeTo(newImplementation);
        if (data.length > 0) {
            (bool success, ) = newImplementation.delegatecall(data);
            require(success, "TransparentUpgradeableProxy: call failed");
        }
    }

    function _admin() internal view returns (address adm) {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    function _setAdmin(address newAdmin) private {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            sstore(slot, newAdmin)
        }
    }

    function _beforeFallback() internal override virtual {
        require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");
        super._beforeFallback();
    }
}
```

This implementation:

1. Properly implements admin management with secure slot storage
2. Enforces transparent proxy behavior where admin calls only execute proxy functions
3. Maintains upgrade functionality from UpgradeableProxy
4. Includes proper access control modifiers
5. Implements secure initialization and upgrade patterns
6. Follows EIP-1967 standard for proxy storage slots
7. Includes necessary security checks for admin operations
8. Maintains compatibility with the specified compiler version 0.6.12

The contract ensures that:
- Only admins can perform administrative functions
- Implementation upgrades are properly handled
- Admin addresses are validated and stored securely
- Fallback behavior properly separates admin and user functionality
- Upgrade initialization can include data payloads for contract initialization