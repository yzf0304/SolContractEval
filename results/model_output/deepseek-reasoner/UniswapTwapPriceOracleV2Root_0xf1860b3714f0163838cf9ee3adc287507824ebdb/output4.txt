To solve this problem, we need to implement an upgradeable ERC20 token contract using the OpenZeppelin libraries for SafeMath, Address, and Initializable. The contract should follow the ERC20 standard, including functions for transferring tokens, approving allowances, and managing token supply through minting and burning. The contract should be designed to work with a proxy pattern for upgradeability.

### Approach
1. **Initialization**: The contract uses the Initializable pattern to support upgradeability. The constructor logic is moved to an initializer function that can be called once when the contract is deployed via a proxy.
2. **Safe Arithmetic**: Utilize the SafeMath library to handle arithmetic operations safely, preventing overflow and underflow issues.
3. **ERC20 Standard Functions**: Implement the standard ERC20 functions including `transfer`, `transferFrom`, `approve`, `allowance`, `totalSupply`, and `balanceOf`.
4. **Minting and Burning**: Internal functions to mint new tokens (increasing supply) and burn existing tokens (decreasing supply).
5. **Allowance Management**: Functions to increase and decrease allowances atomically.
6. **Upgradeability Hooks**: Include hooks like `_beforeTokenTransfer` to allow customization in derived contracts.

### Solution Code
```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0 <0.8.0;

contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {
    using SafeMathUpgradeable for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {
        __Context_init_unchained();
        __ERC20_init_unchained(name_, symbol_);
    }

    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {
        _name = name_;
        _symbol = symbol_;
        _decimals = 18;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function decimals() public view virtual override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _beforeTokenTransfer(sender, recipient, amount);

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to the zero address");

        _beforeTokenTransfer(address(0), account, amount);

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        _beforeTokenTransfer(account, address(0), amount);

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _setupDecimals(uint8 decimals_) internal virtual {
        _decimals = decimals_;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }

    uint256[44] private __gap;
}
```

### Explanation
1. **Initialization**: The `__ERC20_init` and `__ERC20_init_unchained` functions initialize the token name, symbol, and decimals (default 18).
2. **View Functions**: `name`, `symbol`, `decimals`, `totalSupply`, and `balanceOf` provide basic token information.
3. **Transfer Functions**: `transfer` and `transferFrom` handle token transfers, using `_transfer` to adjust balances and emit events.
4. **Allowance Management**: `approve`, `increaseAllowance`, and `decreaseAllowance` manage spending permissions using SafeMath for safe arithmetic operations.
5. **Internal Functions**: `_mint` and `_burn` adjust the total supply and balances, emitting transfer events. `_approve` sets allowances and emits approval events.
6. **Hooks**: `_beforeTokenTransfer` is a placeholder for logic that can be added in derived contracts, such as hooks before any token transfer.

This implementation ensures compliance with the ERC20 standard while incorporating upgradeability and safe arithmetic practices.