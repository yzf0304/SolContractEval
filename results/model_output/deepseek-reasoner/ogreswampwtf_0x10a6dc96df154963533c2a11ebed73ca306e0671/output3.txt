```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;

contract ogreswampwtf is ERC721, Ownable {
  using Counters for Counters.Counter; 
  using Strings for uint256;

  Counters.Counter private _tokenSupply;
  string public ogreURI;
  string public ogreExtension = ".json"; 
  uint256 public cost = 0 ether; 
  uint256 public maxSupply = 3333; 
  uint256 public freeMints = 3333; 
  uint256 public maxMintAmount = 3; 
  bool public paused = false;
  bool public revealed = false;
  string public SwampUri;
  mapping(address => bool) public whitelisted;
  mapping(address => uint256) private freeMintsWallet;

  constructor(
    string memory _name,
    string memory _symbol,
    string memory _initOgreURI,
    string memory _initSwampUri
  ) ERC721(_name, _symbol) {
    setOgreURI(_initOgreURI);
    setSwampURI(_initSwampUri);
  }

  function totalSupply() public view returns (uint256) {
    return _tokenSupply.current();
  }

  function _ogreURI() internal view override returns (string memory) {
    return ogreURI;
  }

  function mint(address _to, uint256 _mintAmount) public payable {
    require(!paused, "Contract is paused");
    require(_mintAmount > 0, "Mint amount must be positive");
    require(_mintAmount <= maxMintAmount, "Exceeds max mint amount");
    require(_tokenSupply.current() + _mintAmount <= maxSupply, "Exceeds max supply");

    if (_tokenSupply.current() + _mintAmount <= freeMints) {
      require(whitelisted[msg.sender], "Not whitelisted");
      require(msg.value == 0, "Free mint requires no payment");
    } else {
      require(msg.value >= cost * _mintAmount, "Insufficient funds");
      require(freeMintsWallet[msg.sender] + _mintAmount <= 20, "Exceeds wallet limit");
      freeMintsWallet[msg.sender] += _mintAmount;
    }

    for (uint256 i = 0; i < _mintAmount; i++) {
      _tokenSupply.increment();
      uint256 tokenId = _tokenSupply.current();
      _safeMint(_to, tokenId);
    }
  }

  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
    
    if (!revealed) {
      return SwampUri;
    }

    string memory base = _ogreURI();
    return bytes(base).length > 0 ? string(abi.encodePacked(base, tokenId.toString(), ogreExtension)) : "";
  }

  function reveal() public onlyOwner {
    revealed = true;
  }

  function setCost(uint256 _newCost) public onlyOwner {
    cost = _newCost;
  }

  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {
    maxMintAmount = _newmaxMintAmount;
  }

  function setSwampURI(string memory _SwampURI) public onlyOwner {
    SwampUri = _SwampURI;
  }

  function setOgreURI(string memory _newOgreURI) public onlyOwner {
    ogreURI = _newOgreURI;
  }

  function setOgreExtension(string memory _newOgreExtension) public onlyOwner {
    ogreExtension = _newOgreExtension;
  }

  function pause(bool _state) public onlyOwner {
    paused = _state;
  }

  function whitelistUser(address _user) public onlyOwner {
    whitelisted[_user] = true;
  }

  function removeWhitelistUser(address _user) public onlyOwner {
    whitelisted[_user] = false;
  }

  function withdraw() public payable onlyOwner {
    (bool success, ) = payable(owner()).call{value: address(this).balance}("");
    require(success);
  }
}
```