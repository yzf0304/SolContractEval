Here's the complete implementation of the `ogreswampwtf` contract based on the provided context and specifications:

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.7;

contract ogreswampwtf is ERC721, Ownable {
    using Counters for Counters.Counter;
    using Strings for uint256;

    Counters.Counter private _tokenSupply;
    string public ogreURI;
    string public ogreExtension = ".json";
    uint256 public cost = 0 ether;
    uint256 public maxSupply = 3333;
    uint256 public freeMints = 3333;
    uint256 public maxMintAmount = 3;
    bool public paused = false;
    bool public revealed = false;
    string public SwampUri;
    mapping(address => bool) public whitelisted;
    mapping(address => uint256) private freeMintsWallet;

    constructor(
        string memory _name,
        string memory _symbol,
        string memory _initOgreURI,
        string memory _initSwampUri
    ) ERC721(_name, _symbol) {
        setOgreURI(_initOgreURI);
        setSwampURI(_initSwampUri);
    }

    function totalSupply() public view returns (uint256) {
        return _tokenSupply.current();
    }

    function _ogreURI() internal view virtual override returns (string memory) {
        return ogreURI;
    }

    function mint(address _to, uint256 _mintAmount) public payable {
        require(!paused, "Contract is paused");
        require(_mintAmount > 0 && _mintAmount <= maxMintAmount, "Invalid mint amount");
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");

        if (totalSupply() + _mintAmount <= freeMints) {
            require(whitelisted[msg.sender], "Not whitelisted");
            require(freeMintsWallet[msg.sender] + _mintAmount <= 20, "Exceeds free limit");
            require(msg.value >= cost * _mintAmount, "Insufficient funds");
            freeMintsWallet[msg.sender] += _mintAmount;
        } else {
            require(msg.value >= cost * _mintAmount, "Insufficient funds");
        }

        for (uint256 i = 0; i < _mintAmount; i++) {
            _tokenSupply.increment();
            uint256 tokenId = _tokenSupply.current();
            _safeMint(_to, tokenId);
        }
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        
        if (!revealed) {
            return SwampUri;
        } else {
            string memory base = _ogreURI();
            return bytes(base).length > 0 
                ? string(abi.encodePacked(base, tokenId.toString(), ogreExtension))
                : "";
        }
    }

    function reveal() public onlyOwner {
        revealed = true;
    }

    function setCost(uint256 _newCost) public onlyOwner {
        cost = _newCost;
    }

    function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {
        maxMintAmount = _newmaxMintAmount;
    }

    function setSwampURI(string memory _SwampURI) public onlyOwner {
        SwampUri = _SwampURI;
    }

    function setOgreURI(string memory _newOgreURI) public onlyOwner {
        ogreURI = _newOgreURI;
    }

    function setOgreExtension(string memory _newOgreExtension) public onlyOwner {
        ogreExtension = _newOgreExtension;
    }

    function pause(bool _state) public onlyOwner {
        paused = _state;
    }

    function whitelistUser(address _user) public onlyOwner {
        whitelisted[_user] = true;
    }

    function removeWhitelistUser(address _user) public onlyOwner {
        whitelisted[_user] = false;
    }

    function withdraw() public payable onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }
}
```

This implementation includes:

1. NFT minting with free and paid phases
2. Whitelist functionality for free mints
3. Reveal mechanism for metadata
4. Administrative functions for managing costs, mint amounts, and URIs
5. Withdrawal functionality for contract funds
6. Compliance with ERC721 standard and OpenZeppelin components
7. Safety checks for minting parameters and payments
8. Per-wallet limits for free mints

The contract maintains all specified requirements while using the provided OpenZeppelin components and following Solidity best practices for version 0.8.7.