Here is the complete implementation of the xApe721 contract:

```solidity
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

/// @title xApe721 - Modern ERC721 Token Contract with Minting and Claiming
contract xApe721 is Ownable, ERC721 {
    using Strings for uint256;

    error NotOwner();
    error ExceedsTotalSupply();
    error InvalidRecipient();
    error IncorrectPayment();
    error MintInactive();

    uint256 public constant TOTAL_SUPPLY = 10_000;
    uint256 public constant PRICE_PER_MINT = 0.05 ether;
    uint256 public constant MAX_MINT_PER_TX = 20;
    
    bool public mintActive;
    uint256 public totalSupply;
    uint256 internal nextMintableId = 10038;
    string public baseURI;
    IERC721 public oldContract;
    address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;

    constructor(
        string memory name,
        string memory symbol,
        string memory _baseURI,
        address _oldContract,
        address[] memory recipients,
        uint256[] memory tokens
    ) ERC721(name, symbol) {
        require(recipients.length == tokens.length, "Mismatched arrays");
        baseURI = _baseURI;
        oldContract = IERC721(_oldContract);

        for (uint256 i = 0; i < tokens.length; ) {
            _mint(recipients[i], tokens[i]);
            totalSupply++;
            unchecked { ++i; }
        }
    }

    modifier onlyTeamWallet() {
        require(msg.sender == teamWallet, "Unauthorized");
        _;
    }

    function mint(uint16 amount) external payable {
        if (!mintActive) revert MintInactive();
        if (amount == 0 || amount > MAX_MINT_PER_TX) revert InvalidRecipient();
        if (msg.value != PRICE_PER_MINT * amount) revert IncorrectPayment();
        if (totalSupply + amount > TOTAL_SUPPLY) revert ExceedsTotalSupply();

        for (uint16 i = 0; i < amount; ) {
            uint256 tokenId = _getNextUnusedID();
            _mint(msg.sender, tokenId);
            totalSupply++;
            unchecked { ++i; }
        }
    }

    function claim(uint256 tokenId) external {
        if (oldContract.ownerOf(tokenId) != msg.sender) revert NotOwner();
        if (totalSupply + 1 > TOTAL_SUPPLY) revert ExceedsTotalSupply();
        _mint(msg.sender, tokenId);
        totalSupply++;
    }

    function claimAll() external {
        uint256[] memory tokens = oldContract.getPhunksBelongingToOwner(msg.sender);
        uint256 length = tokens.length;
        
        for (uint256 i = 0; i < length; ) {
            uint256 tokenId = tokens[i];
            if (totalSupply >= TOTAL_SUPPLY) break;
            
            if (oldContract.ownerOf(tokenId) == msg.sender && ownerOf[tokenId] == address(0)) {
                _mint(msg.sender, tokenId);
                totalSupply++;
            }
            unchecked { ++i; }
        }
    }

    function _getNextUnusedID() internal returns (uint256) {
        while (true) {
            if (ownerOf[nextMintableId] == address(0)) {
                (bool success, bytes memory data) = address(oldContract).staticcall(
                    abi.encodeWithSelector(IERC721.ownerOf.selector, nextMintableId)
                );

                if (!success || (success && abi.decode(data, (address)) == address(0))) {
                    return nextMintableId++;
                }
            }
            nextMintableId++;
        }
    }

    function tokenURI(uint256 id) public view override returns (string memory) {
        if (ownerOf[id] == address(0)) revert InvalidRecipient();
        return string(abi.encodePacked(baseURI, id.toString()));
    }

    function withdraw() external onlyTeamWallet {
        SafeTransferLib.safeTransferETH(teamWallet, address(this).balance);
    }

    function pauseMint() external {
        if (msg.sender != _owner) revert NotOwner();
        mintActive = false;
    }

    function startMint() external {
        if (msg.sender != _owner) revert NotOwner();
        mintActive = true;
    }

    function setBaseURI(string memory _baseURI) external {
        if (msg.sender != _owner) revert NotOwner();
        baseURI = _baseURI;
    }

    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes calldata
    ) external pure returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}
```

This implementation:
1. Inherits from Solmate's optimized ERC721 implementation
2. Implements all required functionality including minting, claiming, and metadata handling
3. Includes proper access control and ownership management
4. Handles token ID allocation with efficient unused ID discovery
5. Implements ERC721Receiver interface
6. Includes comprehensive error handling and gas optimizations
7. Maintains strict adherence to the ERC721 standard while adding project-specific features