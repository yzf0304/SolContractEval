interface IERC20Permit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external payable;
}

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );
    event Exchange(address pair, uint256 amountOut, address output);

    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, "Router: EXPIRED");
        _;
    }

    constructor(address _WETH) public {
        WETH = _WETH;
    }

    receive() external payable {}

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "Router: MIN_RETURN_AMOUNT_TOO_LOW");
        require(data.length > 0, "Router: INVALID_CALL_DATA");

        uint256 value = msg.value;
        uint256 amount = desc.amount;
        IERC20 srcToken = desc.srcToken;
        address srcReceiver = desc.srcReceiver == address(0) ? _msgSender() : desc.srcReceiver;

        if (desc.permit.length > 0) {
            _permit(srcToken, amount, desc.permit);
        } else if (!isETH(srcToken) && (desc.flags & _BURN_FROM_MSG_SENDER == 0) && (desc.flags & _BURN_FROM_TX_ORIGIN == 0)) {
            TransferHelper.safeTransferFrom(srcToken, srcReceiver, address(this), amount);
        } else if (isETH(srcToken) && (desc.flags & _REQUIRES_EXTRA_ETH != 0)) {
            require(value >= amount, "Router: INSUFFICIENT_ETH");
        }

        (bool success, bytes memory result) = address(caller).call{value: value}(data);
        if (!success) {
            revert(RevertReasonParser.parse(result, "Aggregation call failed: "));
        }

        returnAmount = getBalance(desc.dstToken, desc.dstReceiver == address(0) ? _msgSender() : desc.dstReceiver).sub(getBalance(desc.dstToken, address(this)));

        if (returnAmount < desc.minReturnAmount && (desc.flags & _PARTIAL_FILL == 0)) {
            revert("Router: INSUFFICIENT_OUTPUT_AMOUNT");
        }

        uint256 spentAmount;
        if (isETH(srcToken)) {
            spentAmount = amount;
            if (value > amount) {
                TransferHelper.safeTransferETH(srcReceiver, value.sub(amount));
            }
        } else {
            spentAmount = desc.amount;
            uint256 balance = IERC20(srcToken).balanceOf(address(this));
            if (balance > 0) {
                TransferHelper.safeTransfer(srcToken, srcReceiver, balance);
            }
        }

        TransferHelper.safeTransfer(desc.dstToken, desc.dstReceiver == address(0) ? _msgSender() : desc.dstReceiver, returnAmount);

        emit Swapped(_msgSender(), srcToken, desc.dstToken, desc.dstReceiver == address(0) ? _msgSender() : desc.dstReceiver, spentAmount, returnAmount);

        // Handle remaining ETH if any (should not happen in normal execution)
        if (address(this).balance > 0) {
            TransferHelper.safeTransferETH(_msgSender(), address(this).balance);
        }

        return returnAmount;
    }

    function getBalance(IERC20 token, address account)
        internal
        view
        returns (uint256)
    {
        if (isETH(token)) {
            return account.balance;
        } else if (address(token) == WETH) {
            return IERC20(WETH).balanceOf(account);
        } else {
            return token.balanceOf(account);
        }
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == ETH_ADDRESS) {
            TransferHelper.safeTransferETH(owner(), amount);
        } else {
            IERC20(token).transfer(owner(), amount);
        }
    }
}