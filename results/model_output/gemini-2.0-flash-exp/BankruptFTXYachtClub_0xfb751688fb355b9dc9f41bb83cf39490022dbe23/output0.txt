```solidity
pragma solidity ^0.8.7;

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension. Built to optimize for lower gas during batch mints.
 *
 * Assumes serials are sequentially minted starting at _startTokenId() (defaults to 0, e.g. 0, 1, 2, 3..).
 *
 * Assumes that an owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
 *
 * Assumes that the maximum token id cannot exceed 2**256 - 1 (max value of uint256).
 */

contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;

    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    mapping (address => uint8) public NFTPerPublicAddress;

    /**
     * @notice Constructor to initialize the NFT contract with name and symbol.
     * @dev Sets the name and symbol for the NFT collection.
     */
    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    /**
     * @notice Allows users to mint NFTs by paying the specified cost.
     * @dev Checks if the contract is not paused, does not exceed max supply, and handles free mints per wallet.
     * @param _mintAmount The number of NFTs to mint.
     */
    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Contract is paused");
        require(_totalMinted() + _mintAmount <= maxSupply, "Exceeds max supply");
        require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, "Invalid mint amount");

        if (NFTPerPublicAddress[msg.sender] < maxFreeMintAmountPerWallet) {
            require(msg.value >= (cost * (_mintAmount - NFTPerPublicAddress[msg.sender])), "Insufficient funds");
            _safeMint(msg.sender, _mintAmount);
            NFTPerPublicAddress[msg.sender] = maxFreeMintAmountPerWallet;
        } else {
            require(msg.value >= (cost * _mintAmount), "Insufficient funds");
            _safeMint(msg.sender, _mintAmount);
        }
    }

    /**
     * @notice Allows the owner to reserve a certain amount of NFTs for a specific address.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _mintAmount The number of NFTs to reserve.
     * @param _receiver The address to receive the reserved NFTs.
     */
    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(_totalMinted() + _mintAmount <= maxSupply, "Exceeds max supply");
        _safeMint(_receiver, _mintAmount);
    }

    /**
     * @notice Allows the owner to airdrop a certain amount of NFTs to multiple addresses.
     * @dev Ensures that the total supply does not exceed the max supply.
     * @param _amountPerAddress The number of NFTs to airdrop to each address.
     * @param addresses The list of addresses to airdrop the NFTs to.
     */
    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        uint256 totalMintAmount = uint256(addresses.length) * _amountPerAddress;
        require(_totalMinted() + totalMintAmount <= maxSupply, "Exceeds max supply");
        for (uint256 i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    /**
     * @notice Sets the maximum supply of NFTs.
     * @dev Only the owner can call this function.
     * @param _maxSupply The new maximum supply.
     */
    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        maxSupply = _maxSupply;
    }

    /**
     * @notice Returns the token URI for a given token ID.
     * @dev If the reveal is not set, returns the hidden URL; otherwise, constructs the token URI.
     * @param _tokenId The ID of the token.
     * @return The token URI.
     */
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");

        if (!reveal) {
            return hiddenURL;
        }

        string memory strId = Strings.toString(_tokenId);
        string memory base = _baseURI();

        return string(abi.encodePacked(base, strId, uriSuffix));
    }

    /**
     * @notice Sets the maximum number of free mints per wallet.
     * @dev Only the owner can call this function.
     * @param _limit The new limit for free mints per wallet.
     */
    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    /**
     * @notice Sets the URI prefix for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new URI prefix.
     */
    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    /**
     * @notice Sets the hidden URI for the NFTs.
     * @dev Only the owner can call this function.
     * @param _uriPrefix The new hidden URI.
     */
    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        hiddenURL = _uriPrefix;
    }

    /**
     * @notice Toggles the paused state of the contract.
     * @dev Only the owner can call this function.
     */
    function setPaused() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Sets the cost for minting NFTs.
     * @dev Only the owner can call this function.
     * @param _cost The new cost for minting.
     */
    function setCost(uint _cost) external onlyOwner {
        cost = _cost;
    }

    /**
     * @notice Toggles the revealed state of the NFTs.
     * @dev Only the owner can call this function.
     */
    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.
     * @dev Only the owner can call this function.
     * @param _maxtx The new maximum mint amount per transaction.
     */
    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    /**
     * @notice Allows the owner to withdraw the contract's balance.
     * @dev Only the owner can call this function.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Withdrawal failed");
    }

    /**
     * @notice Returns the base URI for the NFTs.
     * @dev This is used to construct the full token URI.
     * @return The base URI.
     */
    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    /**
     * @notice Fallback function to accept ETH.
     * @dev This function is called when the contract receives ETH without any data.
     */
    receive() external payable {}
}
```