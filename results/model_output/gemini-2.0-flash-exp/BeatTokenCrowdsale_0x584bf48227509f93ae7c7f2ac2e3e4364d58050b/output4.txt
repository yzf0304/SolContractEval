```solidity
pragma solidity ^0.4.18;

/**

 *Submitted for verification at Etherscan.io on 2018-01-23

*/

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {

    if (a == 0) {

      return 0;

    }

    uint256 c = a * b;

    assert(c / a == b);

    return c;

  }



  function div(uint256 a, uint256 b) internal pure returns (uint256) {

    // assert(b > 0); // Solidity automatically throws when dividing by 0

    uint256 c = a / b;

    // assert(a == b * c + a % b); // There is no case in which this doesn't hold

    return c;

  }



  function sub(uint256 a, uint256 b) internal pure returns (uint256) {

    assert(b <= a);

    return a - b;

  }



  function add(uint256 a, uint256 b) internal pure returns (uint256) {

    uint256 c = a + b;

    assert(c >= a);

    return c;

  }

}

contract Ownable {

  address public owner;





  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);





  /**

   * @dev The Ownable constructor sets the original `owner` of the contract to the sender

   * account.

   */

  function Ownable() public {

    owner = msg.sender;

  }





  /**

   * @dev Throws if called by any account other than the owner.

   */

  modifier onlyOwner() {

    require(msg.sender == owner);

    _;

  }





  /**

   * @dev Allows the current owner to transfer control of the contract to a newOwner.

   * @param newOwner The address to transfer ownership to.

   */

  function transferOwnership(address newOwner) public onlyOwner {

    require(newOwner != address(0));

    OwnershipTransferred(owner, newOwner);

    owner = newOwner;

  }



}

contract CappedToken {

  using SafeMath for uint256;



  string public name;

  string public symbol;

  uint8 public decimals;

  uint256 public totalSupply;

  uint256 public cap;



  mapping(address => uint256) public balanceOf;

  mapping (address => mapping (address => uint256)) public allowance;



  event Transfer(address indexed from, address indexed to, uint256 value);

  event Approval(address indexed owner, address indexed spender, uint256 value);





  /**

   * @dev Fix for the ERC20 short address attack.

   */

  modifier onlyPayloadSize(uint numwords) {

    assert(msg.data.length >= numwords * 32 + 4);

    _;

  }





  /**

   * @dev Constrctor function

   * @param _cap Maximum token supply being emitted

   */

  function CappedToken(uint256 _cap) public {

    require(_cap > 0);

    name = "CappedToken";

    symbol = "CPD";

    decimals = 18;

    totalSupply = 0;

    cap = _cap;

  }



  /**

   * @dev Transfer token for a specified address

   * @param _to The address to transfer to.

   * @param _value The amount to be transferred.

   */

  function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool) {

    require(_to != address(0));

    require(_value <= balanceOf[msg.sender]);



    // SafeMath.sub will throw if there is not enough balance.

    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);

    balanceOf[_to] = balanceOf[_to].add(_value);

    Transfer(msg.sender, _to, _value);

    return true;

  }



  /**

   * @dev Transfer tokens from one address to another

   * @param _from address The address which you want to send tokens from

   * @param _to address The address which you want to transfer to

   * @param _value uint256 the amount of tokens to be transferred

   */

  function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool) {

    require(_to != address(0));

    require(_value <= balanceOf[_from]);

    require(_value <= allowance[_from][msg.sender]);



    balanceOf[_from] = balanceOf[_from].sub(_value);

    balanceOf[_to] = balanceOf[_to].add(_value);

    allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);

    Transfer(_from, _to, _value);

    return true;

  }



  /**

   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.

   *

   * Beware that changing an allowance with this method brings the risk that someone may use both the old

   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this

   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:

   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

   * @param _spender The address which will spend the funds.

   * @param _value The amount of tokens to be spent.

   */

  function approve(address _spender, uint256 _value) public returns (bool) {

    allowance[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;

  }



  /**

   * @dev Function to check the amount of tokens that an owner allowed to a spender.

   * @param _owner address The address which owns the funds.

   * @param _spender address The address which will spend the funds.

   * @return A uint256 specifying the amount of tokens still available for the spender.

   */

  function allowance(address _owner, address _spender) public view returns (uint256) {

    return allowance[_owner][_spender];

  }



  /**

   * @dev Increase the amount of tokens that an owner allowed to a spender.

   *

   * approve should be called when allowed[_spender] == 0. To increment

   * allowed value is better to use this function to avoid 2 steps approval transaction.

   * @param _spender The address which will spend the funds.

   * @param _addedValue The amount of to be spent.

   */

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {

    allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue);

    Approval(msg.sender, _spender, allowance[msg.sender][_spender]);

    return true;

  }



  /**

   * @dev Decrease the amount of tokens that an owner allowed to a spender.

   *

   * approve should be called when allowed[_spender] == 0. To decrement

   * allowed value is better to use this function to avoid 2 steps approval transaction.

   * @param _spender The address which will spend the funds.

   * @param _subtractedValue The amount of to be spent.

   */

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {

    uint oldValue = allowance[msg.sender][_spender];

    if (_subtractedValue > oldValue) {

      allowance[msg.sender][_spender] = 0;

    } else {

      allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue);

    }

    Approval(msg.sender, _spender, allowance[msg.sender][_spender]);

    return true;

  }

}

contract BeatToken is CappedToken {



    string public constant name = "BEAT Token";

    string public constant symbol = "BEAT";

    uint8 public constant decimals = 18;



    function BeatToken(uint256 _cap) CappedToken(_cap) public {

    }



    function getTotalSupply() public view returns (uint256) {

        return totalSupply;

    }



}



// You task is to complete the smart contract BeatTokenCrowdsale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @notice This contract is a crowdsale for BeatToken, which includes different ICO phases with varying bonus percentages.
 * @dev The contract manages the token distribution, stages of the ICO, and finalization. It uses SafeMath for arithmetic operations.
 */
contract BeatTokenCrowdsale is Ownable {

    /**
     * @notice Enum representing the different stages of the crowdsale.
     * @dev Used to track the current stage of the ICO.
     */
    enum Stages {
        Deployed,
        PreIco,
        IcoPhase1,
        IcoPhase2,
        IcoPhase3,
        IcoEnded,
        Finalized
    }

    Stages public stage;

    using SafeMath for uint256;

    /**
     * @notice The BeatToken contract instance.
     * @dev Token contract that will be minted and distributed during the ICO.
     */
    BeatToken public token;

    /**
     * @notice Timestamp when the contract was started.
     * @dev Used to determine the start time of the ICO.
     */
    uint256 public contractStartTime;

    /**
     * @notice Timestamp when the Pre-ICO phase ends.
     * @dev Used to determine the end time of the Pre-ICO phase.
     */
    uint256 public preIcoEndTime;

    /**
     * @notice Timestamp when the ICO Phase 1 ends.
     * @dev Used to determine the end time of the ICO Phase 1.
     */
    uint256 public icoPhase1EndTime;

    /**
     * @notice Timestamp when the ICO Phase 2 ends.
     * @dev Used to determine the end time of the ICO Phase 2.
     */
    uint256 public icoPhase2EndTime;

    /**
     * @notice Timestamp when the ICO Phase 3 ends.
     * @dev Used to determine the end time of the ICO Phase 3.
     */
    uint256 public icoPhase3EndTime;

    /**
     * @notice Timestamp when the entire ICO ends.
     * @dev Used to determine the end time of the entire ICO.
     */
    uint256 public contractEndTime;

    /**
     * @notice Wallet address for the ETH team.
     * @dev ETH raised during the ICO will be sent to this wallet.
     */
    address public ethTeamWallet;

    /**
     * @notice Wallet address for the BEAT team.
     * @dev Unsold tokens after the ICO will be minted and sent to this wallet.
     */
    address public beatTeamWallet;

    /**
     * @notice Total amount of ETH (in wei) raised during the ICO.
     * @dev Tracks the total ETH raised.
     */
    uint256 public ethWeiRaised;

    /**
     * @notice Mapping to store the balance of each participant.
     * @dev Maps addresses to their respective BEAT token balances.
     */
    mapping(address => uint256) public balanceOf;

    /**
     * @notice Duration of the Pre-ICO phase.
     * @dev Constant value set to 28 days.
     */
    uint public constant PRE_ICO_PERIOD = 28 days;

    /**
     * @notice Duration of the ICO Phase 1.
     * @dev Constant value set to 28 days.
     */
    uint public constant ICO_PHASE1_PERIOD = 28 days;

    /**
     * @notice Duration of the ICO Phase 2.
     * @dev Constant value set to 28 days.
     */
    uint public constant ICO_PHASE2_PERIOD = 28 days;

    /**
     * @notice Duration of the ICO Phase 3.
     * @dev Constant value set to 28 days.
     */
    uint public constant ICO_PHASE3_PERIOD = 28 days;

    /**
     * @notice Bonus percentage for the Pre-ICO phase.
     * @dev Constant value set to 100%.
     */
    uint256 public constant PRE_ICO_BONUS_PERCENTAGE = 100;

    /**
     * @notice Bonus percentage for the ICO Phase 1.
     * @dev Constant value set to 75%.
     */
    uint256 public constant ICO_PHASE1_BONUS_PERCENTAGE = 75;

    /**
     * @notice Bonus percentage for the ICO Phase 2.
     * @dev Constant value set to 50%.
     */
    uint256 public constant ICO_PHASE2_BONUS_PERCENTAGE = 50;

    /**
     * @notice Bonus percentage for the ICO Phase 3.
     * @dev Constant value set to 25%.
     */
    uint256 public constant ICO_PHASE3_BONUS_PERCENTAGE = 25;

    /**
     * @notice Total amount of tokens available in the Pre-ICO phase.
     * @dev Constant value set to 5.0 billion tokens.
     */
    uint256 public constant PRE_ICO_AMOUNT = 5000 * (10 ** 6) * (10 ** 18);

    /**
     * @notice Total amount of tokens available in the ICO Phase 1.
     * @dev Constant value set to 7.0 billion tokens.
     */
    uint256 public constant ICO_PHASE1_AMOUNT = 7000 * (10 ** 6) * (10 ** 18);

    /**
     * @notice Total amount of tokens available in the ICO Phase 2.
     * @dev Constant value set to 10.5 billion tokens.
     */
    uint256 public constant ICO_PHASE2_AMOUNT = 10500 * (10 ** 6) * (10 ** 18);

    /**
     * @notice Total amount of tokens available in the ICO Phase 3.
     * @dev Constant value set to 11.875 billion tokens.
     */
    uint256 public constant ICO_PHASE3_AMOUNT = 11875 * (10 ** 6) * (10 ** 18);

    /**
     * @notice Limit of tokens for the Pre-ICO phase.
     * @dev Constant value set to the total amount of tokens in the Pre-ICO phase.
     */
    uint256 public constant PRE_ICO_LIMIT = PRE_ICO_AMOUNT;

    /**
     * @notice Limit of tokens for the ICO Phase 1.
     * @dev Constant value set to the sum of Pre-ICO and ICO Phase 1 tokens.
     */
    uint256 public constant ICO_PHASE1_LIMIT = PRE_ICO_LIMIT + ICO_PHASE1_AMOUNT;

    /**
     * @notice Limit of tokens for the ICO Phase 2.
     * @dev Constant value set to the sum of Pre-ICO, ICO Phase 1, and ICO Phase 2 tokens.
     */
    uint256 public constant ICO_PHASE2_LIMIT = ICO_PHASE1_LIMIT + ICO_PHASE2_AMOUNT;

    /**
     * @notice Limit of tokens for the ICO Phase 3.
     * @dev Constant value set to the sum of all tokens in all phases.
     */
    uint256 public constant ICO_PHASE3_LIMIT = ICO_PHASE2_LIMIT + ICO_PHASE3_AMOUNT;

    /**
     * @notice Hard cap of the ICO.
     * @dev Constant value set to 230 billion tokens.
     */
    uint256 public constant HARD_CAP = 230 * (10 ** 9) * (10 ** 18);

    /**
     * @notice Price of ETH in Euro cents.
     * @dev Used to calculate the amount of BEAT tokens to be minted.
     */
    uint256 public ethPriceInEuroCent;

    /**
     * @notice Event emitted when BEAT tokens are purchased.
     * @dev Logs the purchaser, beneficiary, ETH amount, and BEAT amount.
     */
    event BeatTokenPurchased(address indexed purchaser, address indexed beneficiary, uint256 ethWeiAmount, uint256 beatWeiAmount);

    /**
     * @notice Event emitted when the ETH price in Euro cents is changed.
     * @dev Logs the new ETH price.
     */
    event BeatTokenEthPriceChanged(uint256 newPrice);

    /**
     * @notice Event emitted when the Pre-ICO phase starts.
     * @dev Logs the start of the Pre-ICO phase.
     */
    event BeatTokenPreIcoStarted();

    /**
     * @notice Event emitted when the ICO Phase 1 starts.
     * @dev Logs the start of the ICO Phase 1.
     */
    event BeatTokenIcoPhase1Started();

    /**
     * @notice Event emitted when the ICO Phase 2 starts.
     * @dev Logs the start of the ICO Phase 2.
     */
    event BeatTokenIcoPhase2Started();

    /**
     * @notice Event emitted when the ICO Phase 3 starts.
     * @dev Logs the start of the ICO Phase 3.
     */
    event BeatTokenIcoPhase3Started();

    /**
     * @notice Event emitted when the ICO is finalized.
     * @dev Logs the finalization of the ICO.
     */
    event BeatTokenIcoFinalized();

    /**
     * @notice Constructor to initialize the crowdsale contract.
     * @dev Sets up the initial state and parameters of the contract.
     * @param _ethTeamWallet The wallet address for the ETH team.
     * @param _beatTeamWallet The wallet address for the BEAT team.
     */
    function BeatTokenCrowdsale(address _ethTeamWallet, address _beatTeamWallet) public {
        require(_ethTeamWallet != address(0));
        require(_beatTeamWallet != address(0));

        token = new BeatToken(HARD_CAP);
        stage = Stages.Deployed;
        ethTeamWallet = _ethTeamWallet;
        beatTeamWallet = _beatTeamWallet;
        ethPriceInEuroCent = 0;

        contractStartTime = 0;
        preIcoEndTime = 0;
        icoPhase1EndTime = 0;
        icoPhase2EndTime = 0;
        icoPhase3EndTime = 0;
        contractEndTime = 0;
    }

    /**
     * @notice Function to set the ETH price in Euro cents.
     * @dev Only the owner can call this function.
     * @param _ethPriceInEuroCent The new ETH price in Euro cents.
     */
    function setEtherPriceInEuroCent(uint256 _ethPriceInEuroCent) onlyOwner public {
        require(_ethPriceInEuroCent > 0);
        ethPriceInEuroCent = _ethPriceInEuroCent;
        BeatTokenEthPriceChanged(_ethPriceInEuroCent);
    }

    /**
     * @notice Function to start the ICO.
     * @dev Only the owner can call this function.
     */
    function start() onlyOwner public {
        require(stage == Stages.Deployed);

        contractStartTime = now;
        preIcoEndTime = contractStartTime + PRE_ICO_PERIOD;
        icoPhase1EndTime = preIcoEndTime + ICO_PHASE1_PERIOD;
        icoPhase2EndTime = icoPhase1EndTime + ICO_PHASE2_PERIOD;
        icoPhase3EndTime = icoPhase2EndTime + ICO_PHASE3_PERIOD;
        contractEndTime = icoPhase3EndTime;

        stage = Stages.PreIco;
        BeatTokenPreIcoStarted();
    }

    /**
     * @notice Function to finalize the ICO.
     * @dev Only the owner can call this function.
     */
    function finalize() onlyOwner public {
        require(stage != Stages.Finalized);
        require(stage == Stages.IcoEnded);

        stage = Stages.Finalized;
        uint256 remainingTokens = HARD_CAP.sub(token.totalSupply());
        token.transfer(beatTeamWallet, remainingTokens);
        BeatTokenIcoFinalized();

        // Transfer ownership of the token to the contract owner
        token.transferOwnership(owner);
    }

    /**
     * @notice Fallback function to allow buying tokens by sending ETH directly.
     * @dev Calls the `buyTokens` function with the sender as the beneficiary.
     */
    function() payable public {
        buyTokens(msg.sender);
    }

    /**
     * @notice Function to buy BEAT tokens.
     * @dev Ensures the ICO is in a valid phase, calculates the token amount, and mints the tokens.
     * @param beneficiary The address to receive the BEAT tokens.
     */
    function buyTokens(address beneficiary) payable public {
        require(beneficiary != address(0));
        require(isWithinValidIcoPhase());
        require(ethPriceInEuroCent > 0);
        require(msg.value > 0);

        uint256 ethWeiAmount = msg.value;
        uint256 beatWeiAmount = calculateBeatWeiAmount(ethWeiAmount);
        require(isWithinTokenAllocLimit(beatWeiAmount));

        ethWeiRaised = ethWeiRaised.add(ethWeiAmount);

        balanceOf[beneficiary] = balanceOf[beneficiary].add(beatWeiAmount);
        token.transfer(beneficiary, beatWeiAmount);

        ethTeamWallet.transfer(ethWeiAmount);

        determineCurrentStage(beatWeiAmount);

        BeatTokenPurchased(msg.sender, beneficiary, ethWeiAmount, beatWeiAmount);
    }

    /**
     * @notice Internal function to check if the ICO is in a valid phase.
     * @dev Returns true if the ICO is in one of the valid phases.
     * @return bool True if the ICO is in a valid phase, false otherwise.
     */
    function isWithinValidIcoPhase() internal view returns (bool) {
        return (stage == Stages.PreIco ||
                stage == Stages.IcoPhase1 ||
                stage == Stages.IcoPhase2 ||
                stage == Stages.IcoPhase3);
    }

    /**
     * @notice Internal function to calculate the BEAT token amount based on the ETH amount.
     * @dev Applies the bonus percentage based on the current ICO phase.
     * @param ethWeiAmount The amount of ETH (in wei) sent.
     * @return uint256 The calculated BEAT token amount.
     */
    function calculateBeatWeiAmount(uint256 ethWeiAmount) internal view returns (uint256) {
        uint256 bonusPercentage;

        if (stage == Stages.PreIco) {
            bonusPercentage = PRE_ICO_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase1) {
            bonusPercentage = ICO_PHASE1_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase2) {
            bonusPercentage = ICO_PHASE2_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase3) {
            bonusPercentage = ICO_PHASE3_BONUS_PERCENTAGE;
        }

        // Conversion rate: 1 ETH = 1000 BEAT
        uint256 baseAmount = ethWeiAmount.mul(ethPriceInEuroCent).mul(1000);

        // Apply bonus
        uint256 bonusAmount = baseAmount.mul(bonusPercentage).div(100);

        return baseAmount.add(bonusAmount);
    }

    /**
     * @notice Internal function to check if the token allocation is within the limit.
     * @dev Ensures the total supply does not exceed the ICO phase limit.
     * @param beatWeiAmount The amount of BEAT tokens to be minted.
     * @return bool True if the token allocation is within the limit, false otherwise.
     */
    function isWithinTokenAllocLimit(uint256 beatWeiAmount) internal view returns (bool) {
        if (stage == Stages.PreIco) {
            return (token.totalSupply().add(beatWeiAmount) <= PRE_ICO_LIMIT);
        } else if (stage == Stages.IcoPhase1) {
            return (token.totalSupply().add(beatWeiAmount) <= ICO_PHASE1_LIMIT);
        } else if (stage == Stages.IcoPhase2) {
            return (token.totalSupply().add(beatWeiAmount) <= ICO_PHASE2_LIMIT);
        } else if (stage == Stages.IcoPhase3) {
            return (token.totalSupply().add(beatWeiAmount) <= ICO_PHASE3_LIMIT);
        } else {
            return false;
        }
    }

    /**
     * @dev Updates the ICO stage based on token supply and time.
     * @param beatWeiAmount Wei amount to be converted to tokens
     * @dev Transitions between stages when:
     *   - PreICO ends: supply > PRE_ICO_LIMIT or time exceeds PRE_ICO_PERIOD
     *   - Phase 1 ends: supply > ICO_PHASE1_LIMIT or time exceeds phase duration
     *   - Phase 2 ends: supply > ICO_PHASE2_LIMIT or time exceeds phase duration
     *   - Phase 3 ends: supply reaches limit or time expires
     * @dev Updates stage timestamps and emits corresponding events
     */
    function determineCurrentStage(uint256 beatWeiAmount) internal {
        if (stage == Stages.PreIco && (token.totalSupply().add(beatWeiAmount) > PRE_ICO_LIMIT || now > preIcoEndTime)) {
            stage = Stages.IcoPhase1;
            BeatTokenIcoPhase1Started();
        } else if (stage == Stages.IcoPhase1 && (token.totalSupply().add(beatWeiAmount) > ICO_PHASE1_LIMIT || now > icoPhase1EndTime)) {
            stage = Stages.IcoPhase2;
            BeatTokenIcoPhase2Started();
        } else if (stage == Stages.IcoPhase2 && (token.totalSupply().add(beatWeiAmount) > ICO_PHASE2_LIMIT || now > icoPhase2EndTime)) {
            stage = Stages.IcoPhase3;
            BeatTokenIcoPhase3Started();
        } else if (stage == Stages.IcoPhase3 && (token.totalSupply().add(beatWeiAmount) >= HARD_CAP || now > icoPhase3EndTime)) {
            stage = Stages.IcoEnded;
        }
    }
}
```