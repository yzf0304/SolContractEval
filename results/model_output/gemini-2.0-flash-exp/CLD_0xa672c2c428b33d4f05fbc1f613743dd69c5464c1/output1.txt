```solidity
pragma solidity ^0.5.17;

library SafeMath
{
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
	{
		c = a + b;
		require(c >= a, "SafeMath: addition overflow");
	}
	
	function sub(uint256 a, uint256 b) internal pure returns (uint256 c) 
	{
		require(b <= a, "SafeMath: subtraction overflow");
		c = a - b;
	}
}

contract Variable
{
	string public name;
	string public symbol;
	uint256 public decimals;
	uint256 public totalSupply;
	address public owner;

	uint256 internal _decimals;
	bool internal transferLock;
	
	mapping (address => bool) public allowedAddress;
	mapping (address => bool) public blockedAddress;

	mapping (address => uint256) public balanceOf;
	
	mapping (address => mapping (address => uint256)) internal allowed;

	constructor() public
	{
		name = "Celloud";
		symbol = "CLD";
		decimals = 18;
		_decimals = 10 ** uint256(decimals);
		totalSupply = _decimals * 1000000000;
		transferLock = true;
		owner =	msg.sender;
		balanceOf[owner] = totalSupply;
		allowedAddress[owner] = true;
	}
}

contract Modifiers is Variable
{
	modifier isOwner
	{
		assert(owner == msg.sender);
		_;
	}
}

contract Event
{
	event Transfer(address indexed from, address indexed to, uint256 value);
	event TokenBurn(address indexed from, uint256 value);
	event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Admin is Variable, Modifiers, Event {
    using SafeMath for uint256;

    function tokenBurn(uint256 _value) public isOwner returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Insufficient balance");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit TokenBurn(msg.sender, _value);
        return true;
    }

    function addAllowedAddress(address _address) public isOwner {
        allowedAddress[_address] = true;
    }

    function deleteAllowedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot remove owner from allowed addresses");
        allowedAddress[_address] = false;
    }

    function addBlockedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot block the owner");
        blockedAddress[_address] = true;
    }

    function deleteBlockedAddress(address _address) public isOwner {
        blockedAddress[_address] = false;
    }

    function setTransferLock(bool _transferLock) public isOwner returns (bool success) {
        transferLock = _transferLock;
        return true;
    }
}
```