```solidity
/**
 *Submitted for verification at Etherscan.io on 2022-12-11
*/

library SafeMath
{
	function add(uint256 a, uint256 b) internal pure returns (uint256 c) 
	{
		c = a + b;
		require(c >= a, "SafeMath: addition overflow");
	}
	
	function sub(uint256 a, uint256 b) internal pure returns (uint256 c) 
	{
		require(b <= a, "SafeMath: subtraction overflow");
		c = a - b;
	}
}

contract Variable
{
	string public name;
	string public symbol;
	uint256 public decimals;
	uint256 public totalSupply;
	address public owner;

	uint256 internal _decimals;
	bool internal transferLock;
	
	mapping (address => bool) public allowedAddress;
	mapping (address => bool) public blockedAddress;

	mapping (address => uint256) public balanceOf;
	
	mapping (address => mapping (address => uint256)) internal allowed;

	constructor() public
	{
		name = "Celloud";
		symbol = "CLD";
		decimals = 18;
		_decimals = 10 ** uint256(decimals);
		totalSupply = _decimals * 1000000000;
		transferLock = true;
		owner =	msg.sender;
		balanceOf[owner] = totalSupply;
		allowedAddress[owner] = true;
	}
}

contract Modifiers is Variable
{
	modifier isOwner
	{
		assert(owner == msg.sender);
		_;
	}
}

contract Event
{
	event Transfer(address indexed from, address indexed to, uint256 value);
	event TokenBurn(address indexed from, uint256 value);
	event Approval(address indexed owner, address indexed spender, uint256 value);
}



// You task is to complete the smart contract Admin strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @notice This contract provides administrative functionalities for managing token balances, allowed and blocked addresses, and transfer locks.
 * @dev The contract inherits from `Variable`, `Modifiers`, and `Event` contracts. It uses SafeMath for arithmetic operations to prevent overflows and underflows.
 */
contract Admin is Variable, Modifiers, Event {
    using SafeMath for uint256;

    /**
     * @notice Allows the owner to burn a specified amount of tokens from their balance.
     * @dev The function checks if the sender has enough balance before burning the tokens and updates the total supply accordingly.
     * @param _value The amount of tokens to be burned.
     * @return success A boolean indicating whether the operation was successful.
     */
    function tokenBurn(uint256 _value) public isOwner  {
        require(balanceOf[msg.sender] >= _value, "Not enough balance");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit TokenBurn(msg.sender, _value);
        return true;
    }

    /**
     * @notice Allows the owner to add an address to the list of allowed addresses.
     * @dev The function sets the `_address` as allowed, which can be used in other functions to check permissions.
     * @param _address The address to be added to the allowed list.
     */
    function addAllowedAddress(address _address) public isOwner {
        allowedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of allowed addresses.
     * @dev The function ensures that the owner's address cannot be removed from the allowed list.
     * @param _address The address to be removed from the allowed list.
     */
    function deleteAllowedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot remove owner from allowed addresses");
        allowedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to add an address to the list of blocked addresses.
     * @dev The function ensures that the owner's address cannot be added to the blocked list.
     * @param _address The address to be added to the blocked list.
     */
    function addBlockedAddress(address _address) public isOwner {
        require(_address != owner, "Cannot block owner address");
        blockedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of blocked addresses.
     * @dev The function removes the `_address` from the blocked list, allowing it to perform certain actions again.
     * @param _address The address to be removed from the blocked list.
     */
    function deleteBlockedAddress(address _address) public isOwner {
        blockedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to set or unset the transfer lock.
     * @dev The function toggles the `transferLock` state, which can be used to enable or disable token transfers.
     * @param _transferLock The new state of the transfer lock (true to enable, false to disable).
     * @return success A boolean indicating whether the operation was successful.
     */
    function setTransferLock(bool _transferLock) public isOwner returns (bool success) {
        transferLock = _transferLock;
        return true;
    }
}
```