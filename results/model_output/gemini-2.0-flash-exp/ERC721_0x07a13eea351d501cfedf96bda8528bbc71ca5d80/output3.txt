Okay, I will complete the `ERC721` smart contract according to the provided context. Here is the completed contract:

contract ERC721 is ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    uint256 private _totalMintsAllowed = 4;

    string private uriLink = "https://spicypumpkins.com/api/json";

    bool private _minting = true;

    address payable private _owner;

    uint256 private _count;

    string private _name;

    string private _symbol;

    mapping(uint256 => address) private _owners;

    mapping(uint256 => string) private _uri;

    mapping(address => uint256) private _balances;

    mapping(uint256 => address) private _tokenApprovals;

    mapping(address => uint256) private _minted;

    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
     * @notice Initializes the contract with the provided name and symbol.
     * @param name_ The name of the NFT collection.
     * @param symbol_ The symbol of the NFT collection.
     * @dev Sets the initial owner and assigns the first token to the contract creator.
     */
    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _owners[_count] = msg.sender;
        _balances[_owner]++;
        _uri[_count] = string(abi.encodePacked(uriLink, "/", _count.toString(), ".json"));
        emit Transfer(address(0), msg.sender, _count);
        _owner = payable(msg.sender);
        _count++;
    }

    /**
     * @notice Allows the owner to enable or disable minting.
     * @param boolean The new minting status.
     * @dev Only the contract owner can call this function.
     */
    function setMinting(bool boolean) external onlyOwner {
        _minting = boolean;
    }

    /**
     * @notice Transfers ownership of the contract to a new address.
     * @param to The new owner's address.
     * @dev Only the current owner can call this function.
     */
    function transferOwnership(address to) external onlyOwner {
        require(to != address(0), "ERC721: new owner is the zero address");
        emit OwnershipTransferred(_owner, to);
        _owner = payable(to);
    }

    /**
     * @dev Modifier to make a function callable only by the owner.
     */
    modifier onlyOwner() {
        require(_owner == msg.sender, "ERC721: caller is not the owner");
        _;
    }

    /**
     * @notice Checks if the contract supports a given interface.
     * @param interfaceId The ID of the interface to check.
     * @return A boolean indicating whether the interface is supported.
     * @dev Supports the ERC721 and ERC721Metadata interfaces.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC721).interfaceId ||
               interfaceId == type(IERC721Metadata).interfaceId ||
               super.supportsInterface(interfaceId);
    }

    /**
     * @notice Returns the balance of NFTs owned by a given address.
     * @param owner The address to query the balance of.
     * @return The number of NFTs owned by the address.
     * @dev Reverts if the `owner` is the zero address.
     */
    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: address zero is not a valid owner");
        return _balances[_ownersToAddresses(owner)];
    }

    function _ownersToAddresses(address owner) internal view returns (address) {
        for (uint256 i = 0; i < _count; i++) {
            if (_owners.at(i) == owner) {
                return owner;
            }
        }
        return address(0); // Should ideally never reach here if balanceOf is called correctly
    }

    /**
     * @notice Returns the owner of a given NFT.
     * @param tokenId The ID of the NFT to query.
     * @return The address of the NFT's owner.
     * @dev Reverts if the `tokenId` does not exist.
     */
    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: invalid token ID");
        return _owners.at(tokenId);
    }

    /**
     * @notice Returns the name of the NFT collection.
     * @return The name of the NFT collection.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the NFT collection.
     * @return The symbol of the NFT collection.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @notice Returns the total supply of NFTs in the collection.
     * @return The total number of NFTs in the collection.
     * @dev This is a fixed value of 4444.
     */
    function totalSupply() external view override returns(uint256){
        return _count;
    }

    /**
     * @notice Returns the URI for a given NFT.
     * @param tokenId The ID of the NFT to query.
     * @return The URI of the NFT.
     * @dev The URI is generated based on the `uriLink` and `tokenId`.
     */
    function tokenURI(uint256 tokenId) external view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return _uri.at(tokenId);
    }

    /**
     * @notice Returns the base URI for the NFTs.
     * @return The base URI for the NFTs.
     * @dev This is currently an empty string.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    /**
     * @notice Approves a given address to manage a specific NFT.
     * @param to The address to approve.
     * @param tokenId The ID of the NFT to approve.
     * @dev Only the owner or an approved operator can call this function.
     */
    function approve(address to, uint256 tokenId) external override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");
        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all");

        _tokenApprovals.set(tokenId, to);
        emit Approval(owner, to, tokenId);
    }

    /**
     * @notice Returns the address approved to manage a specific NFT.
     * @param tokenId The ID of the NFT to query.
     * @return The address approved to manage the NFT.
     * @dev Reverts if the `tokenId` does not exist.
     */
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");
        return _tokenApprovals.at(tokenId);
    }

    /**
     * @notice Sets the approval for all NFTs of the caller to a given address.
     * @param operator The address to set the approval for.
     * @param approved The new approval status.
     * @dev Emits an `ApprovalForAll` event.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != msg.sender, "ERC721: approve to caller");
        _operatorApprovals.set(msg.sender, operator, approved);
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    /**
     * @notice Checks if an address is approved for all NFTs of another address.
     * @param owner The address to check the approval for.
     * @param operator The address to check the approval of.
     * @return A boolean indicating whether the operator is approved for all NFTs of the owner.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals.at(owner, operator);
    }

    /**
     * @notice Transfers an NFT from one address to another.
     * @param from The address to transfer the NFT from.
     * @param to The address to transfer the NFT to.
     * @param tokenId The ID of the NFT to transfer.
     * @dev Only the owner or an approved operator can call this function.
     */
    function transferFrom(address from, address to, uint256 tokenId) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @notice Safely transfers an NFT from one address to another.
     * @param from The address to transfer the NFT from.
     * @param to The address to transfer the NFT to.
     * @param tokenId The ID of the NFT to transfer.
     * @dev Ensures that the recipient is an ERC721Receiver.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId) external override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @notice Safely transfers an NFT from one address to another with additional data.
     * @param from The address to transfer the NFT from.
     * @param to The address to transfer the NFT to.
     * @param tokenId The ID of the NFT to transfer.
     * @param _data Additional data to send with the transfer.
     * @dev Ensures that the recipient is an ERC721Receiver and processes the `_data`.
     */
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    /**
     * @notice Safely transfers an NFT from one address to another with additional data.
     * @param from The address sending the NFT.
     * @param to The address receiving the NFT.
     * @param tokenId The ID of the NFT being transferred.
     * @param _data Additional data to send with the transfer.
     * @dev Ensures that the recipient is an ERC721Receiver and processes the `_data`.
     */
    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    /**
     * @notice Checks if an NFT exists.
     * @param tokenId The ID of the NFT to check.
     * @return A boolean indicating whether the NFT exists.
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners.contains(tokenId);
    }

    /**
     * @notice Checks if an address is the owner or approved to manage a specific NFT.
     * @param spender The address to check.
     * @param tokenId The ID of the NFT to check.
     * @return A boolean indicating whether the address is the owner or approved.
     * @dev Reverts if the `tokenId` does not exist.
     */
    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: invalid token ID");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    