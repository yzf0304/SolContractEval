```solidity
pragma solidity ^0.4.16;

contract Owner {

	

	// Адреса владельцев

	mapping ( address => bool ) public ownerAddressMap;

	// Соответсвие адреса владельца и его номера

	mapping ( address => uint256 ) public ownerAddressNumberMap;

	// список менеджеров

	mapping ( uint256 => address ) public ownerListMap;

	// сколько всего менеджеров

	uint256 public ownerCountInt = 0;

	

	// событие "изменение в контракте"

	event ContractManagementUpdate( string _type, address _initiator, address _to, bool _newvalue );



	// модификатор - если смотрит владелец

	modifier isOwner {

        require( ownerAddressMap[msg.sender]==true );

        _;

    }

	

	// создание/включение владельца

	function ownerOn( address _onOwnerAddress ) external isOwner returns (bool retrnVal) {

		// Check if it's a non-zero address

		require( _onOwnerAddress != address(0) );

		// если такой владелец есть (стартового владельца удалить нельзя)

		if ( ownerAddressNumberMap[ _onOwnerAddress ]>0 )

		{

			// если такой владелец отключен, влючим его обратно

			if ( !ownerAddressMap[ _onOwnerAddress ] )

			{

				ownerAddressMap[ _onOwnerAddress ] = true;

				ContractManagementUpdate( "Owner", msg.sender, _onOwnerAddress, true );

				retrnVal = true;

			}

			else

			{

				retrnVal = false;

			}

		}

		// если такого владеьца нет

		else

		{

			ownerAddressMap[ _onOwnerAddress ] = true;

			ownerAddressNumberMap[ _onOwnerAddress ] = ownerCountInt;

			ownerListMap[ ownerCountInt ] = _onOwnerAddress;

			ownerCountInt++;

			ContractManagementUpdate( "Owner", msg.sender, _onOwnerAddress, true );

			retrnVal = true;

		}

	}

	

	// отключение менеджера

	function ownerOff( address _offOwnerAddress ) external isOwner returns (bool retrnVal) {

		// если такой менеджер есть и он не 0-вой, а также активен

		// 0-вой менеджер не может быть отключен

		if ( ownerAddressNumberMap[ _offOwnerAddress ]>0 && ownerAddressMap[ _offOwnerAddress ] )

		{

			ownerAddressMap[ _offOwnerAddress ] = false;

			ContractManagementUpdate( "Owner", msg.sender, _offOwnerAddress, false );

			retrnVal = true;

		}

		else

		{

			retrnVal = false;

		}

	}



	// конструктор, при создании контракта добалвяет создателя в "неудаляемые" создатели

	function Owner() public {

		// создаем владельца

		ownerAddressMap[ msg.sender ] = true;

		ownerAddressNumberMap[ msg.sender ] = ownerCountInt;

		ownerListMap[ ownerCountInt ] = msg.sender;

		ownerCountInt++;

	}

}

contract SpecialManager is Owner {



	// адреса специальных менеджеров

	mapping ( address => bool ) public specialManagerAddressMap;

	// Соответсвие адреса специального менеджера и его номера

	mapping ( address => uint256 ) public specialManagerAddressNumberMap;

	// список специальноых менеджеров

	mapping ( uint256 => address ) public specialManagerListMap;

	// сколько всего специальных менеджеров

	uint256 public specialManagerCountInt = 0;

	

	// модификатор - если смотрит владелец или специальный менеджер

	modifier isSpecialManagerOrOwner {

        require( specialManagerAddressMap[msg.sender]==true || ownerAddressMap[msg.sender]==true );

        _;

    }

	

	// создание/включение специального менеджера

	function specialManagerOn( address _onSpecialManagerAddress ) external isOwner returns (bool retrnVal) {

		// Check if it's a non-zero address

		require( _onSpecialManagerAddress != address(0) );

		// если такой менеджер есть

		if ( specialManagerAddressNumberMap[ _onSpecialManagerAddress ]>0 )

		{

			// если такой менеджер отключен, влючим его обратно

			if ( !specialManagerAddressMap[ _onSpecialManagerAddress ] )

			{

				specialManagerAddressMap[ _onSpecialManagerAddress ] = true;

				ContractManagementUpdate( "Special Manager", msg.sender, _onSpecialManagerAddress, true );

				retrnVal = true;

			}

			else

			{

				retrnVal = false;

			}

		}

		// если такого менеджера нет

		else

		{

			specialManagerAddressMap[ _onSpecialManagerAddress ] = true;

			specialManagerAddressNumberMap[ _onSpecialManagerAddress ] = specialManagerCountInt;

			specialManagerListMap[ specialManagerCountInt ] = _onSpecialManagerAddress;

			specialManagerCountInt++;

			ContractManagementUpdate( "Special Manager", msg.sender, _onSpecialManagerAddress, true );

			retrnVal = true;

		}

	}

	

	// отключение менеджера

	function specialManagerOff( address _offSpecialManagerAddress ) external isOwner returns (bool retrnVal) {

		// если такой менеджер есть и он не 0-вой, а также активен

		// 0-вой менеджер не может быть отключен

		if ( specialManagerAddressNumberMap[ _offSpecialManagerAddress ]>0 && specialManagerAddressMap[ _offSpecialManagerAddress ] )

		{

			specialManagerAddressMap[ _offSpecialManagerAddress ] = false;

			ContractManagementUpdate( "Special Manager", msg.sender, _offSpecialManagerAddress, false );

			retrnVal = true;

		}

		else

		{

			retrnVal = false;

		}

	}





	// конструктор, добавляет создателя в суперменеджеры

	function SpecialManager() public {

		// создаем менеджера

		specialManagerAddressMap[ msg.sender ] = true;

		specialManagerAddressNumberMap[ msg.sender ] = specialManagerCountInt;

		specialManagerListMap[ specialManagerCountInt ] = msg.sender;

		specialManagerCountInt++;

	}

}



// You task is to complete the smart contract Manager strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.16, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @notice A contract for managing a list of managers with the ability to add, remove, and check their status.
 * @dev This contract inherits from SpecialManager and provides functionality to manage a list of addresses that are considered managers.
 */
contract Manager is SpecialManager {

	// адрес менеджеров
	mapping ( address => bool ) public managerAddressMap;

	// Соответсвие адреса менеджеров и его номера
	mapping ( address => uint256 ) public managerAddressNumberMap;

	// список менеджеров
	mapping ( uint256 => address ) public managerListMap;

	// сколько всего менеджеров
	uint256 public managerCountInt = 0;

	/**
	 * @notice Modifier to restrict access to only the owner or a manager.
	 * @dev This modifier checks if the message sender is either the owner or a registered manager.
	 */
	modifier isManagerOrOwner {
        require( managerAddressMap[msg.sender]==true || ownerAddressMap[msg.sender]==true );
        _;
    }

	/**
     * @dev Enables or re-enables a manager address.
     * @param _onManagerAddress The address of the manager to enable
     * @return retrnVal Boolean indicating success (true) or if manager already active (false)
     * @dev Requirements:
     *   - Only callable by contract owner
     *   - Manager address cannot be zero
     * @dev Behavior:
     *   - If manager exists but is disabled, enables them and emits event
     *   - If manager doesn't exist, adds them to the manager list with sequential numbering
     *   - Updates all relevant manager tracking mappings
     *   - Emits ContractManagementUpdate event in all cases
     * @dev Notes:
     *   - Maintains three related mappings for manager tracking:
     *     1. managerAddressMap: tracks enabled/disabled status
     *     2. managerAddressNumberMap: tracks manager's sequential number
     *     3. managerListMap: maintains ordered list of managers
     *   - Increments managerCountInt when adding new managers
     * @dev Events:
     *   - Emits ContractManagementUpdate with action details
     */
	function managerOn( address _onManagerAddress ) external isOwner returns (bool retrnVal) {
		// Check if it's a non-zero address
		require( _onManagerAddress != address(0) );
		// если такой менеджер есть
		if ( managerAddressNumberMap[ _onManagerAddress ]>0 )
		{
			// если такой менеджер отключен, влючим его обратно
			if ( !managerAddressMap[ _onManagerAddress ] )
			{
				managerAddressMap[ _onManagerAddress ] = true;
				ContractManagementUpdate( "Manager", msg.sender, _onManagerAddress, true );
				retrnVal = true;
			}
			else
			{
				retrnVal = false;
			}
		}
		// если такого менеджера нет
		else
		{
			managerAddressMap[ _onManagerAddress ] = true;
			managerAddressNumberMap[ _onManagerAddress ] = managerCountInt;
			managerListMap[ managerCountInt ] = _onManagerAddress;
			managerCountInt++;
			ContractManagementUpdate( "Manager", msg.sender, _onManagerAddress, true );
			retrnVal = true;
		}
	}

	/**
	 * @notice Disables a manager.
	 * @dev This function disables an existing manager. Only the owner can call this function.
	 * @param _offManagerAddress The address of the manager to be disabled.
	 * @return retrnVal Returns true if the operation was successful, false otherwise.
	 */
	function managerOff( address _offManagerAddress ) external isOwner returns (bool retrnVal) {
		// если такой менеджер есть и он не 0-вой, а также активен
		if ( managerAddressNumberMap[ _offManagerAddress ]>0 && managerAddressMap[ _offManagerAddress ] )
		{
			managerAddressMap[ _offManagerAddress ] = false;
			ContractManagementUpdate( "Manager", msg.sender, _offManagerAddress, false );
			retrnVal = true;
		}
		else
		{
			retrnVal = false;
		}
	}

	/**
	 * @notice Initializes the contract and adds the creator as the first manager.
	 * @dev The constructor sets up the initial state and adds the contract creator as the first manager.
	 */
	function Manager() public {
		managerAddressMap[ msg.sender ] = true;
		managerAddressNumberMap[ msg.sender ] = managerCountInt;
		managerListMap[ managerCountInt ] = msg.sender;
		managerCountInt++;
	}
}
```