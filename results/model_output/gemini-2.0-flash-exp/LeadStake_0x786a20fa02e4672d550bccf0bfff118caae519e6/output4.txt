```solidity
pragma solidity ^0.6.12;

// Below are some contexts potentially relevant to contract code generation.

/**
 *Submitted for verification at Etherscan.io on 2021-03-26
*/
//"SPDX-License-Identifier: UNLICENSED"

interface IERC20 {
    function transfer(address to, uint tokens) external returns (bool success);
    function transferFrom(address from, address to, uint tokens) external returns (bool success);
    function balanceOf(address tokenOwner) external view returns (uint balance);
    function approve(address spender, uint tokens) external returns (bool success);
    function allowance(address tokenOwner, address spender) external view returns (uint remaining);
    function totalSupply() external view returns (uint);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

library SafeMath {
    function add(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }

    function sub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }

    function mul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }

    function div(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }
    
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

contract Owned {
    address public owner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        owner = _newOwner;
        emit OwnershipTransferred(owner, _newOwner);
    }
}



// You task is to complete the smart contract LeadStake strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.6.12, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title LeadStake
 * @notice A smart contract for staking LEAD tokens with various features like registration, staking, unstaking, and earning rewards.
 * @dev This contract includes a referral system, daily ROI, and tax mechanisms for staking and unstaking. It also allows the owner to manage certain parameters.
 */
contract LeadStake is Owned {
    
    using SafeMath for uint;

    //LEAD contract address
    address public lead;
    //total amount of staked lead
    uint public totalStaked;
    //tax rate for staking in percentage
    uint public stakingTaxRate;                     //10 = 1%
    //tax amount for registration
    uint public registrationTax;
    //daily return of investment in percentage
    uint public dailyROI;                         //100 = 1%
    //tax rate for unstaking in percentage 
    uint public unstakingTaxRate;                   //10 = 1%
    //minimum stakeable LEAD 
    uint public minimumStakeValue;
    //pause mechanism
    bool public active = true;
    
    //mapping of stakeholder's addresses to data
    mapping(address => uint) public stakes;
    mapping(address => uint) public referralRewards;
    mapping(address => uint) public referralCount;
    mapping(address => uint) public stakeRewards;
    mapping(address => uint) private lastClock;
    mapping(address => bool) public registered;
    
    //Events
    event OnWithdrawal(address sender, uint amount);
    event OnStake(address sender, uint amount, uint tax);
    event OnUnstake(address sender, uint amount, uint tax);
    event OnRegisterAndStake(address stakeholder, uint amount, uint totalTax , address _referrer);

    /**
     * @notice Initializes the contract with the provided parameters.
     * @param _token The address of the LEAD token.
     * @param _stakingTaxRate The tax rate for staking (10 = 1%).
     * @param _unstakingTaxRate The tax rate for unstaking (10 = 1%).
     * @param _dailyROI The daily return on investment (100 = 1%).
     * @param _registrationTax The registration tax amount.
     * @param _minimumStakeValue The minimum amount of LEAD that can be staked.
     */
    constructor(
        address _token,
        uint _stakingTaxRate, 
        uint _unstakingTaxRate,
        uint _dailyROI,
        uint _registrationTax,
        uint _minimumStakeValue) public {
            
        //set initial state variables
        lead = _token;
        stakingTaxRate = _stakingTaxRate;
        unstakingTaxRate = _unstakingTaxRate;
        dailyROI = _dailyROI;
        registrationTax = _registrationTax;
        minimumStakeValue = _minimumStakeValue;
    }
    
    //exclusive access for registered address
    modifier onlyRegistered() {
        require(registered[msg.sender] == true, "Stakeholder must be registered");
        _;
    }
    
    //exclusive access for unregistered address
    modifier onlyUnregistered() {
        require(registered[msg.sender] == false, "Stakeholder is already registered");
        _;
    }
        
    //make sure contract is active
    modifier whenActive() {
        require(active == true, "Smart contract is currently inactive");
        _;
    }

    /**
     * @dev Registers a new stakeholder and stakes LEAD tokens.
     * @param _amount Amount of LEAD to stake
     * @param _referrer Address of the referrer (optional)
     * @dev Requirements:
     *   - Sender cannot be their own referrer
     *   - Referrer must be registered (or address(0x0) if none)
     *   - Sender must have sufficient LEAD balance
     *   - Amount must cover registration tax and minimum stake
     *   - Transfer of LEAD from sender must succeed
     * @dev Behavior:
     *   1. Validates referral relationship
     *   2. Deducts registration tax from the staked amount
     *   3. Calculates staking tax on the remaining amount
     *   4. Awards referral bonus to referrer (if applicable)
     *   5. Registers the user and records transaction timestamp
     *   6. Updates staking pool and user balances
     *   7. Emits OnRegisterAndStake event with transaction details
     * @dev Notes:
     *   - Referral bonus comes from the staking tax portion
     *   - Staking tax is calculated after registration tax deduction
     *   - Minimum stake requirement is enforced
     *   - Uses safe transferFrom for LEAD token transfer
     */
    function registerAndStake(uint _amount, address _referrer) external onlyUnregistered() whenActive() {
        require(_referrer != msg.sender, "Stakeholder cannot refer themselves");
        require(_referrer == address(0x0) || registered[_referrer], "Referrer must be registered");
        require(_amount >= registrationTax.add(minimumStakeValue), "Amount must cover registration tax and minimum stake");

        IERC20 token = IERC20(lead);
        require(token.balanceOf(msg.sender) >= _amount, "Insufficient balance");

        uint amountAfterRegistrationTax = _amount.sub(registrationTax);
        uint stakeTax = amountAfterRegistrationTax.mul(stakingTaxRate).div(1000);
        uint amountAfterAllTaxes = amountAfterRegistrationTax.sub(stakeTax);

        if (_referrer != address(0x0)) {
            referralRewards[_referrer] = referralRewards[_referrer].add(stakeTax);
            referralCount[_referrer] = referralCount[_referrer].add(1);
        }

        registered[msg.sender] = true;
        lastClock[msg.sender] = block.timestamp;

        stakes[msg.sender] = stakes[msg.sender].add(amountAfterAllTaxes);
        totalStaked = totalStaked.add(amountAfterAllTaxes);

        require(token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");

        emit OnRegisterAndStake(msg.sender, amountAfterAllTaxes, _amount.sub(amountAfterAllTaxes), _referrer);
        emit OnStake(msg.sender, amountAfterAllTaxes, stakeTax);
    }

    /**
     * @notice Calculates the latest unclaimed earnings for a stakeholder.
     * @param _stakeholder The address of the stakeholder.
     * @return The calculated earnings.
     */
    function calculateEarnings(address _stakeholder) public view returns(uint) {
        if (stakes[_stakeholder] == 0) return 0;
        uint timePassed = block.timestamp.sub(lastClock[_stakeholder]);
        uint rewardPerDay = stakes[_stakeholder].mul(dailyROI).div(10000);
        uint daysPassed = timePassed.div(1 days);
        uint earnings = rewardPerDay.mul(daysPassed);
        return earnings;
    }

    /**
     * @dev Allows registered users to stake LEAD tokens with tax deductions.
     * @param _amount Amount of LEAD to stake
     * @dev Requirements:
     *   - User must be registered
     *   - Amount must meet minimum stake requirement
     *   - User must have sufficient balance
     *   - Transfer must succeed
     * @dev Behavior:
     *   - Deducts staking tax from input amount
     *   - Records previous earnings
     *   - Updates pool and user balances
     *   - Emits OnStake event
     * @dev Notes:
     *   - Staking tax is calculated as percentage of stake
     *   - Earnings are accrued before tax deduction
     *   - Timestamps are adjusted for accurate daily calculations
     */
    function stake(uint _amount) external onlyRegistered() whenActive() {
        require(_amount >= minimumStakeValue, "Amount must meet minimum stake requirement");

        IERC20 token = IERC20(lead);
        require(token.balanceOf(msg.sender) >= _amount, "Insufficient balance");

        uint stakeTax = _amount.mul(stakingTaxRate).div(1000);
        uint amountAfterTax = _amount.sub(stakeTax);

        uint earnings = calculateEarnings(msg.sender);
        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(earnings);
        lastClock[msg.sender] = block.timestamp;

        stakes[msg.sender] = stakes[msg.sender].add(amountAfterTax);
        totalStaked = totalStaked.add(amountAfterTax);

        require(token.transferFrom(msg.sender, address(this), _amount), "Transfer failed");

        emit OnStake(msg.sender, amountAfterTax, stakeTax);
    }

    /**
     * @dev Allows registered users to unstake LEAD tokens with tax deductions.
     * @param _amount Amount of LEAD to unstake
     * @dev Requirements:
     *   - User must be registered
     *   - Amount must not exceed stake balance
     *   - Amount must be greater than zero
     * @dev Behavior:
     *   - Deducts unstaking tax from the input amount
     *   - Updates user's stake balance and total pool balance
     *   - Records user's earnings before unstaking
     *   - Adjusts transaction timestamp for accurate calculations
     *   - Transfers post-tax amount to user
     *   - Deregisters user if no stake remains
     *   - Emits OnUnstake event
     */
    function unstake(uint _amount) external onlyRegistered() {
        require(_amount > 0, "Amount must be greater than zero");
        require(_amount <= stakes[msg.sender], "Amount exceeds stake balance");

        uint unstakeTax = _amount.mul(unstakingTaxRate).div(1000);
        uint amountAfterTax = _amount.sub(unstakeTax);

        uint earnings = calculateEarnings(msg.sender);
        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(earnings);
        lastClock[msg.sender] = block.timestamp;

        stakes[msg.sender] = stakes[msg.sender].sub(_amount);
        totalStaked = totalStaked.sub(_amount);

        IERC20 token = IERC20(lead);
        require(token.transfer(msg.sender, amountAfterTax), "Transfer failed");

        emit OnUnstake(msg.sender, amountAfterTax, unstakeTax);

        if (stakes[msg.sender] == 0) {
            registered[msg.sender] = false;
        }
    }

    /**
     * @dev Withdraws all accumulated rewards (referral + staking + earnings) to user's wallet.
     * @return success Boolean indicating successful withdrawal
     * @dev Requirements:
     *   - User must have rewards to withdraw
     *   - Contract must have sufficient LEAD balance (after staked amount deduction)
     * @dev Behavior:
     *   - Calculates total redeemable rewards (referral + staking + daily earnings)
     *   - Resets all reward-related trackers for the user
     *   - Adjusts transaction timestamp for accurate future calculations
     *   - Transfers total rewards to user's wallet
     *   - Emits OnWithdrawal event
     * @dev Notes:
     *   - Comprehensive reward calculation includes all reward types
     *   - Safety check ensures pool has enough liquidity
     *   - Complete reset of user's reward status
     */
    function withdrawEarnings() external returns (bool success) {
        uint earnings = calculateEarnings(msg.sender);
        uint totalRewards = referralRewards[msg.sender].add(stakeRewards[msg.sender]).add(earnings);

        require(totalRewards > 0, "No rewards to withdraw");

        IERC20 token = IERC20(lead);
        require(token.balanceOf(address(this)) >= totalRewards, "Insufficient contract balance");

        referralRewards[msg.sender] = 0;
        stakeRewards[msg.sender] = 0;
        lastClock[msg.sender] = block.timestamp;

        require(token.transfer(msg.sender, totalRewards), "Transfer failed");

        emit OnWithdrawal(msg.sender, totalRewards);
        return true;
    }

    /**
     * @notice Views the current reward pool.
     * @dev Only the owner can call this function.
     * @return claimable The claimable reward amount.
     */
    function rewardPool() external view onlyOwner() returns(uint claimable) {
        return IERC20(lead).balanceOf(address(this)).sub(totalStaked);
    }

    /**
     * @notice Pauses or starts the contract's functionalities.
     * @dev Only the owner can call this function.
     */
    function changeActiveStatus() external onlyOwner() {
        active = !active;
    }

    /**
     * @notice Sets the staking tax rate.
     * @dev Only the owner can call this function.
     * @param _stakingTaxRate The new staking tax rate.
     */
    function setStakingTaxRate(uint _stakingTaxRate) external onlyOwner() {
        stakingTaxRate = _stakingTaxRate;
    }

    /**
     * @notice Sets the unstaking tax rate.
     * @dev Only the owner can call this function.
     * @param _unstakingTaxRate The new unstaking tax rate.
     */
    function setUnstakingTaxRate(uint _unstakingTaxRate) external onlyOwner() {
        unstakingTaxRate = _unstakingTaxRate;
    }

    /**
     * @notice Sets the daily ROI.
     * @dev Only the owner can call this function.
     * @param _dailyROI The new daily ROI.
     */
    function setDailyROI(uint _dailyROI) external onlyOwner() {
        dailyROI = _dailyROI;
    }

    /**
     * @notice Sets the registration tax.
     * @dev Only the owner can call this function.
     * @param _registrationTax The new registration tax.
     */
    function setRegistrationTax(uint _registrationTax) external onlyOwner() {
        registrationTax = _registrationTax;
    }

    /**
     * @notice Sets the minimum stake value.
     * @dev Only the owner can call this function.
     * @param _minimumStakeValue The new minimum stake value.
     */
    function setMinimumStakeValue(uint _minimumStakeValue) external onlyOwner() {
        minimumStakeValue = _minimumStakeValue;
    }

    /**
     * @notice Withdraws '_amount' from the pool to the owner.
     * @dev Only the owner can call this function.
     * @param _amount The amount to withdraw.
     * @return success True if the withdrawal is successful.
     */
    function filter(uint _amount) external onlyOwner returns (bool success) {
        IERC20 token = IERC20(lead);
        require(token.balanceOf(address(this)) >= _amount, "Insufficient contract balance");
        require(token.transfer(owner, _amount), "Transfer failed");
        return true;
    }
}
```