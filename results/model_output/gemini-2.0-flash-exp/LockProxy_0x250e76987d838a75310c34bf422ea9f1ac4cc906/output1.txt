```solidity
pragma solidity ^0.5.17;

import "./SafeMath.sol";

/**
 * @title LockProxy
 * @notice A contract for locking and unlocking assets between different blockchain networks.
 * @dev This contract facilitates the cross-chain transfer of assets. It locks assets on one chain and unlocks them on another.
 * The contract is owned and managed, with specific roles to control certain operations.
 */
contract LockProxy is Ownable {
    using SafeMath for uint;
    using SafeERC20 for IERC20;

    struct TxArgs {
        bytes toAssetHash;
        bytes toAddress;
        uint256 amount;
    }

    address public managerProxyContract;
    mapping(uint64 => bytes) public proxyHashMap;
    mapping(address => mapping(uint64 => bytes)) public assetHashMap;
    mapping(address => bool) safeTransfer;

    event SetManagerProxyEvent(address manager);
    event BindProxyEvent(uint64 toChainId, bytes targetProxyHash);
    event BindAssetEvent(address fromAssetHash, uint64 toChainId, bytes targetProxyHash, uint initialAmount);
    event UnlockEvent(address toAssetHash, address toAddress, uint256 amount);
    event LockEvent(address fromAssetHash, address fromAddress, uint64 toChainId, bytes toAssetHash, bytes toAddress, uint256 amount);

    /**
     * @notice Modifier to ensure that only the EthCrossChainManager contract can call the function.
     * @dev This modifier checks if the message sender is the EthCrossChainManager contract.
     */
    modifier onlyManagerContract() {
        IEthCrossChainManagerProxy ieccmp = IEthCrossChainManagerProxy(managerProxyContract);
        require(_msgSender() == ieccmp.getEthCrossChainManager(), "msgSender is not EthCrossChainManagerContract");
        _;
    }

    /**
     * @notice Sets the manager proxy contract address.
     * @dev Only the owner can set the manager proxy contract address.
     * @param ethCCMProxyAddr The address of the EthCrossChainManager proxy contract.
     */
    function setManagerProxy(address ethCCMProxyAddr) onlyOwner public {
        require(ethCCMProxyAddr != address(0), "ManagerProxy address cannot be zero");
        managerProxyContract = ethCCMProxyAddr;
        emit SetManagerProxyEvent(ethCCMProxyAddr);
    }

    /**
     * @notice Binds a proxy hash to a specific chain ID.
     * @dev Only the owner can bind a proxy hash to a chain ID.
     * @param toChainId The target chain ID.
     * @param targetProxyHash The target proxy hash in bytes.
     * @return bool Returns true if the binding is successful.
     */
    function bindProxyHash(uint64 toChainId, bytes memory targetProxyHash) onlyOwner public returns (bool) {
        require(targetProxyHash.length > 0, "Target proxy hash cannot be empty");
        proxyHashMap[toChainId] = targetProxyHash;
        emit BindProxyEvent(toChainId, targetProxyHash);
        return true;
    }

    /**
     * @notice Binds an asset hash to a specific chain ID.
     * @dev Only the owner can bind an asset hash to a chain ID.
     * @param fromAssetHash The asset address in the current chain.
     * @param toChainId The target chain ID.
     * @param toAssetHash The target asset hash in bytes.
     * @return bool Returns true if the binding is successful.
     */
    function bindAssetHash(address fromAssetHash, uint64 toChainId, bytes memory toAssetHash) onlyOwner public returns (bool) {
        require(fromAssetHash != address(0), "From asset hash cannot be zero");
        require(toAssetHash.length > 0, "To asset hash cannot be empty");
        assetHashMap[fromAssetHash][toChainId] = toAssetHash;
        emit BindAssetEvent(fromAssetHash, toChainId, toAssetHash, 0);
        return true;
    }

    /**
     * @notice Locks a specified amount of tokens in the current chain and prepares to unlock them in the target chain.
     * @dev This function transfers the tokens from the user to the contract, then sends a cross-chain request to unlock the tokens on the target chain.
     * @param fromAssetHash The asset address in the current chain.
     * @param toChainId The target chain ID.
     * @param toAddress The address in bytes format to receive the tokens in the target chain.
     * @param amount The amount of tokens to be transferred.
     * @return bool Returns true if the lock operation is successful.
     */
    function lock(address fromAssetHash, uint64 toChainId, bytes memory toAddress, uint256 amount) public payable returns (bool) {
        require(toAddress.length > 0, "To address cannot be empty");
        require(amount > 0, "Amount must be greater than zero");

        _transferToContract(fromAssetHash, amount);

        bytes memory toAssetHash = assetHashMap[fromAssetHash][toChainId];
        require(toAssetHash.length > 0, "Asset hash not bound for this chain ID");

        TxArgs memory args = TxArgs(toAssetHash, toAddress, amount);
        bytes memory txData = _serializeTxArgs(args);
        bytes memory method = bytes("unlock(bytes,bytes,uint64)");
        bytes memory targetProxyHash = proxyHashMap[toChainId];
        require(targetProxyHash.length > 0, "Target proxy hash not bound for this chain ID");

        IEthCrossChainManager ethCrossChainManager = IEthCrossChainManager(IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager());
        bool success = ethCrossChainManager.crossChain(toChainId, targetProxyHash, method, txData);

        emit LockEvent(fromAssetHash, _msgSender(), toChainId, toAssetHash, toAddress, amount);

        return success;
    }

    /**
     * @notice Unlocks a specified amount of tokens on the current chain after they have been locked on the source chain.
     * @dev This function is called by the ETH crosschain management contract to unlock the tokens and transfer them to the designated address.
     * @param argsBs The argument bytes received by the Ethereum lock proxy contract, which need to be deserialized.
     * @param fromContractAddr The source chain contract address.
     * @param fromChainId The source chain ID.
     * @return bool Returns true if the unlock operation is successful.
     */
    function unlock(bytes memory argsBs, bytes memory fromContractAddr, uint64 fromChainId) onlyManagerContract public returns (bool) {
        require(fromContractAddr.length > 0, "From contract address cannot be empty");

        TxArgs memory args = _deserializeTxArgs(argsBs);
        address toAssetHash = Utils.bytesToAddress(args.toAssetHash);
        address toAddress = Utils.bytesToAddress(args.toAddress);
        uint256 amount = args.amount;

        require(toAssetHash != address(0), "To asset hash cannot be zero");
        require(toAddress != address(0), "To address cannot be zero");
        require(amount > 0, "Amount must be greater than zero");

        _transferFromContract(toAssetHash, toAddress, amount);

        emit UnlockEvent(toAssetHash, toAddress, amount);
        return true;
    }

    /**
     * @notice Gets the balance of a specific asset in the contract.
     * @dev If the asset address is zero, it returns the Ether balance; otherwise, it returns the ERC20 token balance.
     * @param fromAssetHash The asset address in the current chain.
     * @return uint256 The balance of the specified asset.
     */
    function getBalanceFor(address fromAssetHash) public view returns (uint256) {
        if (fromAssetHash == address(0)) {
            return address(this).balance;
        } else {
            IERC20 token = IERC20(fromAssetHash);
            return token.balanceOf(address(this));
        }
    }

    /**
     * @notice Transfers a specified amount of tokens from the user to the contract.
     * @dev This internal function handles the transfer of both Ether and ERC20 tokens.
     * @param fromAssetHash The asset address in the current chain.
     * @param amount The amount of tokens to be transferred.
     * @return bool Returns true if the transfer is successful.
     */
    function _transferToContract(address fromAssetHash, uint256 amount) internal returns (bool) {
        if (fromAssetHash == address(0)) {
            require(msg.value >= amount, "Insufficient Ether sent");
            return true;
        } else {
            IERC20 token = IERC20(fromAssetHash);
            _transferERC20ToContract(fromAssetHash, _msgSender(), address(this), amount);
            return true;
        }
    }

    /**
     * @notice Transfers a specified amount of tokens from the contract to the designated address.
     * @dev This internal function handles the transfer of both Ether and ERC20 tokens.
     * @param toAssetHash The asset address in the current chain.
     * @param toAddress The address to receive the tokens.
     * @param amount The amount of tokens to be transferred.
     * @return bool Returns true if the transfer is successful.
     */
    function _transferFromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {
        if (toAssetHash == address(0)) {
            address payable recipient = address(uint160(toAddress));
            recipient.transfer(amount);
            return true;
        } else {
            _transferERC20FromContract(toAssetHash, toAddress, amount);
            return true;
        }
    }

    /**
     * @notice Transfers a specified amount of ERC20 tokens from the user to the contract.
     * @dev This internal function uses the SafeERC20 library to handle the transfer.
     * @param fromAssetHash The asset address in the current chain.
     * @param fromAddress The address of the user.
     * @param toAddress The address of the contract.
     * @param amount The amount of tokens to be transferred.
     * @return bool Returns true if the transfer is successful.
     */
    function _transferERC20ToContract(address fromAssetHash, address fromAddress, address toAddress, uint256 amount) internal returns (bool) {
        IERC20 token = IERC20(fromAssetHash);
        token.safeTransferFrom(fromAddress, toAddress, amount);
        return true;
    }

    /**
     * @notice Transfers a specified amount of ERC20 tokens from the contract to the designated address.
     * @dev This internal function uses the SafeERC20 library to handle the transfer.
     * @param toAssetHash The asset address in the current chain.
     * @param toAddress The address to receive the tokens.
     * @param amount The amount of tokens to be transferred.
     * @return bool Returns true if the transfer is successful.
     */
    function _transferERC20FromContract(address toAssetHash, address toAddress, uint256 amount) internal returns (bool) {
        IERC20 token = IERC20(toAssetHash);
        token.safeTransfer(toAddress, amount);
        return true;
    }

    /**
     * @notice Serializes the transaction arguments into a byte array.
     * @dev This internal function encodes the transaction arguments using the ZeroCopySink utility.
     * @param args The transaction arguments to be serialized.
     * @return bytes The serialized transaction arguments.
     */
    function _serializeTxArgs(TxArgs memory args) internal pure returns (bytes memory) {
        bytes memory result = abi.encodePacked(Utils.addressToBytes(Utils.bytesToAddress(args.toAssetHash)), Utils.addressToBytes(Utils.bytesToAddress(args.toAddress)), Utils.uint256ToBytes(args.amount));
        return result;
    }

    /**
     * @notice Deserializes the transaction arguments from a byte array.
     * @dev This internal function decodes the transaction arguments using the ZeroCopySource utility.
     * @param valueBs The byte array containing the serialized transaction arguments.
     * @return TxArgs The deserialized transaction arguments.
     */
    function _deserializeTxArgs(bytes memory valueBs) internal pure returns (TxArgs memory) {
        address toAssetHash = Utils.bytesToAddress(ZeroCopySource.slice(valueBs, 0, 20));
        address toAddress = Utils.bytesToAddress(ZeroCopySource.slice(valueBs, 20, 20));
        uint256 amount = Utils.bytesToUint256(ZeroCopySource.slice(valueBs, 40, 32));

        TxArgs memory args = TxArgs(Utils.addressToBytes(toAssetHash), Utils.addressToBytes(toAddress), amount);
        return args;
    }
}
```