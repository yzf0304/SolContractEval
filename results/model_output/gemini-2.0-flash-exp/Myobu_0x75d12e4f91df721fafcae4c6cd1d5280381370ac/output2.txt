```solidity
// Below are some contexts potentially relevant to contract code generation.

/**
 *Submitted for verification at Etherscan.io on 2021-06-04
*/
/*
https://t.me/MyobuOfficial
https://myobu.io 
https://twitter.com/MyobuOfficial
https://www.reddit.com/r/Myobu/

Myōbu are celestial fox spirits with white fur and full, fluffy tails reminiscent of ripe grain. They are holy creatures, and bring happiness and blessings to those around them.

With a dynamic sell limit based on price impact and increasing sell cooldowns and redistribution taxes on consecutive sells, Myōbu was designed to reward holders and discourage dumping.

1. Buy limit and cooldown timer on buys to make sure no automated bots have a chance to snipe big portions of the pool.
2. No Team & Marketing wallet. 100% of the tokens will come on the market for trade. 
3. No presale wallets that can dump on the community. 

Token Information
1. 1,000,000,000,000 Total Supply
3. Developer provides LP
4. Fair launch for everyone! 
5. 0,2% transaction limit on launch
6. Buy limit lifted after launch
7. Sells limited to 3% of the Liquidity Pool, <2.9% price impact 
8. Sell cooldown increases on consecutive sells, 4 sells within a 24 hours period are allowed
9. 2% redistribution to holders on all buys
10. 7% redistribution to holders on the first sell, increases 2x, 3x, 4x on consecutive sells
11. Redistribution actually works!
12. 5-6% developer fee split within the team

                ..`                                `..                
             /dNdhmNy.                          .yNmhdMd/             
            yMMdhhhNMN-                        -NMNhhhdMMy            
           oMMmhyhhyhMN-                      -NMhyhhyhmMMs           
          /MMNhs/hhh++NM+                    +MN++hhh/shNMM/          
         .NMNhy`:hyyh:-mMy`                `yMm::hyyh:`yhNMN.         
        `mMMdh. -hyohy..yNh.`............`.yNy..yhoyh- .hdMMm`        
        hMMdh:  .hyosho...-:--------------:-...ohsoyh.  :hdMMh        
       oMMmh+   .hyooyh/...-::---------:::-.../hyooyh.   +hmMMo       
      /MMNhs    `hyoooyh-...://+++oo+++//:...-hyoooyh`    shNMM/      
     .NMNhy`     hhoooshysyhhhhhhhhhhhhhhhhysyhsooohh     `yhNMN-     
    `mMMdh.      yhsyhyso+::-.```....```.--:/osyhyshy      .hdMMm`    
    yMMmh/      -so/-`            ..            `-/os-      /hmMMh    
   /MMyhy      .`                 ``                 `.      shyMM/   
   mN/+h/                                                    /h+/Nm   
  :N:.sh.                                                    .hs.:N/  
  s-./yh`                                                    `hy/.-s  
  .`:/yh`                                                    `hy/:`-  
 ``-//yh-                                                    .hy//-`` 
 ``://oh+      `                                      `      +ho//:`` 
``.://+yy`     `+`                                  `+`     `yh+//:.``
``-///+oho      /y:                                :y/      ohs+///-``
``:////+sh/ ``  `yhs-                            -shy`  `` /hs+////:``
``:////++sh/  ```:syhs-                        -shys:```  /hs++////:``
``://///++sho`    `.-/+o/.                  ./o+/-.`    `+hs++/////:``
``://///+++oyy-      ``..--.              .--..``      -yyo+++/////:``
``-/////+++++shs.       ``...            ...``       .ohs+++++/////-``
 ``/////+++++++shs-        ..`          `..        -shs+++++++/////`` 
 ``-/////++++++++oys-       ..`        `..       -syo++++++++/////-`` 
  ``:////++++:-....+yy:      ..        ..      :yy+....-:++++////:``  
   `.////+++:-......./yy:     ..      ..     :yy/.......-:+++////.`   
    `.////++ooo+/-...../yy/`   .`    `.   `/yy/.....-/+ooo++////.`    
     `.////+++oooos+/:...:sy/`  .    .  `/ys:...:/+soooo+++////.`     
      `.:////+++++ooooso/:.:sh+` .  . `+hs:.:/osoooo+++++////:.`      
        `-//////++++++ooooso++yh+....+hy++osoooo++++++//////-`        
         `.:///////+++++++oooossyhoohyssoooo++++++////////:.`         
            .:/+++++++++++++++ooosyysooo++++++++++++++//:.            
              `-/+++++++++++++++oooooo+++++++++++++++/-`              
                 .-/++++++++++++++++++++++++++++++/-.                 
                    `.-//++++++++++++++++++++//-.`                    
                         `..-::://////:::-..`                         
                                                                      
                                                                      
                                                                      

SPDX-License-Identifier: Mines™®©
*/

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }
}

contract Ownable is Context {
    address private _owner;
    address private _previousOwner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

interface IUniswapV2Router02 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function addLiquidityETH(
        address token,
        uint256 amountTokenDesired,
        uint256 amountTokenMin,
        uint256 amountETHMin,
        address to,
        uint256 deadline
    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);
}



// You task is to complete the smart contract Myobu strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.4, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title Myobu
 * @notice This contract implements a token with features like fee management, cooldowns, and trading controls.
 * @dev The contract extends Context, IERC20, and Ownable. It includes functionalities for managing fees, cooldown periods,
 *      and trading restrictions. The contract also integrates with Uniswap for liquidity and swapping.
 */
contract Myobu is Context, IERC20, Ownable {
    using SafeMath for uint256;

    string private constant _name = unicode"Myōbu";
    string private constant _symbol = "MYOBU";
    uint8 private constant _decimals = 9;
    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _tOwned;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => bool) private _isExcludedFromFee;
    uint256 private constant MAX = ~uint256(0);
    uint256 private constant _tTotal = 1000000000000 * 10**9;
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    uint256 private _taxFee = 7;
    uint256 private _teamFee = 5;
    mapping(address => bool) private bots;
    mapping(address => uint256) private buycooldown;
    mapping(address => uint256) private sellcooldown;
    mapping(address => uint256) private firstsell;
    mapping(address => uint256) private sellnumber;
    address payable private _teamAddress;
    address payable private _marketingFunds;
    IUniswapV2Router02 private uniswapV2Router;
    address private uniswapV2Pair;
    bool private tradingOpen = false;
    bool private liquidityAdded = false;
    bool private inSwap = false;
    bool private swapEnabled = false;
    bool private cooldownEnabled = false;
    uint256 private _maxTxAmount = _tTotal;

    event MaxTxAmountUpdated(uint256 _maxTxAmount);

    modifier lockTheSwap {
        inSwap = true;
        _;
        inSwap = false;
    }

    /**
     * @notice Initializes the contract, setting the initial token distribution and excluded addresses from fees.
     * @param addr1 The address of the team wallet.
     * @param addr2 The address of the marketing funds wallet.
     * @dev Sets the initial token balances, excludes certain addresses from fees, and emits the initial token transfer event.
     */
    constructor(address payable addr1, address payable addr2) {
        _teamAddress = addr1;
        _marketingFunds = addr2;
        _rOwned[_msgSender()] = _rTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;
        _isExcludedFromFee[_teamAddress] = true;
        _isExcludedFromFee[_marketingFunds] = true;
        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    /**
     * @notice Returns the name of the token.
     * @return The name of the token.
     * @dev This function is used to get the token's name.
     */
    function name() public pure returns (string memory) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @return The symbol of the token.
     * @dev This function is used to get the token's symbol.
     */
    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    /**
     * @notice Returns the number of decimals the token uses.
     * @return The number of decimals.
     * @dev This function is used to get the token's decimal precision.
     */
    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    /**
     * @notice Returns the total supply of the token.
     * @return The total supply of the token.
     * @dev This function is used to get the total supply of the token.
     */
    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    /**
     * @notice Returns the balance of the specified address.
     * @param account The address to query the balance of.
     * @return The balance of the specified address.
     * @dev This function is used to get the balance of an address.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return tokenFromReflection(_rOwned[account]);
    }

    /**
     * @notice Transfers tokens from the sender to the recipient.
     * @param recipient The recipient address.
     * @param amount The amount of tokens to transfer.
     * @return A boolean indicating whether the operation succeeded.
     * @dev This function is used to transfer tokens between addresses.
     */
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @notice Returns the remaining allowance for the spender to spend tokens on behalf of the owner.
     * @param owner The address of the token owner.
     * @param spender The address of the spender.
     * @return The remaining allowance.
     * @dev This function is used to check the remaining allowance for a spender.
     */
    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @notice Approves the spender to spend a specific amount of tokens on behalf of the owner.
     * @param spender The address of the spender.
     * @param amount The amount of tokens to approve.
     * @return A boolean indicating whether the operation succeeded.
     * @dev This function is used to set the allowance for a spender.
     */
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @notice Transfers tokens from one address to another, using the allowance mechanism.
     * @param sender The address of the token sender.
     * @param recipient The address of the token recipient.
     * @param amount The amount of tokens to transfer.
     * @return A boolean indicating whether the operation succeeded.
     * @dev This function is used to transfer tokens from one address to another, using the allowance mechanism.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @notice Enables or disables the cooldown feature.
     * @param onoff A boolean to enable or disable the cooldown.
     * @dev This function is used to control the cooldown feature.
     */
    function setCooldownEnabled(bool onoff) external onlyOwner() {
        cooldownEnabled = onoff;
    }

    /**
     * @notice Converts reflection tokens to actual tokens.
     * @param rAmount The amount of reflection tokens to convert.
     * @return The amount of actual tokens.
     * @dev This function is used to convert reflection tokens to actual tokens.
     */
    function tokenFromReflection(uint256 rAmount) private view returns (uint256) {
        require(rAmount <= _rTotal, "Amount must be less than total reflections");
        uint256 currentRate = _getRate();
        return rAmount.div(currentRate);
    }

    /**
     * @notice Removes all fees.
     * @dev This function is used to remove all fees.
     */
    function removeAllFee() private {
        _taxFee = 0;
        _teamFee = 0;
    }

    /**
     * @notice Restores all fees to their original values.
     * @dev This function is used to restore all fees to their original values.
     */
    function restoreAllFee() private {
        _taxFee = 7;
        _teamFee = 5;
    }

    /**
     * @notice Sets the fee based on a multiplier.
     * @param multiplier The multiplier to apply to the fees.
     * @dev This function is used to set the fee based on a multiplier and `teamfee` to be set 10.
     */
    function setFee(uint256 multiplier) private {
        _taxFee = 7 * multiplier;
        _teamFee = 5 * multiplier;
    }

    /**
     * @notice Approves a spender to spend a specific amount of tokens on behalf of the owner.
     * @param owner The address of the token owner.
     * @param spender The address of the spender.
     * @param amount The amount of tokens to approve.
     * @dev This function is used to set the allowance for a spender.
     */
    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Handles token transfers with comprehensive trading restrictions, cooldowns, and fee management.
     * This private function performs the following operations:
     * 1. Validates basic transfer requirements (non-zero addresses, positive amount)
     * 2. Enforces Uniswap-only access for certain router interactions
     * 3. Blocks transactions from/to bot addresses
     * 4. Implements buy-side restrictions (cooldown, max amount, fees) for trades through Uniswap pair
     * 5. Manages sell-side cooldowns with progressive time increases based on sell frequency
     * 6. Executes token/ETH swaps when conditions are met
     * 7. Applies fees based on transfer context (buy/sell/excluded)
     * 8. Performs the actual token transfer with/without fees
     * 
     * @param from The address of the token sender
     * @param to The address of the token recipient
     * @param amount The amount of tokens to transfer
     * @notice Key features and restrictions:
     *         - Only Uniswap router/pair can interact under certain conditions
     *         - Bot addresses are completely blocked
     *         - Buy-side has cooldown (30 seconds) and max transaction limit
     *         - Sell-side has progressive cooldowns (1h → 2h → 6h → 1d)
     *         - Fees are dynamically set based on sell frequency (1-4 sells)
     *         - Excluded addresses bypass all fees
     * @dev Important implementation details:
     *      - Uses internal _tokenTransfer for actual transfer execution
     *      - Maintains separate cooldown trackers for buyers/sellers
     *      - Implements progressive sell cooldown system
     *      - Includes protection against flash loans through swap mechanics
     *      - Automatically restores all fees after transfer
     */
    function _transfer(address from, address to, uint256 amount) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        if (!tradingOpen && from != owner() && to != owner()) {
            require(from == address(uniswapV2Router) || to == address(uniswapV2Router), "Trading is not yet open.");
        }

        if (bots[from] || bots[to]) {
            require(false);
        }

        bool takeFee = true;

        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {
            takeFee = false;
        }

        if (cooldownEnabled && to == uniswapV2Pair && from != address(uniswapV2Router)) {
            require(buycooldown[from] < block.timestamp, "Cooldown still active");
            buycooldown[from] = block.timestamp + 30;
        }

        if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {
             uint256 time = 3600;
            if(firstsell[to] == 0){
                firstsell[to] = block.timestamp;
                sellnumber[to] = 1;
            }
            else{
                sellnumber[to] = sellnumber[to] + 1;
            }
            if(sellnumber[to] > 4){
                sellnumber[to] = 4;
            }
            if(sellnumber[to] == 2){
                time = 7200;
            }
            if(sellnumber[to] == 3){
                time = 21600;
            }
            if(sellnumber[to] == 4){
                time = 86400;
            }
            require(sellcooldown[to] < block.timestamp, "Sell cooldown active");
            sellcooldown[to] = block.timestamp + time;
            setFee(sellnumber[to]);
        } else {
            setFee(1);
        }

        if (inSwap) {
            return;
        }

        if (swapEnabled && !inSwap && from != uniswapV2Pair && _tOwned[address(this)] > 0) {
            swapTokensForEth(balanceOf(address(this)));
            sendETHToFee(address(this).balance);
        }

        _tokenTransfer(from, to, amount, takeFee);
        restoreAllFee();
    }

    /**
     * @notice Swaps tokens for ETH.
     * @param tokenAmount The amount of tokens to swap.
     * @dev This function is used to swap tokens for ETH.
     */
    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        _approve(address(this), address(uniswapV2Router), tokenAmount);
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    /**
     * @notice Sends ETH to the team and marketing funds wallets.
     * @param amount The amount of ETH to send.
     * @dev This function is used to distribute ETH to the team and marketing funds wallets.
     */
    function sendETHToFee(uint256 amount) private {
        _teamAddress.transfer(amount.mul(50).div(100));
        _marketingFunds.transfer(amount.mul(50).div(100));
    }

    /**
     * @notice Opens trading for the token.
     * @dev This function is used to open trading for the token.
     */
    function openTrading() public onlyOwner {
        tradingOpen = true;
        swapEnabled = true;
    }

    /**
     * @notice Manually swaps tokens for ETH.
     * @dev This function is used to manually swap tokens for ETH.
     */
    function manualswap() external {
        require(_msgSender() == _teamAddress || _msgSender() == _marketingFunds);
        uint256 contractBalance = balanceOf(address(this));
        swapTokensForEth(contractBalance);
    }

    /**
     * @notice Manually sends ETH to the team and marketing funds wallets.
     * @dev This function is used to manually send ETH to the team and marketing funds wallets.
     */
    function manualsend() external {
        require(_msgSender() == _teamAddress || _msgSender() == _marketingFunds);
        sendETHToFee(address(this).balance);
    }

    /**
     * @notice Transfers tokens from one address to another, optionally taking fees.
     * @param sender The address of the token sender.
     * @param recipient The address of the token recipient.
     * @param amount The amount of tokens to transfer.
     * @param takeFee A boolean to indicate whether to take fees.
     * @dev This function is used to transfer tokens from one address to another, optionally taking fees.
     */
    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {
        if (!takeFee) {
            removeAllFee();
        }

        if(sender == uniswapV2Pair && ! _isExcludedFromFee[recipient]){
            require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");
        }
        
        if (sender == uniswapV2Pair && recipient != address(uniswapV2Router) && ! _isExcludedFromFee[recipient] && liquidityAdded) {
            uint256 contractETHBalance = address(this).balance;
            if (contractETHBalance > 0) {
                sendETHToFee(contractETHBalance);
            }
        }

        if (_isExcludedFromFee[sender] && _isExcludedFromFee[recipient] ) {
            removeAllFee();
        }

        if (takeFee) {
            uint256 currentRate = _getRate();
            (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(amount);
            _rOwned[sender] = _rOwned[sender].sub(rAmount);
            _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
            _takeTeam(tTeam);
            _reflectFee(rFee, tFee);
            emit Transfer(sender, recipient, tTransferAmount);
        } else {
            _transferStandard(sender, recipient, amount);
        }

    }

    /**
     * @notice Transfers tokens from one address to another, applying standard fees.
     * @param sender The address of the token sender.
     * @param recipient The address of the token recipient.
     * @param tAmount The amount of tokens to transfer.
     * @dev This function is used to transfer tokens from one address to another, applying standard fees.
     */
    function _transferStandard(address sender, address recipient, uint256 tAmount) private {
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    /**
     * @notice Takes a portion of the tokens as a team fee.
     * @param tTeam The amount of tokens to take as a team fee.
     * @dev This function is used to take a portion of the tokens as a team fee.
     */
    function _takeTeam(uint256 tTeam) private {
        uint256 currentRate = _getRate();
        uint256 rTeam = tTeam.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rTeam);
    }

    /**
     * @notice Reflects the fee by reducing the total supply.
     * @param rFee The amount of reflection tokens to reflect as a fee.
     * @param tFee The amount of tokens to reflect as a fee.
     * @dev This function is used to reflect the fee by reducing the total supply.
     */
    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
    }

    /**
     * @notice Receives ETH.
     * @dev This function is used to receive ETH.
     */
    receive() external payable {}

    /**
     * @dev Calculates both token (t) and reserve (r) values for a transfer amount, 
     *      including fees and converted amounts.
     * This function:
     * 1. Gets token-level values (amounts after fees) using _getTValues
     * 2. Converts these to reserve values using current exchange rate via _getRValues
     * 3. Returns all calculated values (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam)
     * 
     * @param tAmount The transfer amount in tokens
     * @return rAmount Total amount in reserves before fees
     * @return rTransferAmount Amount in reserves after fees (transferable amount)
     * @return rFee Fee amount in reserves
     * @return tTransferAmount Amount in tokens after fees (transferable amount)
     * @return tFee Fee amount in tokens
     * @return tTeam Team allocation amount in tokens
     * @notice This is the main calculation function that combines token and reserve     calculations.
     */
    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {
        (uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getTValues(tAmount, _taxFee, _teamFee);
        uint256 currentRate = _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tTeam, currentRate);
        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tTeam);
    }

    /**
     * @dev Calculates token-level values (amounts after fees) for a transfer.
     * This pure function:
     * 1. Takes a token amount and fee percentages
     * 2. Calculates the fee amounts (tax + team)
     * 3. Returns the transferable amount after fees
     * @param tAmount The transfer amount in tokens
     * @param taxFee The percentage fee for tax (out of 100)
     * @param teamFee The percentage fee for team allocation (out of 100)
     * @return tTransferAmount Amount in tokens after fees (transferable)
     * @return tFee Tax fee amount in tokens
     * @return tTeam Team allocation amount in tokens
     * @notice This is a pure mathematical calculation without any state access.
     *         It only operates on the input parameters.
     */
    function _getTValues(uint256 tAmount, uint256 taxFee, uint256 teamFee) private pure returns (uint256, uint256, uint256) {
        uint256 tFee = tAmount.mul(taxFee).div(100);
        uint256 tTeam = tAmount.mul(teamFee).div(100);
        uint256 tTransferAmount = tAmount.sub(tFee).sub(tTeam);
        return (tTransferAmount, tFee, tTeam);
    }

    /**
     * @dev Converts token-level values to reserve values using the current exchange rate.
     * This pure function:
     * 1. Takes token amounts (including fees) and current rate
     * 2. Converts all amounts to reserve values
     * 3. Returns the converted amounts with fees subtracted
     * @param tAmount Original amount in tokens
     * @param tFee Fee amount in tokens
     * @param tTeam Team allocation amount in tokens
     * @param currentRate Exchange rate (tokens per reserve unit)
     * @return rAmount Total amount in reserves before fees
     * @return rTransferAmount Amount in reserves after fees (transferable)
     * @return rFee Fee amount in reserves
     * @notice This function performs currency conversion using the rate.
     *         It's used after _getTValues to get reserve equivalents.
     */
    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tTeam, uint256 currentRate) private pure returns (uint256, uint256, uint256) {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        uint256 rTeam = tTeam.mul(currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rTeam);
        return (rAmount, rTransferAmount, rFee);
    }

    /**
     * @notice Gets the current rate