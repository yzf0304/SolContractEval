// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title N
 * @notice A simple ERC721 token contract that allows minting of a single token, with ownership transfer and URI setting functionalities.
 * @dev This contract is designed to be minimalistic and only supports the basic functionalities of an ERC721 token.
 */
contract N {
  uint public tokenId = 1;
  mapping(address => uint) public collectors;
  address _owner;
  address _tokenOwner;
  string _uri;

  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

  constructor() { _owner = msg.sender; }

  /**
   * @notice Checks if the contract implements the given interface.
   * @dev Supports IERC721, IERC721Metadata, and IERC165 interfaces.
   * @param interfaceId The interface identifier, as specified in ERC-165.
   * @return bool True if the contract implements the interface, false otherwise.
   */
  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
    return (
      interfaceId == type(IERC721).interfaceId ||
      interfaceId == type(IERC721Metadata).interfaceId ||
      interfaceId == type(IERC165).interfaceId
    );
  }

  /**
   * @notice Returns the owner of the specified token ID.
   * @dev Throws if the token ID is invalid.
   * @param _tokenId The ID of the token to query the owner of.
   * @return address The owner of the token.
   */
  function ownerOf(uint256 _tokenId) public view virtual returns (address) {
    require(_tokenId == tokenId, "ERC721: invalid token ID");
    require(_tokenOwner != address(0), "ERC721: owner query for non-existent token");
    return _tokenOwner;
  }

  /**
   * @notice Returns the number of tokens in `owner`'s account.
   * @dev Since this contract only supports one token, the balance will always be either 0 or 1.
   * @param owner Address for whom to query the balance.
   * @return uint256 The number of tokens owned by `owner`.
   */
  function balanceOf(address owner) public view virtual returns (uint256) {
    return (_tokenOwner == owner) ? 1 : 0;
  }

  /**
   * @notice Mints a new token and assigns it to the caller.
   * @dev Only the contract owner can call this function initially. If a token already exists, it will be burned and re-minted.
   */
  function mint() external onlyOwner {
    if (_tokenOwner != address(0)) {
      address previousOwner = _tokenOwner;
      _tokenOwner = address(0);
      emit Transfer(previousOwner, address(0), tokenId);
    }
    _tokenOwner = msg.sender;
    emit Transfer(address(0), msg.sender, tokenId);
  }

  /**
   * @notice Returns a URI for a given token ID.
   * @dev The URI is constructed based on the token ID and the set URI.
   * @param _tokenId The ID of the token to generate a URI for.
   * @return string The URI of the token.
   */
  function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {
    require(_tokenId == tokenId, "ERC721: invalid token ID");
    return string(
      abi.encodePacked(
        "data:application/json;utf8,",
        '{"name":"N. #',_toString(tokenId),'","created_by":"', address(this), '","description":"","image":"',
        bytes(_uri).length > 0 ? _uri : 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJ5ZXMiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIHN0eWxlPSJ3aWR0aDogMTAwdmg7IGhlaWdodDogMTAwdmg7IG1heC13aWR0aDogMTAwJTsgbWF4LWhlaWdodDogMTAwJTsgbWFyZ2luOiBhdXRvIj4KICA8IS0tIE4uIOKAkyDCqSAweEcgLS0+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9IjB4R19iZyIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMTExIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSIweEdfbCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMDAwIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIHN0b3Atb3BhY2l0eT0iMCIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8ZmlsdGVyIGlkPSIweEdfbm9pc2UiPgogICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iNSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIgLz4KICAgICAgPGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIgLz4KICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICAgICAgPGZlRnVuY1IgdHlwZT0ibGluZWFyIiBzbG9wZT0iMC41IiAvPgogICAgICAgIDxmZUZ1bmNHIHR5cGU9ImxpbmVhciIgc2xvcGU9IjAuNSIgLz4KICAgICAgICA8ZmVGdW5jQiB0eXBlPSJsaW5lYXIiIHNsb3BlPSIwLjUiIC8+CiAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgICAgPGZlQmxlbmQgbW9kZT0ic2NyZWVuIiAvPgogICAgPC9maWx0ZXI+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9InVybCgjMHhHX2JnKSIgLz4KICA8cmVjdCBoZWlnaHQ9IjUwMCIgd2lkdGg9IjUwMCIgeT0iMjUwIiB4PSIyNTAiIGZpbGw9InVybCgjMHhHX2wpIiAgLz4KICA8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWx0ZXI9InVybCgjMHhHX25vaXNlKSIgb3BhY2l0eT0iMC4xIi8+Cjwvc3ZnPgo=',
        '"}'
      )
    );
  }

  /**
   * @notice Returns the name of the token.
   * @return string The name of the token.
   */
  function name() public view virtual returns (string memory) {
    return "N.";
  }

  /**
   * @notice Returns the symbol of the token.
   * @return string The symbol of the token.
   */
  function symbol() public view virtual returns (string memory) {
    return "N";
  }

  /**
   * @notice Returns the owner of the contract.
   * @return address The owner of the contract.
   */
  function owner() public view virtual returns (address) {
    return _owner;
  }

  /**
   * @notice Modifier to ensure that only the contract owner can call certain functions.
   */
  modifier onlyOwner {
    require(msg.sender == _owner, "Unauthorized");
    _;
  }

  /**
   * @notice Event emitted when the contract ownership is transferred.
   * @param previousOwner The previous owner of the contract.
   * @param newOwner The new owner of the contract.
   */
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @notice Transfers the ownership of the contract to a new address.
   * @dev Only the current owner can call this function.
   * @param _new The new owner's address.
   */
  function transferOwnership(address _new) external virtual onlyOwner {
    require(_new != address(0), "Ownable: new owner is the zero address");
    emit OwnershipTransferred(_owner, _new);
    _owner = _new;
  }

  /**
   * @notice Sets the URI for the token.
   * @dev Only the contract owner can call this function.
   * @param _new The new URI.
   */
  function setUri(string calldata _new) external onlyOwner {
    _uri = _new;
  }

  /**
   * @notice Converts a uint256 to its ASCII string representation.
   * @dev This function is taken from "@openzeppelin/contracts/utils/Strings.sol".
   * @param value The value to convert.
   * @return string The ASCII string representation of the value.
   */
  function _toString(uint256 value) internal pure returns (string memory) {
    // Inspired by OraclizeAPI's implementation - MIT licence
    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d16cb78e9ddbe5c14c167c7c6329/oraclizeAPI_0.4.25.sol

    if (value == 0) {
      return "0";
    }
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
      digits++;
      temp /= 10;
    }
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
      digits -= 1;
      buffer(digits) = bytes1(uint8(48 + uint256(value % 10)));
      value /= 10;
    }
    return string(buffer);
  }
}

interface IERC165 {
  /**
   * @dev Returns true if this contract implements the interface defined by
   * `interfaceId`. See the corresponding
   * https://eips.ethereum.org/EIPS/eip-165#how-to-detect-interface-support
   * section to learn more about how these ID are created.
   *
   * This function call must not revert if the contract does not implement
   * the interface id.
   */
  function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC721 is IERC165 {
  /**
   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
   *
   * Requirements:
   *
   * - MUST emit when token ownership is transferred.
   * - MUST emit when approval for a token is set or cleared.
   *
   * Note: the transfer of tokens between accounts with identical on-chain
   * identity (e.g., smart contracts that own other smart contracts) may
   * be interpreted differently by some interfaces, as per the
   * https://eips.ethereum.org/EIPS/eip-721#transfers-between-contracts
   * section.
   */
  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

  /**
   * @dev Returns the number of tokens in ``owner``'s account.
   */
  function balanceOf(address owner) external view returns (uint256);

  /**
   * @dev Returns the owner of the `tokenId` token.
   *
   * Requirements:
   *
   * - MUST revert if `tokenId` is not valid.
   */
  function ownerOf(uint256 tokenId) external view returns (address);

  /**
   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
   * are aware of the ERC721 protocol to prevent tokens from being forever locked.
   *
   * Requirements:
   *
   * - If `to` refers to a smart contract, it MUST implement
   *   {IERC721Receiver.onERC721Received}, which is called upon a safe transfer.
   * - Emits a {Transfer} event.
   */
  function safeTransferFrom(
    address from,
    address to,
    uint256 tokenId,
    bytes calldata data
  ) external;

  /**
   * @dev Safely transfers `tokenId` token from `from` to `to`.
   *
   * Requirements:
   *
   * - If `to` refers to a smart contract, it MUST implement
   *   {IERC721Receiver.onERC721Received}, which is called upon a safe transfer.
   * - Emits a {Transfer} event.
   */
  function safeTransferFrom(
    address from,
    address to,
    uint256 tokenId
  ) external;

  /**
   * @dev Transfers `tokenId` token from `from` to `to`.
   *
   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
   *
   * Requirements:
   *
   * - MUST revert if `from` is not the owner or approved for the token.
   * - MUST revert if `to` is the zero address.
   * - MUST emit a {Transfer} event.
   */
  function transferFrom(
    address from,
    address to,
    uint256 tokenId
  ) external;

  /**
   * @dev Approve `spender` to operate on `tokenId` token
   *
   * Emits an {Approval} event.
   */
  function approve(address spender, uint256 tokenId) external;

  /**
   * @dev Returns the account approved for `tokenId` token.
   *
   * Requirements:
   *
   * - MUST revert if `tokenId` is not valid.
   */
  function getApproved(uint256 tokenId) external view returns (address);

  /**
   * @dev Approve or unapprove to the operator can manage all of the caller's tokens.
   *
   * Emits an {ApprovalForAll} event.
   */
  function setApprovalForAll(address operator, bool approved) external;

  /**
   * @dev Returns if the `operator` is allowed to manage all of the `owner`'s tokens.
   *
   * See {setApprovalForAll}
   */
  function isApprovedForAll(address owner, address operator) external view returns (bool);
}

interface IERC721Metadata is IERC721 {
  /**
   * @dev Returns a human-readable string that represents the token name.
   */
  function name() external view returns (string memory);

  /**
   * @dev Returns a human-readable string that represents the token symbol.
   */
  function symbol() external view returns (string memory);

  /**
   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
   */
  function tokenURI(uint256 tokenId) external view returns (string memory);
}
