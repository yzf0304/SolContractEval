// Below are some contexts potentially relevant to contract code generation.

// You task is to complete the smart contract N strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.17, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title N
 * @notice A simple ERC721 token contract that allows minting of a single token, with ownership transfer and URI setting functionalities.
 * @dev This contract is designed to be minimalistic and only supports the basic functionalities of an ERC721 token.
 */
contract N {
  uint public tokenId;
  mapping(address => uint) public collectors;
  address _owner;
  address _tokenOwner;
  string _uri;

  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

  constructor() { _owner = msg.sender; }

  /**
   * @notice Checks if the contract implements the given interface.
   * @dev Supports IERC721, IERC721Metadata, and IERC165 interfaces.
   * @param interfaceId The interface identifier, as specified in ERC-165.
   * @return bool True if the contract implements the interface, false otherwise.
   */
  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
    return (
      interfaceId == /* IERC721 */ 0x80ac58cd ||
      interfaceId == /* IERC721Metadata */ 0x5b5e139f ||
      interfaceId == /* IERC165 */ 0x01ffc9a7
    );
  }

  /**
   * @notice Returns the owner of the specified token ID.
   * @dev Throws if the token ID is invalid.
   * @param _tokenId The ID of the token to query the owner of.
   * @return address The owner of the token.
   */
  function ownerOf(uint256 _tokenId) public view virtual returns (address) {
    require(_tokenId == tokenId, "ERC721: invalid token ID");
    return _tokenOwner;
  }

  /**
   * @notice Returns the number of tokens in `owner`'s account.
   * @dev Since this contract only supports one token, the balance will always be either 0 or 1.
   * @param owner Address for whom to query the balance.
   * @return uint256 The number of tokens owned by `owner`.
   */
  function balanceOf(address owner) public view virtual returns (uint256) {
    return owner == _tokenOwner ? 1 : 0;
  }

  /**
   * @notice Mints a new token and assigns it to the caller.
   * @dev Only the contract owner can call this function initially. If a token already exists, it will be burned and re-minted.
   */
  function mint() external onlyOwner {
    if (_tokenOwner != address(0)) {
      // Simulate burning by resetting the owner
      emit Transfer(_tokenOwner, address(0), tokenId);
    }
    tokenId = 1;
    _tokenOwner = msg.sender;
    emit Transfer(address(0), msg.sender, tokenId);
  }

  /**
   * @notice Returns a URI for a given token ID.
   * @dev The URI is constructed based on the token ID and the set URI.
   * @param _tokenId The ID of the token to generate a URI for.
   * @return string The URI of the token.
   */
  function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {
    require(_tokenId == tokenId, "ERC721: invalid token ID");

    return string(
      abi.encodePacked(
        "data:application/json;utf8,",
        '{"name":"N. #',toString(tokenId),'","created_by":"',
        toString(uint160(_owner)),
        '","description":"","image":"',
        bytes(_uri).length > 0 ? _uri : 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJ5ZXMiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIHN0eWxlPSJ3aWR0aDogMTAwdmg7IGhlaWdodDogMTAwdmg7IG1heC13aWR0aDogMTAwJTsgbWF4LWhlaWdodDogMTAwJTsgbWFyZ2luOiBhdXRvIj4KICA8IS0tIE4uIOKAkyDCqSAweEcgLS0+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9IjB4R19iZyIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMTExIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSIweEdfbCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMDAwIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIHN0b3Atb3BhY2l0eT0iMCIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8ZmlsdGVyIGlkPSIweEdfbm9pc2UiPgogICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iNSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIgLz4KICAgICAgPGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIgLz4KICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICAgICAgPGZlRnVuY1IgdHlwZT0ibGluZWFyIiBzbG9wZT0iMC41IiAvPgogICAgICAgIDxmZUZ1bmNHIHR5cGU9ImxpbmVhciIgc2xvcGU9IjAuNSIgLz4KICAgICAgICA8ZmVGdW5jQiB0eXBlPSJsaW5lYXIiIHNsb3BlPSIwLjUiIC8+CiAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgICAgPGZlQmxlbmQgbW9kZT0ic2NyZWVuIiAvPgogICAgPC9maWx0ZXI+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9InVybCgjMHhHX2JnKSIgLz4KICA8cmVjdCBoZWlnaHQ9IjUwMCIgd2lkdGg9IjUwMCIgeT0iMjUwIiB4PSIyNTAiIGZpbGw9InVybCgjMHhHX2wpIiAgLz4KICA8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWx0ZXI9InVybCgjMHhHX25vaXNlKSIgb3BhY2l0eT0iMC4xIi8+Cjwvc3ZnPgo=',
        '"}'
      )
    );
  }

  /**
   * @notice Returns the name of the token.
   * @return string The name of the token.
   */
  function name() public view virtual returns (string memory) {
    return "N.";
  }

  /**
   * @notice Returns the symbol of the token.
   * @return string The symbol of the token.
   */
  function symbol() public view virtual returns (string memory) {
    return "N";
  }

  /**
   * @notice Returns the owner of the contract.
   * @return address The owner of the contract.
   */
  function owner() public view virtual returns (address) {
    return _owner;
  }

  /**
   * @notice Modifier to ensure that only the contract owner can call certain functions.
   */
  modifier onlyOwner {
    require(msg.sender == _owner, "Unauthorized");
    _;
  }

  /**
   * @notice Event emitted when the contract ownership is transferred.
   * @param previousOwner The previous owner of the contract.
   * @param newOwner The new owner of the contract.
   */
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  /**
   * @notice Transfers the ownership of the contract to a new address.
   * @dev Only the current owner can call this function.
   * @param _new The new owner's address.
   */
  function transferOwnership(address _new) external virtual onlyOwner {
    require(_new != address(0), "Ownable: new owner is the zero address");
    emit OwnershipTransferred(_owner, _new);
    _owner = _new;
  }

  /**
   * @notice Sets the URI for the token.
   * @dev Only the contract owner can call this function.
   * @param _new The new URI.
   */
  function setUri(string calldata _new) external onlyOwner {
    _uri = _new;
  }

  /**
   * @notice Converts a uint256 to its ASCII string representation.
   * @dev This function is taken from "@openzeppelin/contracts/utils/Strings.sol".
   * @param value The value to convert.
   * @return string The ASCII string representation of the value.
   */
  function toString(uint256 value) internal pure returns (string memory) {
    // Inspired by OraclizeAPI's implementation - MIT licence
    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d16cb785378347e99d101670f906/oraclizeAPI_0.4.25.sol

    if (value == 0) {
      return "0";
    }
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
      digits++;
      temp /= 10;
    }
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
      digits -= 1;
      buffer [digits] = bytes1(uint8(48 + uint256(value % 10)));
      value /= 10;
    }
    return string(buffer);
  }
}