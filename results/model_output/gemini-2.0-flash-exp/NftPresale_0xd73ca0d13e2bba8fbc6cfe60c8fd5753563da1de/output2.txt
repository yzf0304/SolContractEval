```solidity
// SPDX-License-Identifier: MIT
/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */

abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface INFT {
	function mint(address _to) external;
	function mintBatch(address _to, uint _amount) external;
}

interface INftPresale {
	function buy(uint _amount, bytes memory _signature) external payable;
}



// You task is to complete the smart contract NftPresale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title NftPresale
 * @author [Your Name]
 * @notice This contract allows for a presale of NFTs, where users can buy one token each during a specified time window.
 * @dev The contract includes functionality to verify signatures and ensures that only authorized purchases are made. 
 * It also supports withdrawing funds by the owner.
 */
contract NftPresale is INftPresale, Ownable {

    uint public constant START_TIME = 1634929200;
    uint public constant FINISH_TIME = 1635015600;
    uint public constant PRE_SALE_PRICE = 0.2 ether;

    INFT public nft;
    
    address public verifyAddress = 0x142581fda5769fe7f8d3b50794dBda454DA4F3ac;
    mapping(address => bool) public buyers;
    
    address payable public receiver;

    /**
     * @notice Initializes the contract with the NFT contract address and the receiver's address.
     * @param _nftAddress The address of the NFT contract.
     * @param _receiverAddress The address to receive the funds from the presale.
     */
    constructor(address _nftAddress, address payable _receiverAddress) {
        nft = INFT(_nftAddress);
        
        //receiver - 0xD3db8094b50F2F094D164C1131BB9E604dfe0590
        receiver = _receiverAddress;
    }

    /**
     * @notice Allows a user to buy one NFT during the presale period.
     * @dev Ensures that the purchase is within the presale time, the correct amount is paid, and the signature is valid.
     * @param _amount The number of tokens to buy (must be 1).
     * @param _signature The signed message from the verifyAddress.
     */
    function buy(uint _amount, bytes memory _signature) external override payable {
        require(block.timestamp >= START_TIME && block.timestamp <= FINISH_TIME, "Presale is not active");
        require(_amount == 1, "You can only buy one token");
        require(msg.value >= PRE_SALE_PRICE, "Incorrect amount sent");
        require(!buyers[msg.sender], "You have already purchased a token");
        require(verify(_signature), "Invalid signature");

        buyers[msg.sender] = true;
        nft.mint(msg.sender);

        (bool success, ) = receiver.call{value: msg.value}("");
        require(success, "Transfer failed.");
    }

    /**
     * @notice Allows the contract owner to withdraw all ETH from the contract.
     * @dev Only the owner can call this function.
     * @param _to The address to send the ETH to.
     */
    function cashOut(address _to) public onlyOwner {
        (bool success, ) = payable(_to).call{value: address(this).balance}("");
        require(success, "Transfer failed.");
    }

    /**
     * @notice Verifies the signature against the verifyAddress.
     * @dev Uses the prefixed hash and ecrecover to validate the signature.
     * @param _signature The signature to verify.
     * @return bool True if the signature is valid, false otherwise.
     */
    function verify(bytes memory _signature) internal view returns(bool) {
        bytes32 message = keccak256(abi.encodePacked(msg.sender));
        address signer = recoverSigner(prefixed(message), _signature);
        return signer == verifyAddress;
    }

    /**
     * @notice Recovers the signer from the message and signature.
     * @dev Decodes the signature and uses ecrecover to find the signer.
     * @param message The message hash.
     * @param sig The signature.
     * @return address The recovered signer.
     */
    function recoverSigner(bytes32 message, bytes memory sig)
        internal
        pure
        returns (address)
    {
        require(sig.length == 65, "invalid signature length");
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }
        if (v < 27) {
            v += 27;
        }
        require(v == 27 || v == 28, "invalid signature 'v' value");
        return ecrecover(message, v, r, s);
    }

    /**
     * @dev Prepends the Ethereum signed message prefix to a hash and returns the resulting hash.
     * This function is typically used to prepare a hash for signature verification by adding the
     * standard Ethereum prefix that indicates the message was signed by an externally owned account (EOA).
     * The prefix format follows the Ethereum standard:
     * "\x19Ethereum Signed Message:\n32" followed by the original hash.
     * @param hash The original hash value to be prefixed.
     * @return bytes32 The resulting hash after prepending the Ethereum prefix.
     * @notice This function is marked as `pure` because it doesn't access any contract state.
     * @dev The resulting hash is what should be passed to ecrecover for verifying signatures created by externally owned accounts (EOAs) on Ethereum.
     */
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
    }
}
```