You have provided the Solidity code for a token contract named "PIKA". This contract implements the ERC20 interface and includes features like tax fees on transfers, integration with Uniswap V2 for liquidity and swapping, and owner-controlled functions for managing fees and ownership.

Here's a breakdown of the contract's key components:

*   **Libraries:** It utilizes the `SafeMath` library to prevent integer overflows and underflows in arithmetic operations.
*   **Inheritance:** It inherits from `Context` (for accessing `msg.sender` and `msg.data`), `Owned` (for implementing an owner role with transfer of ownership functionality), and implements the `ERC20` interface.
*   **State Variables:**
    *   `_taxFee`: Stores the accumulated tax fees.
    *   `totalSupply`: The total number of tokens in existence.
    *   `symbol`, `name`, `decimals`: Standard ERC20 metadata.
    *   `_taxFeepercent`: The percentage of tax applied to transfers (currently set to 225, which likely represents 2.25% if the calculation is `amount.mul(_taxFeepercent).div(10000)`).
    *   `uniswapV2Router`, `uniswapV2Pair`: Addresses for interacting with the Uniswap V2 router and the created pair for this token.
    *   `_isExcludedFromFee`: A mapping to track addresses that are exempt from paying transfer fees (owner and the contract itself are excluded).
    *   `ContractDeployed`: Stores the timestamp of contract deployment.
    *   `oldPika`: Address of a potentially previous token.
    *   `oldPika_amount`: Stores the amount of old Pika tokens exchanged.
    *   `minamountTakenOut`: Minimum amount of tokens that can be extracted (currently set to 1,000,000 * 10^9 * 10^9).
    *   `MinimumSupply`: The minimum allowed total supply (currently set to 100,000,000 * 10^9 * 10^9).
    *   `balances`: A mapping from address to token balance.
    *   `allowed`: A nested mapping for ERC20 allowance tracking.
*   **Events:**
    *   `TransferFee`: Emitted when a transfer fee is applied.
*   **Modifiers:**
    *   `onlyOwner`: Restricts function access to the contract owner (inherited from the `Owned` contract).
*   **Interfaces:** It interacts with `ERC20`, `IUniswapV2Factory`, and `IUniswapV2Router02`.
*   **Constructor:**
    *   Initializes the token's symbol, name, decimals, and total supply.
    *   Sets the contract deployer as the owner.
    *   Assigns the initial total supply to the owner's balance.
    *   Excludes the owner and the contract itself from transfer fees.
    *   Creates a Uniswap V2 pair for this token and ETH using the provided Uniswap Router address.
    *   Records the deployment timestamp.
*   **ERC20 Functions (Declared but Empty):** The contract declares the standard ERC20 functions (`balanceOf`, `transfer`, `transferFrom`, `approve`, `allowance`) but their implementations are currently empty.
*   **Internal Functions (Declared but Empty):** Internal functions like `_transfer`, `_approve`, `_burn`, and `calSwapToken` are declared without any implementation.
*   **Public/External Functions (Declared but Empty or Minimal):** Functions for viewing and setting configuration (`viewMinExtractAmt`, `setMinExtractAmt`, `viewFee`, `viewMinSupply`, `changeMinSupply`), exchanging old tokens (`exchnagePika`), extracting fees and old tokens (`extractOldPIKA`, `extractfee`), burning tokens (`burn`), and adding liquidity (`addLiquidity`) are declared with either empty bodies or minimal access control.
*   **Receive Function:** Allows the contract to receive ETH and immediately transfers it to the owner.

**To make this contract functional, you would need to implement the logic for the declared but empty functions, especially:**

*   **ERC20 core functions:** `balanceOf`, `transfer`, `transferFrom`, `approve`, `allowance`. This would involve updating the `balances` and `allowed` mappings.
*   **`_transfer`:** This internal function would contain the core logic for transferring tokens, including calculating and applying transfer fees (if applicable and not excluded), updating balances, and emitting the `Transfer` event (and `TransferFee` event if a fee is applied).
*   **`_approve`:** This internal function would update the `allowed` mapping and emit the `Approval` event.
*   **`transferFee logic`:** Implement how the `_taxFeepercent` is used to calculate fees and how the fees are accumulated in `_taxFee`.
*   **Uniswap interaction in `transfer` and potentially a dedicated swap function:** If the contract is intended to automatically swap tokens for ETH and/or add liquidity, this logic would typically be included in the `_transfer` function when specific conditions are met (e.g., crossing a threshold, interacting with the Uniswap pair address). The `swapTokensForEth` function would need to be implemented as well.
*   **`exchnagePika`:** Implement the logic for exchanging the `oldPika` token for the new `PIKA` token with the specified bonus tiers, ensuring to transfer and burn the `oldPika` tokens and mint/transfer the new `PIKA` tokens.
*   **`extractOldPIKA` and `extractfee`:** Implement the transfer of the respective tokens to the owner and the resetting of the corresponding balance.
*   **`calSwapToken`:** Implement the calculation of the swapped token amount based on the provided percentage.
*   **`burn`:** Implement the logic to decrease the caller's balance and the `totalSupply`.
*   **`addLiquidity`:** Implement the interaction with the Uniswap router to add liquidity using the contract's tokens and the provided ETH.

This contract provides a solid foundation for a DeFi token with various features, but the core logic needs to be implemented to make it fully functional.