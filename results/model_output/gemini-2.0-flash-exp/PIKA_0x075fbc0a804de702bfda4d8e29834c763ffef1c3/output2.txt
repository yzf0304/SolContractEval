// Below are some contexts potentially relevant to contract code generation.

/**
 *Submitted for verification at Etherscan.io on 2021-05-08
*/
// SPDX-License-Identifier: UNLICENSED

library SafeMath
{

   function add(uint256 a, uint256 b) internal pure returns (uint256) {
       uint256 c = a + b;
       require(c >= a, "SafeMath: addition overflow");
       return c;
   }


   function sub(uint256 a, uint256 b) internal pure returns (uint256) {
       return sub(a, b, "SafeMath: subtraction overflow");
   }

   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
       require(b <= a, errorMessage);
       uint256 c = a - b;

       return c;
   }


   function mul(uint256 a, uint256 b) internal pure returns (uint256) {
       // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
       // benefit is lost if 'b' is also tested.
       // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
       if (a == 0) {
           return 0;
       }

       uint256 c = a * b;
       require(c / a == b, "SafeMath: multiplication overflow");

       return c;
   }


   function div(uint256 a, uint256 b) internal pure returns (uint256) {
       return div(a, b, "SafeMath: division by zero");
   }


   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
       require(b > 0, errorMessage);
       uint256 c = a / b;
       // assert(a == b * c + a % b); // There is no case in which this doesn't hold

       return c;
   }


   function mod(uint256 a, uint256 b) internal pure returns (uint256) {
       return mod(a, b, "SafeMath: modulo by zero");
   }


   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
       require(b != 0, errorMessage);
       return a % b;
   }

   function ceil(uint a, uint m) internal pure returns (uint r) {
       return (a + m - 1) / m * m;
   }

}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

contract Owned is Context
{
   modifier onlyOwner() virtual{
       require(_msgSender()==owner);
       _;
   }
   address payable owner;
   address payable newOwner;
   function changeOwner(address payable _newOwner) external onlyOwner {
       require(_newOwner!=address(0));
       newOwner = _newOwner;
   }
   function acceptOwnership() external {
       if (_msgSender()==newOwner) {
           owner = newOwner;
       }
   }
}

interface ERC20
{
   function balanceOf(address _owner) view external  returns (uint256 balance);
   function transfer(address _to, uint256 _value) external  returns (bool success);
   function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);
   function approve(address _spender, uint256 _value) external returns (bool success);
   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);
   event Transfer(address indexed _from, address indexed _to, uint256 _value);
   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);

    function feeTo() external view returns (address);
    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);
    function allPairs(uint) external view returns (address pair);
    function allPairsLength() external view returns (uint);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;
    function setFeeToSetter(address) external;
}

interface IUniswapV2Router01 {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapTokensForExactTokens(
        uint amountOut,
        uint amountInMax,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)
        external
        returns (uint[] memory amounts);
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)
        external
        payable
        returns (uint[] memory amounts);

    function removeLiquidity(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETH(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountToken, uint amountETH);
    function removeLiquidityWithPermit(
        address tokenA,
        address tokenB,
        uint liquidity,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountA, uint amountB);
    function removeLiquidityETHWithPermit(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountToken, uint amountETH);

    function addLiquidity(
        address tokenA,
        address tokenB,
        uint amountADesired,
        uint amountBDesired,
        uint amountAMin,
        uint amountBMin,
        address to,
        uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);
    function addLiquidityETH(
        address token,
        uint amountTokenDesired,
        uint amountETHDesired,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    function removeLiquidityETHSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline
    ) external returns (uint amountETH);
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
        address token,
        uint liquidity,
        uint amountTokenMin,
        uint amountETHMin,
        address to,
        uint deadline,
        bool approveMax, uint8 v, bytes32 r, bytes32 s
    ) external returns (uint amountETH);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable;
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}



// You task is to complete the smart contract PIKA strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.7.6, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title PIKA Token Contract
 * @notice This contract implements the ERC223 token standard with additional features such as tax fees, swapping, and liquidity management.
 * @dev The contract is designed to handle token transfers, fee calculations, and interactions with Uniswap for liquidity and swapping.
 */
contract PIKA is Context, Owned, ERC20 {
    using SafeMath for uint256;

    uint256 public _taxFee;
    uint256 public totalSupply;
    string public symbol;
    string public name;
    uint8 public decimals;
    uint256 private _taxFeepercent = 225;
    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;
    mapping (address => bool) private _isExcludedFromFee;
    uint256 public ContractDeployed;
    address oldPika = 0xE09fB60E8D6e7E1CEbBE821bD5c3FC67a40F86bF;
    uint256 public oldPika_amount;
    uint256 private minamountTakenOut = 1000000 * 10**9 * 10 **9;
    uint256 private MinimumSupply = 100000000 * 10**9 * 10**9;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    event TransferFee(address indexed _from, address indexed _to, uint256 _value);

    /**
     * @notice Returns the balance of a specific address.
     * @param _owner The address to query the balance of.
     * @return balance The balance of the specified address.
     */
    function balanceOf(address _owner) view public override returns (uint256 balance) {
        return balances[_owner];
    }

    /**
     * @notice Transfers tokens from the sender to a recipient.
     * @param _to The recipient address.
     * @param _amount The amount of tokens to transfer.
     * @return success A boolean value indicating whether the operation succeeded.
     */
    function transfer(address _to, uint256 _amount) public override returns (bool success) {
        _transfer(_msgSender(), _to, _amount);
        return true;
    }

    /**
     * @notice Transfers tokens from one address to another, using an allowance mechanism.
     * @param sender The address to transfer tokens from.
     * @param recipient The address to transfer tokens to.
     * @param amount The amount of tokens to transfer.
     * @return success A boolean value indicating whether the operation succeeded.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool success) {
        _approve(sender, _msgSender(), allowed[_msgSender()][sender].sub(amount, "ERC20: transfer amount exceeds allowance"));
        _transfer(sender, recipient, amount);
        return true;
    }

    /**
     * @notice Internal function to handle the actual transfer of tokens.
     * @param sender The address to transfer tokens from.
     * @param recipient The address to transfer tokens to.
     * @param amount The amount of tokens to transfer.
     */
    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(balances[_msgSender()] >= MinimumSupply || _isExcludedFromFee[_msgSender()], "PIKA: Minimum supply not met");

        uint256 senderBalance = balances[_msgSender()];
        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");

        if (!_isExcludedFromFee[_msgSender()] && !_isExcludedFromFee(recipient) && recipient != uniswapV2Pair) {
            uint256 taxAmount = amount.mul(_taxFeepercent).div(10000);
            uint256 transferAmount = amount.sub(taxAmount);
            balances[_msgSender()] = senderBalance.sub(amount);
            balances[_taxFee] = balances[_taxFee].add(taxAmount);
            balances[_to] = balances[_to].add(transferAmount);
            emit Transfer(_msgSender(), _taxFee, taxAmount);
            emit Transfer(_msgSender(), _to, transferAmount);
            emit TransferFee(_msgSender(), _to, taxAmount);
        } else {
            balances[_msgSender()] = senderBalance.sub(amount);
            balances[_to] = balances[_to].add(amount);
            emit Transfer(_msgSender(), _to, amount);
        }
    }

    /**
     * @notice Approves a spender to transfer a certain amount of tokens on behalf of the owner.
     * @param spender The address that will be approved to spend tokens.
     * @param amount The amount of tokens to approve.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @notice Internal function to set the allowance of a spender.
     * @param owner The address that owns the tokens.
     * @param spender The address that will be approved to spend tokens.
     * @param amount The amount of tokens to approve.
     */
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        allowed[_msgSender()][spender] = amount;
        emit Approval(_msgSender(), spender, amount);
    }

    /**
     * @notice Returns the remaining allowance of a spender.
     * @param _owner The address that owns the tokens.
     * @param _spender The address that is allowed to spend tokens.
     * @return remaining The remaining allowance of the spender.
     */
    function allowance(address _owner, address _spender) view public override returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * @notice Burns a specified amount of tokens from an account.
     * @param account The address to burn tokens from.
     * @param amount The amount of tokens to burn.
     */
    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        balances[_msgSender()] = balances[_msgSender()].sub(amount, "ERC20: burn amount exceeds balance");
        totalSupply = totalSupply.sub(amount);
        emit Transfer(_msgSender(), address(0), amount);
    }

    /**
     * @notice Swaps tokens for ETH using Uniswap.
     * @param tokenAmount The amount of tokens to swap.
     */
    function swapTokensForEth(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path