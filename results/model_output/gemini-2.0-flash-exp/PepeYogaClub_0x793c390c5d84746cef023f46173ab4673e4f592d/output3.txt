```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import "@openzeppelin/contracts/access/Ownable.sol";
import "erc721a/contracts/ERC721A.sol";

/**
 * @title PepeYogaClub
 * @notice A smart contract for the PepeYogaClub NFT collection, implementing ERC721A and Ownable.
 * @dev This contract allows users to mint NFTs, with various controls and configurations managed by the owner.
 */
contract PepeYogaClub is ERC721A, Ownable {

    string public baseURI = "ipfs://QmTLWN9WPq5L9eS9EKcTn2rqUCzr9QK5sd8DYVkkL7yguL/";
    string public contractURI = "ipfs://QmUvB8sKL4XFTxbMkL9FykiqLgrXeBV1mUkdzWMWhachvD";

    uint256 public MAX_PER_WALLET = 11;
    uint256 public constant MAX_SUPPLY = 2069;
    uint256 public price = 0.0069 ether;

    bool public paused = true;

    /**
     * @notice Initializes the contract with the name and symbol.
     * @dev Sets the initial values for the contract's name and symbol.
     */
    constructor() ERC721A("PepeYogaClub", "PYC") {}

    /**
     * @notice Allows a user to mint a specified number of NFTs.
     * @dev Ensures that the minting process adheres to the set constraints and conditions.
     * @param _amount The number of NFTs to mint.
     */
    function mint(uint256 _amount) external payable {
        require(!paused, "Minting is paused");
        require(_amount > 0, "Amount must be greater than 0");
        require(_amount <= MAX_PER_WALLET, "Cannot mint more than MAX_PER_WALLET");
        require(totalSupply() + _amount <= MAX_SUPPLY, "Not enough NFTs left to mint");
        require(msg.value >= price * _amount, "Incorrect amount sent");
        require(minted(_msgSender()) + _amount <= MAX_PER_WALLET, "You have reached mint limit");

        _safeMint(_msgSender(), _amount);
    }

    /**
     * @notice Overrides the default starting token ID.
     * @dev Returns the starting token ID for the collection.
     * @return The starting token ID.
     */
    function _startTokenId() internal override view virtual returns (uint256) {
        return 1;
    }

    /**
     * @notice Returns the number of NFTs minted by a specific address.
     * @dev Uses the internal `_numberMinted` function to get the count.
     * @param _owner The address to check.
     * @return The number of NFTs minted by the address.
     */
    function minted(address _owner) public view returns (uint256) {
        return _numberMinted(_owner);
    }

    /**
     * @notice Allows the owner to withdraw the contract's balance.
     * @dev Transfers the contract's balance to the owner.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = _msgSender().call{value: address(this).balance}("");
        require(success, "Withdrawal failed");
    }

    /**
     * @notice Allows the owner to mint NFTs to multiple addresses in bulk.
     * @dev Mints NFTs to the specified addresses with the specified amounts.
     * @param _to An array of addresses to receive the NFTs.
     * @param _amount An array of amounts corresponding to each address.
     */
    function teamMint(address[] memory _to, uint256[] memory _amount) external onlyOwner {
        require(_to.length == _amount.length, "Arrays must be same length");
        for (uint256 i = 0; i < _to.length; i++) {
            require(totalSupply() + _amount[i] <= MAX_SUPPLY, "Not enough NFTs left to mint");
            _safeMint(_to[i], _amount[i]);
        }
    }

    /**
     * @notice Allows the owner to set the maximum number of NFTs that can be minted per wallet.
     * @dev Updates the `MAX_PER_WALLET` variable.
     * @param _max The new maximum number of NFTs per wallet.
     */
    function setMaxPerWallet(uint256 _max) external onlyOwner {
        MAX_PER_WALLET = _max;
    }

    /**
     * @notice Allows the owner to set the price for minting an NFT.
     * @dev Updates the `price` variable.
     * @param _price The new price for minting an NFT.
     */
    function setPrice(uint256 _price) external onlyOwner {
        price = _price;
    }

    /**
     * @notice Allows the owner to toggle the minting state.
     * @dev Toggles the `paused` variable.
     */
    function toggleMint() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Allows the owner to set the base URI for the NFT metadata.
     * @dev Updates the `baseURI` variable.
     * @param baseURI_ The new base URI.
     */
    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    /**
     * @notice Allows the owner to set the contract URI.
     * @dev Updates the `contractURI` variable.
     * @param _contractURI The new contract URI.
     */
    function setContractURI(string memory _contractURI) external onlyOwner {
        contractURI = _contractURI;
    }

    /**
     * @notice Returns the URI for a given token ID.
     * @dev Constructs the token URI using the base URI and the token ID.
     * @param _tokenId The ID of the token.
     * @return The URI for the token.
     */
    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "Token does not exist");
        return string(abi.encodePacked(baseURI, Strings.toString(_tokenId), ".json"));
    }

    /**
     * @dev See {IERC721Metadata-contractURI}.
     */
    function contractURI() public view returns (string memory) {
        return contractURI;
    }
}

library Strings {
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
```