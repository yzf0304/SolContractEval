// Below are some contexts potentially relevant to contract code generation.

/**
 *Submitted for verification at Etherscan.io on 2021-01-31
*/
/*
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with GSN meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */

contract Context {
    // Empty internal constructor, to prevent people from mistakenly deploying
    // an instance of this contract, which should be used via inheritance.
    constructor () internal { }
    // solhint-disable-previous-line no-empty-blocks

    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return _msgSender() == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */

library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     *
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     *
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     *
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts with custom message when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     *
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

interface IPepemonFactory {
    function balanceOf(address _owner, uint256 _id) external view returns (uint256);
    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);
    function mint(address _to, uint256 _id, uint256 _quantity, bytes calldata _data) external;
    function burn(address _account, uint256 _id, uint256 _amount) external;
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;
    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;
}



// You task is to complete the smart contract PepemonStake strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.6.6, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title PepemonStake
 * @notice A smart contract for staking Pepemon cards, allowing users to participate in staking events and earn rewards.
 * @dev Inherits from Ownable, providing basic authorization control functions.
 */
contract PepemonStake is Ownable {
    using SafeMath for uint256;

    IPepemonFactory public pepemonFactory;

    /**
     * @notice Structure to hold the details of a staking event.
     * @dev Contains information about the cards required, reward, and staking duration.
     */
    struct StakingEvent {
        uint256[] cardIdList;
        uint256 cardAmountAny; // If this is > 0, cardAmountList will be ignored, and user will be able to stake multiple cards of any card accepted
        uint256[] cardAmountList; // Will be ignored if cardAmountAny > 0
        uint256 cardRewardId;
        uint256 blockStakeLength; // Amounts of blocks of staking required to complete the event
        uint256 blockEventClose; // Block at which this event will not accept any new stake
        uint256[] toBurnIdList; // Id list of cards to burn on completion of event
        uint256[] toBurnAmountList; // Amount list of cards to burn on completion of event
    }

    /**
     * @notice Structure to hold the user's staking information.
     * @dev Tracks whether the user has completed the event and the block at which the staking ends.
     */
    struct UserInfo {
        bool isCompleted;
        uint256 blockEnd; // Block at which user will have completed the event (If this is not 0, user is currently staking)
    }

    StakingEvent[] public stakingEvents;
    mapping (address => mapping(uint256 => UserInfo)) public userInfo;
    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) public cardsStaked; // address => eventId => cardId => amountStaked

    ////
    // Events
    ////

    /**
     * @notice Emitted when a new staking event is created.
     * @param eventId The ID of the newly created staking event.
     */
    event StakingEventCreated(uint256 eventId);

    /**
     * @notice Emitted when a user enters a staking event.
     * @param user The address of the user entering the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventEntered(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user completes a staking event.
     * @param user The address of the user completing the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCompleted(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user cancels their participation in a staking event.
     * @param user The address of the user canceling the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCancelled(address indexed user, uint256 eventId);

    //////////////

    constructor(IPepemonFactory _pepemonFactoryAddress) public {
        pepemonFactory = _pepemonFactoryAddress;
    }

    ////
    // View
    ////

    /**
     * @notice Returns the total number of staking events.
     * @return The length of the stakingEvents array.
     */
    function getStakingEventsLength() external view returns(uint256) {
        return stakingEvents.length;
    }

    /**
     * @notice Returns all staking events.
     * @return An array of all staking events.
     */
    function getAllEvents() public view returns(StakingEvent[] memory) {
        return stakingEvents;
    }

    /**
     * @notice Returns the IDs of all active staking events.
     * @return An array of IDs of active staking events.
     */
    function getActiveEvents() external view returns(uint256[] memory) {
        uint256[] memory activeEventIds = new uint256[](stakingEvents.length);
        uint256 count = 0;
        uint256 currentBlock = block.number;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (currentBlock < stakingEvents [i].blockEventClose) {
                activeEventIds [count] = i;
                count++;
            }
        }
        // Resize the array to the actual number of active events
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result [i] = activeEventIds [i];
        }
        return result;
    }

    /**
     * @notice Returns the IDs of all closed staking events.
     * @return An array of IDs of closed staking events.
     */
    function getClosedEvents() external view returns(uint256[] memory) {
        uint256[] memory closedEventIds = new uint256[](stakingEvents.length);
        uint256 count = 0;
        uint256 currentBlock = block.number;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (currentBlock >= stakingEvents [i].blockEventClose) {
                closedEventIds [count] = i;
                count++;
            }
        }
        // Resize the array to the actual number of closed events
        uint256[] memory result = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            result [i] = closedEventIds [i];
        }
        return result;
    }

    /**
     * @notice Returns the list of card IDs for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card IDs for the specified staking event.
     */
    function getCardIdListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        return stakingEvents[_eventId].cardIdList;
    }

    /**
     * @notice Returns the list of card amounts for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card amounts for the specified staking event.
     */
    function getCardAmountListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        return stakingEvents[_eventId].cardAmountList;
    }

    /**
     * @notice Returns the progress of a user towards completing a staking event.
     * @param _user The address of the user.
     * @param _eventId The ID of the staking event.
     * @return The progress as a percentage (100% = 1e5).
     */
    function getUserProgress(address _user, uint256 _eventId) external view returns(uint256) {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        UserInfo storage user = userInfo[_user][_eventId];
        if (user.blockEnd == 0 || user.isCompleted) {
            return 0;
        }
        uint256 currentBlock = block.number;
        if (currentBlock >= user.blockEnd) {
            return 100000;
        }
        uint256 blocksElapsed = currentBlock.sub(user.blockEnd.sub(stakingEvents[_eventId].blockStakeLength));
        uint256 progress = blocksElapsed.mul(100000).div(stakingEvents[_eventId].blockStakeLength);
        return progress;
    }

    //////////////

    /**
     * @notice Creates a new staking event.
     * @param _cardIdList The list of card IDs required for the event.
     * @param _cardAmountAny The amount of any card required for the event.
     * @param _cardAmountList The list of card amounts required for the event.
     * @param _cardRewardId The ID of the card to be rewarded.
     * @param _blockStakeLength The number of blocks required to complete the event.
     * @param _blockEventClose The block at which the event will close.
     * @param _toBurnIdList The list of card IDs to be burned on completion.
     * @param _toBurnAmountList The list of card amounts to be burned on completion.
     */
    function createStakingEvent(uint256[] memory _cardIdList, uint256 _cardAmountAny, uint256[] memory _cardAmountList, uint256 _cardRewardId,
        uint256 _blockStakeLength, uint256 _blockEventClose, uint256[] memory _toBurnIdList, uint256[] memory _toBurnAmountList) public onlyOwner {
        require(_blockStakeLength > 0, "PepemonStake: stake length must be greater than 0");
        require(_blockEventClose > block.number, "PepemonStake: close block must be in the future");
        if (_cardAmountAny == 0) {
            require(_cardIdList.length == _cardAmountList.length, "PepemonStake: card id and amount lists must have the same length");
            require(_cardIdList.length > 0, "PepemonStake: at least one card must be required");
        } else {
            require(_cardIdList.length > 0, "PepemonStake: at least one accepted card id must be provided");
            require(_cardAmountList.length == 0, "PepemonStake: card amount list should be empty if cardAmountAny > 0");
        }
        require(_cardRewardId > 0, "PepemonStake: reward card id must be greater than 0");
        require(_toBurnIdList.length == _toBurnAmountList.length, "PepemonStake: burn id and amount lists must have the same length");

        stakingEvents.push(StakingEvent({
            cardIdList: _cardIdList,
            cardAmountAny: _cardAmountAny,
            cardAmountList: _cardAmountList,
            cardRewardId: _cardRewardId,
            blockStakeLength: _blockStakeLength,
            blockEventClose: _blockEventClose,
            toBurnIdList: _toBurnIdList,
            toBurnAmountList: _toBurnAmountList
        }));
        emit StakingEventCreated(stakingEvents.length - 1);
    }

    /**
     * @notice Closes a staking event prematurely.
     * @param _eventId The ID of the staking event to be closed.
     */
    function closeStakingEvent(uint256 _eventId) public onlyOwner {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        require(block.number < stakingEvents[_eventId].blockEventClose, "PepemonStake: event is already closed");
        stakingEvents[_eventId].blockEventClose = block.number;
    }

    //////////////

    /**
     * @dev Stakes multiple cards for a staking event.
     *
     * @param _eventId The ID of the staking event
     * @param _cardIdList List of card IDs to stake
     * @param _cardAmountList Corresponding amounts of each card
     * @notice Emits StakingEventEntered event
     * @dev
     * - Validates card acceptance and total amount
     * - Transfers cards via safeBatchTransferFrom
     * - Records staked cards in storage
     */
    function stakeAny(uint256 _eventId, uint256[] memory _cardIdList, uint256[] memory _cardAmountList) public {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        require(block.number < stakingEvents[_eventId].blockEventClose, "PepemonStake: event is closed");
        require(userInfo[_msgSender()][_eventId].blockEnd == 0, "PepemonStake: already staking in this event");
        require(_cardIdList.length == _cardAmountList.length, "PepemonStake: card id and amount lists must have the same length");
        require(_cardIdList.length > 0, "PepemonStake: must stake at least one card");
        require(stakingEvents[_eventId].cardAmountAny > 0, "PepemonStake: this event does not accept any of the listed cards");

        uint256 totalAmount = 0;
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            require(_isInArray(_cardIdList [i], stakingEvents[_eventId].cardIdList), "PepemonStake: one or more cards are not accepted in this event");
            require(pepemonFactory.balanceOf(_msgSender(), _cardIdList [i]) >= _cardAmountList [i], "PepemonStake: insufficient balance for one or more cards");
            totalAmount = totalAmount.add(_cardAmountList [i]);
            cardsStaked[_msgSender()][_eventId][_cardIdList [i]] = cardsStaked[_msgSender()][_eventId][_cardIdList [i]].add(_cardAmountList [i]);
        }
        require(totalAmount == stakingEvents[_eventId].cardAmountAny, "PepemonStake: staked amount does not match required amount");

        pepemonFactory.safeBatchTransferFrom(_msgSender(), address(this), _cardIdList, _cardAmountList, "");
        userInfo[_msgSender()][_eventId].blockEnd = block.number.add(stakingEvents[_eventId].blockStakeLength);
        emit StakingEventEntered(_msgSender(), _eventId);
    }

    /**
     * @notice Allows a user to stake specific cards into a staking event.
     * @param _eventId The ID of the staking event.
     */
    function stake(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        require(block.number < stakingEvents[_eventId].blockEventClose, "PepemonStake: event is closed");
        require(userInfo[_msgSender()][_eventId].blockEnd == 0, "PepemonStake: already staking in this event");
        require(stakingEvents[_eventId].cardAmountAny == 0, "PepemonStake: this event requires a specific amount of any listed card");
        require(stakingEvents[_eventId].cardIdList.length == stakingEvents[_eventId].cardAmountList.length, "PepemonStake: configuration error");
        require(stakingEvents[_eventId].cardIdList.length > 0, "PepemonStake: no cards required for this event");

        uint256[] memory _stakeCardIds = stakingEvents[_eventId].cardIdList;
        uint256[] memory _stakeCardAmounts = stakingEvents[_eventId].cardAmountList;
        uint256 totalAmount = 0;

        for (uint256 i = 0; i < _stakeCardIds.length; i++) {
            require(pepemonFactory.balanceOf(_msgSender(), _stakeCardIds [i]) >= _stakeCardAmounts [i], "PepemonStake: insufficient balance for one or more required cards");
            cardsStaked[_msgSender()][_eventId][_stakeCardIds [i]] = cardsStaked[_msgSender()][_eventId][_stakeCardIds [i]].add(_stakeCardAmounts [i]);
            totalAmount = totalAmount.add(_stakeCardAmounts [i]);
        }

        pepemonFactory.safeBatchTransferFrom(_msgSender(), address(this), _stakeCardIds, _stakeCardAmounts, "");
        userInfo[_msgSender()][_eventId].blockEnd = block.number.add(stakingEvents[_eventId].blockStakeLength);
        emit StakingEventEntered(_msgSender(), _eventId);
    }

    /**
     * @notice Allows a user to claim their staked cards and the reward.
     * @param _eventId The ID of the staking event.
     */
    function claim(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        UserInfo storage user = userInfo[_msgSender()][_eventId];
        require(user.blockEnd > 0, "PepemonStake: not currently staking in this event");
        require(!user.isCompleted, "PepemonStake: already claimed for this event");
        require(block.number >= user.blockEnd, "PepemonStake: staking period not yet completed");

        pepemonFactory.mint(_msgSender(), stakingEvents[_eventId].cardRewardId, 1, "");
        _withdrawCardsStaked(_eventId, true);
        userInfo[_msgSender()][_eventId].isCompleted = true;
        emit StakingEventCompleted(_msgSender(), _eventId);
    }

    /**
     * @notice Allows a user to cancel their participation in a staking event and withdraw their staked cards.
     * @param _eventId The ID of the staking event.
     */
    function cancel(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: invalid event id");
        UserInfo storage user = userInfo[_msgSender()][_eventId];
        require(user.blockEnd > 0, "PepemonStake: not currently staking in this event");
        require(!user.isCompleted, "PepemonStake: cannot cancel a completed event");

        _withdrawCardsStaked(_eventId, false);
        delete userInfo[_msgSender()][_eventId];
        emit StakingEventCancelled(_msgSender(), _eventId);
    }

    function _withdrawCardsStaked(uint256 _eventId, bool _burn) internal {
        StakingEvent storage currentEvent = stakingEvents[_eventId];
        address staker = _msgSender();
        uint256[] memory stakedCardIds;
        uint256[] memory stakedCardAmounts;
        uint256 index = 0;

        // Calculate the total number of staked cards
        uint256 totalStakedCards = 0;
        for (uint256 i = 0; i < currentEvent.cardIdList.length; i++) {
            uint256 balance = cardsStaked [staker][_eventId][currentEvent.cardIdList [i]];
            if (balance > 0) {
                totalStakedCards++;
            }
        }
        if (currentEvent.cardAmountAny > 0) {
            for (uint256 i = 0; i < currentEvent.cardIdList.length; i++) {
                uint256 balance = cardsStaked [staker][_eventId][currentEvent.cardIdList [i]];
                if (balance > 0) {
                    totalStakedCards++;
                    break; // Assuming only one type of card is staked when cardAmountAny > 0
                }
            }
            stakedCardIds = new uint256[](1);
            stakedCardAmounts = new uint256[](1);
            for (uint256 i = 0; i < currentEvent.cardIdList.length; i++) {
                uint256 balance = cardsStaked [staker][_eventId][currentEvent.cardIdList [i]];
                if (balance > 0) {
                    stakedCardIds [0] = currentEvent.cardIdList [i];
                    stakedCardAmounts [0] = balance;
                    if (_burn) {
                        for (uint256 j = 0; j < currentEvent.toBurnIdList.length; j++) {
                            if (currentEvent.toBurnIdList [j] == stakedCardIds [0]) {
                                pepemonFactory.burn(staker, stakedCardIds [0], currentEvent.toBurnAmountList [j]);
                            }
                        }
                    } else {
                        pepemonFactory.safeTransferFrom(address(this), staker, stakedCardIds [0], stakedCardAmounts [0], "");
                    }
                    delete cardsStaked [staker][_eventId][stakedCardIds [0]];
                    break;
                }
            }
            return;
        } else {
            stakedCardIds = new uint256[](totalStakedCards);
            stakedCardAmounts = new uint256[](totalStakedCards);
            for (uint256 i = 0; i < currentEvent.cardIdList.length; i++) {
                uint256 balance = cardsStaked [staker][_eventId][currentEvent.cardIdList [i]];
                if (balance > 0) {
                    stakedCardIds [index] = currentEvent.cardIdList [i];
                    stakedCardAmounts [index] = balance;
                    if (_burn) {
                        for (uint256 j = 0; j < currentEvent.toBurnIdList.length; j++) {
                            if (currentEvent.toBurnIdList [j] == stakedCardIds [index]) {
                                pepemonFactory.burn(staker, stakedCardIds [index], currentEvent.toBurnAmountList [j]);
                            }
                        }
                    } else {
                        pepemonFactory.safeTransferFrom(address(this), staker, stakedCardIds [index], stakedCardAmounts [index], "");
                    }
                    delete cardsStaked [staker][_eventId][stakedCardIds [index]];
                    index++;
                }
            }
        }
    }

    function _isInArray(uint256 _value, uint256[] memory _array) internal pure returns(bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array [i] == _value) {
                return true;
            }
        }
        return false;
    }

    /////////
    /////////
    /////////

    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4) {
        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4) {
        return 0xbc197c81;
    }

    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).
        interfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) ^ bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`).
    }
}
