Okay, I will complete the `PepemonStake` smart contract based on the provided context.

contract PepemonStake is Ownable {
    using SafeMath for uint256;

    IPepemonFactory public pepemonFactory;

    /**
     * @notice Structure to hold the details of a staking event.
     * @dev Contains information about the cards required, reward, and staking duration.
     */
    struct StakingEvent {
        uint256[] cardIdList;
        uint256 cardAmountAny; // If this is > 0, cardAmountList will be ignored, and user will be able to stake multiple cards of any card accepted
        uint256[] cardAmountList; // Will be ignored if cardAmountAny > 0
        uint256 cardRewardId;
        uint256 blockStakeLength; // Amounts of blocks of staking required to complete the event
        uint256 blockEventClose; // Block at which this event will not accept any new stake
        uint256[] toBurnIdList; // Id list of cards to burn on completion of event
        uint256[] toBurnAmountList; // Amount list of cards to burn on completion of event
        bool isActive;
    }

    /**
     * @notice Structure to hold the user's staking information.
     * @dev Tracks whether the user has completed the event and the block at which the staking ends.
     */
    struct UserInfo {
        bool isCompleted;
        uint256 blockEnd; // Block at which user will have completed the event (If this is not 0, user is currently staking)
    }

    StakingEvent[] public stakingEvents;
    mapping (address => mapping(uint256 => UserInfo)) public userInfo;
    mapping (address => mapping(uint256 => mapping(uint256 => uint256))) public cardsStaked; // address => eventId => cardId => amountStaked

    ////
    // Events
    ////

    /**
     * @notice Emitted when a new staking event is created.
     * @param eventId The ID of the newly created staking event.
     */
    event StakingEventCreated(uint256 eventId);

    /**
     * @notice Emitted when a user enters a staking event.
     * @param user The address of the user entering the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventEntered(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user completes a staking event.
     * @param user The address of the user completing the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCompleted(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a user cancels their participation in a staking event.
     * @param user The address of the user canceling the staking event.
     * @param eventId The ID of the staking event.
     */
    event StakingEventCancelled(address indexed user, uint256 eventId);

    /**
     * @notice Emitted when a staking event is closed.
     * @param eventId The ID of the closed staking event.
     */
    event StakingEventClosed(uint256 eventId);

    //////////////

    constructor(IPepemonFactory _pepemonFactoryAddress) public {
        pepemonFactory = _pepemonFactoryAddress;
    }

    ////
    // View
    ////

    /**
     * @notice Returns the total number of staking events.
     * @return The length of the stakingEvents array.
     */
    function getStakingEventsLength() external view returns(uint256) {
        return stakingEvents.length;
    }

    /**
     * @notice Returns all staking events.
     * @return An array of all staking events.
     */
    function getAllEvents() public view returns(StakingEvent[] memory) {
        return stakingEvents;
    }

    /**
     * @notice Returns the IDs of all active staking events.
     * @return An array of IDs of active staking events.
     */
    function getActiveEvents() external view returns(uint256[] memory) {
        uint256[] memory activeEventIds = new uint256[](stakingEvents.length);
        uint256 counter = 0;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (stakingEvents(i).isActive && block.number < stakingEvents(i).blockEventClose) {
                activeEventIds(counter) = i;
                counter++;
            }
        }
        uint256[] memory result = new uint256[](counter);
        for (uint256 i = 0; i < counter; i++) {
            result(i) = activeEventIds(i);
        }
        return result;
    }

    /**
     * @notice Returns the IDs of all closed staking events.
     * @return An array of IDs of closed staking events.
     */
    function getClosedEvents() external view returns(uint256[] memory) {
        uint256[] memory closedEventIds = new uint256[](stakingEvents.length);
        uint256 counter = 0;
        for (uint256 i = 0; i < stakingEvents.length; i++) {
            if (!stakingEvents(i).isActive || block.number >= stakingEvents(i).blockEventClose) {
                closedEventIds(counter) = i;
                counter++;
            }
        }
        uint256[] memory result = new uint256[](counter);
        for (uint256 i = 0; i < counter; i++) {
            result(i) = closedEventIds(i);
        }
        return result;
    }

    /**
     * @notice Returns the list of card IDs for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card IDs for the specified staking event.
     */
    function getCardIdListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        return stakingEvents(_eventId).cardIdList;
    }

    /**
     * @notice Returns the list of card amounts for a specific staking event.
     * @param _eventId The ID of the staking event.
     * @return An array of card amounts for the specified staking event.
     */
    function getCardAmountListOfEvent(uint256 _eventId) external view returns(uint256[] memory) {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        return stakingEvents(_eventId).cardAmountList;
    }

    /**
     * @notice Returns the progress of a user towards completing a staking event.
     * @param _user The address of the user.
     * @param _eventId The ID of the staking event.
     * @return The progress as a percentage (100% = 1e5).
     */
    function getUserProgress(address _user, uint256 _eventId) external view returns(uint256) {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        UserInfo storage user = userInfo(_user)[_eventId];
        if (user.blockEnd == 0 || user.isCompleted) {
            return 0;
        }
        uint256 elapsedBlocks = block.number.sub(block.number.sub(user.blockEnd, "PepemonStake: Underflow"), "PepemonStake: Underflow");
        uint256 totalBlocks = stakingEvents(_eventId).blockStakeLength;
        if (elapsedBlocks >= totalBlocks) {
            return 100000;
        }
        return elapsedBlocks.mul(100000).div(totalBlocks);
    }

    //////////////

    /**
     * @notice Creates a new staking event.
     * @param _cardIdList The list of card IDs required for the event.
     * @param _cardAmountAny The amount of any card required for the event.
     * @param _cardAmountList The list of card amounts required for the event.
     * @param _cardRewardId The ID of the card to be rewarded.
     * @param _blockStakeLength The number of blocks required to complete the event.
     * @param _blockEventClose The block at which the event will close.
     * @param _toBurnIdList The list of card IDs to be burned on completion.
     * @param _toBurnAmountList The list of card amounts to be burned on completion.
     */
    function createStakingEvent(uint256[] memory _cardIdList, uint256 _cardAmountAny, uint256[] memory _cardAmountList, uint256 _cardRewardId,
        uint256 _blockStakeLength, uint256 _blockEventClose, uint256[] memory _toBurnIdList, uint256[] memory _toBurnAmountList) public onlyOwner {
        require(_blockStakeLength > 0, "PepemonStake: Stake length must be greater than 0");
        require(_blockEventClose > block.number, "PepemonStake: Close block must be in the future");
        if (_cardAmountAny == 0) {
            require(_cardIdList.length == _cardAmountList.length, "PepemonStake: Card IDs and Amounts must have the same length");
            require(_cardIdList.length > 0, "PepemonStake: At least one card ID must be specified if cardAmountAny is 0");
        } else {
            require(_cardIdList.length > 0, "PepemonStake: At least one card ID must be specified if cardAmountAny is > 0");
            require(_cardAmountList.length == 0, "PepemonStake: cardAmountList must be empty if cardAmountAny is > 0");
        }
        if (_toBurnIdList.length > 0) {
            require(_toBurnIdList.length == _toBurnAmountList.length, "PepemonStake: Burn IDs and Amounts must have the same length");
        }

        stakingEvents.push(StakingEvent({
            cardIdList: _cardIdList,
            cardAmountAny: _cardAmountAny,
            cardAmountList: _cardAmountList,
            cardRewardId: _cardRewardId,
            blockStakeLength: _blockStakeLength,
            blockEventClose: _blockEventClose,
            toBurnIdList: _toBurnIdList,
            toBurnAmountList: _toBurnAmountList,
            isActive: true
        }));
        emit StakingEventCreated(stakingEvents.length - 1);
    }

    /**
     * @notice Closes a staking event prematurely.
     * @param _eventId The ID of the staking event to be closed.
     */
    function closeStakingEvent(uint256 _eventId) public onlyOwner {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        require(stakingEvents(_eventId).isActive, "PepemonStake: Event is already closed");
        stakingEvents(_eventId).isActive = false;
        emit StakingEventClosed(_eventId);
    }

    //////////////

    /**
     * @dev Stakes multiple cards for a staking event.
     *
     * @param _eventId The ID of the staking event
     * @param _cardIdList List of card IDs to stake
     * @param _cardAmountList Corresponding amounts of each card
     * @notice Emits StakingEventEntered event
     * @dev
     * - Validates card acceptance and total amount
     * - Transfers cards via safeBatchTransferFrom
     * - Records staked cards in storage
     */
    function stakeAny(uint256 _eventId, uint256[] memory _cardIdList, uint256[] memory _cardAmountList) public {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        require(stakingEvents(_eventId).isActive, "PepemonStake: Event is closed");
        require(block.number < stakingEvents(_eventId).blockEventClose, "PepemonStake: Event close block reached");
        require(userInfo(msg.sender)[_eventId].blockEnd == 0, "PepemonStake: Already staking in this event");
        require(_cardIdList.length == _cardAmountList.length, "PepemonStake: Card IDs and Amounts must have the same length");
        require(_cardIdList.length > 0, "PepemonStake: Must provide at least one card to stake");

        StakingEvent storage currentEvent = stakingEvents(_eventId);
        uint256 totalStaked = 0;
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            require(_isInArray(_cardIdList(i), currentEvent.cardIdList), "PepemonStake: Card ID not accepted in this event");
            uint256 balance = pepemonFactory.balanceOf(msg.sender, _cardIdList(i));
            require(balance >= _cardAmountList(i), "PepemonStake: Insufficient balance");
            cardsStaked(msg.sender)[_eventId][_cardIdList(i)] = cardsStaked(msg.sender)[_eventId][_cardIdList(i)].add(_cardAmountList(i));
            totalStaked = totalStaked.add(_cardAmountList(i));
        }

        require(currentEvent.cardAmountAny > 0, "PepemonStake: This event does not accept any of the whitelisted cards");
        require(totalStaked >= currentEvent.cardAmountAny, "PepemonStake: Must stake at least the required amount of accepted cards");

        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), _cardIdList, _cardAmountList, "");
        userInfo(msg.sender)[_eventId].blockEnd = block.number.add(currentEvent.blockStakeLength);
        emit StakingEventEntered(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to stake specific cards into a staking event.
     * @param _eventId The ID of the staking event.
     */
    function stake(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        require(stakingEvents(_eventId).isActive, "PepemonStake: Event is closed");
        require(block.number < stakingEvents(_eventId).blockEventClose, "PepemonStake: Event close block reached");
        require(userInfo(msg.sender)[_eventId].blockEnd == 0, "PepemonStake: Already staking in this event");

        StakingEvent storage currentEvent = stakingEvents(_eventId);
        require(currentEvent.cardAmountAny == 0, "PepemonStake: This event requires staking any of the accepted cards");
        require(currentEvent.cardIdList.length == currentEvent.cardAmountList.length, "PepemonStake: Configuration error");
        require(currentEvent.cardIdList.length > 0, "PepemonStake: No cards required for this event");

        uint256[] memory _stakeCardIds = currentEvent.cardIdList;
        uint256[] memory _stakeCardAmounts = currentEvent.cardAmountList;
        for (uint256 i = 0; i < _stakeCardIds.length; i++) {
            uint256 balance = pepemonFactory.balanceOf(msg.sender, _stakeCardIds(i));
            require(balance >= _stakeCardAmounts(i), "PepemonStake: Insufficient balance for required cards");
            cardsStaked(msg.sender)[_eventId][_stakeCardIds(i)] = cardsStaked(msg.sender)[_eventId][_stakeCardIds(i)].add(_stakeCardAmounts(i));
        }

        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), _stakeCardIds, _stakeCardAmounts, "");
        userInfo(msg.sender)[_eventId].blockEnd = block.number.add(currentEvent.blockStakeLength);
        emit StakingEventEntered(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to claim their staked cards and the reward.
     * @param _eventId The ID of the staking event.
     */
    function claim(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        require(stakingEvents(_eventId).isActive, "PepemonStake: Event is closed");
        UserInfo storage user = userInfo(msg.sender)[_eventId];
        require(user.blockEnd > 0, "PepemonStake: Not currently staking in this event");
        require(block.number >= user.blockEnd, "PepemonStake: Staking period not yet complete");
        require(!user.isCompleted, "PepemonStake: Already claimed rewards for this event");

        StakingEvent storage currentEvent = stakingEvents(_eventId);

        // Burn cards if specified
        if (currentEvent.toBurnIdList.length > 0) {
            require(currentEvent.toBurnIdList.length == currentEvent.toBurnAmountList.length, "PepemonStake: Burn IDs and Amounts mismatch");
            for (uint256 i = 0; i < currentEvent.toBurnIdList.length; i++) {
                uint256 stakedAmount = cardsStaked(msg.sender)[_eventId][currentEvent.toBurnIdList(i)];
                require(stakedAmount >= currentEvent.toBurnAmountList(i), "PepemonStake: Cannot burn more than staked");
                pepemonFactory.burn(address(this), currentEvent.toBurnIdList(i), currentEvent.toBurnAmountList(i));
                cardsStaked(msg.sender)[_eventId][currentEvent.toBurnIdList(i)] = stakedAmount.sub(currentEvent.toBurnAmountList(i));
            }
        }

        // Return remaining staked cards
        _withdrawCardsStaked(_eventId, false);

        // Mint reward
        if (currentEvent.cardRewardId > 0) {
            pepemonFactory.mint(msg.sender, currentEvent.cardRewardId, 1, "");
        }

        user.isCompleted = true;
        emit StakingEventCompleted(msg.sender, _eventId);
    }

    /**
     * @notice Allows a user to cancel their participation in a staking event and withdraw their staked cards.
     * @param _eventId The ID of the staking event.
     */
    function cancel(uint256 _eventId) public {
        require(_eventId < stakingEvents.length, "PepemonStake: Event ID out of bounds");
        require(stakingEvents(_eventId).isActive, "PepemonStake: Event is closed");
        UserInfo storage user = userInfo(msg.sender)[_eventId];
        require(user.blockEnd > 0, "PepemonStake: Not currently staking in this event");
        require(!user.isCompleted, "PepemonStake: Cannot cancel after completing the event");

        _withdrawCardsStaked(_eventId, false);
        delete userInfo(msg.sender)[_eventId];
        emit StakingEventCancelled(msg.sender, _eventId);
    }

    function _withdrawCardsStaked(uint256 _eventId, bool _burn) internal {
        for (uint256 i = 0; i < stakingEvents(_eventId).cardIdList.length; i++) {
            uint256 cardId = stakingEvents(_eventId).cardIdList(i);
            uint256 amountStaked = cardsStaked(msg.sender)[_eventId][cardId];
            if (amountStaked > 0) {
                delete cardsStaked(msg.sender)[_eventId][cardId];
                if (!_burn) {
                    pepemonFactory.safeTransferFrom(address(this), msg.sender, cardId, amountStaked, "");
                } else {
                    pepemonFactory.burn(address(this), cardId, amountStaked);
                }
            }
        }
        if (stakingEvents(_eventId).cardAmountAny > 0) {
            for (uint256 i = 0; i < stakingEvents(_eventId).cardIdList.length; i++) {
                uint256 cardId = stakingEvents(_eventId).cardIdList(i);
                uint256 amountStaked = cardsStaked(msg.sender)[_eventId][cardId];
                if (amountStaked > 0) {
                    delete cardsStaked(msg.sender)[_eventId][cardId];
                    if (!_burn) {
                        pepemonFactory.safeTransferFrom(address(this), msg.sender, cardId, amountStaked, "");
                    } else {
                        pepemonFactory.burn(address(this), cardId, amountStaked);
                    }
                }
            }
        }
    }

    function _isInArray(uint256 _value, uint256[] memory _array) internal pure returns(bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array(i) == _value) {
                return true;
            }
        }
        return false;
    }

    /////////
    /////////
    /////////

    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4) {
        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4) {
        return 0xbc197c81;
    }

    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support (i.e. `bytes4(keccak256('supportsInterface(bytes4)'))`).
        interfaceID == 0x4e2312e0;      // ERC-1155 `ERC1155TokenReceiver` support (i.e. `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) ^ bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`).
    }
}