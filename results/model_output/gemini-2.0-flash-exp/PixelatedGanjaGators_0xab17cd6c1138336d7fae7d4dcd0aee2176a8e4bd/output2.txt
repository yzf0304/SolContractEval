```solidity
pragma solidity ^0.8.7;

// Below are some contexts potentially relevant to contract code generation.

// File: @openzeppelin/contracts/utils/Strings.sol
// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)
/**
 * @dev String operations.
 */

library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// File: @openzeppelin/contracts/utils/Context.sol
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/utils/Address.sol
// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)
/**
 * @dev Collection of functions related to the address type
 */

library Address {
    
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

   
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)
/**
 * @title ERC721 token receiver interface
 * @dev Interface for any contract that wants to support safeTransfers
 * from ERC721 asset contracts.
 */

interface IERC721Receiver {
   
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

// File: @openzeppelin/contracts/utils/introspection/IERC165.sol
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: @openzeppelin/contracts/utils/introspection/ERC165.sol
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: @openzeppelin/contracts/token/ERC721/IERC721.sol
// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)
/**
 * @dev Required interface of an ERC721 compliant contract.
 */

interface IERC721 is IERC165 {
    /**
     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
     */
    event Approval(address indexed owner, address indexed approved, address indexed tokenId);

    /**
     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in ``owner``'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the `tokenId` token.
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);


    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

 
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

   
    function approve(address to, uint256 tokenId) external;

  
    function getApproved(uint256 tokenId) external view returns (address operator);

   
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;
}

// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)
/**
 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */

interface IERC721Enumerable is IERC721 {
    /**
     * @dev Returns the total amount of tokens stored by the contract.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.
     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);

    /**
     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.
     * Use along with {totalSupply} to enumerate all tokens.
     */
    function tokenByIndex(uint256 index) external view returns (uint256);
}

// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
/**
 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 * @dev See https://eips.ethereum.org/EIPS/eip-721
 */

interface IERC721Metadata is IERC721 {
    /**
     * @dev Returns the token collection name.
     */
    function name() external view returns (string memory);

    /**
     * @dev Returns the token collection symbol.
     */
    function symbol() external view returns (string memory);

    /**
     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
     */
    function tokenURI(uint256 tokenId) external view returns (string memory);
}



// You task is to complete the smart contract ERC721A strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.7, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title ERC721A
 * @notice This contract implements the ERC721 standard with additional features for efficient batch minting and enumeration.
 * @dev This implementation is optimized for gas efficiency and includes the IERC721, IERC721Metadata, and IERC721Enumerable interfaces.
 */
contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using Address for address;
    using Strings for uint256;

    struct TokenOwnership {
        address addr;
        uint64 startTimestamp;
    }

    struct AddressData {
        uint128 balance;
        uint128 numberMinted;
    }

    uint256 internal currentIndex;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    string private _baseTokenURI;

    /**
     * @notice Initializes the contract by setting a name and a symbol to the token collection.
     * @dev The constructor sets the name and symbol of the token.
     * @param name_ The name of the token.
     * @param symbol_ The symbol of the token.
     */
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    /**
     * @notice Returns the total amount of tokens stored by the contract.
     * @dev This function returns the total supply of tokens.
     * @return The total supply of tokens.
     */
    function totalSupply() public view override returns (uint256) {
        return currentIndex;
    }

    /**
     * @notice Returns a token ID at a given index of all the tokens stored by the contract.
     * @dev This function returns the token ID at a specific index.
     * @param index A valid index in the list of tokens.
     * @return The token ID at the given index.
     */
    function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < currentIndex, "ERC721A: global index out of bounds");
        return index;
    }

    /**
     * @notice Returns a token ID at a given index of all the tokens owned by a given address.
     * @dev This function returns the token ID at a specific index for a given owner.
     * @param owner The address of the token owner.
     * @param index A valid index in the list of tokens owned by the owner.
     * @return The token ID at the given index.
     */
    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
        uint256 resultIndex = 0;
        for (uint256 i = 0; i < currentIndex; i++) {
            if (_ownerships[i].addr == owner) {
                if (resultIndex == index) {
                    return i;
                }
                resultIndex++;
            }
        }
        revert("ERC721A: Unable to determine owning token");
    }

    /**
     * @notice Returns true if this contract implements the interface defined by `interfaceId`.
     * @dev This function checks if the contract supports a specific interface.
     * @param interfaceId The interface identifier, as specified in ERC-165.
     * @return True if the contract implements the interface, false otherwise.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC721Enumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @notice Returns the number of tokens in `owner`'s account.
     * @dev This function returns the balance of a specific owner.
     * @param owner The address of the token owner.
     * @return The balance of the owner.
     */
    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721A: balance query for the zero address");
        return _addressData[owner].balance;
    }

    /**
     * @notice Returns the number of tokens minted by a given address.
     * @dev This function returns the number of tokens minted by a specific address.
     * @param owner The address of the minter.
     * @return The number of tokens minted by the address.
     */
    function _numberMinted(address owner) internal view returns (uint256) {
        require(owner != address(0), "ERC721A: numberMinted query for the zero address");
        return _addressData[owner].numberMinted;
    }

    /**
     * @notice Returns the ownership details of a given token ID.
     * @dev This function returns the ownership details of a specific token.
     * @param tokenId The ID of the token.
     * @return The ownership details of the token.
     */
    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        require(_exists(tokenId), "ERC721A: owner query for nonexistent token");

        return _ownerships[tokenId];
    }

    /**
     * @notice Returns the owner of the `tokenId` token.
     * @dev This function returns the owner of a specific token.
     * @param tokenId The ID of the token.
     * @return The owner of the token.
     */
    function ownerOf(uint256 tokenId) public view override returns (address) {
        return ownershipOf(tokenId).addr;
    }

    /**
     * @notice Returns the name of the token.
     * @dev This function returns the name of the token.
     * @return The name of the token.
     */
    function name() public view virtual override returns (string memory) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @dev This function returns the symbol of the token.
     * @return The symbol of the token.
     */
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    /**
     * @notice Returns the URI for a given token ID.
     * @dev This function returns the URI for a specific token.
     * @param tokenId The ID of the token.
     * @return The URI for the token.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory baseURI = _baseURI();
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId))) : "";
    }

    /**
     * @notice Returns the base URI for the token.
     * @dev This function returns the base URI for the token.
     * @return The base URI for the token.
     */
    function _baseURI() internal view virtual returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @notice Gives permission to `to` to transfer `tokenId` token to another account.
     * @dev This function approves an address to transfer a specific token.
     * @param to The address to approve.
     * @param tokenId The ID of the token to approve.
     */
    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721A: approval to current owner");

        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721A: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId, owner);
    }

    /**
     * @notice Returns the account approved for `tokenId` token.
     * @dev This function returns the approved address for a specific token.
     * @param tokenId The ID of the token.
     * @return The approved address for the token.
     */
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), "ERC721A: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    /**
     * @notice Approve or remove `operator` as an operator for the caller.
     * @dev This function sets or removes the approval for an operator.
     * @param operator The address of the operator.
     * @param approved True if the operator is approved, false to revoke approval.
     */
    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != _msgSender(), "ERC721A: approve to caller");

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @notice Returns if the `operator` is allowed to manage all of `owner`'s assets.
     * @dev This function checks if an operator is approved for all assets of an owner.
     * @param owner The address of the token owner.
     * @param operator The address of the operator.
     * @return True if the operator is approved for all, false otherwise.
     */
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    /**
     * @notice Transfers `tokenId` token from `from` to `to`.
     * @dev This function transfers a specific token from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokenId The ID of the token to transfer.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721A: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    /**
     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.
     * @dev This function safely transfers a specific token from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokenId The ID of the token to transfer.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    /**
     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.
     * @dev This function safely transfers a specific token from one address to another with additional data.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokenId The ID of the token to transfer.
     * @param _data Additional data with no specified format.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public override {
        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721A: transfer caller is not owner nor approved");
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721A: transfer to non ERC721Receiver implementer");
    }

    /**
     * @notice Checks if a token exists.
     * @dev This function checks if a specific token exists.
     * @param tokenId The ID of the token.
     * @return True if the token exists, false otherwise.
     */
    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < currentIndex;
    }

    /**
     * @notice Mints `quantity` tokens and transfers them to `to`.
     * @dev This function mints a specific quantity of tokens and transfers them to an address.
     * @param to The address to transfer the tokens to.
     * @param quantity The number of tokens to mint.
     */
    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, "");
    }

    /**
     * @notice Mints `quantity` tokens and transfers them to `to`.
     * @dev This function mints a specific quantity of tokens and transfers them to an address with additional data.
     * @param to The address to transfer the tokens to.
     * @param quantity The number of tokens to mint.
     * @param _data Additional data with no specified format.
     */
    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        _mint(to, quantity, _data, true);
    }

    /**
     * @notice Mints `quantity` tokens and transfers them to `to`.
     * @dev This function mints a specific quantity of tokens and transfers them to an address.
     * @param to The address to transfer the tokens to.
     * @param quantity The number of tokens to mint.
     * @param _data Additional data with no specified format.
     * @param safe Whether to check onERC721Received.
     * @notice
     * - Mints NFTs starting from the current index
     * - Updates balances and ownership records
     * - Emits Transfer events for each minted NFT
     * - Performs safety checks for ERC721Receiver if enabled
     * @dev
     * - Uses unchecked arithmetic for performance
     * - Calls _beforeTokenTransfers and _afterTokenTransfers hooks
     * - Requires valid recipient address and quantity
     * - Automatically increments the current index
     */
    function _mint(
        address to,
        uint256 quantity,
        bytes memory _data,
        bool safe
    ) internal {
        require(to != address(0), "ERC721A: mint to the zero address");
        require(quantity > 0, "ERC721A: quantity must be greater than 0");

        _beforeTokenTransfers(address(0), to, currentIndex, quantity);

        AddressData storage addressData = _addressData[to];

        uint256 end = currentIndex + quantity;

        if (safe) {
            for (uint256 i = currentIndex; i < end; i++) {
                _ownerships[i] = TokenOwnership(to, uint64(block.timestamp));
                emit Transfer(address(0), to, i);
                require(_checkOnERC721Received(address(0), to, i, _data), "ERC721A: transfer to non ERC721Receiver implementer");
            }
        } else {
            for (uint256 i = currentIndex; i < end; i++) {
                _ownerships[i] = TokenOwnership(to, uint64(block.timestamp));
                emit Transfer(address(0), to, i);
            }
        }

        addressData.balance += uint128(quantity);
        addressData.numberMinted += uint128(quantity);
        currentIndex = end;

        _afterTokenTransfers(address(0), to, currentIndex - quantity, quantity);
    }

    /**
     * @notice Transfers `tokenId` token from `from` to `to`.
     * @dev This function transfers a specific token from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokenId The ID of the token to transfer.
     * @notice
     * - Verifies sender is owner or approved operator
     * - Checks for valid 'from' address
     * - Prevents transfer to zero address
     * - Emits Transfer event
     * - Updates ownership and balance records
     * 
     * @dev
     * - Uses unchecked arithmetic for performance
     * - Handles adjacent token ownership continuity
     * - Calls before/after transfer hooks
     * - Clears previous approvals
     * - Maintains data consistency for ownerOf(tokenId+1) checks
     */
    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = ownershipOf(tokenId);

        require(prevOwnership.addr == from, "ERC721A: transfer from incorrect owner");
        require(to != address(0), "ERC721A: transfer to the zero address");

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        delete _tokenApprovals[tokenId];

        _addressData[from].balance -= 1;
        _addressData[to].balance += 1;

        _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));

        emit Transfer(from, to, tokenId);

        _afterTokenTransfers(from, to, tokenId, 1);
    }

    /**
     * @notice Approves `to` to operate on `tokenId`.
     * @dev This function approves an address to operate on a specific token.
     * @param to The address to approve.
     * @param tokenId The ID of the token to approve.
     * @param owner The address of the token owner.
     */
    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    /**
     * @notice Checks if the recipient is an ERC721Receiver and if it accepts the token.
     * @dev This function checks if the recipient is an ERC721Receiver and if it accepts the token.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokenId The ID of the token to transfer.
     * @param _data Additional data with no specified format.
     * @return True if the recipient is an ERC721Receiver and accepts the token, false otherwise.
     */
    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC72