```solidity
pragma solidity ^0.4.18;

// File: contracts/Discounts.sol

library Discounts {

  using SafeMath for uint256;



  /**************************************************************************
   * TYPES
   *************************************************************************/

  /*
   * Top-level struct for grouping of tiers with a base purchase rate
   */
  struct Collection {
    Tier[] tiers;

    // number of tokens per wei
    uint256 baseRate;
  }

  /*
   * Struct for a given tier - discount and availability
   */
  struct Tier {
    // discount the set purchase price, expressed in basis points (‱)
    // range (0‱ .. 10,000‱) corresponds to (0.00% .. 100.00%)
    uint256 discount;

    // number of remaining available tokens in tier
    uint256 available;
  }

  // upper-bound of basis point scale
  uint256 public constant MAX_DISCOUNT = 10000;


  /**************************************************************************
   * CREATE
   *************************************************************************/

  /*
   * @dev Add a new tier at the end of the list
   * @param _discount - Discount in basis points
   * @param _available - Available supply at tier
   */
  function addTier(
    Collection storage self,
    uint256 _discount,
    uint256 _available
  )
    internal
  {
    self.tiers.push(Tier({
      discount: _discount,
      available: _available
    }));
  }


  /**************************************************************************
   * PURCHASE
   *************************************************************************/

  /*
   * @dev Subtracts supply from tiers starting at a minimum, using up funds
   * @param _amount - Maximum number of tokens to purchase
   * @param _funds - Allowance in Wei
   * @param _minimumTier - Minimum tier to start purchasing from
   * @return Total tokens purchased and remaining funds in wei
   */
  function purchaseTokens(
    Collection storage self,
    uint256 _amount,
    uint256 _funds,
    uint256 _minimumTier
  )
    internal
    returns (
      uint256 purchased,
      uint256 remaining
    )
  {
    uint256 issue = 0; // tracks total tokens to issue
    remaining = _funds;

    uint256 available;  // var for available tokens at tier
    uint256 spend; // amount spent at tier
    uint256 affordable;  // var for # funds can pay for at tier
    uint256 purchase; // var for # to purchase at tier

    // for each tier starting at minimum
    // draw from the sent funds and count tokens to issue
    for (uint256 i = _minimumTier; i < self.tiers.length && issue < _amount; i++) {
      // get the available tokens left at each tier
      available = self.tiers[i].available;

      // compute the maximum tokens that the funds can pay for
      affordable = _computeTokensPurchasedAtTier(self, i, remaining);

      // either purchase what the funds can afford, or the whole supply
      // at the tier
      if (affordable < available) {
        purchase = affordable;
      } else {
        purchase = available;
      }

      // limit the amount purchased up to specified amount
      // use safemath here in case of unknown overflow risk
      if (purchase.add(issue) > _amount) {
        purchase = purchase.sub(purchase.add(issue).sub(_amount));
      }

      spend = _computeCostForTokensAtTier(self, i, purchase);

      // decrease available supply at tier
      self.tiers[i].available = self.tiers[i].available.sub(purchase);

      // increase tokens to issue
      issue = issue.add(purchase);

      // decrement funds to proceed
      remaining = remaining.sub(spend);
    }

    return (issue, remaining);
  }


  /**************************************************************************
   * PRICE MATH
   *************************************************************************/

  // @return total number of tokens for an amount of wei, discount-adjusted
  function _computeTokensPurchasedAtTier(
    Collection storage self,
    uint256 _tier,
    uint256 _wei
  )
    private
    view
    returns (uint256)
  {
    uint256 paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);

    return _wei.mul(self.baseRate).mul(MAX_DISCOUNT) / paidBasis;
  }

  // @return cost in wei for that many tokens
  function _computeCostForTokensAtTier(
    Collection storage self,
    uint256 _tier,
    uint256 _tokens
  )
    private
    view
    returns (uint256)
  {
    uint256 paidBasis = MAX_DISCOUNT.sub(self.tiers[_tier].discount);

    uint256 numerator = _tokens.mul(paidBasis);
    uint256 denominator = MAX_DISCOUNT.mul(self.baseRate);

    uint256 floor = _tokens.mul(paidBasis).div(
      MAX_DISCOUNT.mul(self.baseRate)
    );

    // must round up cost to next wei (cause token computation rounds down)
    if (numerator % denominator != 0) {
      floor = floor.add(1);
    }

    return floor;
  }
}

// File: contracts/Limits.sol

library Limits {

  using SafeMath for uint256;

  struct PurchaseRecord {
    uint256 blockNumber;
    uint256 amount;
  }

  struct Window {
    uint256 amount;  // # of tokens
    uint256 duration;  // # of blocks

    mapping (address => PurchaseRecord) purchases;
  }

  /*
   * Record a purchase towards a purchaser's cap limit
   * @dev resets the purchaser's cap if the window duration has been met
   * @param _participant - purchaser
   * @param _amount - token amount of new purchase
   */
  function recordPurchase(
    Window storage self,
    address _participant,
    uint256 _amount
  )
    internal
  {
    uint256 blocksLeft = getBlocksUntilReset(self, _participant);
    PurchaseRecord storage record = self.purchases[_participant];

    if (blocksLeft == 0) {
      record.amount = _amount;
      record.blockNumber = block.number;
    } else {
      record.amount = record.amount.add(_amount);
    }
  }

  /*
   * Retrieve the current limit for a given participant, based on previous
   * purchase history
   * @param _participant - Purchaser
   * @return amount of tokens left for participant with cap
   */
  function getLimit(Window storage self, address _participant)
    public
    view
    returns (uint256 _amount)
  {
    uint256 blocksLeft = getBlocksUntilReset(self, _participant);

    if (blocksLeft == 0) {
      return self.amount;
    } else {
      return self.amount.sub(self.purchases[_participant].amount);
    }
  }

  function getBlocksUntilReset(Window storage self, address _participant)
    public
    view
    returns (uint256 _blocks)
  {
    uint256 expires = self.purchases[_participant].blockNumber.add(self.duration);
    if (block.number > expires) {
      return 0;
    } else {
      return expires.sub(block.number);
    }
  }
}

// File: zeppelin-solidity/contracts/ownership/Ownable.sol
/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}

// File: zeppelin-solidity/contracts/ownership/Claimable.sol
/**
 * @title Claimable
 * @dev Extension for the Ownable contract, where the ownership needs to be claimed.
 * This allows the new owner to accept the transfer.
 */
contract Claimable is Ownable {
  address public pendingOwner;

  /**
   * @dev Modifier throws if called by any account other than the pendingOwner.
   */
  modifier onlyPendingOwner() {
    require(msg.sender == pendingOwner);
    _;
  }

  /**
   * @dev Allows the current owner to set the pendingOwner address.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner public {
    pendingOwner = newOwner;
  }

  /**
   * @dev Allows the pendingOwner address to finalize the transfer.
   */
  function claimOwnership() onlyPendingOwner public {
    OwnershipTransferred(owner, pendingOwner);
    owner = pendingOwner;
    pendingOwner = address(0);
  }
}

// File: zeppelin-solidity/contracts/math/SafeMath.sol
/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

// File: contracts/SeeToken.sol
/**
 * @title SEE Token
 * Not a full ERC20 token - prohibits transferring. Serves as a record of
 * account, to redeem for real tokens after launch.
 */
contract SeeToken is Claimable {
  using SafeMath for uint256;

  string public constant name = "See Presale Token";
  string public constant symbol = "SEE";
  uint8 public constant decimals = 18;

  uint256 public totalSupply;
  mapping (address => uint256) balances;

  event Issue(address to, uint256 amount);

  /**
   * @dev Issue new tokens
   * @param _to The address that will receive the minted tokens
   * @param _amount the amount of new tokens to issue
   */
  function issue(address _to, uint256 _amount) onlyOwner public {
    totalSupply = totalSupply.add(_amount);
    balances[_to] = balances[_to].add(_amount);

    Issue(_to, _amount);
  }

  /**
   * @dev Get the balance for a particular token holder
   * @param _holder The token holder's address
   * @return The holder's balance
   */
  function balanceOf(address _holder) public view returns (uint256 balance) {
    balance = balances[_holder];
  }
}

// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol
/**
 * @title Pausable
 * @dev Base contract which allows children to implement an emergency stop mechanism.
 */
contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  /**
   * @dev Modifier to make a function callable only when the contract is not paused.
   */
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  /**
   * @dev Modifier to make a function callable only when the contract is paused.
   */
  modifier whenPaused() {
    require(paused);
    _;
  }

  /**
   * @dev called by the owner to pause, triggers stopped state
   */
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  /**
   * @dev called by the owner to unpause, returns to normal state
   */
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}



// You task is to complete the smart contract Presale strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.4.18, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,
 *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {

  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;
  using SafeMath for uint256;

  /**
   * @notice Struct to store participant information.
   * @dev Contains whether the participant is authorized and their minimum tier.
   */
  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  /**************************************************************************
   * STORAGE / EVENTS
   *************************************************************************/

  SeeToken token;
  Discounts.Collection discounts;
  Limits.Window cap;
  mapping (address => Participant) participants;

  /**
   * @notice Emitted when a new tier is added.
   * @param discount The discount in basis points.
   * @param available The available supply at the tier.
   */
  event Tier(uint256 discount, uint256 available);

  /**************************************************************************
   * CONSTRUCTOR / LIFECYCLE
   *************************************************************************/

  function Presale(address _token)
    public
  {
    token = SeeToken(_token);
    paused = true;
  }

  /**
   * @notice Claims ownership of the token contract.
   * @dev This function should be called as part of the migration process.
   */
  function claimToken() public {
    token.transferOwnership(this);
    token.claimOwnership();
  }

  /**
   * @notice Unpauses the contract, allowing purchases.
   * @dev Can only be called by the owner, and the contract must be paused, have a set rate, be capped, and own the token.
   */
  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  /**************************************************************************
   * ADMIN INTERFACE
   *************************************************************************/

  /**
   * @notice Sets the base purchase rate for the token.
   * @param _purchaseRate The number of tokens granted per wei.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    discounts.baseRate = _purchaseRate;
  }

  /**
   * @notice Specifies purchasing limits for a single account.
   * @param _amount The limit of tokens that a participant may purchase.
   * @param _duration The duration in blocks over which the limit applies.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    cap.amount = _amount;
    cap.duration = _duration;
  }

  /**
   * @notice Adds a new tier with a given discount and available supply.
   * @param _discount The discount in basis points.
   * @param _available The available supply at the tier.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    discounts.addTier(_discount, _available);
    Tier(_discount, _available);
  }

  /**
   * @notice Authorizes a group of participants for a specific tier.
   * @param _minimumTier The minimum tier for the list of participants.
   * @param _authorized An array of addresses to be authorized.
   * @dev Can only be called by the owner.
   */
  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _authorized.length; i++) {
      participants[_authorized[i]].authorized = true;
      participants[_authorized[i]].minimumTier = _minimumTier;
    }
  }

  /**
   * @notice Withdraws the balance from the presale contract.
   * @dev Can only be called by the owner.
   */
  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(this.balance);
  }

  /**************************************************************************
   * PURCHASE INTERFACE
   *************************************************************************/

  /**
   * @notice Fallback function that forwards to `purchaseTokens()`.
   * @dev Accepts Ether and calls `purchaseTokens()`.
   */
  function ()
    public
    payable
  {
    purchaseTokens();
  }

  /**
   * @notice Public purchase interface for authorized participants.
   * @dev Purchases tokens starting from the authorized minimum tier.
   * Can only be called by an authorized participant and while the contract is not paused.
   */
  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    uint256 limit = cap.getLimit(msg.sender);

    uint256 tokens, remaining;
    (tokens, remaining) = discounts.purchaseTokens(
      limit,
      msg.value,
      participants[msg.sender].minimumTier
    );

    require(tokens > 0);

    cap.recordPurchase(msg.sender, tokens);
    token.issue(msg.sender, tokens);

    if (remaining > 0) {
      msg.sender.transfer(remaining);
    }
  }

  /**************************************************************************
   * PRICING / AVAILABILITY - VIEW INTERFACE
   *************************************************************************/

  /**
   * @notice Gets the terms for the purchasing limit window.
   * @return _amount The number of tokens allowed.
   * @return _duration The duration in blocks.
   */
  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    return (cap.amount, cap.duration);
  }

  /**
   * @notice Gets the tiers currently set up, with discounts and available supplies.
   * @return An array of tuples (discount, available).
   */
  function getTiers()
    public
    view
    returns (uint256[2][])
  {
    uint256[2][] memory _tiers = new uint256[2][](discounts.tiers.length);
    for (uint256 i = 0; i < discounts.tiers.length; i++) {
      _tiers[i][0] = discounts.tiers[i].discount;
      _tiers[i][1] = discounts.tiers[i].available;
    }
    return _tiers;
  }

  /**
   * @notice Gets the available supply for each tier for a given participant.
   * @param _participant The address of the participant.
   * @return An array of available supplies by tier index, zeroes for non-authorized participants.
   */
  function getAvailability(address _participant)
    public
    view
    returns (uint256[])
  {
    uint256[] memory availability = new uint256[](discounts.tiers.length);

    if (!participants[_participant].authorized) {
      return availability;
    }

    for (uint256 i = 0; i < discounts.tiers.length; i++) {
      availability[i] = discounts.tiers[i].available;
    }

    return availability;
  }

  /**************************************************************************
   * MODIFIERS
   *************************************************************************/

  /**
   * @dev Requires the participant to be whitelist-authorized.
   */
  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  /**
   * @dev Ensures the base rate is set (not zero).
   */
  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  /**
   * @dev Ensures the contract is capped (cap amount is not zero).
   */
  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  /**
   * @dev Ensures the contract owns the token.
   */
  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}
```