```solidity
pragma solidity ^0.4.24;

/**
 * @notice This contract implements a system for managing investments, dividends, and referrals.
 * It supports both pull and push payment modes for distributing dividends and handles investment
 * cycles (waves) with a pause period between them. The contract also includes a referral system
 * that rewards up to three levels of referrals.
 * @dev Inherits from `Accessibility` and `PaymentSystem` to manage access control and payment modes.
 */
contract Revolution is Accessibility, PaymentSystem {

  using Percent for Percent.percent;
  using SafeMath for uint256;
  using Zero for *;
  using ToAddress for *;

  // investors storage - iterable map;
  InvestorsStorage private m_investors;
  mapping(address => bool) private m_referrals;
  bool private m_nextWave;

  // automatically generates getters
  address public adminAddr;
  address public payerAddr;
  uint public waveStartup;
  uint public investmentsNum;
  uint public constant minInvesment = 10 finney; // 0.01 eth
  uint public constant maxBalance = 333e18; // 333e5 ether; // 33,300,000 eth
  uint public constant pauseOnNextWave = 168 hours;

  // percents 
  Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 333/10000*100% = 3.33%
  Percent.percent private m_adminPercent = Percent.percent(1, 10); // 1/10*100% = 10%
  Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7/100*100% = 7%
  Percent.percent private m_refPercent = Percent.percent(3, 100); // 3/100*100% = 3%

  // more events for easy read from blockchain
  event LogNewInvestor(address indexed addr, uint when, uint256 value);
  event LogNewInvesment(address indexed addr, uint when, uint256 value);
  event LogNewReferral(address indexed addr, uint when, uint256 value);
  event LogPayDividends(address indexed addr, uint when, uint256 value);
  event LogPayReferrerBonus(address indexed addr, uint when, uint256 value);
  event LogBalanceChanged(uint when, uint256 balance);
  event LogAdminAddrChanged(address indexed addr, uint when);
  event LogPayerAddrChanged(address indexed addr, uint when);
  event LogNextWave(uint when);

  /**
   * @dev Modifier to emit an event when the contract's balance changes.
   */
  modifier balanceChanged {
    _;
    emit LogBalanceChanged(now, address(this).balance);
  }

  /**
   * @dev Modifier to ensure the function is not called during the pause period after a new wave starts.
   */
  modifier notOnPause() {
    require(waveStartup + pauseOnNextWave <= now, "pause on next wave not expired");
    _;
  }

  constructor() public {
    m_investors = new InvestorsStorage();
    adminAddr = msg.sender;
    emit LogAdminAddrChanged(msg.sender, now);

    payerAddr = msg.sender;
    emit LogPayerAddrChanged(msg.sender, now);

    nextWave();
    waveStartup = waveStartup.sub(pauseOnNextWave);

    changePaymode(Paymode.Pull); // Initialize in pull mode
  }

  /**
   * @notice Fallback function to handle incoming ETH. If no ETH is sent, it triggers dividend withdrawal.
   * Otherwise, it processes a new investment.
   * @dev Uses the `notOnPause` and `balanceChanged` modifiers to enforce conditions.
   */
  function() public payable {
    // investor get him dividends
    if (msg.value == 0) {
      getMyDividends();
      return;
    }

    // sender do invest
    address a = msg.data.toAddr();
    address[3] memory refs;
    if (a.notZero()) {
      refs[0] = a;
      doInvest(refs); 
    } else {
      doInvest(refs);
    }
  }

  /**
   * @notice Returns the number of investors in the system.
   * @dev Adjusts the count by subtracting one due to the initial state of the storage.
   * @return The number of investors.
   */
  function investorsNumber() public view returns(uint256) {
      return m_investors.size().sub(1);
  }

  /**
   * @notice Returns the current ETH balance of the contract.
   * @return The current balance in wei.
   */
  function balanceETH() public view returns(uint256) {
      return address(this).balance;
  }

  /**
   * @notice Returns the percentage used for the payer's commission.
   * @return The numerator and denominator of the percentage.
   */
  function payerPercent() public view returns(uint256 numerator, uint256 denominator) {
      numerator = m_payerPercent.num;
      denominator = m_payerPercent.den;
  }

  /**
   * @notice Returns the percentage used for calculating dividends.
   * @return The numerator and denominator of the percentage.
   */
  function dividendsPercent() public view returns(uint256 numerator, uint256 denominator) {
      numerator = m_dividendsPercent.num;
      denominator = m_dividendsPercent.den;
  }

  /**
   * @notice Returns the percentage used for the admin's commission.
   * @return The numerator and denominator of the percentage.
   */
  function adminPercent() public view returns(uint256 numerator, uint256 denominator) {
      numerator = m_adminPercent.num;
      denominator = m_adminPercent.den;
  }

  /**
   * @notice Returns the percentage used for the referrer's bonus.
   * @return The numerator and denominator of the percentage.
   */
  function referrerPercent() public view returns(uint256 numerator, uint256 denominator) {
      numerator = m_refPercent.num;
      denominator = m_refPercent.den;
  }

  /**
   * @notice Returns detailed information about an investor.
   * @param addr The address of the investor.
   * @return The value of the investment, the last payment time, the referral bonus, and whether the investor is a referral.
   */
  function investorInfo(address addr) public view returns(uint256 value, uint256 paymentTime, uint256 refBonus, bool isReferral) {
      (value, paymentTime, refBonus) = m_investors.investorBaseInfo(addr);
      isReferral = m_referrals[addr];
  }

  /**
   * @notice Returns the timestamp of the latest payout.
   * @return The timestamp of the latest payout.
   */
  function latestPayout() public view returns(uint256 timestamp) {
    timestamp = m_paysys.latestTime;
  }

  /**
   * @notice Allows an investor to claim their accumulated dividends.
   * @dev
   * - Checks if the contract is not paused and the caller is in pull payment mode
   * - Verifies the caller has an active investor account
   * - Updates the investor's payment timestamp if needed
   * - Calculates the dividends based on investment amount and days since last payment
   * - Ensures sufficient contract balance before distribution
   * - Handles referral bonuses if applicable
   * - Triggers a new dividend wave if insufficient funds
   * @return None
   * @notice Emits events related to dividend payments and referral bonuses
   * @dev
   * - Uses SafeMath operations for arithmetic calculations
   * - Validates investor status and payment timestamps
   * - Manages dividend distribution and referral bonuses
   * - Implements wave-based dividend distribution logic
   */
  function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {
    address addr = msg.sender;

    require(m_investors.contains(addr), "not an investor");

    (uint256 value, uint256 paymentTime, uint256 refBonus) = m_investors.investorBaseInfo(addr);
    
    uint256 nowTime = now;

    if (paymentTime == 0) {
      m_investors.setPaymentTime(addr, nowTime);
      return;
    }

    uint256 timePassed = nowTime.sub(paymentTime);
    uint256 dividends = m_dividendsPercent.mul(value).mul(timePassed) / (1 days);

    require(address(this).balance >= dividends, "not enough funds to pay dividends");

    m_investors.setPaymentTime(addr, nowTime);

    sendDividends(addr, dividends);

    emit LogPayDividends(addr, nowTime, dividends);

    if (address(this).balance < minInvesment) {
      nextWave();
    }
  }

  /**
   * @notice Processes investment with referral bonuses and commissions.
   * @param refs Array of up to three referral addresses (level 1, 2, 3).
   * @dev
   * - Requires contract not paused and within balance limits
   * - Validates minimum investment amount
   * - Implements tiered referral bonus system (max 3 levels)
   * - Prevents duplicate referrals for sender
   * - Distributes admin/payer commissions
   * - Updates investor records and payment time (if pull mode)
   * - Emits investment/referral events
   * @notice Referral bonuses calculated as percentage of investment value
   */
  function doInvest(address[3] refs) public payable notOnPause balanceChanged {
    uint256 value = msg.value;
    address addr = msg.sender;

    require(address(this).balance.add(value) <= maxBalance, "max balance limit");
    require(value >= minInvesment, "min investment");

    uint256 refBonusTotal = m_refPercent.mul(value);
    uint256 adminCommission = m_adminPercent.mul(value);
    uint256 payerCommission = m_payerPercent.mul(value);

    uint256 valueToInvestor = value.sub(refBonusTotal).sub(adminCommission).sub(payerCommission);

    if (!m_investors.contains(addr)) {
      m_investors.insert(addr, valueToInvestor);
      investmentsNum = investmentsNum.add(1);

      emit LogNewInvestor(addr, now, valueToInvestor);
    } else {
      m_investors.addValue(addr, valueToInvestor);

      emit LogNewInvesment(addr, now, valueToInvestor);
    }

    address ref1 = refs[0];

    if (notZeroNotSender(ref1) && !m_referrals[addr]) {
      uint256 refBonus1 = refBonusTotal; // All ref bonus goes to first level in this simplified example

      if (m_investors.contains(ref1)) {
        m_investors.addRefBonus(ref1, refBonus1);
        m_referrals[addr] = true;

        emit LogNewReferral(addr, now, value);
        emit LogPayReferrerBonus(ref1, now, refBonus1);
      }
    }

    // Admin and payer payouts
    adminAddr.transfer(adminCommission);
    payerAddr.transfer(payerCommission);

    m_investors.setPaymentTime(addr, now);

    if (address(this).balance < minInvesment) {
      nextWave();
    }
  }

  /**
   * @notice Distributes dividends to investors in push mode.
   * @dev
   * - Only callable by admin with Payout access rank
   * - Uses push payment mode (atPaymode(Paymode.Push))
   * - Checks if next wave should be initiated
   * - Validates minimum payment interval (12 hours)
   * - Processes investor payments in batches to prevent gas limit issues
   * - Calculates dividends based on investment value and percentage
   * - Handles referral bonuses if applicable
   * - Updates payment progress tracking
   * - Automatically starts new wave if funds are insufficient
   * @notice Emits events for dividend payments and referral bonuses
   * @dev
   * - Uses gasleft() check to prevent out-of-gas errors
   * - Implements batch processing with safe iteration
   * - Maintains payment progress between transactions
   */
  function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {
    require(now > m_paysys.latestTime.add(12 hours), "min payout interval");

    uint256 investorsCount = m_investors.size();
    uint256 start = m_paysys.latestKeyIndex == 0 ? m_investors.iterStart() : m_paysys.latestKeyIndex;

    uint256 gasStart = gasleft();

    for (uint256 i = start; i < investorsCount && gasleft() > gasStart.div(2); i++) {
      address investorAddr = m_investors.keyFromIndex(i);

      (uint256 value, uint256 paymentTime, uint256 refBonus) = m_investors.investorBaseInfo(investorAddr);

      uint256 nowTime = now;
      uint256 timePassed = nowTime.sub(paymentTime);
      uint256 dividends = m_dividendsPercent.mul(value).mul(timePassed) / (1 days);

      if (dividends > 0) {
        if (refBonus > 0) {
          sendDividendsWithRefBonus(investorAddr, dividends, refBonus);
          emit LogPayReferrerBonus(investorAddr, nowTime, refBonus);
          m_investors.setRefBonus(investorAddr, 0);
        } else {
          sendDividends(investorAddr, dividends);
        }

        emit LogPayDividends(investorAddr, nowTime, dividends);
        m_investors.setPaymentTime(investorAddr, nowTime);
      }
       m_paysys.latestKeyIndex = i.add(1);
    }

    m_paysys.latestTime = now;
    if (m_paysys.latestKeyIndex >= investorsCount){
         m_paysys.latestKeyIndex = 0;
    }


    if (address(this).balance < minInvesment) {
      nextWave();
    }
  }

  /**
   * @notice Sets the admin address.
   * @param addr The new admin address.
   * @dev Requires the caller to have full admin access.
   */
  function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {
    require(addr != address(0), "invalid address");
    adminAddr = addr;
    emit LogAdminAddrChanged(addr, now);
  }

  /**
   * @notice Sets the payer address.
   * @param addr The new payer address.
   * @dev Requires the caller to have full admin access.
   */
  function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {
    require(addr != address(0), "invalid address");
    payerAddr = addr;
    emit LogPayerAddrChanged(addr, now);
  }

  /**
   * @notice Changes the payment mode to pull.
   * @dev Requires the caller to have paymode admin access and the current mode to be push.
   */
  function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {
    changePaymode(Paymode.Pull);
  }

  /**
   * @notice Retrieves the investor information from storage.
   * @param addr The address of the investor.
   * @return The investor's information.
   * @dev Internal function used to fetch investor data.
   */
  function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {
      InvestorsStorage.itmap storage s = m_investors.s();
    return s.data[addr];
  }

  /**
   * @notice Checks if an address is not zero and not the sender.
   * @param addr The address to check.
   * @return True if the address is valid, false otherwise.
   * @dev Internal function used to validate referral addresses.
   */
  function notZeroNotSender(address addr) internal view returns(bool) {
    return (addr != address(0) && addr != msg.sender);
  }

  /**
   * @notice Sends dividends to an investor.
   * @param addr The address of the investor.
   * @param value The amount of dividends to send.
   * @dev Private function to handle the actual transfer.
   */
  function sendDividends(address addr, uint256 value) private {
    addr.transfer(value);
  }

  /**
   * @notice Sends dividends along with a referral bonus to an investor.
   * @param addr The address of the investor.
   * @param value The amount of dividends to send.
   * @param refBonus The amount of referral bonus to send.
   * @dev Private function to handle the combined transfer.
   */
  function sendDividendsWithRefBonus(address addr, uint256 value, uint256 refBonus) private {
    uint256 total = value.add(refBonus);
    addr.transfer(total);
  }

  /**
   * @notice Initializes a new wave, resetting the system and changing the payment mode.
   * @dev Private function to handle the transition to a new wave.
   */
  function nextWave() private {
    waveStartup = now;
    m_nextWave = true;
    emit LogNextWave(now);

    m_paysys.latestTime = 0;
    m_paysys.latestKeyIndex = 0;

    changePaymode(Paymode.Pull);
  }
}
```