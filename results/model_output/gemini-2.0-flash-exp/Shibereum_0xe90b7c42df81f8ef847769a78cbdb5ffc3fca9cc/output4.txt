```solidity
// SPDX-License-Identifier: MIT

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IUniswapV2Router {
    function factory() external pure returns (address);
    function WETH() external pure returns (address);
    function swapExactTokensForETHSupportingFeeOnTransferTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external;
}

interface IUniswapV2Factory {
    function createPair(address tokenA, address tokenB) external returns (address pair);
}

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    modifier onlyOwner() {
        require(_owner == msg.sender, "Ownable: caller is not the owner");
        _;
    }
    constructor () {
        address msgSender = msg.sender;
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
}


contract Shibereum is IERC20, Ownable {       
    string private constant _name = "Shibereum.Ai";
    string private constant _symbol = "Shibereum";
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _blocked;

    mapping (address => uint256) private _lastTradeBlock;
    mapping (address => bool) private isContractExempt;
    uint256 private tradeCooldown = 1;
    
    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;
    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;
    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;

    struct TradingFees{
        uint256 buyTax;
        uint256 sellTax;
    }  

    TradingFees public tradingFees = TradingFees(10,45);
    uint256 public constant sniperTax = 49;

    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address private immutable ETH = uniswapRouter.WETH();
    address private immutable uniswapPair;

    address payable private immutable deployerAddress = payable(msg.sender);
    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);

    bool private tradingOpen = false;
    bool private swapping = false;
    bool private antiMEV = false;
    uint256 private startingBlock;
    uint private preLaunch;

    modifier swapLock {
        swapping = true;
        _;
        swapping = false;
    }

    modifier tradingLock(address sender) {
        require(tradingOpen || sender == deployerAddress || sender == devWallet, "Trading is not open yet");
        _;
    }

    constructor () {
        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);
        isContractExempt[address(this)] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    
    function name() public pure returns (string memory) {
        return _name;
    }

    
    function symbol() public pure returns (string memory) {
        return _symbol;
    }

    
    function decimals() public pure returns (uint8) {
        return _decimals;
    }

    
    function totalSupply() public pure returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        _transfer(sender, recipient, amount);
        return true;
    }

    
    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    
    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        if (_blocked[from] || _blocked[to]) {
            revert("Blacklisted address");
        }

        if (!isContractExempt[from] && !isContractExempt[to] && antiMEV) {
            address human = ensureOneHuman(to, from);
            ensureMaxTxFrequency(human);
        }


        if (to != address(uniswapRouter) && to != uniswapPair) {
            require(balanceOf(to) + amount <= maxWalletAmount, "Exceeds maximum wallet amount.");
        }

        uint256 contractBalance = balanceOf(address(this));

        if (shouldSwapback(from, amount) && contractBalance > contractSwapLimit) {
            uint256 swapAmount = getSwapAmount(contractBalance);
            swapback(swapAmount);
        }
        
        uint256 feeAmount = takeFee(from, amount);
        uint256 transferAmount = amount - feeAmount;

        _balances[from] -= amount;
        _balances[to] += transferAmount;
        if(feeAmount > 0){
             _balances[address(this)] += feeAmount;
             emit Transfer(from, address(this), feeAmount);
        }


        emit Transfer(from, to, transferAmount);
    }

    
    function swapback(uint256 tokenAmount) private swapLock {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ETH;

        _approve(address(this), address(uniswapRouter), tokenAmount);

        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            address(devWallet),
            block.timestamp
        );
    }

    
    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool) {
         return from != uniswapPair && !swapping && balanceOf(address(this)) >= contractSwapLimit;
    }

    
    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {
        return tokenAmount > contractSwapMax ? contractSwapMax : tokenAmount;
    }

    
    function takeFee(address from, uint256 amount) private view returns (uint256) {
        uint256 fee = 0;
        if(from == uniswapPair){
            fee = amount * tradingFees.buyTax / 1000;
        } else if (uniswapPair != address(0)){
            fee = amount * tradingFees.sellTax / 1000;
        }
        return fee;
    }

    
    function isContract(address account) private view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }

    
    function ensureOneHuman(address _to, address _from) private view returns (address) {
        bool toIsContract = isContract(_to);
        bool fromIsContract = isContract(_from);
        require(!(toIsContract && fromIsContract), "At least one address must be a human.");

        return toIsContract ? _from : _to;
    }

    
    function ensureMaxTxFrequency(address addr) view private {
        require(block.number >= _lastTradeBlock[addr] + tradeCooldown, "Cool down not over yet");
        _lastTradeBlock[addr] = block.number;
    }

    
    function toggleAntiMEV(bool toggle) external onlyOwner {
        antiMEV = toggle;
    }

    
    function setTradeCooldown(uint256 newTradeCooldown) external onlyOwner {
        tradeCooldown = newTradeCooldown;
    }

    
    function manualSwapback(uint256 percent) external onlyOwner {
        require(percent <= 100, "Percent must be <= 100");
        uint256 tokenAmount = balanceOf(address(this)) * percent / 100;
        swapback(tokenAmount);
    }

    
    function setFees(uint256 newBuyTax, uint256 newSellTax) external onlyOwner {
        tradingFees.buyTax = newBuyTax;
        tradingFees.sellTax = newSellTax;
    }

    
    function setContractExempt(address account, bool value) external onlyOwner {
        isContractExempt[account] = value;
    }

    
    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {
        for (uint256 i = 0; i < bots.length; i++) {
            _blocked[bots[i]] = shouldBlock;
        }
    }

    
    function initialize() external onlyOwner {
        require(!tradingOpen, "Trading is already open");
        tradingOpen = true;
        startingBlock = block.number;
    }

   
    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {
        require(!tradingOpen, "Trading must be closed to modify parameters.");
        preLaunch = nrBlocks;
    }

    
    function openTrading() external onlyOwner {
         require(!tradingOpen, "Trading is already open");
        tradingOpen = true;
        startingBlock = block.number;
    }
}
```