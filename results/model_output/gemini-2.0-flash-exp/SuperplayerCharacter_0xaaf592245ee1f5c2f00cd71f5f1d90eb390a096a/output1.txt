```solidity
pragma solidity ^0.5.1;

/**
 *Submitted for verification at Etherscan.io on 2019-07-09
*/
// File: openzeppelin-solidity/contracts/math/SafeMath.sol
/**
 * @dev Wrappers over Solidity's arithmetic operations with added overflow
 * checks.
 *
 * Arithmetic operations in Solidity wrap on overflow. This can easily result
 * in bugs, because programmers usually assume that an overflow raises an
 * error, which is the standard behavior in high level programming languages.
 * `SafeMath` restores this intuition by reverting the transaction when an
 * operation overflows.
 *
 * Using this library instead of the unchecked operations eliminates an entire
 * class of bugs, so it's recommended to use it always.
 */

library SafeMath {
    /**
     * @dev Returns the addition of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `+` operator.
     *
     * Requirements:
     * - Addition cannot overflow.
     */
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, reverting on
     * overflow (when the result is negative).
     *
     * Counterpart to Solidity's `-` operator.
     *
     * Requirements:
     * - Subtraction cannot overflow.
     */
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;

        return c;
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, reverting on
     * overflow.
     *
     * Counterpart to Solidity's `*` operator.
     *
     * Requirements:
     * - Multiplication cannot overflow.
     */
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
        // benefit is lost if 'b' is also tested.
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    /**
     * @dev Returns the integer division of two unsigned integers. Reverts on
     * division by zero. The result is rounded towards zero.
     *
     * Counterpart to Solidity's `/` operator. Note: this function uses a
     * `revert` opcode (which leaves remaining gas untouched) while Solidity
     * uses an invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, "SafeMath: division by zero");
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold

        return c;
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
     * Reverts when dividing by zero.
     *
     * Counterpart to Solidity's `%` operator. This function uses a `revert`
     * opcode (which leaves remaining gas untouched) while Solidity uses an
     * invalid opcode to revert (consuming all remaining gas).
     *
     * Requirements:
     * - The divisor cannot be zero.
     */
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0, "SafeMath: modulo by zero");
        return a % b;
    }
}

// File: openzeppelin-solidity/contracts/ownership/Ownable.sol
/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be aplied to your functions to restrict their use to
 * the owner.
 */

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor () internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(isOwner(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Returns true if the caller is the current owner.
     */
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * > Note: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     */
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}



// You task is to complete the smart contract SuperplayerCharacter strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.5.1, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @notice This contract manages a set of characters that users can select. Each character has an ID and a weight, which is used in a weighted random selection process. The contract also allows the owner to add new characters, set a fee for changing characters, and withdraw funds.
 * @dev The contract uses SafeMath for arithmetic operations to prevent overflows and underflows. It also emits events and maintains mappings and arrays to track character selections and configurations.
 */
contract SuperplayerCharacter is Ownable {
  using SafeMath for uint256;

  /**
   * @notice Emitted when a user selects a character.
   * @param from The address of the user who selected the character.
   * @param chaId The ID of the character selected.
   */
  event CharacterSelect(address from, uint32 chaId);

  /**
   * @notice A mapping that associates each address with a character ID.
   */
  mapping(address => uint32) public addrMapCharacterIds;

  /**
   * @notice The fee required to change a character.
   */
  uint256 public changeFee = 0;

  /**
   * @notice A struct representing a character, which includes an ID and a weight.
   */
  struct Character {
    uint32 id;
    uint weight;
  }

  /**
   * @notice An array of characters.
   */
  Character[] private characters;

  /**
   * @notice The total number of characters.
   */
  uint256 public totalNum = 0;

  /**
   * @notice The sum of all character weights.
   */
  uint256 public totalWeight = 0;

  /**
   * @notice Initializes the contract by adding initial characters.
   */
  constructor() public {
      _addCharacter(1, 1000000);
      _addCharacter(2, 1000000);
      _addCharacter(3, 1000000);
      _addCharacter(4, 1000);
      _addCharacter(5, 1000);
      _addCharacter(6, 1000);
  }

  /**
   * @notice Allows the owner to add a new character.
   * @param id The ID of the new character.
   * @param weight The weight of the new character.
   */
  function AddCharacter(uint32 id, uint weight) public onlyOwner {
      _addCharacter(id, weight);
  }

  /**
   * @notice Allows the owner to set the fee for changing a character.
   * @param fee The new fee amount.
   */
  function SetFee(uint256 fee) public onlyOwner {
      changeFee = fee;
  }

  /**
   * @notice Allows the owner to withdraw the contract's balance.
   * @param to The address to send the funds to.
   */
  function withdraw(address payable to) public onlyOwner {
    to.transfer(address(this).balance);
  }

  /**
   * @notice Returns the configuration of all characters, including their IDs and weights.
   * @return ids An array of character IDs.
   * @return weights An array of character weights.
   */
  function getConfig() public view returns (uint32[] memory ids, uint256[] memory weights) {
        uint256 len = characters.length;
        ids = new uint32[](len);
        weights = new uint256[](len);

        for (uint256 i = 0; i < len; i++) {
            ids[i] = characters[i].id;
            weights[i] = characters[i].weight;
        }
  }

  /**
   * @notice Allows users to select a character by sending a transaction with the required fee.
   */
  function () payable external {
    require(msg.value >= changeFee, "Insufficient fee");
    uint256 sum = 0 ;
    uint256 index = characters.length;

    uint256 weight = uint256(keccak256(abi.encodePacked(block.timestamp,msg.value,block.difficulty))) %totalWeight + 1;

    for (uint256 i = 0;i < characters.length ; i++){
      Character memory ch  = characters[i];
      sum = sum.add(ch.weight);
      if( weight  <=  sum ){
        index = i;
        break;
      }
    }
    require(index < characters.length, "No character selected");
    _selectCharacter(msg.sender,characters[index].id);

    if(msg.value > changeFee){
        msg.sender.transfer(msg.value.sub(changeFee));
    }

  }

  /**
   * @dev Internal function to select a character for a user.
   * @param from The address of the user.
   * @param id The ID of the character to select.
   */
  function _selectCharacter(address from, uint32 id) internal {
      addrMapCharacterIds[from] = id;
      emit CharacterSelect(from, id);
  }

  /**
   * @dev Internal function to add a new character to the list.
   * @param id The ID of the new character.
   * @param weight The weight of the new character.
   */
  function _addCharacter(uint32 id, uint weight) internal {
      characters.push(Character(id, weight));
      totalNum = totalNum.add(1);
      totalWeight = totalWeight.add(weight);
  }
}
```