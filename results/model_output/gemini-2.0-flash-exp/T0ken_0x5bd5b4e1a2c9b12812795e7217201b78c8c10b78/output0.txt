```solidity
pragma solidity ^0.5.2;

/**
 * @title T0ken
 * @notice A token contract that extends ERC20, Ownable, and LockableDestroyable. It includes features for issuing tokens, managing shareholders, and compliance checks.
 * @dev This contract is designed to manage a token with specific compliance rules, allowing for the issuance of tokens, transfer of tokens, and management of shareholders. It also includes functionality to cancel and reissue tokens to new addresses.
 */
contract T0ken is ERC20, Ownable, LockableDestroyable {

    // ------------------------------- Variables -------------------------------

    using AdditiveMath for uint256;
    using AddressMap for AddressMap.Data;

    address constant internal ZERO_ADDRESS = address(0);
    string public constant name = "TZERO PREFERRED";
    string public constant symbol = "TZROP";
    uint8 public constant decimals = 0;

    AddressMap.Data public shareholders;
    Compliance public compliance;
    address public issuer;
    bool public issuingFinished = false;
    mapping(address => address) public cancellations;

    mapping(address => uint256) internal balances;
    uint256 internal totalSupplyTokens;

    mapping (address => mapping (address => uint256)) private allowed;

    // ------------------------------- Modifiers -------------------------------

    /**
     * @notice Modifier to ensure only the issuer can call the function.
     * @dev Reverts if the caller is not the issuer.
     */
    modifier onlyIssuer() {
        require(msg.sender == issuer, "Only issuer allowed");
        _;
    }

    /**
     * @notice Modifier to ensure token issuance is not finished.
     * @dev Reverts if issuing is already finished.
     */
    modifier canIssue() {
        require(!issuingFinished, "Issuing is already finished");
        _;
    }

    /**
     * @notice Modifier to ensure the address has not been cancelled.
     * @dev Reverts if the address has been cancelled.
     * @param addr The address to check.
     */
    modifier isNotCancelled(address addr) {
        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");
        _;
    }

    /**
     * @notice Modifier to ensure the address has sufficient funds.
     * @dev Reverts if the address does not have enough tokens.
     * @param addr The address to check.
     * @param tokens The number of tokens to check.
     */
    modifier hasFunds(address addr, uint256 tokens) {
        require(tokens <= balances[addr], "Insufficient funds");
        _;
    }

    // -------------------------------- Events ---------------------------------

    /**
     * @notice Emitted when an address is cancelled and replaced with a new address.
     * @dev This event is used to log the replacement of a shareholder's address.
     * @param original The address being superseded.
     * @param replacement The new address.
     * @param sender The address that caused the address to be superseded.
     */
    event VerifiedAddressSuperseded(address indexed original, address indexed replacement, address indexed sender);

    /**
     * @notice Emitted when the issuer address is set.
     * @dev This event is used to log the change in the issuer address.
     * @param previousIssuer The previous issuer address.
     * @param newIssuer The new issuer address.
     */
    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);

    /**
     * @notice Emitted when tokens are issued.
     * @dev This event is used to log the issuance of tokens.
     * @param to The address to which tokens are issued.
     * @param tokens The number of tokens issued.
     */
    event Issue(address indexed to, uint256 tokens);

    /**
     * @notice Emitted when token issuance is finished.
     * @dev This event is used to log the completion of token issuance.
     */
    event IssueFinished();

    /**
     * @notice Emitted when a shareholder is added.
     * @dev This event is used to log the addition of a new shareholder.
     * @param shareholder The address of the new shareholder.
     */
    event ShareholderAdded(address shareholder);

    /**
     * @notice Emitted when a shareholder is removed.
     * @dev This event is used to log the removal of a shareholder.
     * @param shareholder The address of the removed shareholder.
     */
    event ShareholderRemoved(address shareholder);

    // -------------------------------------------------------------------------

    /**
     * @notice Transfers tokens to the whitelisted account.
     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed from the list of shareholders.
     * @param to The address to transfer to.
     * @param tokens The number of tokens to be transferred.
     * @return A boolean that indicates if the operation was successful.
     */
    function transfer(address to, uint256 tokens)
    external
    isUnlocked
    isNotCancelled(to)
    hasFunds(msg.sender, tokens)
    returns (bool) {
        require(canTransfer(msg.sender, to, tokens, false), "Transfer failed compliance check");
        transferTokens(msg.sender, to, tokens);
        return true;
    }

    /**
     * @notice Transfers tokens between whitelisted accounts.
     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'from' balance to 0, then that address MUST be removed from the list of shareholders.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokens The number of tokens to be transferred.
     * @return A boolean that indicates if the operation was successful.
     */
    function transferFrom(address from, address to, uint256 tokens)
    external
    isUnlocked
    isNotCancelled(to)
    hasFunds(from, tokens)
    returns (bool) {
        require(allowed[from][msg.sender] >= tokens, "Allowance too low");
        require(canTransfer(from, to, tokens, false), "TransferFrom failed compliance check");
        allowed[from][msg.sender] = allowed[from][msg.sender].subtract(tokens);
        transferTokens(from, to, tokens);
        return true;
    }

    /**
     * @notice Overrides a transfer of tokens to the whitelisted account.
     * @dev If the 'to' address is not currently a shareholder, it MUST become one. If the transfer will reduce 'msg.sender' balance to 0, then that address MUST be removed from the list of shareholders.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param tokens The number of tokens to be transferred.
     * @return A boolean that indicates if the operation was successful.
     */
    function transferOverride(address from, address to, uint256 tokens)
    external
    isUnlocked
    isNotCancelled(to)
    hasFunds(from, tokens)
    returns (bool) {
        require(canTransfer(from, to, tokens, true), "TransferOverride failed compliance check");
        transferTokens(from, to, tokens);
        return true;
    }

    /**
     * @notice Issues tokens to the issuer's address only.
     * @dev Tokens will be issued to the issuer's address only.
     * @param quantity The number of tokens to mint.
     * @return A boolean that indicates if the operation was successful.
     */
    function issueTokens(uint256 quantity)
    external
    isUnlocked
    onlyIssuer
    canIssue
    returns (bool) {
        balances[issuer] = balances[issuer].add(quantity);
        totalSupplyTokens = totalSupplyTokens.add(quantity);
        shareholders.append(issuer);
        emit Issue(issuer, quantity);
        emit Transfer(address(0), issuer, quantity);
        return true;
    }

    /**
     * @notice Finishes token issuance.
     * @dev This is a single-use function; once invoked, it cannot be undone.
     * @return A boolean that indicates if the operation was successful.
     */
    function finishIssuing()
    external
    isUnlocked
    onlyIssuer
    canIssue
    returns (bool) {
        issuingFinished = true;
        emit IssueFinished();
        return true;
    }

    /**
     * @notice Cancels the original address and reissues the tokens to the replacement address.
     * @dev Access to this function is restricted to the issuer only. The 'original' address MUST be removed from the set of whitelisted addresses. Throws if the 'original' address supplied is not a shareholder or if the 'replacement' address is not a whitelisted address.
     * @param original The address to be superseded. This address MUST NOT be reused and must be whitelisted.
     * @param replacement The address that supersedes the original. This address MUST be whitelisted.
     */
    function cancelAndReissue(address original, address replacement)
    external
    isUnlocked
    onlyIssuer
    isNotCancelled(replacement) {
        require(shareholders.exists(original), "Original address is not a shareholder");
        require(balances[original] > 0, "Original address has no balance");

        uint256 originalBalance = balances[original];

        balances[original] = 0;
        balances[replacement] = balances[replacement].add(originalBalance);

        shareholders.remove(original);
        shareholders.append(replacement);

        cancellations[original] = replacement;

        emit VerifiedAddressSuperseded(original, replacement, msg.sender);
        emit Transfer(original, replacement, originalBalance);
    }

    /**
     * @notice Approves the passed address to spend the specified number of tokens on behalf of msg.sender.
     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards.
     * @param spender The address which will spend the funds.
     * @param tokens The number of tokens to be spent.
     * @return A boolean that indicates if the operation was successful.
     */
    function approve(address spender, uint256 tokens)
    external
    isUnlocked
    isNotCancelled(msg.sender)
    returns (bool) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    /**
     * @notice Sets the issuer address.
     * @dev Only the owner can set the issuer address.
     * @param newIssuer The address of the new issuer.
     */
    function setIssuer(address newIssuer)
    external
    isUnlocked
    onlyOwner {
        require(newIssuer != ZERO_ADDRESS, "New issuer cannot be zero address");
        emit IssuerSet(issuer, newIssuer);
        issuer = newIssuer;
    }

    /**
     * @notice Sets the compliance contract address to use during transfers.
     * @dev Only the owner can set the compliance contract address.
     * @param newComplianceAddress The address of the new compliance contract.
     */
    function setCompliance(address newComplianceAddress)
    external
    isUnlocked
    onlyOwner {
        require(newComplianceAddress != ZERO_ADDRESS, "Compliance address cannot be zero address");
        compliance = Compliance(newComplianceAddress);
    }

    // -------------------------------- Getters --------------------------------

    /**
     * @notice Returns the total token supply.
     * @dev Returns the total number of tokens in existence.
     * @return The total number of tokens in existence.
     */
    function totalSupply()
    external
    view
    returns (uint256) {
        return totalSupplyTokens;
    }

    /**
     * @notice Gets the balance of the specified address.
     * @dev Returns the number of tokens owned by the passed address.
     * @param addr The address to query the balance of.
     * @return The number of tokens owned by the passed address.
     */
    function balanceOf(address addr)
    external
    view
    returns (uint256) {
        return balances[addr];
    }

    /**
     * @notice Gets the number of tokens that an owner has allowed the spender to transfer.
     * @dev Returns the number of tokens still available for the spender.
     * @param addrOwner The address which owns the funds.
     * @param spender The address which will spend the funds.
     * @return The number of tokens still available for the spender.
     */
    function allowance(address addrOwner, address spender)
    external
    view
    returns (uint256) {
        return allowed[addrOwner][spender];
    }

    /**
     * @notice Returns the holder at the given index.
     * @dev By counting the number of token holders using 'holderCount', you can retrieve the complete list of token holders, one at a time. It MUST throw if 'index >= holderCount()'.
     * @param index The zero-based index of the holder.
     * @return The address of the token holder with the given index.
     */
    function holderAt(int256 index)
    external
    view
    returns (address) {
        return shareholders.at(index);
    }

    /**
     * @notice Checks to see if the supplied address is a shareholder.
     * @dev Returns true if the supplied address owns a token.
     * @param addr The address to check.
     * @return True if the supplied address owns a token.
     */
    function isHolder(address addr)
    external
    view
    returns (bool) {
        return shareholders.exists(addr);
    }

    /**
     * @notice Checks to see if the supplied address was superseded.
     * @dev Returns true if the supplied address was superseded by another address.
     * @param addr The address to check.
     * @return True if the supplied address was superseded by another address.
     */
    function isSuperseded(address addr)
    external
    view
    returns (bool) {
        return cancellations[addr] != ZERO_ADDRESS;
    }

    /**
     * @notice Gets the most recent address, given a superseded one.
     * @dev Addresses may be superseded multiple times, so this function needs to follow the chain of addresses until it reaches the final, verified address.
     * @param addr The superseded address.
     * @return The verified address that ultimately holds the share.
     */
    function getSuperseded(address addr)
    external
    view
    returns (address) {
        address current = addr;
        while (cancellations[current] != ZERO_ADDRESS) {
            current = cancellations[current];
        }
        return current;
    }

    // -------------------------------- Private --------------------------------

    /**
     * @notice Checks if a transfer/override may take place between the two accounts.
     * @dev Validates that the transfer can take place. Ensures the 'to' address is not cancelled and that the transfer is compliant.
     * @param from The sender address.
     * @param to The recipient address.
     * @param tokens The number of tokens being transferred.
     * @param isOverride If this is a transfer override.
     * @return If the transfer can take place.
     */
    function canTransfer(address from, address to, uint256 tokens, bool isOverride)
    private
    isNotCancelled(to)
    returns (bool) {
        if (address(compliance) == address(0)) {
            return true; // No compliance contract set, allow all transfers
        }

        if (isOverride) {
            return compliance.canOverride(msg.sender, from, to, tokens);
        } else {
            return compliance.canTransfer(msg.sender, from, to, tokens);
        }
    }

    /**
     * @notice Transfers tokens from one address to another.
     * @dev Updates balances and emits the Transfer event. Adds the shareholder if they don't already exist and removes the shareholder if they no longer hold tokens.
     * @param from The sender address.
     * @param to The recipient address.
     * @param tokens The number of tokens being transferred.
     */
    function transferTokens(address from, address to, uint256 tokens)
    private {
        balances[from] = balances[from].subtract(tokens);
        balances[to] = balances[to].add(tokens);

        if (!shareholders.exists(to)) {
            shareholders.append(to);
            emit ShareholderAdded(to);
        }

        if (balances[from] == 0) {
            shareholders.remove(from);
            emit ShareholderRemoved(from);
        }

        emit Transfer(from, to, tokens);
    }
}
```