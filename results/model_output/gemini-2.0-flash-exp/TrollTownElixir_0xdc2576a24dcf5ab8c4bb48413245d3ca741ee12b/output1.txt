```solidity
// SPDX-License-Identifier: MIT
/**
 * @title TrollTownElixir
 * @author AhmYieTrollElixir
 * @dev Used for Ethereum projects compatible with OpenSea
 */

interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

interface IERC1155 is IERC165 {
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);
    event URI(string value, uint256 indexed id);
    function balanceOf(address account, uint256 id) external view returns (uint256);
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);
    function setApprovalForAll(address operator, bool approved) external;
    function isApprovedForAll(address account, address operator) external view returns (bool);
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}

interface IERC1155Receiver is IERC165 {
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

interface IERC1155MetadataURI is IERC1155 {
    function uri(uint256 id) external view returns (string memory);
}

library Address {
    function isContract(address account) internal view returns (bool) {
        // for contracts in construction, since the code is only stored at the end

        return account.code.length > 0;
    }
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            if (returndata.length > 0) {

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract ERC165 is IERC165 {
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}



// You task is to complete the smart contract ERC1155 strictly according to the provided context and description. Note that the contract is deployed using compiler version 0.8.4, and do not introduce any additional contracts, dependencies, or unrelated code. Deliver only the complete and functional target contract without any extraneous implementations or examples.

/**
 * @notice This contract implements the ERC1155 standard, which allows for the creation and management of both fungible and non-fungible tokens.
 * @dev The contract includes functions for minting, burning, transferring, and setting approvals for token transfers. It also supports batch operations.
 */
contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {
    using Address for address;
    mapping(uint256 => mapping(address => uint256)) private _balances;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    string private _uri;

    constructor(string memory uri_) {
        _setURI(uri_);
    }

    /**
     * @notice Checks if the contract implements a specific interface.
     * @param interfaceId The interface identifier to check.
     * @return A boolean indicating whether the interface is supported.
     * @dev This function is used to check if the contract supports the ERC1155 and ERC1155MetadataURI interfaces.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155).interfaceId || interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC1155MetadataURI).interfaceId;
    }

    /**
     * @notice Returns the URI for a given token ID.
     * @param id The token ID to query.
     * @return The URI associated with the token ID.
     * @dev The URI can be used to retrieve metadata about the token.
     */
    function uri(uint256 id) public view virtual override returns (string memory) {
        return string(abi.encodePacked(_uri, Strings.toString(id)));
    }

    /**
     * @notice Gets the balance of a specific token ID for an account.
     * @param account The account to query.
     * @param id The token ID to query.
     * @return The balance of the specified token ID for the given account.
     * @dev Reverts if the account is the zero address.
     */
    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        require(account != address(0), "ERC1155: address cannot be zero");
        return _balances[id][account];
    }

    /**
     * @notice Gets the balances of multiple token IDs for multiple accounts.
     * @param accounts The list of accounts to query.
     * @param ids The list of token IDs to query.
     * @return An array of balances corresponding to the provided accounts and token IDs.
     * @dev Reverts if the lengths of the accounts and ids arrays do not match.
     */
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)
        public
        view
        virtual
        override
        returns (uint256[] memory)
    {
        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");

        uint256[] memory batchBalances = new uint256[](accounts.length);

        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }

        return batchBalances;
    }

    /**
     * @notice Sets or unsets the approval for a specific operator.
     * @param operator The operator to set or unset approval for.
     * @param approved A boolean indicating whether the operator is approved or not.
     * @dev Emits an ApprovalForAll event.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @notice Checks if an operator is approved for all tokens of an account.
     * @param account The account to check.
     * @param operator The operator to check.
     * @return A boolean indicating whether the operator is approved for all tokens of the account.
     */
    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @notice Safely transfers a specified amount of a token from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param id The token ID to transfer.
     * @param amount The amount of the token to transfer.
     * @param data Additional data to send along with the transfer.
     * @dev Reverts if the caller is not the owner or approved for the token.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(from == _msgSender() || isApprovedForAll(from, _msgSender()), "ERC1155: caller is not owner nor approved");
        _safeTransferFrom(from, to, id, amount, data);
    }

    /**
     * @notice Safely transfers multiple tokens from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param ids The list of token IDs to transfer.
     * @param amounts The list of amounts of each token to transfer.
     * @param data Additional data to send along with the transfer.
     * @dev Reverts if the caller is not the owner or approved for the tokens.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(from == _msgSender() || isApprovedForAll(from, _msgSender()), "ERC1155: caller is not owner nor approved");
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    /**
     * @dev Safely transfers a specific amount of tokens from one address to another.
     * @param from The address to transfer tokens from.
     * @param to The address to transfer tokens to (must not be the zero address).
     * @param id The token ID to transfer.
     * @param amount The amount of tokens to transfer.
     * @param data Additional data to pass along with the transfer.
     * @notice
     * - Reverts if the recipient is the zero address.
     * - Emits a TransferSingle event upon successful transfer.
     * - Performs safety checks before and after the transfer.
     * - Calls _beforeTokenTransfer hook for extension points.
     * - Uses unchecked arithmetic for performance optimization.
     * @dev
     * - Updates balances for both sender and recipient.
     * - Calls _doSafeTransferAcceptanceCheck to ensure recipient accepts the transfer.
     * - This is an internal function intended for use by derived contracts.
     * @dev Note: This function handles single token ID transfers (not batches).
     */
    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: transfer to the zero address");
        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @notice Internal function to safely transfer multiple tokens from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param ids The list of token IDs to transfer.
     * @param amounts The list of amounts of each token to transfer.
     * @param data Additional data to send along with the transfer.
     * @dev This function is called internally by `safeBatchTransferFrom`.
     */
    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
            _balances[id][to] += amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
    }

    /**
     * @notice Internal function to set the URI for the contract.
     * @param newuri The new URI to set.
     * @dev This function is used to update the base URI for the contract.
     */
    function _setURI(string memory newuri) internal virtual {
        _uri = newuri;
        emit URI(newuri, 0);
    }

    /**
     * @notice Internal function to mint a specified amount of a token to an address.
     * @param to The address to mint to.
     * @param id The token ID to mint.
     * @param amount The amount of the token to mint.
     * @param data Additional data to send along with the mint.
     * @dev Reverts if the `to` address is the zero address.
     */
    function _mint(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: mint to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);

        _balances[id][to] += amount;
        emit TransferSingle(operator, address(0), to, id, amount);

        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);
    }

    /**
     * @notice Internal function to mint multiple tokens to an address.
     * @param to The address to mint to.
     * @param ids The list of token IDs to mint.
     * @param amounts The list of amounts of each token to mint.
     * @param data Additional data to send along with the mint.
     * @dev Reverts if the `to` address is the zero address or if the lengths of the ids and amounts arrays do not match.
     */
    function _mintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: mint to the zero address");
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            _balances[ids[i]][to] += amounts[i];
        }

        emit TransferBatch(operator, address(0), to, ids, amounts);
        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);
    }

    /**
     * @notice Internal function to burn a specified amount of a token from an address.
     * @param from The address to burn from.
     * @param id The token ID to burn.
     * @param amount The amount of the token to burn.
     * @dev Reverts if the `from` address is the zero address or if the burn amount exceeds the balance.
     */
    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC1155: burn from the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), "");

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }

        emit TransferSingle(operator, from, address(0), id, amount);
    }

    /**
     * @notice Internal function to burn multiple tokens from an address.
     * @param from The address to burn from.
     * @param ids The list of token IDs to burn.
     * @param amounts The list of amounts of each token to burn.
     * @dev Reverts if the `from` address is the zero address or if the lengths of the ids and amounts arrays do not match, or if any burn amount exceeds the balance.
     */
    function _burnBatch(
        address from,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal virtual {
        require(from != address(0), "ERC1155: burn from the zero address");
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
            unchecked {
                _balances[id][from] = fromBalance - amount;
            }
        }

        emit TransferBatch(operator, from, address(0), ids, amounts);
    }

    /**
     * @notice Internal function to set or unset the approval for a specific operator.
     * @param owner The owner of the tokens.
     * @param operator The operator to set or unset approval for.
     * @param approved A boolean indicating whether the operator is approved or not.
     * @dev Reverts if the owner is the same as the operator.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC1155: setting approval status for self");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @notice Internal function to perform actions before a token transfer.
     * @param operator The address performing the operation.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param ids The list of token IDs being transferred.
     * @param amounts The list of amounts of each token being transferred.
     * @param data Additional data to send along with the transfer.
     * @dev This function can be overridden to add custom logic before a token transfer.
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}

    /**
     * @notice Private function to check if a single token transfer is accepted by the recipient.
     * @param operator The address performing the operation.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param id The token ID being transferred.
     * @param amount The amount of the token being transferred.
     * @param data Additional data to send along with the transfer.
     * @dev Reverts if the recipient is a contract and does not implement the onERC1155Received function correctly.
     */
    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    /**
     * @notice Private function to check if a batch token transfer is accepted by the recipient.
     * @param operator The address performing the operation.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param ids The list of token IDs being transferred.
     * @param amounts The list of amounts of each token being transferred.
     * @param data Additional data to send along with the transfer.
     * @dev Reverts if the recipient is a contract and does not implement the onERC1155BatchReceived function correctly.
     */
    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    /**
     * @notice Private function to convert a single element into a single-element array.
     * @param element The element to convert.
     * @return A single-element array containing the element.
     */
    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
        uint256[] memory result = new uint256[](1);
        result[0] = element;
        return result;
    }
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";

    /**
     * @dev Converts `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation as well as strings.js's stringFromUTF8Array
        // While I appreciate both, I've tried to write things as concise as possible while maintaining readabilty.
        // uint256 values have a max length of 78 digits (there are 66 bytes in a uint256)
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        uint256 y = digits;
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            uint256 remainder = value % 10;
            value /= 10;
            buffer[--y] = bytes1(uint8(remainder + 48));
        }
        return string(buffer);
    }
}
```