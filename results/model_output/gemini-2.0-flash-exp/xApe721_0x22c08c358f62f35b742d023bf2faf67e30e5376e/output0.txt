```solidity
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity 0.8.10;

import "@rari-capital/solmate/src/tokens/ERC721.sol";
import "@rari-capital/solmate/src/utils/SafeTransferLib.sol";
import "contracts/Ownable.sol";
import "contracts/IERC721.sol";
import "contracts/Strings.sol";

/**
 * @title xApe721
 * @notice This contract is an ERC721 token contract that allows for minting, claiming, and managing a collection of 10,000 unique tokens.
 * @dev The contract includes functionalities to claim tokens from an old contract, mint new tokens, and manage the minting process.
 */
contract xApe721 is Ownable, ERC721, ERC721TokenReceiver {
  using Strings for uint256;

  /**
   * @notice Total supply of tokens in the contract.
   * @dev This constant defines the total number of tokens that can be minted.
   */
  uint256 public constant TOTAL_SUPPLY = 10_000;

  /**
   * @notice Price per token in ether.
   * @dev This constant defines the price required to mint one token.
   */
  uint256 public constant PRICE_PER_MINT = 0.05 ether;

  /**
   * @notice Maximum number of tokens that can be minted in a single transaction.
   * @dev This constant defines the maximum number of tokens a user can mint in one transaction.
   */
  uint256 public constant MAX_MINT_PER_TX = 20;

  /**
   * @notice Flag to indicate whether minting is active.
   * @dev This boolean flag controls whether users can mint new tokens.
   */
  bool public mintActive;

  /**
   * @notice Current total supply of minted tokens.
   * @dev This variable keeps track of the total number of tokens that have been minted.
   */
  uint256 public totalSupply;

  /**
   * @notice ID of the next token to be minted.
   * @dev This internal variable keeps track of the next available token ID for minting.
   */
  uint256 internal nextMintableId = 10038; // IDs start at 10038

  /**
   * @notice Base URI for token metadata.
   * @dev This string is used to construct the token URI for each token.
   */
  string public baseURI;

  /**
   * @notice Reference to the old ERC721 contract.
   * @dev This interface is used to interact with the old contract for claiming tokens.
   */
  IERC721 public oldContract = IERC721(0x090b1DE324fEA5f0A0B4226101Db645819102629);

  /**
   * @notice Address of the team wallet.
   * @dev This address is used to receive funds when the withdraw function is called.
   */
  address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;

  error NotEnoughFunds();
  error MintNotActive();
  error ExceedsMaxMint();
  error SupplyExceeded();
  error AlreadyClaimed();
  error NotOwner();
  error NotOldOwner();

  /**
   * @notice Constructor to initialize the contract with initial parameters.
   * @param name The name of the token.
   * @param symbol The symbol of the token.
   * @param _baseURI The base URI for token metadata.
   * @param _oldContract The address of the old contract.
   * @param recipients Array of addresses to airdrop tokens to.
   * @param tokens Array of token IDs to airdrop.
   */
  constructor(
    string memory name,
    string memory symbol,
    string memory _baseURI,
    address _oldContract,
    address[] memory recipients,
    uint256[] memory tokens
  ) payable ERC721(name, symbol) {
    require(recipients.length == tokens.length, "Airdrop lengths");
    baseURI = _baseURI;

    if (_oldContract != address(0)) {
      oldContract = IERC721(_oldContract);
    }

    uint256 length = tokens.length;

    for (uint i; i < length; ++i) {
      _mint(recipients[i], tokens[i]);
      totalSupply++;
    }
  }

  /**
   * @notice Modifier to restrict function calls to the team wallet.
   * @dev This modifier ensures that only the team wallet can call the function.
   */
  modifier onlyTeamWallet() {
    if (msg.sender != teamWallet) revert NotOwner();
    _;
  }

  /**
   * @notice Function to mint new tokens.
   * @param amount The number of tokens to mint.
   * @dev This function allows users to mint new tokens, subject to certain conditions.
   */
  function mint(uint16 amount) external payable {
    if (!mintActive) revert MintNotActive();
    if (amount > MAX_MINT_PER_TX) revert ExceedsMaxMint();
    if (totalSupply + amount > TOTAL_SUPPLY) revert SupplyExceeded();
    if (msg.value < amount * PRICE_PER_MINT) revert NotEnoughFunds();

    for (uint256 i = 0; i < amount; i++) {
      _safeMint(msg.sender, nextMintableId);
      nextMintableId++;
      totalSupply++;
    }
  }

  /**
   * @notice Function to claim a token from the old contract.
   * @param tokenId The ID of the token to claim.
   * @dev This function allows users to claim a token from the old contract and mint it in the new contract.
   */
  function claim(uint256 tokenId) external payable {
    if (!_ownsOldToken(msg.sender, tokenId)) revert NotOldOwner();
    if (ownerOf[tokenId] != address(0)) revert AlreadyClaimed();

    IERC721(oldContract).safeTransferFrom(msg.sender, address(this), tokenId);
    _safeMint(msg.sender, tokenId);
    totalSupply++;
  }

  /**
   * @notice Function to claim all tokens from the old contract.
   * @dev This function allows users to claim all their tokens from the old contract and mint them in the new contract.
   */
  function claimAll() external payable {
    uint256[] memory tokenIds = oldContract.getPhunksBelongingToOwner(msg.sender);
    uint256 length = tokenIds.length;

    for (uint256 i = 0; i < length; i++) {
      uint256 tokenId = tokenIds[i];
      if (_ownsOldToken(msg.sender, tokenId) && ownerOf[tokenId] == address(0)) {
        IERC721(oldContract).safeTransferFrom(msg.sender, address(this), tokenId);
        _safeMint(msg.sender, tokenId);
        totalSupply++;
      }
    }
  }

  /**
   * @notice Internal function to check if an account owns a token in the old contract.
   * @param account The address of the account to check.
   * @param tokenId The ID of the token to check.
   * @return A boolean indicating whether the account owns the token.
   * @dev This function checks if an account owns a specific token in the old contract.
   */
  function _ownsOldToken(address account, uint256 tokenId) internal view returns (bool) {
    try {
      return IERC721(oldContract).ownerOf(tokenId) == account;
    } catch {
      return false;
    }
  }

  /**
   * @notice Internal function to get the next unused token ID.
   * @return The next available token ID.
   * @dev This function finds the next available token ID that is not owned in either the old or new contract.
   */
  function _getNextUnusedID() internal returns (uint256) {
    while (ownerOf[nextMintableId] != address(0) || _ownsOldToken(address(this), nextMintableId)) {
      nextMintableId++;
    }
    return nextMintableId;
  }

  /**
   * @notice Function to get the token URI for a given token ID.
   * @param id The ID of the token.
   * @return The token URI.
   * @dev This function constructs the token URI for a given token ID.
   */
  function tokenURI(uint256 id) public view override returns (string memory) {
    require(ownerOf[id] != address(0), "NOT_MINTED");
    return string(abi.encodePacked(baseURI, Strings.toString(id)));
  }

  /**
   * @notice Function to withdraw funds to the team wallet.
   * @dev This function allows the team wallet to withdraw the contract's balance.
   */
  function withdraw() external onlyTeamWallet() {
    uint256 balance = address(this).balance;
    SafeTransferLib.safeTransferETH(teamWallet, balance);
  }

  /**
   * @notice Function to pause minting.
   * @dev This function allows the owner to pause the minting process.
   */
  function pauseMint() external onlyOwner() {
    mintActive = false;
  }

  /**
   * @notice Function to start minting.
   * @dev This function allows the owner to start the minting process.
   */
  function startMint() external onlyOwner() {
    mintActive = true;
  }

  /**
   * @notice Function to set the base URI for token metadata.
   * @param _baseURI The new base URI.
   * @dev This function allows the owner to set the base URI for token metadata.
   */
  function setBaseURI(string memory _baseURI) external onlyOwner() {
    baseURI = _baseURI;
  }

  /**
   * @notice Function to check if the contract supports a specific interface.
   * @param interfaceId The ID of the interface to check.
   * @return A boolean indicating whether the contract supports the interface.
   * @dev This function checks if the contract supports a specific interface.
   */
  function supportsInterface(bytes4 interfaceId)
    public
    pure
    override
    returns (bool)
  {
    return
      interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
      interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
      interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata
      interfaceId == 0x4e2312e0; // ERC721TokenReceiver
  }

  /**
   * @notice Function to handle the receipt of an ERC721 token.
   * @param operator The address which called `safeTransferFrom` to transfer the token.
   * @param from The address which previously owned the token.
   * @param tokenId The ID of the token being transferred.
   * @param data Additional data with no specified format.
   * @return A magic value indicating that the token was received.
   * @dev This function is called when an ERC721 token is received.
   */
  function onERC721Received(
      address operator,
      address from,
      uint256 tokenId,
      bytes calldata data
  ) external override returns (bytes4) {
      return ERC721TokenReceiver.onERC721Received.selector;
  }
}
```