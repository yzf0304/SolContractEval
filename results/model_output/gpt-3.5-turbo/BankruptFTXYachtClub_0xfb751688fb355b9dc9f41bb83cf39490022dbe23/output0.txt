To generate a Solidity smart contract for an NFT collection with minting, reservation, airdrop, and other functionalities, you can start by defining the contract structure and importing necessary libraries. Here is a basic outline of the contract code based on the provided context:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract NFTCollection is ERC721Enumerable, Ownable {
    using Strings for uint256;

    string private _baseTokenURI;
    string private _hiddenURI;
    uint256 private _cost = 0.0025 ether;
    uint16 private _maxSupply = 6969;
    uint8 private _maxMintAmountPerTx = 21;
    uint8 private _maxFreeMintAmountPerWallet = 1;
    bool private _paused = true;
    bool private _reveal = false;
    mapping(address => uint8) private _NFTPerPublicAddress;

    constructor() ERC721("Bankrupt FTX Yacht Club", "BFTX") {}

    function mint(uint8 _mintAmount) external payable {
        // Implementation for minting NFTs
    }

    function reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        // Implementation for reserving NFTs
    }

    function airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        // Implementation for airdropping NFTs
    }

    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        // Implementation for setting maximum supply
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        // Implementation for returning token URI
    }

    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        // Implementation for setting free mint limit per wallet
    }

    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        // Implementation for setting URI prefix
    }

    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        // Implementation for setting hidden URI
    }

    function setPaused() external onlyOwner {
        // Implementation for toggling paused state
    }

    function setCost(uint _cost) external onlyOwner {
        // Implementation for setting minting cost
    }

    function setRevealed() external onlyOwner {
        // Implementation for toggling reveal state
    }

    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        // Implementation for setting max mint amount per transaction
    }

    function withdraw() external onlyOwner {
        // Implementation for withdrawing contract balance
    }

    function _baseURI() internal view override returns (string memory) {
        // Implementation for returning base URI
    }

    receive() external payable {
        // Fallback function to accept ETH
    }
}
```

This code provides a basic structure for an NFT collection contract with the functionalities mentioned in the provided context. You can further customize and expand upon this code to suit your specific requirements and business logic.