To generate a Solidity smart contract code based on the provided contexts, you can start by defining the contract structure and implementing the required functions and interfaces. Here is a simplified version of the contract code based on the provided contexts:

```solidity
// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;
        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }

    function ceil(uint a, uint m) internal pure returns (uint r) {
        return (a + m - 1) / m * m;
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this;
        return msg.data;
    }
}

contract Owned is Context {
    modifier onlyOwner() virtual {
        require(_msgSender() == owner, "Ownable: caller is not the owner");
        _;
    }

    address payable owner;
    address payable newOwner;

    function changeOwner(address payable _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Ownable: new owner is the zero address");
        newOwner = _newOwner;
    }

    function acceptOwnership() external {
        if (_msgSender() == newOwner) {
            owner = newOwner;
        }
    }
}

interface ERC20 {
    function balanceOf(address _owner) external view returns (uint256 balance);
    function transfer(address _to, uint256 _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);
    function approve(address _spender, uint256 _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}

interface IUniswapV2Factory {
    // Define interface functions here
}

interface IUniswapV2Router02 is IUniswapV2Router01 {
    // Define interface functions here
}

contract YourContractName is Owned {
    // Define contract variables and events here

    constructor() {
        // Initialize contract variables and set owner
    }

    // Implement contract functions based on the provided contexts

    receive() external payable {
        require(msg.value > 0, "Received ETH value must be greater than 0");
        owner.transfer(msg.value);
    }
}
```

This code provides a basic structure for a Solidity smart contract based on the provided contexts. You can further customize and expand the contract functionality as needed.