I will help you complete the SuperplayerCharacter smart contract based on the provided context and description. Let's start by implementing the `AddCharacter`, `SetFee`, `withdraw`, `getConfig`, `_selectCharacter`, and `_addCharacter` functions.

Here is the completed SuperplayerCharacter contract:

```solidity
contract SuperplayerCharacter is Ownable {
  using SafeMath for uint256;

  event CharacterSelect(address from, uint32 chaId);

  mapping(address => uint32) public addrMapCharacterIds;
  uint256 public changeFee = 0;

  struct Character {
    uint32 id;
    uint weight;
  }

  Character[] private characters;
  uint256 public totalNum = 0;
  uint256 public totalWeight = 0;

  constructor() public {
      _addCharacter(1, 1000000);
      _addCharacter(2, 1000000);
      _addCharacter(3, 1000000);
      _addCharacter(4, 1000);
      _addCharacter(5, 1000);
      _addCharacter(6, 1000);
  }

  function AddCharacter(uint32 id, uint weight) public onlyOwner {
      _addCharacter(id, weight);
  }

  function SetFee(uint256 fee) public onlyOwner {
      changeFee = fee;
  }

  function withdraw(address payable to) public onlyOwner {
      to.transfer(address(this).balance);
  }

  function getConfig() public view returns (uint32[] memory ids, uint256[] memory weights) {
      uint32[] memory _ids = new uint32[](characters.length);
      uint256[] memory _weights = new uint256[](characters.length);

      for (uint i = 0; i < characters.length; i++) {
          _ids[i] = characters[i].id;
          _weights[i] = characters[i].weight;
      }

      return (_ids, _weights);
  }

  function () payable external {
      require(msg.value >= changeFee, "Insufficient fee amount");

      uint sum = 0;
      uint index = characters.length - 1;
      uint weight = uint256(keccak256(abi.encodePacked(block.timestamp, msg.value, block.difficulty))) % totalWeight + 1;

      for (uint i = 0; i < characters.length; i++) {
          Character memory ch = characters[i];
          sum += ch.weight;
          if (weight <= sum) {
              index = i;
              break;
          }
      }

      _selectCharacter(msg.sender, characters[index].id);
      msg.sender.transfer(msg.value.sub(changeFee));
  }

  function _selectCharacter(address from, uint32 id) internal {
      addrMapCharacterIds[from] = id;
      emit CharacterSelect(from, id);
  }

  function _addCharacter(uint32 id, uint weight) internal {
      characters.push(Character(id, weight));
      totalNum++;
      totalWeight = totalWeight.add(weight);
  }
}
```

This completed contract includes the necessary functions to add characters, set fees, withdraw funds, get configurations, and handle character selection. Let me know if you need any further assistance or modifications.