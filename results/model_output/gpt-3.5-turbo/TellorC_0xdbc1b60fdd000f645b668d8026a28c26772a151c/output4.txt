I see the provided context for the `TellorC` smart contract. It interacts with the Tellor system for staking, withdrawing, and submitting mining solutions. The contract is controlled by an owner who can manage various operations.

Here is the completed `TellorC` contract based on the provided context:

```solidity
contract TellorC {
    address private tellor = 0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;

    bytes32 constant slotProgress = 0x6c505cb2db6644f57b42d87bd9407b0f66788b07d0617a2bc1356a0e69e66f9a; // keccak256("slotProgress")
    address private owner;
    address private miner;
    
    constructor () public {
        owner = msg.sender;
    }
    
    function changeMiner(address _addr) external {
        require(msg.sender == owner, "Only owner can change miner");
        miner = _addr;
    }

    function withdrawTrb(uint256 _amount) external {
        require(msg.sender == owner, "Only owner can withdraw TRB");
        // Withdraw TRB logic
    }

    function withdrawEth(uint256 _amount) external {
        require(msg.sender == owner, "Only owner can withdraw ETH");
        // Withdraw ETH logic
    }

    function depositStake() external {
        require(msg.sender == owner, "Only owner can deposit stake");
        // Deposit stake logic
    }

    function requestStakingWithdraw() external {
        require(msg.sender == owner, "Only owner can request staking withdrawal");
        // Request staking withdrawal logic
    }

    function withdrawStake() external {
        require(msg.sender == owner, "Only owner can withdraw stake");
        // Withdraw stake logic
    }

    function finalize() external {
        require(msg.sender == owner, "Only owner can finalize");
        // Finalize logic
        selfdestruct(msg.sender);
    }

    function submitMiningSolution(string calldata _nonce, uint256[5] calldata _requestId, uint256[5] calldata _value) external {
        require(msg.sender == owner || msg.sender == miner, "Only owner or miner can submit mining solution");
        // Submit mining solution logic
    }

    function() external {
        require(msg.sender == address(0), "Not allowed");
        
        address addr = tellor;
        bytes memory _calldata = msg.data;
        assembly {
            let result := call(not(0), addr, 0, add(_calldata, 0x20), mload(_calldata), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
                case 0 {
                    revert(ptr, size)
                }
                default {
                    return(ptr, size)
                }
        }
    }
}
```

This completed contract includes functions for changing the miner, withdrawing TRB and ETH, depositing and withdrawing stake, finalizing the contract, submitting mining solutions, and forwarding calls to the Tellor contract.