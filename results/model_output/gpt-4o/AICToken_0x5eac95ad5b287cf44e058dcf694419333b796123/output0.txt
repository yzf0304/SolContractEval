Here's the implementation of the `BasicToken` contract based strictly on the given context and requirements:

```solidity
pragma solidity ^0.4.25;

/**
 * @title BasicToken
 * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.
 * Note they can later distribute these tokens as they wish using `transfer` and other
 * `ERC20` functions.
 */
contract BasicToken is ERC20Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances;

    uint256 totalSupply_;

    /**
     * @notice Constructor that assigns all tokens to the contract creator.
     * @dev Assigns the total token supply to the account that deploys the contract.
     * @param initialSupply The total number of tokens to be minted during deployment.
     */
    constructor(uint256 initialSupply) public {
        totalSupply_ = initialSupply;
        balances[msg.sender] = initialSupply;
        emit Transfer(address(0), msg.sender, initialSupply);
    }

    /**
     * @notice Returns the total token supply.
     * @dev This function returns the total number of tokens in existence.
     * @return The total supply of tokens.
     */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @notice Returns the token balance of a specified address.
     * @dev This function returns the token balance of a specified address.
     * @param _owner The address to query the balance of.
     * @return An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    /**
     * @notice Transfers a specified amount of tokens from the message sender to a specified recipient.
     * @dev This function transfers tokens from the message sender to a specified recipient. It ensures
     * that the recipient is not the zero address, the recipient is not the sender, and the sender has
     * sufficient balance. It also calls `_preValidateTransfer` for additional validation before
     * updating the balances and emitting the `Transfer` event.
     * @param _to The address of the recipient.
     * @param _value The amount of tokens to transfer.
     * @return A boolean value indicating whether the transfer was successful.
     */
    function transfer(address _to, uint256 _value) public returns (bool) {
        _preValidateTransfer(msg.sender, _to, _value);

        // Update balances
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @dev Internal function to perform pre-validation before a transfer.
     * @param _from The address of the token sender.
     * @param _to The address of the token recipient.
     * @param _value The amount of tokens to transfer.
     */
    function _preValidateTransfer(
        address _from, 
        address _to, 
        uint256 _value
    ) internal {
        require(_to != address(0), "Cannot transfer to the zero address");
        require(_to != _from, "Cannot transfer to yourself");
        require(balances[_from] >= _value, "Insufficient balance");
    }

    /**
     * @notice Returns the address of the message sender.
     * @dev This function is a utility function that returns the address of the message sender.
     * @return The address of the message sender.
     */
    function msgSender() public view returns (address) {
        return msg.sender;
    }
}
```

### Explanation of the Implementation:

1. **`totalSupply`**:
   - Returns the total supply of tokens that is stored in `totalSupply_`.

2. **`balanceOf`**:
   - Provides the balance of tokens for a specific address from the `balances` mapping.

3. **`transfer`**:
   - Implements the transfer logic by first validating the transfer through `_preValidateTransfer`.
   - Updates balances using `SafeMath` to ensure proper handling of overflows/underflows.
   - Emits the `Transfer` event to comply with the ERC20 standard.

4. **`_preValidateTransfer`**:
   - Internal function that ensures the `_to` address is not the zero address and is not the sender.
   - Ensures the sender has enough tokens to transfer.

5. **`msgSender`**:
   - A utility function to return the address of the sender of the transaction.

6. **Constructor**:
   - Assigns the total supply of tokens to the account deploying the contract (`msg.sender`).
   - Emits the `Transfer` event from address `0` to the creator, signaling token creation.

This implementation is strictly within the described context, focusing on correct adherence to the ERC20 basics using `SafeMath` for safe arithmetic operations. It avoids introducing any new contracts or unnecessary complexity.