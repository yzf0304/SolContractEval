```solidity
pragma solidity 0.6.12;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "./UnoswapRouter.sol";
import "./helpers/UniERC20.sol";
import "./access/Ownable.sol";
import "./interfaces/IAggregationExecutor.sol";
import "./helpers/Permitable.sol";
import "./interfaces/IChi.sol";

contract AggregationRouterV3 is Ownable, UnoswapRouter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    using UniERC20 for IERC20;

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    function discountedSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft, uint256 chiSpent)
    {
        uint256 initialGas = gasleft();

        // Execute the swap
        returnAmount = _executeSwap(caller, desc, data);

        // Calculate remaining gas and possibly burn CHI tokens
        gasLeft = gasleft();
        if (desc.flags & _BURN_FROM_MSG_SENDER != 0) {
            chiSpent = _burnChiFrom(msg.sender, initialGas.sub(gasLeft));
        } else if (desc.flags & _BURN_FROM_TX_ORIGIN != 0) {
            chiSpent = _burnChiFrom(tx.origin, initialGas.sub(gasLeft));
        }
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (uint256 returnAmount, uint256 gasLeft)
    {
        uint256 initialGas = gasleft();

        // Execute the swap
        returnAmount = _executeSwap(caller, desc, data);

        // Calculate remaining gas
        gasLeft = gasleft();
    }

    function _executeSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        internal
        returns (uint256 returnAmount)
    {
        require(desc.amount > 0, "Amount must be greater than zero");
        require(desc.dstReceiver != address(0), "Destination receiver is zero address");

        uint256 amountIn = desc.amount;
        if (desc.permit.length > 0) {
            _permit(desc.srcToken, amountIn, desc.permit);
        }
        if (!desc.srcToken.isETH()) {
            desc.srcToken.safeTransferFrom(msg.sender, desc.srcReceiver, amountIn);
        }

        (bool success, bytes memory result) = address(caller).delegatecall(data);
        require(success, string(abi.encodePacked("Swap failed: ", result)));

        assembly {
            returnAmount := mload(add(result, 32))
        }

        require(returnAmount >= desc.minReturnAmount, "Insufficient return amount");
        if (desc.dstToken.isETH()) {
            desc.dstReceiver.transfer(returnAmount);
        } else {
            desc.dstToken.safeTransfer(desc.dstReceiver, returnAmount);
        }

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            amountIn,
            returnAmount
        );
    }

    function _burnChiFrom(address account, uint256 gasUsed) internal returns (uint256 chiBurned) {
        // Calculate the number of CHI tokens to burn
        uint256 gasSavings = gasUsed.div(2400); // Example conversion rate
        IChi chiToken = IChi(0x0000000000000000000000000000000000000000); // Replace with actual CHI token address
        uint256 balance = chiToken.balanceOf(account);
        chiBurned = balance < gasSavings ? balance : gasSavings;
        chiToken.freeFromUpTo(account, chiBurned);
    }

    function rescueFunds(IERC20 token, uint256 amount) external onlyOwner {
        token.uniTransfer(msg.sender, amount);
    }

    function destroy() external onlyOwner {
        selfdestruct(payable(owner()));
    }
}
```

This implementation provides the core functionality described in the task. It incorporates features such as permitting transfers, discounted swaps with CHI token burning options, and fund rescue, all while ensuring proper access controls and fail-safes are in place.