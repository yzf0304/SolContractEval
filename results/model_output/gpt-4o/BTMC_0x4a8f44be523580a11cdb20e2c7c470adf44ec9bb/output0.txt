Below is the completed `BTMC` contract strictly following the provided context, description, and functionality:

```solidity
pragma solidity ^0.4.22;

/**
 * @notice BTMC is a token contract that implements ERC20, Ownable, and Pausable functionalities.
 * It includes features for token distribution, team token vesting, and funding.
 * @dev The contract is designed to manage the initial supply, mining, public funding, and team vesting of tokens.
 */
contract BTMC is ERC20, Ownable, Pausable {
    using SafeMath for uint256;

    // Base information of the token
    string public constant name = "MinerCoin";
    string public constant symbol = "BTMC";
    string public constant version = "1.0";
    uint256 public constant decimals = 18;

    // Supply definitions
    uint256 public constant INIT_SUPPLY = 100000000 * 10**decimals;
    uint256 public constant MINING_SUPPLY = 500000000 * 10**decimals;
    uint256 public constant MAX_FUNDING_SUPPLY = 200000000 * 10**decimals;
    uint256 public constant TEAM_KEEPING = 200000000 * 10**decimals;
    uint256 public constant MAX_SUPPLY = INIT_SUPPLY + MINING_SUPPLY + MAX_FUNDING_SUPPLY + TEAM_KEEPING;
    uint256 public constant TEAM_UNFREEZE = 40000000 * 10**decimals;

    // Funding parameters
    uint256 public totalFundingSupply;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public rate;

    // Team vesting steps
    bool public hasOneStepWithdraw;
    bool public hasTwoStepWithdraw;
    bool public hasThreeStepWithdraw;
    bool public hasFourStepWithdraw;
    bool public hasFiveStepWithdraw;

    // ERC20 state variables
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    // Events
    event CreateBTMC(address indexed _to, uint256 _value);
    event Fund(address indexed _to, uint256 _value);
    event Withdraw(address indexed _owner, uint256 _value);

    /**
     * @dev Constructor sets up the initial supply and funding parameters.
     */
    function BTMC() public {
        totalSupply = INIT_SUPPLY;
        balances[msg.sender] = INIT_SUPPLY;
        emit Transfer(address(0), msg.sender, INIT_SUPPLY);

        totalFundingSupply = 0;
        startTime = 1524499199; // 2018-04-23 23:59:59
        endTime = 1526313600;   // 2018-05-15 00:00:00
        rate = 5000;

        hasOneStepWithdraw = false;
        hasTwoStepWithdraw = false;
        hasThreeStepWithdraw = false;
        hasFourStepWithdraw = false;
        hasFiveStepWithdraw = false;
    }

    modifier notReachTotalSupply(uint256 _value, uint256 _rate) {
        require(totalSupply.add(_value.mul(_rate)) <= MAX_SUPPLY);
        _;
    }

    modifier notReachFundingSupply(uint256 _value, uint256 _rate) {
        require(totalFundingSupply.add(_value.mul(_rate)) <= MAX_FUNDING_SUPPLY);
        _;
    }

    modifier assertFalse(bool _status) {
        require(!_status);
        _;
    }

    modifier notBeforeTime(uint256 _time) {
        require(now > _time);
        _;
    }

    modifier notAfterTime(uint256 _time) {
        require(now <= _time);
        _;
    }

    function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    function setupFundingRate(uint256 _rate) external onlyOwner {
        rate = _rate;
    }

    function setupFundingTime(uint256 _startTime, uint256 _endTime) external onlyOwner {
        require(_startTime < _endTime);
        startTime = _startTime;
        endTime = _endTime;
    }

    function processFunding(address receiver, uint256 _value, uint256 _rate)
        internal
        notReachTotalSupply(_value, _rate)
    {
        uint256 tokens = _value.mul(_rate);
        totalSupply = totalSupply.add(tokens);
        balances[receiver] = balances[receiver].add(tokens);

        emit CreateBTMC(receiver, tokens);
    }

    function funding(address receiver, uint256 _value, uint256 _rate)
        internal
        whenNotPaused
        notReachFundingSupply(_value, _rate)
    {
        processFunding(receiver, _value, _rate);
        totalFundingSupply = totalFundingSupply.add(_value.mul(_rate));
        emit Fund(receiver, _value.mul(_rate));
    }

    function () payable external notBeforeTime(startTime) notAfterTime(endTime) {
        funding(msg.sender, msg.value, rate);
    }

    function etherProceeds() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    function withdrawForOneStep() external onlyOwner assertFalse(hasOneStepWithdraw) notBeforeTime(1587571200) {
        balances[owner] = balances[owner].add(TEAM_UNFREEZE);
        hasOneStepWithdraw = true;
        emit Withdraw(owner, TEAM_UNFREEZE);
    }

    function withdrawForTwoStep() external onlyOwner assertFalse(hasTwoStepWithdraw) notBeforeTime(1603382400) {
        balances[owner] = balances[owner].add(TEAM_UNFREEZE);
        hasTwoStepWithdraw = true;
        emit Withdraw(owner, TEAM_UNFREEZE);
    }

    function withdrawForThreeStep() external onlyOwner assertFalse(hasThreeStepWithdraw) notBeforeTime(1619107200) {
        balances[owner] = balances[owner].add(TEAM_UNFREEZE);
        hasThreeStepWithdraw = true;
        emit Withdraw(owner, TEAM_UNFREEZE);
    }

    function withdrawForFourStep() external onlyOwner assertFalse(hasFourStepWithdraw) notBeforeTime(1634918400) {
        balances[owner] = balances[owner].add(TEAM_UNFREEZE);
        hasFourStepWithdraw = true;
        emit Withdraw(owner, TEAM_UNFREEZE);
    }

    function withdrawForFiveStep() external onlyOwner assertFalse(hasFiveStepWithdraw) notBeforeTime(1650643200) {
        balances[owner] = balances[owner].add(TEAM_UNFREEZE);
        hasFiveStepWithdraw = true;
        emit Withdraw(owner, TEAM_UNFREEZE);
    }
}
```

### Key Features Implemented:
1. **ERC20 Implementation**:
   - `transfer`, `transferFrom`, `balanceOf`, `approve`, and `allowance` comply with the ERC20 specification.
2. **Funding Management**:
   - Public funding based on rate and time constraints.
   - `processFunding` and `funding` methods enforce max supply limits.
3. **Team Vesting**:
   - Five-step vesting schedule with specific time constraints.
4. **Pausable Mechanism**:
   - Functions like `transfer`, `transferFrom`, and `approve` respect the `whenNotPaused` modifier.
5. **Fundraiser Withdrawal**:
   - Owner can withdraw ETH (`etherProceeds`) from the contract.

The implementation aligns with the specification and adheres strictly to the provided contract interfaces.