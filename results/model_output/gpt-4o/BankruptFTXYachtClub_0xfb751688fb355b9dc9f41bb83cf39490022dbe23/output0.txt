Here's the completed implementation of the smart contract `BankruptFTXYachtClub` based on the given context and contract description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;

    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    mapping(address => uint8) public NFTPerPublicAddress;

    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    /**
     * @notice Allows users to mint NFTs by paying the specified cost.
     */
    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Sale is paused");
        require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTx, "Invalid mint amount");
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");

        if (NFTPerPublicAddress[msg.sender] < maxFreeMintAmountPerWallet) {
            uint8 freeMintsAvailable = maxFreeMintAmountPerWallet - NFTPerPublicAddress[msg.sender];
            uint8 payableAmount = _mintAmount > freeMintsAvailable ? _mintAmount - freeMintsAvailable : 0;

            require(msg.value >= cost * payableAmount, "Insufficient funds");
            NFTPerPublicAddress[msg.sender] += _mintAmount;
        } else {
            require(msg.value >= cost * _mintAmount, "Insufficient funds");
            NFTPerPublicAddress[msg.sender] += _mintAmount;
        }

        _safeMint(msg.sender, _mintAmount);
    }

    /**
     * @notice Allows the owner to reserve a certain amount of NFTs for a specific address.
     */
    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");
        _safeMint(_receiver, _mintAmount);
    }

    /**
     * @notice Allows the owner to airdrop a certain amount of NFTs to multiple addresses.
     */
    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        require(totalSupply() + (_amountPerAddress * addresses.length) <= maxSupply, "Exceeds max supply");

        for (uint i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    /**
     * @notice Sets the maximum supply of NFTs.
     */
    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        maxSupply = _maxSupply;
    }

    /**
     * @notice Returns the token URI for a given token ID.
     */
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "Query for nonexistent token");

        if (!reveal) {
            return hiddenURL;
        }

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _tokenId.toString(), uriSuffix)) : "";
    }

    /**
     * @notice Sets the maximum number of free mints per wallet.
     */
    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    /**
     * @notice Sets the URI prefix for the NFTs.
     */
    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    /**
     * @notice Sets the hidden URI for the NFTs.
     */
    function setHiddenUri(string memory _uriPrefix) external onlyOwner {
        hiddenURL = _uriPrefix;
    }

    /**
     * @notice Toggles the paused state of the contract.
     */
    function setPaused() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Sets the cost for minting NFTs.
     */
    function setCost(uint256 _cost) external onlyOwner {
        cost = _cost;
    }

    /**
     * @notice Toggles the revealed state of the NFTs.
     */
    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.
     */
    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    /**
     * @notice Allows the owner to withdraw the contract's balance.
     */
    function withdraw() external onlyOwner {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Withdraw failed");
    }

    /**
     * @notice Returns the base URI for the NFTs.
     */
    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    /**
     * @notice Fallback function to accept ETH.
     */
    receive() external payable {}
}
```

### Key Features:
- **Mint Functionality**: Allows public minting, with consideration for free mints per wallet.
- **Reserve and Airdrop**: Owner can reserve or airdrop NFTs to specified addresses.
- **Manage Parameters**: Owner can update minting costs, URI prefix, hidden URL, max supply, etc.
- **Reveal Logic**: Supports revealing NFTs once metadata is finalized.
- **Withdraw Functionality**: Allows the owner to withdraw accumulated funds.