To complete the `BeatTokenCrowdsale` contract based on the provided context and requirements, the following code includes methods and logic to manage the ICO phases, handle token purchases, and manage the ICO's finalization. The code leverages the `SafeMath` library for safe arithmetic operations and respects the contract's predefined phases and limitations.

```solidity
pragma solidity ^0.4.18;

contract BeatTokenCrowdsale is Ownable {
    using SafeMath for uint256;
    
    // Enum for ICO stages
    enum Stages {
        Deployed,
        PreIco,
        IcoPhase1,
        IcoPhase2,
        IcoPhase3,
        IcoEnded,
        Finalized
    }

    Stages public stage;

    BeatToken public token;

    uint256 public contractStartTime;
    uint256 public preIcoEndTime;
    uint256 public icoPhase1EndTime;
    uint256 public icoPhase2EndTime;
    uint256 public icoPhase3EndTime;
    uint256 public contractEndTime;

    address public ethTeamWallet;
    address public beatTeamWallet;

    uint256 public ethWeiRaised;
    uint256 public ethPriceInEuroCent;

    mapping(address => uint256) public balanceOf;

    event BeatTokenPurchased(address indexed purchaser, address indexed beneficiary, uint256 ethWeiAmount, uint256 beatWeiAmount);
    event BeatTokenEthPriceChanged(uint256 newPrice);
    event BeatTokenPreIcoStarted();
    event BeatTokenIcoPhase1Started();
    event BeatTokenIcoPhase2Started();
    event BeatTokenIcoPhase3Started();
    event BeatTokenIcoFinalized();

    // ICO Parameters
    uint public constant PRE_ICO_PERIOD = 28 days;
    uint public constant ICO_PHASE1_PERIOD = 28 days;
    uint public constant ICO_PHASE2_PERIOD = 28 days;
    uint public constant ICO_PHASE3_PERIOD = 28 days;

    uint256 public constant PRE_ICO_BONUS_PERCENTAGE = 100;
    uint256 public constant ICO_PHASE1_BONUS_PERCENTAGE = 75;
    uint256 public constant ICO_PHASE2_BONUS_PERCENTAGE = 50;
    uint256 public constant ICO_PHASE3_BONUS_PERCENTAGE = 25;

    uint256 public constant PRE_ICO_AMOUNT = 5000 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE1_AMOUNT = 7000 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE2_AMOUNT = 10500 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE3_AMOUNT = 11875 * (10 ** 6) * (10 ** 18);

    uint256 public constant PRE_ICO_LIMIT = PRE_ICO_AMOUNT;
    uint256 public constant ICO_PHASE1_LIMIT = PRE_ICO_LIMIT + ICO_PHASE1_AMOUNT;
    uint256 public constant ICO_PHASE2_LIMIT = ICO_PHASE1_LIMIT + ICO_PHASE2_AMOUNT;
    uint256 public constant ICO_PHASE3_LIMIT = ICO_PHASE2_LIMIT + ICO_PHASE3_AMOUNT;
    uint256 public constant HARD_CAP = 230 * (10 ** 9) * (10 ** 18);

    function BeatTokenCrowdsale(address _ethTeamWallet, address _beatTeamWallet) public {
        require(_ethTeamWallet != address(0));
        require(_beatTeamWallet != address(0));

        token = new BeatToken(HARD_CAP);
        stage = Stages.Deployed;
        ethTeamWallet = _ethTeamWallet;
        beatTeamWallet = _beatTeamWallet;
        ethPriceInEuroCent = 0;
    }

    function setEtherPriceInEuroCent(uint256 _ethPriceInEuroCent) onlyOwner public {
        require(_ethPriceInEuroCent > 0);
        ethPriceInEuroCent = _ethPriceInEuroCent;
        emit BeatTokenEthPriceChanged(ethPriceInEuroCent);
    }

    function start() onlyOwner public {
        require(stage == Stages.Deployed);
        require(ethPriceInEuroCent > 0);
        
        contractStartTime = now;
        preIcoEndTime = contractStartTime + PRE_ICO_PERIOD;
        icoPhase1EndTime = preIcoEndTime + ICO_PHASE1_PERIOD;
        icoPhase2EndTime = icoPhase1EndTime + ICO_PHASE2_PERIOD;
        icoPhase3EndTime = icoPhase2EndTime + ICO_PHASE3_PERIOD;
        contractEndTime = icoPhase3EndTime;

        stage = Stages.PreIco;
        emit BeatTokenPreIcoStarted();
    }

    function finalize() onlyOwner public {
        require(stage == Stages.IcoEnded);
        require(now >= contractEndTime);

        uint256 unsoldTokens = HARD_CAP.sub(token.totalSupply());
        token.mint(beatTeamWallet, unsoldTokens);
        stage = Stages.Finalized;
        emit BeatTokenIcoFinalized();
    }

    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address beneficiary) payable public {
        require(beneficiary != address(0));
        require(isWithinValidIcoPhase());

        uint256 ethWeiAmount = msg.value;
        uint256 beatWeiAmount = calculateBeatWeiAmount(ethWeiAmount);
        require(isWithinTokenAllocLimit(beatWeiAmount));

        ethWeiRaised = ethWeiRaised.add(ethWeiAmount);
        token.mint(beneficiary, beatWeiAmount);
        ethTeamWallet.transfer(msg.value);

        emit BeatTokenPurchased(msg.sender, beneficiary, ethWeiAmount, beatWeiAmount);

        determineCurrentStage(beatWeiAmount);
    }

    function isWithinValidIcoPhase() internal view returns (bool) {
        if (stage == Stages.PreIco && now <= preIcoEndTime) return true;
        if (stage == Stages.IcoPhase1 && now <= icoPhase1EndTime) return true;
        if (stage == Stages.IcoPhase2 && now <= icoPhase2EndTime) return true;
        if (stage == Stages.IcoPhase3 && now <= icoPhase3EndTime) return true;
        return false;
    }

    function calculateBeatWeiAmount(uint256 ethWeiAmount) internal view returns (uint256) {
        uint256 euroCents = ethWeiAmount.mul(ethPriceInEuroCent).div(1 ether);
        uint256 beatWeiAmount = euroCents.mul(10 ** 18); // Assuming 1 Euro Cent = 1 BEAT

        if (stage == Stages.PreIco) {
            return beatWeiAmount.mul(200).div(100); // 100% Bonus
        } else if (stage == Stages.IcoPhase1) {
            return beatWeiAmount.mul(175).div(100); // 75% Bonus
        } else if (stage == Stages.IcoPhase2) {
            return beatWeiAmount.mul(150).div(100); // 50% Bonus
        } else if (stage == Stages.IcoPhase3) {
            return beatWeiAmount.mul(125).div(100); // 25% Bonus
        }

        return beatWeiAmount;
    }

    function isWithinTokenAllocLimit(uint256 beatWeiAmount) internal view returns (bool) {
        uint256 newTotalSupply = token.totalSupply().add(beatWeiAmount);

        if (stage == Stages.PreIco && newTotalSupply <= PRE_ICO_LIMIT) return true;
        if (stage == Stages.IcoPhase1 && newTotalSupply <= ICO_PHASE1_LIMIT) return true;
        if (stage == Stages.IcoPhase2 && newTotalSupply <= ICO_PHASE2_LIMIT) return true;
        if (stage == Stages.IcoPhase3 && newTotalSupply <= ICO_PHASE3_LIMIT) return true;
        return false;
    }

    function determineCurrentStage(uint256 beatWeiAmount) internal {
        uint256 newTotalSupply = token.totalSupply();

        if (stage == Stages.PreIco && (newTotalSupply > PRE_ICO_LIMIT || now > preIcoEndTime)) {
            stage = Stages.IcoPhase1;
            emit BeatTokenIcoPhase1Started();
        }

        if (stage == Stages.IcoPhase1 && (newTotalSupply > ICO_PHASE1_LIMIT || now > icoPhase1EndTime)) {
            stage = Stages.IcoPhase2;
            emit BeatTokenIcoPhase2Started();
        }

        if (stage == Stages.IcoPhase2 && (newTotalSupply > ICO_PHASE2_LIMIT || now > icoPhase2EndTime)) {
            stage = Stages.IcoPhase3;
            emit BeatTokenIcoPhase3Started();
        }

        if (stage == Stages.IcoPhase3 && (newTotalSupply >= ICO_PHASE3_LIMIT || now > icoPhase3EndTime)) {
            stage = Stages.IcoEnded;
        }
    }
}
```

### Key Functionalities Implemented:
- **ICO Stage Management:** The contract manages transitions between different ICO phases and uses the current timestamp and supply caps to determine transitions.
- **Token Purchase:** Participants can purchase tokens by sending ETH, and tokens are minted with applicable bonuses depending on the phase.
- **ETH Price in Euro Cents:** This price is used to calculate the amount of tokens minted per ETH, adjustable only by the owner.
- **Finalization:** Unsold tokens are minted to the BEAT team wallet upon finalization, ensuring all phases are completed.

### Considerations:
- The code assumes certain constants and calculations for simplicity, such as the direct conversion from Euro cents to BEAT tokens, which might need refinement based on actual requirements.
- The contract's logic strictly adheres to handling stage transitions based on time or supply, allowing for a structured approach to managing the ICO lifecycle.
