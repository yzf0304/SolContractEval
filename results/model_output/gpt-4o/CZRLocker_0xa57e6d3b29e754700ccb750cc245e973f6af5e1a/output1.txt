```solidity
pragma solidity ^0.4.18;

contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

interface token { 
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); 
    function transfer(address _to, uint256 _value) public returns (bool success);
}

contract CZRLocker is owned {
    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);
    event RemoveLock(address addr, uint index);
    event Unlock(address addr, uint index, uint unlockAmount);

    address public tokenAddr;
    address public unlocker;

    struct LockedCZR {
        uint startLockTime;
        uint lockMonth;
        uint lockedAmount;
        uint unlockedAmount;
    }

    mapping(address => LockedCZR[]) public lockedCZRMap;

    function CZRLocker(address _tokenAddr, address _unlocker) public {
        tokenAddr = _tokenAddr;
        unlocker = _unlocker;
    }

    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public {
        if(startLockTime == 0) {
            startLockTime = now;
        }

        lockedCZRMap[addr].push(LockedCZR({
            startLockTime: startLockTime,
            lockMonth: lockMonth,
            lockedAmount: amount,
            unlockedAmount: 0
        }));

        emit AddLock(addr, lockedCZRMap[addr].length - 1, startLockTime, lockMonth, amount);
    }

    function removeCZRLock(address addr, uint index) onlyOwner public {
        require(index < lockedCZRMap[addr].length);

        delete lockedCZRMap[addr][index];

        emit RemoveLock(addr, index);
    }

    function unlockCZR(address addr, uint limit) public {
        require(msg.sender == owner || msg.sender == unlocker);

        LockedCZR[] storage locks = lockedCZRMap[addr];
        uint numLocks = locks.length;
        require(numLocks > 0);

        uint processed = 0;
        token tokenContract = token(tokenAddr);
        
        for(uint i = 0; i < numLocks && (limit == 0 || processed < limit); i++) {
            LockedCZR storage lock = locks[i];
            if(lock.lockedAmount > lock.unlockedAmount) {
                uint lockMonthsPassed = (now - lock.startLockTime) / 30 days;
                uint unlockableAmount = 0;

                if(lockMonthsPassed >= lock.lockMonth) {
                    unlockableAmount = lock.lockedAmount - lock.unlockedAmount;
                } else {
                    unlockableAmount = (lock.lockedAmount * lockMonthsPassed / lock.lockMonth) - lock.unlockedAmount;
                }

                if(unlockableAmount > 0) {
                    lock.unlockedAmount += unlockableAmount;
                    require(tokenContract.transfer(addr, unlockableAmount));

                    emit Unlock(addr, i, unlockableAmount);
                    processed++;
                }
            }
        }
    }

    function withdrawEth(address to, uint256 value) onlyOwner public {
        require(address(this).balance >= value);
        to.transfer(value);
    }

    function() payable public { }
}
```