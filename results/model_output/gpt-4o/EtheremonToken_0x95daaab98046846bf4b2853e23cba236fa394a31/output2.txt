Below is the completed `TokenERC20` smart contract implemented strictly based on the provided context and description, and using Solidity version `0.4.19`. All specified functionalities are implemented without introducing additional dependencies, unrelated code, or extra contracts.

```solidity
pragma solidity ^0.4.19;

interface TokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;
}

/**
 * @notice A simple ERC20 token contract.
 * @dev This contract implements the basic functionalities of an ERC20 token, including transfer, approve, and burn.
 */
contract TokenERC20 {

    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Burn(address indexed _from, uint256 _value);

    /**
     * @dev Internal function to transfer tokens between two addresses.
     * @param _from The address from which the tokens are sent.
     * @param _to The address to which the tokens are sent.
     * @param _value The amount of tokens to be transferred.
     */
    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != address(0)); // Prevent transfer to 0x0 address
        require(balanceOf[_from] >= _value); // Ensure the sender has sufficient balance
        require(balanceOf[_to] + _value > balanceOf[_to]); // Prevent overflow

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        Transfer(_from, _to, _value);
    }

    /**
     * @notice Transfers tokens from the message sender to another address.
     * @dev This function calls the internal `_transfer` function to perform the transfer.
     * @param _to The address to which the tokens are sent.
     * @param _value The amount of tokens to be transferred.
     */
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    /**
     * @notice Transfers tokens from one address to another, using the allowance mechanism.
     * @dev This function ensures that the spender has enough allowance to transfer the specified amount of tokens.
     * @param _from The address from which the tokens are sent.
     * @param _to The address to which the tokens are sent.
     * @param _value The amount of tokens to be transferred.
     * @return success True if the transfer was successful.
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]); // Check allowance
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    /**
     * @notice Approves a spender to transfer a specified amount of tokens on behalf of the message sender.
     * @dev This function sets the allowance for the specified spender.
     * @param _spender The address that will be allowed to spend the tokens.
     * @param _value The amount of tokens that the spender is allowed to spend.
     * @return success True if the approval was successful.
     */
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    /**
     * @notice Approves a spender to transfer a specified amount of tokens and calls a callback function on the spender.
     * @dev This function sets the allowance and then calls a callback function on the spender with additional data.
     * @param _spender The address that will be allowed to spend the tokens.
     * @param _value The amount of tokens that the spender is allowed to spend.
     * @param _extraData Additional data to be passed to the callback function.
     * @return success True if the approval and callback were successful.
     */
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        return false;
    }

    /**
     * @notice Burns (destroys) a specified amount of tokens from the message sender's balance.
     * @dev This function reduces the total supply and the message sender's balance by the specified amount.
     * @param _value The amount of tokens to be burned.
     * @return success True if the burn was successful.
     */
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value); // Ensure the sender has sufficient balance
        balanceOf[msg.sender] -= _value;
        totalSupply -= _value;

        Burn(msg.sender, _value);
        return true;
    }

    /**
     * @notice Burns (destroys) a specified amount of tokens from another address, using the allowance mechanism.
     * @dev This function reduces the total supply and the specified address's balance by the specified amount, and also reduces the allowance.
     * @param _from The address from which the tokens are burned.
     * @param _value The amount of tokens to be burned.
     * @return success True if the burn was successful.
     */
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value); // Ensure the source has sufficient balance
        require(_value <= allowance[_from][msg.sender]); // Check allowance
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        totalSupply -= _value;

        Burn(_from, _value);
        return true;
    }
}
```

This implementation strictly adheres to the provided context and description. It fulfills the requirements for an ERC20 token, including transfer, approve, and burn functionalities, while ensuring proper event emissions and safety checks.