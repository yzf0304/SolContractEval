Below is the completed `EverMigrate` contract implementation based on the provided context and requirements. The implementation includes all necessary details for token migration, transaction tracking, and support for managing token pairs.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;  // Conversion ratio (source -> target)
        bool isPresent; // Whether the token pair is registered
    }

    struct Transaction {
        uint256 amount;    // Amount of source tokens migrated
        uint256 timestamp; // Timestamp of the transaction
        uint32 txnId;      // Unique transaction ID
    }

    mapping(address => TokenDetails) private _tokenList; // Store details of token pairs
    address[] private _allTokens; // List of all supported source tokens
    uint32 private _txnId = 0; // Transaction counter for tracking unique IDs

    mapping(address => mapping(address => Transaction[])) private _userTxns; // User transaction history

    /**
     * @notice Adds a new token pair to the migration list.
     * @dev Only the contract owner can call this function.
     * @param sourceToken The address of the source token.
     * @param targetToken The address of the target token.
     * @param devAddress The address where the source tokens will be sent.
     * @param ratio The conversion ratio between the source and target tokens.
     */
    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(ratio > 0, "EverMigrate: Ratio must be greater than zero");
        require(!_tokenList[sourceToken].isPresent, "EverMigrate: Source token already added");

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });

        _allTokens.push(sourceToken);

        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    /**
     * @notice Migrates tokens from the source token to the target token.
     * @param sourceToken The address of the source token.
     * @param toAddress The recipient address for the target tokens.
     * @param amount The amount of source tokens to migrate.
     */
    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {
        require(_tokenList[sourceToken].isPresent, "EverMigrate: Token not supported");
        require(amount > 0, "EverMigrate: Amount must be greater than zero");

        TokenDetails memory tokenDetails = _tokenList[sourceToken];
        uint256 targetAmount = amount.mul(tokenDetails.ratio);

        // Transfer source tokens to devAddress
        require(
            IERC20(sourceToken).transferFrom(_msgSender(), tokenDetails.devAddress, amount),
            "EverMigrate: Source token transfer failed"
        );

        // Transfer target tokens to toAddress
        require(
            IERC20(tokenDetails.targetToken).transfer(toAddress, targetAmount),
            "EverMigrate: Target token transfer failed"
        );

        // Record the transaction
        _txnId++;
        _userTxns[sourceToken][_msgSender()].push(Transaction({
            amount: amount,
            timestamp: block.timestamp,
            txnId: _txnId
        }));

        emit TokensMigrated(sourceToken, tokenDetails.targetToken, amount, targetAmount);
    }

    /**
     * @notice Returns the number of transactions for a specific user and source token.
     * @param sourceToken The address of the source token.
     * @param userAddress The address of the user.
     * @return The number of transactions.
     */
    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {
        return _userTxns[sourceToken][userAddress].length;
    }

    /**
     * @notice Returns the details of a specific transaction for a user and source token.
     * @param sourceToken The address of the source token.
     * @param userAddress The address of the user.
     * @param position The index of the transaction in the user's transaction history.
     * @return The amount, timestamp, and transaction ID of the transaction.
     */
    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {
        require(position < _userTxns[sourceToken][userAddress].length, "EverMigrate: Invalid transaction index");
        Transaction memory txn = _userTxns[sourceToken][userAddress][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    /**
     * @notice Returns tokens to a specified address.
     * @param sourceToken The address of the source token.
     * @param toAddress The recipient address for the returned tokens.
     * @param amount The amount of tokens to return.
     */
    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {
        require(_tokenList[sourceToken].isPresent, "EverMigrate: Token not supported");
        require(amount > 0, "EverMigrate: Amount must be greater than zero");

        TokenDetails memory tokenDetails = _tokenList[sourceToken];

        // Transfer target tokens to the recipient
        require(
            IERC20(tokenDetails.targetToken).transfer(toAddress, amount),
            "EverMigrate: Token return failed"
        );

        emit TokensReturned(tokenDetails.targetToken, toAddress, amount);
    }

    /**
     * @notice Returns the migration details for a specific source token.
     * @param sourceToken The address of the source token.
     * @return The target token address and the conversion ratio.
     */
    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {
        require(_tokenList[sourceToken].isPresent, "EverMigrate: Token not supported");
        TokenDetails memory tokenDetails = _tokenList[sourceToken];
        return (tokenDetails.targetToken, tokenDetails.ratio);
    }

    /**
     * @notice Returns an array of all supported source tokens.
     * @return An array of supported source token addresses.
     */
    function allSupportedTokens() external view returns (address[] memory) {
        return _allTokens;
    }

    /**
     * @notice Returns the number of supported source tokens.
     * @return The number of supported source tokens.
     */
    function allSupportedTokensLength() external view returns (uint256) {
        return _allTokens.length;
    }

    /**
     * @notice Checks if a specific source token is supported.
     * @param sourceToken The address of the source token.
     * @return True if the token is supported, false otherwise.
     */
    function supportsToken(address sourceToken) public view returns (bool) {
        return _tokenList[sourceToken].isPresent;
    }
}
```

### Features:
1. **Token Migration**: Users can migrate tokens from a source token to a target token based on the provided ratio.
2. **Transaction History**: Tracks user transactions for each source token.
3. **Token Management**: Only the owner can add new token pairs and return tokens.
4. **Support Queries**: Functions to retrieve supported token lists and details for each token.

All functionality aligns with the provided requirements and description.