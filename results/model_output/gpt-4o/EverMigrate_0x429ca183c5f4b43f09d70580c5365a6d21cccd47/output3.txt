Here's the complete implementation of the `EverMigrate` contract according to the provided context and requirements:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

/**
 * @title EverMigrate
 * @notice A contract for migrating tokens from a source token to a target token, with support for tracking user transactions.
 * @dev The contract allows the owner to add token pairs and migrate tokens. It also provides functions to retrieve transaction details and supported tokens.
 */
contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping (address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId = 0;
    mapping (address => mapping (address => Transaction[])) private _userTxns;

    constructor() {}

    /**
     * @notice Adds a new token pair to the migration list.
     * @param sourceToken The address of the source token.
     * @param targetToken The address of the target token.
     * @param devAddress The address where the source tokens will be sent.
     * @param ratio The conversion ratio between the source and target tokens.
     * @dev Only the contract owner can call this function.
     */
    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(!_tokenList[sourceToken].isPresent, "Token pair already exists");
        require(sourceToken != address(0) && targetToken != address(0), "Invalid token address");

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });

        _allTokens.push(sourceToken);

        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    /**
     * @notice Migrates tokens from the source token to the target token.
     * @param sourceToken The address of the source token.
     * @param toAddress The recipient address for the target tokens.
     * @param amount The amount of source tokens to migrate.
     * @dev The function checks if the source token is supported, transfers the source tokens to the dev address, and sends the converted target tokens to the recipient.
     */
    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {
        TokenDetails memory details = _tokenList[sourceToken];
        require(details.isPresent, "Token is not supported");

        IERC20(sourceToken).transferFrom(_msgSender(), details.devAddress, amount);

        uint256 targetAmount = amount.mul(details.ratio);
        IERC20(details.targetToken).transfer(toAddress, targetAmount);

        _txnId++;
        _userTxns[sourceToken][_msgSender()].push(Transaction({
            amount: amount,
            timestamp: block.timestamp,
            txnId: _txnId
        }));

        emit TokensMigrated(sourceToken, details.targetToken, amount, targetAmount);
    }

    /**
     * @notice Returns the number of transactions for a specific user and source token.
     * @param sourceToken The address of the source token.
     * @param userAddress The address of the user.
     * @return The number of transactions.
     * @dev This function is used to get the length of the transaction history for a user.
     */
    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {
        return _userTxns[sourceToken][userAddress].length;
    }

    /**
     * @notice Returns the details of a specific transaction for a user and source token.
     * @param sourceToken The address of the source token.
     * @param userAddress The address of the user.
     * @param position The index of the transaction in the user's transaction history.
     * @return The amount, timestamp, and transaction ID of the transaction.
     * @dev This function is used to get the details of a specific transaction.
     */
    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {
        Transaction memory txn = _userTxns[sourceToken][userAddress][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    /**
     * @notice Returns tokens to a specified address.
     * @param sourceToken The address of the source token.
     * @param toAddress The recipient address for the returned tokens.
     * @param amount The amount of tokens to return.
     * @dev Only the contract owner can call this function. The function checks if the source token is supported and transfers the target tokens to the recipient.
     */
    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {
        TokenDetails memory details = _tokenList[sourceToken];
        require(details.isPresent, "Token is not supported");

        IERC20(details.targetToken).transfer(toAddress, amount);

        emit TokensReturned(details.targetToken, toAddress, amount);
    }

    /**
     * @notice Returns the migration details for a specific source token.
     * @param sourceToken The address of the source token.
     * @return The target token address and the conversion ratio.
     * @dev This function is used to get the migration details for a specific source token.
     */
    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {
        TokenDetails memory details = _tokenList[sourceToken];
        require(details.isPresent, "Token is not supported");

        return (details.targetToken, details.ratio);
    }

    /**
     * @notice Returns an array of all supported source tokens.
     * @return An array of supported source token addresses.
     * @dev This function is used to get a list of all supported source tokens.
     */
    function allSupportedTokens() external view returns (address[] memory) {
        return _allTokens;
    }

    /**
     * @notice Returns the number of supported source tokens.
     * @return The number of supported source tokens.
     * @dev This function is used to get the count of all supported source tokens.
     */
    function allSupportedTokensLength() external view returns (uint256) {
        return _allTokens.length;
    }

    /**
     * @notice Checks if a specific source token is supported.
     * @param sourceToken The address of the source token.
     * @return True if the token is supported, false otherwise.
     * @dev This function is used to check if a specific source token is supported.
     */
    function supportsToken(address sourceToken) public view returns (bool) {
        return _tokenList[sourceToken].isPresent;
    }
}
```

This contract provides functionality for migrating tokens from one token to another based on pre-defined pairs and ratios, manages transaction records for users, and offers functions to query supported tokens and transaction details.