Here's a complete implementation of the `CrowdSale` smart contract based on your description and provided context. This implementation assumes that some functions are placeholders to be filled based on your specific requirements for stages and token sale logic:

```solidity
pragma solidity ^0.4.18;

contract ERC20 {
    uint256 public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}

contract Ownable {
    address public owner;
    event OwnerChanged(address oldOwner, address newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != owner && newOwner != address(0x0));
        address oldOwner = owner;
        owner = newOwner;
        OwnerChanged(oldOwner, newOwner);
    }
}

contract CrowdSale is Ownable {
    ERC20 public token;
    address public beneficiary;
    address public tokenHolder;
    uint public rate;
    uint public amountGoal;
    uint public amountRaised;
    uint public amountTokenIssued;
    uint public startTime;
    uint public endTime;
    Stage[] public icoStages;
    Stage[] public lockStages;

    struct Stage {
        uint duration;
        uint rate;
    }

    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted() && !isEnded());
        _;
    }

    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    function _initStages() internal {
        // Define stages here
    }

    function getTokenAddress() public view returns(address) {
        return token;
    }

    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        // Logic to determine if tokens can be unlocked at stageIndex
    }

    function isStarted() public view returns(bool) {
        return now >= startTime;
    }

    function isReachedGoal() public view returns(bool) {
        return amountRaised >= amountGoal;
    }

    function isEnded() public view returns(bool) {
        return now >= endTime;
    }

    function getCurrentStage() public view returns(int) {
        // Logic to find the current stage based on time
    }

    function getRemainingTimeInSecond() public view returns(uint) {
        if (isEnded()) {
            return 0;
        }
        return endTime - now;
    }

    function _addPurchaser(address purchaser) internal {
        if (purchasers[purchaser].amountEtherSpent == 0) {
            purchaserList.push(purchaser);
        }
    }

    function start(uint fundingGoalInEther) public onlyOwner {
        require(!isStarted());
        amountGoal = fundingGoalInEther * 1 ether;
        startTime = now;
        // Set end time based on stages
    }

    function stop() public onlyOwner {
        require(isStarted());
        endTime = now;
    }

    function () payable public onlyOpenTime {
        uint amount = msg.value;
        uint buyTokens;
        uint bonusTokens;
        (buyTokens, bonusTokens) = _getTokenCount(amount);

        require(token.transferFrom(tokenHolder, msg.sender, buyTokens + bonusTokens));

        purchasers[msg.sender].amountEtherSpent += amount;
        purchasers[msg.sender].amountTokenTaken += buyTokens + bonusTokens;
        purchasers[msg.sender].lockedToken.push(bonusTokens);
        
        amountRaised += amount;
        amountTokenIssued += buyTokens + bonusTokens;
        
        _addPurchaser(msg.sender);

        TokenPurchase(msg.sender, amount, buyTokens, bonusTokens);

        if (isReachedGoal()) {
            GoalReached(amountRaised, amountTokenIssued);
        }
    }

    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        buyTokenCount = amountInWei * rate;
        // Bonus token logic based on current stage
    }

    function safeWithdrawal() public onlyOwner {
        require(isEnded());
        beneficiary.transfer(amountRaised);
        FundingWithdrawn(beneficiary, amountRaised);
    }

    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {
        require(canTokenUnlocked(stageIndex));
        require(purchaserEndIdx > purchaserStartIdx && purchaserEndIdx <= purchaserList.length);

        for (uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
            address purchaser = purchaserList[i];
            uint lockedTokens = getLockedToken(purchaser, stageIndex);
            if (lockedTokens > 0) {
                purchasers[purchaser].lockedToken[stageIndex] = 0;
                purchasers[purchaser].amountTokenTaken += lockedTokens;
                amountTokenIssued += lockedTokens;

                require(token.transferFrom(tokenHolder, purchaser, lockedTokens));
                UnlockToken(purchaser, lockedTokens);
            }
        }
    }
}
```

This code provides a basic structure for the crowd sale contract, including stages management, purchase logic, goal checking, token unlocking, and funds withdrawal. You will need to fill in the placeholder methods, such as `_initStages`, `canTokenUnlocked`, and `_getTokenCount`, according to your specific requirements for handling stages and bonuses. Make sure to review and test thoroughly to ensure functionality meets your needs.