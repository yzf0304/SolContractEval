Below is the complete and functional implementation of the `FlashToken` contract, based strictly on the provided context and description. Each function is carefully implemented, maintaining adherence to the ERC20 standard, while incorporating the additional minting, burning, and advanced authorization features, such as `permit` (ERC-2612) and `transferWithAuthorization` (ERC-3009).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.7.4;

contract FlashToken is IERC20 {
    using SafeMath for uint256;

    // EIP-712 Domain Separator constants
    bytes32 private constant EIP712DOMAIN_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
    bytes32 private constant NAME_HASH = keccak256("Flashstake");
    bytes32 private constant VERSION_HASH = keccak256("1");

    // Typehashes for EIP-712 signatures
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = keccak256("TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)");

    // Token metadata
    string public constant name = "Flashstake";
    string public constant symbol = "FLASH";
    uint8 public constant decimals = 18;

    // Minter addresses
    address public constant FLASH_PROTOCOL = 0x15EB0c763581329C921C8398556EcFf85Cc48275;
    address public constant FLASH_CLAIM = 0xf2319b6D2aB252d8D80D8CEC34DaF0079222A624;

    // Total supply and balances
    uint256 public override totalSupply;
    mapping(address => uint256) public override balanceOf;
    mapping(address => mapping(address => uint256)) public override allowance;

    // ERC-2612, ERC-3009 state
    mapping(address => uint256) public nonces;
    mapping(address => mapping(bytes32 => bool)) public authorizationState;

    // Events
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);

    // Modifier to restrict functions to only minter addresses
    modifier onlyMinter {
        require(msg.sender == FLASH_PROTOCOL || msg.sender == FLASH_CLAIM, "FlashToken:: NOT_MINTER");
        _;
    }

    constructor() {
        _mint(0x842f8f6fB524996d0b660621DA895166E1ceA691, 1200746000000000000000000);
        _mint(0x0945d9033147F27aDDFd3e7532ECD2100cb91032, 1000000000000000000000000);
    }

    function _validateSignedData(
        address signer,
        bytes32 encodeData,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal view {
        require(signer != address(0), "FlashToken:: INVALID_SIGNER");
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", getDomainSeparator(), encodeData));
        address recoveredSigner = ecrecover(digest, v, r, s);
        require(recoveredSigner == signer, "FlashToken:: INVALID_SIGNATURE");
    }

    function _mint(address to, uint256 value) internal {
        require(to != address(0), "FlashToken:: MINT_TO_ZERO");
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint256 value) internal {
        require(balanceOf[from] >= value, "FlashToken:: BURN_EXCEEDS_BALANCE");
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(
        address owner,
        address spender,
        uint256 value
    ) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(
        address from,
        address to,
        uint256 value
    ) private {
        require(to != address(0) && to != address(this), "FlashToken:: INVALID_TRANSFER");
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function getChainId() public pure returns (uint256 chainId) {
        assembly {
            chainId := chainid()
        }
    }

    function getDomainSeparator() public view returns (bytes32) {
        return keccak256(abi.encode(EIP712DOMAIN_HASH, NAME_HASH, VERSION_HASH, getChainId(), address(this)));
    }

    function mint(address to, uint256 value) external onlyMinter returns (bool) {
        _mint(to, value);
        return true;
    }

    function burn(uint256 value) external returns (bool) {
        _burn(msg.sender, value);
        return true;
    }

    function approve(address spender, uint256 value) external override returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) external override returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external override returns (bool) {
        allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp <= deadline, "FlashToken:: PERMIT_EXPIRED");
        bytes32 encodeData = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));
        _validateSignedData(owner, encodeData, v, r, s);
        _approve(owner, spender, value);
    }

    function transferWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(block.timestamp > validAfter, "FlashToken:: AUTH_NOT_YET_VALID");
        require(block.timestamp < validBefore, "FlashToken:: AUTH_EXPIRED");
        require(!authorizationState[from][nonce], "FlashToken:: AUTH_ALREADY_USED");
        authorizationState[from][nonce] = true;
        emit AuthorizationUsed(from, nonce);
        bytes32 encodeData = keccak256(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, from, to, value, validAfter, validBefore, nonce));
        _validateSignedData(from, encodeData, v, r, s);
        _transfer(from, to, value);
    }
}
```

This implementation is fully compliant with the description provided, including ERC20 standards, minting, burning, `permit`, and `transferWithAuthorization` features. It uses the `SafeMath` library to prevent arithmetic overflows and ensures strict validation for signature-based operations.