To complete the smart contract `GCUToken` based on the provided context and description, we need to implement several functions following both ERC20 and ERC223 standards, ensuring that the contract adheres to the given version constraints (0.4.26) and does not introduce additional dependencies or functionality. 

Below is the completed `GCUToken` contract:

```solidity
pragma solidity ^0.4.26;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error.
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract ERC223Interface {
    uint public totalSupply_;
    function balanceOf(address who) view returns (uint);
    function transfer(address to, uint value) returns (bool);
    function transfer(address to, uint value, bytes data) returns (bool);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data) {
        _from;
        _value;
        _data;
    }
}

contract GCUToken is ERC223Interface {
    using SafeMath for uint256;

    string public constant _name = "Global Currency Unit";
    string public constant _symbol = "GCU";
    uint8 public constant _decimals = 18;

    address public owner;
    uint256 public totalSupply_;

    mapping(address => uint256) public balances;
    mapping(address => mapping (address => uint256)) public allowed;

    constructor (uint256 _amount, address _initialWallet) public {
        owner = _initialWallet;
        totalSupply_ = _amount.mul(uint256(10) ** _decimals);
        balances[_initialWallet] = totalSupply_;

        emit Transfer(0x0, _initialWallet, totalSupply_);
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed from, address indexed to, uint256 value);

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address _address) view returns (uint256 balance) {
        return balances[_address];
    }

    function transfer(address _to, uint _value) returns (bool success) {
        bytes memory empty;
        return transfer(_to, _value, empty);
    }

    function transfer(address _to, uint _value, bytes _data) returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        if (isContract(_to)) {
            ContractReceiver receiver = ContractReceiver(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }

        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        bytes memory empty;
        emit Transfer(_from, _to, _value, empty);
        return true;
    }

    function approve(address _spender, uint256 _allowance) returns (bool success) {
        allowed[msg.sender][_spender] = _allowance;
        emit Approval(msg.sender, _spender, _allowance);
        return true;
    }

    function allowance(address _owner, address _spender) view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function name() view returns (string name) {
        return _name;
    }

    function symbol() view returns (string symbol) {
        return _symbol;
    }

    function decimals() view returns (uint8 decimals) {
        return _decimals;
    }

    function isContract(address _address) internal view returns (bool is_contract) {
        uint length;
        assembly { length := extcodesize(_address) }
        return length > 0;
    }

    function () public {
        revert();
    }
}
```

### Explanation:
- **Library SafeMath**: Utilized for safe arithmetic operations, avoiding overflow errors.
- **Transfer Functions**: Implemented to handle both standard and contract transfers (with `tokenFallback` for contracts).
- **Approval and Allowance**: Implemented to handle token allowances, a necessary feature for ERC20 compliance.
- **Fallback Function**: Prevents Ether from being sent to the contract.
- **Balance and Supply Queries**: Provides balance and total supply information.
- **Contract Initialization**: Initializes token supply and assigns it to the initial wallet.

This implementation ensures compliance with both the ERC20 and ERC223 standards while adhering strictly to the Solidity version 0.4.26 and the constraints mentioned in the task.