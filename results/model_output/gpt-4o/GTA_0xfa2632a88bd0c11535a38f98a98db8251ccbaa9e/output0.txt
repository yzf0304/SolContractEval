Below is the completed version of the `StandardToken` smart contract based strictly on the provided context and description. It implements the required ERC20 functions and uses the `SafeMath` library for safe math operations. Note that this adheres to Solidity compiler version `0.4.16`.

```solidity
pragma solidity ^0.4.16;

contract SafeMath {
    function safeAdd(uint256 x, uint256 y) internal pure returns (uint256) {
        uint256 z = x + y;
        require(z >= x);
        return z;
    }

    function safeSub(uint256 x, uint256 y) internal pure returns (uint256) {
        require(y <= x);
        return x - y;
    }

    function safeMul(uint256 x, uint256 y) internal pure returns (uint256) {
        if (x == 0 || y == 0) {
            return 0;
        }
        uint256 z = x * y;
        require(z / x == y);
        return z;
    }

    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {
        require(y > 0);
        return x / y;
    }
}

contract StandardToken is ERC20 {

    using SafeMath for uint256;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    uint256 public totalSupply;

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(_value > 0);
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].safeSub(_value);
        balances[_to] = balances[_to].safeAdd(_value);

        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(_value > 0);
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].safeSub(_value);
        balances[_to] = balances[_to].safeAdd(_value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender].safeSub(_value);

        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool) {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));
        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
```

### Explanation:
1. **Inheritance:** The `StandardToken` contract adheres to the `ERC20` interface by defining all required functions (`balanceOf`, `transfer`, `transferFrom`, `approve`, and `allowance`) and corresponding `event` emissions (`Transfer` and `Approval`).
2. **SafeMath Usage:** Utilized `SafeMath` for safe addition, subtraction, multiplication, and division to prevent overflows and underflows.
3. **State Variables:**
   - `balances`: Tracks the balance of each address.
   - `allowed`: Manages allowances for spender accounts.
   - `totalSupply`: Records the total number of tokens in circulation.
4. **Events:** Emitting `Transfer` and `Approval` events to adhere to ERC20 standards.
5. **Functionality:** Implements `transfer`, `transferFrom`, `approve`, and `allowance` functionalities, ensuring required checks such as `non-zero address`, `sufficient balance`, `valid allowance`, etc.

Note that the `SafeMath` library was included directly in the code since the provided context does not allow for introducing new contracts.