Here is the complete implementation of the `StandardToken` contract based on the provided context and description. It includes the functionality required to meet the ERC20 standard.

```solidity
pragma solidity ^0.4.16;

import "./SafeMath.sol";

contract StandardToken is ERC20 {
    using SafeMath for uint256;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    /**
     * @dev Total number of tokens in existence
     */
    uint256 public totalSupply;

    /**
     * @notice Returns the balance of the specified address.
     * @param _owner The address to query the balance of.
     * @return The balance of the specified address.
     */
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    /**
     * @notice Transfer token for a specified address
     * @param _to The address to transfer to.
     * @param _value The amount to be transferred.
     * @return True if the transfer was successful.
     */
    function transfer(address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @notice Transfer tokens from one address to another
     * @param _from address The address which you want to send tokens from
     * @param _to address The address which you want to transfer to
     * @param _value uint256 the amount of tokens to be transferred
     * @return True if the transfer was successful.
     */
    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @notice Approves the specified address to spend a certain amount of tokens on behalf of the message sender.
     * @param _spender The address which will spend the funds.
     * @param _value The amount of tokens to be spent.
     * @return True if the approval was successful.
     */
    function approve(address _spender, uint256 _value) returns (bool) {
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @notice Returns the remaining number of tokens that `_spender` is allowed to spend on behalf of `_owner`.
     * @param _owner The address of the token owner.
     * @param _spender The address of the spender.
     * @return The remaining allowance for the spender.
     */
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
```

### Key Points:

- **SafeMath**: The `SafeMath` library is used to prevent integer overflow and underflow. Ensure you have it imported correctly in your environment.
  
- **balanceOf**: Returns the balance of the given address.
  
- **transfer**: Allows a user to transfer tokens to another address, ensuring there is sufficient balance and the recipient address is valid.
  
- **transferFrom**: Enables a third party (spender) to transfer tokens from one address to another, requiring sufficient allowance and balance.
  
- **approve**: Sets an allowance for a spender address, requiring the current allowance to be zero to prevent race conditions.
  
- **allowance**: Returns the remaining allowance for a spender to spend from the owner's account.

Make sure to integrate the `SafeMath` library in your project to use this contract correctly.