Here's the complete `HalloweenMinter` contract implementation based on the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

interface iNFTCollection {
    function externalMint(address _address, uint256 _amount) external payable;
    function totalSupply() external view returns (uint256);
    function balanceOf(address address_) external view returns (uint256);
    function ownerOf(uint256 tokenId_) external view returns (address);
    function tokensOfOwner(address _address) external view returns (uint256[] memory);
}

contract HalloweenMinter is Ownable {

    address public constant withdrawAddress = 0xdEcf4B112d4120B6998e5020a6B4819E490F7db6;
    iNFTCollection public NFTCollection = iNFTCollection(0x2d3C8D1A84cA778A3bba0F4fC389330AB96AF3Be); 

    constructor() {
        pause(false);
        setMintCount(false);
    }

    uint256 public cost = 0;
    uint256 public maxSupply = 5000;
    uint256 public maxMintAmountPerTransaction = 3;
    uint256 public publicSaleMaxMintAmountPerAddress = 300;
    bool public paused = true;
    bool public onlyWhitelisted = true;
    bool public mintCount = true;
    mapping(address => uint256) public whitelistMintedAmount;
    mapping(address => uint256) public publicSaleMintedAmount;
    bytes32 public merkleRoot;

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract.");
        _;
    }

    function mint(uint256 _mintAmount, uint256 _maxMintAmount, bytes32[] calldata _merkleProof) public payable callerIsUser {
        require(!paused, "The contract is paused.");
        require(_mintAmount > 0, "Mint amount must be greater than zero.");
        require(_mintAmount <= maxMintAmountPerTransaction, "Exceeds max mint amount per transaction.");
        require(NFTCollection.totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply.");

        if (onlyWhitelisted) {
            require(isWhitelisted(msg.sender, _maxMintAmount, _merkleProof), "Not whitelisted or invalid proof.");
            if (mintCount) {
                require(whitelistMintedAmount[msg.sender] + _mintAmount <= _maxMintAmount, "Exceeds whitelist mint allowance.");
                whitelistMintedAmount[msg.sender] += _mintAmount;
            }
        } else {
            if (mintCount) {
                require(publicSaleMintedAmount[msg.sender] + _mintAmount <= publicSaleMaxMintAmountPerAddress, "Exceeds public sale mint allowance.");
                publicSaleMintedAmount[msg.sender] += _mintAmount;
            }
        }

        require(msg.value >= cost * _mintAmount, "Insufficient funds.");
        NFTCollection.externalMint(msg.sender, _mintAmount);
    }

    function isWhitelisted(address _address, uint256 _maxMintAmount, bytes32[] calldata _merkleProof) public view returns (bool) {
        bytes32 leaf = keccak256(abi.encodePacked(_address, _maxMintAmount));
        return MerkleProof.verify(_merkleProof, merkleRoot, leaf);
    }

    function setMaxSupply(uint256 _maxSupply) public onlyOwner {
        maxSupply = _maxSupply;
    }

    function totalSupply() public view returns (uint256) {
        return NFTCollection.totalSupply();
    }

    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
        merkleRoot = _merkleRoot;
    }

    function setPublicSaleMaxMintAmountPerAddress(uint256 _publicSaleMaxMintAmountPerAddress) public onlyOwner {
        publicSaleMaxMintAmountPerAddress = _publicSaleMaxMintAmountPerAddress;
    }

    function setCost(uint256 _newCost) public onlyOwner {
        cost = _newCost;
    }

    function setOnlyWhitelisted(bool _state) public onlyOwner {
        onlyWhitelisted = _state;
    }

    function setMaxMintAmountPerTransaction(uint256 _maxMintAmountPerTransaction) public onlyOwner {
        maxMintAmountPerTransaction = _maxMintAmountPerTransaction;
    }

    function pause(bool _state) public onlyOwner {
        paused = _state;
    }

    function setMintCount(bool _state) public onlyOwner {
        mintCount = _state;
    }

    function setNFTCollection(address _address) public onlyOwner {
        NFTCollection = iNFTCollection(_address);
    }

    function withdraw() public onlyOwner {
        (bool success, ) = withdrawAddress.call{value: address(this).balance}("");
        require(success, "Failed to withdraw.");
    }
}
```

### Key Features
1. **Minting Logic**: The `mint` function handles both whitelist and public sale minting.
2. **Whitelist Verification**: Utilizes Merkle Proof for verifying whitelist eligibility.
3. **Supply Restrictions**: Enforces limits on the total supply, mint amount per transaction, and mint amount per address.
4. **Administrative Functions**: Includes setters for various parameters like supply, cost, and whitelist.
5. **Funds Withdrawal**: Allows the owner to withdraw funds to a predefined address.
6. **Safety Measures**: Ensures only external users can call mint functions, prevents contract reentrancy.

This implementation adheres strictly to the provided instructions and context, without introducing unrelated dependencies or functionality.