To create the `Bonus` contract that adheres to the provided description and existing dependencies, we need to complete the stub functions provided in the smart contract. The contract uses Solidity version 0.4.18, and inherits from `IcoPhase` and `Ownable`, while utilizing the `SafeMath` library for secure arithmetic operations. Here is the completed implementation:

```solidity
pragma solidity ^0.4.18;

library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract IcoPhase {
    uint256 public constant phasePresale_From = 1517493600;//14h 01/02/2018 GMT
    uint256 public constant phasePresale_To = 1518703200;//14h 15/02/2018 GMT

    uint256 public constant phasePublicSale1_From = 1520690400;//14h 10/03/2018 GMT
    uint256 public constant phasePublicSale1_To = 1521122400;//14h 15/03/2018 GMT

    uint256 public constant phasePublicSale2_From = 1521122400;//14h 15/03/2018 GMT
    uint256 public constant phasePublicSale2_To = 1521554400;//14h 20/03/2018 GMT

    uint256 public constant phasePublicSale3_From = 1521554400;//14h 20/03/2018 GMT
    uint256 public constant phasePublicSale3_To = 1521986400;//14h 25/03/2018 GMT
}

contract Bonus is IcoPhase, Ownable {
    using SafeMath for uint256;

    // decimals of tokens
    uint256 constant decimals = 18;

    // enable/disable
    bool public isBonus;

    // storage
    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    function Bonus() public {
        isBonus = true;
    }

    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus, "Bonus is already enabled.");
        isBonus = true;
        return true;
    }

    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus, "Bonus is already disabled.");
        isBonus = false;
        return true;
    }

    function getBonusByTime() public view returns (uint256) {
        if (now >= phasePresale_From && now < phasePresale_To) {
            return 20; // 20% bonus in Presale
        } else if (now >= phasePublicSale1_From && now < phasePublicSale1_To) {
            return 15; // 15% bonus in Public Sale 1
        } else if (now >= phasePublicSale2_From && now < phasePublicSale2_To) {
            return 10; // 10% bonus in Public Sale 2
        } else if (now >= phasePublicSale3_From && now < phasePublicSale3_To) {
            return 5;  // 5% bonus in Public Sale 3
        } else {
            return 0;  // No bonus outside sale phases
        }
    }

    function getBonusByETH(uint256 _value) public view returns (uint256) {
        require(isBonus, "Bonuses are currently disabled.");
        uint256 bonusPercentage = getBonusByTime();
        uint256 bonusAmount = _value.mul(bonusPercentage).div(100);
        return bonusAmount;
    }

    function balanceBonusOf(address _owner) public view returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        require(_address != address(0), "Invalid address.");
        uint256 bonusAmount = bonusAccountBalances[_address];
        require(bonusAmount > 0, "No bonus available to pay.");
        bonusAccountBalances[_address] = 0;
        _address.transfer(bonusAmount);
        return true;
    }

    function receive() external payable {}
}
```

This implementation defines the `Bonus` contract with functionalities to enable or disable bonuses, calculate bonus percentages based on the ICO phase and ETH contribution, and manage participant bonus balances. It also includes owner-only functions for managing these bonuses. This solution adheres to the given constraints of Solidity version 0.4.18.