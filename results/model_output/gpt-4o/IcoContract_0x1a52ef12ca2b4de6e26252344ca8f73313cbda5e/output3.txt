Below is the complete implementation of the `Bonus` contract based on the provided context and description. It adheres strictly to the given instructions, uses Solidity version 0.4.18 syntax, and includes the described functionality.

```solidity
pragma solidity ^0.4.18;

import "./SafeMath.sol";
import "./Ownable.sol";
import "./IcoPhase.sol";

/**
 * @notice This contract manages the bonus distribution for an ICO, allowing the owner to enable or disable bonuses,
 *         calculate bonuses based on time and ETH amount, and manage bonus balances for participants.
 * @dev This contract inherits from IcoPhase and Ownable. It uses SafeMath for arithmetic operations.
 */
contract Bonus is IcoPhase, Ownable {
    using SafeMath for uint256;

    // Decimals of tokens
    uint256 constant decimals = 18;

    // Enable/disable the bonus system
    bool public isBonus;

    // Storage for bonus balances
    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    /**
     * @notice Initializes the contract with bonuses enabled.
     * @dev Constructor sets the initial state of the contract.
     */
    function Bonus() public {
        isBonus = true;
    }

    /**
     * @notice Enables the bonus system.
     * @dev Can only be called by the contract owner and when bonuses are currently disabled.
     * @return A boolean indicating the success of the operation.
     */
    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus);
        isBonus = true;
        return true;
    }

    /**
     * @notice Disables the bonus system.
     * @dev Can only be called by the contract owner and when bonuses are currently enabled.
     * @return A boolean indicating the success of the operation.
     */
    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus);
        isBonus = false;
        return true;
    }

    /**
     * @notice Gets the bonus percentage based on the current time.
     * @dev Checks the current time against predefined phases and returns the corresponding bonus percentage.
     * @return The bonus percentage as a uint256.
     */
    function getBonusByTime() public constant returns (uint256) {
        if (now >= phasePresale_From && now <= phasePresale_To) {
            return 30; // Presale phase bonus
        } else if (now >= phasePublicSale1_From && now <= phasePublicSale1_To) {
            return 20; // Public Sale Phase 1 bonus
        } else if (now >= phasePublicSale2_From && now <= phasePublicSale2_To) {
            return 10; // Public Sale Phase 2 bonus
        } else if (now >= phasePublicSale3_From && now <= phasePublicSale3_To) {
            return 5;  // Public Sale Phase 3 bonus
        } else {
            return 0;  // No bonus outside defined phases
        }
    }

    /**
     * @notice Calculates the bonus amount based on the provided ETH value.
     * @dev Determines the bonus amount based on the current phase and the provided ETH value.
     * @param _value The amount of ETH to convert to a bonus.
     * @return The bonus amount as a uint256.
     */
    function getBonusByETH(uint256 _value) public constant returns (uint256) {
        uint256 bonusPercentage = getBonusByTime();
        return _value.mul(bonusPercentage).div(100);
    }

    /**
     * @notice Returns the bonus balance of a specific account.
     * @dev Fetches the bonus balance from the storage mapping.
     * @param _owner The address of the account to check the bonus balance for.
     * @return The bonus balance as a uint256.
     */
    function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    /**
     * @notice Pays a bonus to a specified address.
     * @dev Only the contract owner can call this function. The actual implementation of paying the bonus should be defined.
     * @param _address The address to which the bonus will be paid.
     * @return A boolean indicating the success of the operation.
     */
    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        require(bonusAccountBalances[_address] > 0);

        uint256 bonusAmount = bonusAccountBalances[_address];
        bonusAccountBalances[_address] = 0;

        // Payment logic, e.g., transfer tokens to _address
        _address.transfer(bonusAmount);

        return true;
    }

    /**
     * @notice Fallback function to receive Ether.
     * @dev This function allows the contract to receive Ether.
     */
    function() public payable {}
}
```

### Key Points:
1. **Bonus Activation/Deactivation:** `enableBonus` and `disableBonus` functions allow toggling the bonus system on/off.
2. **Bonus Calculation:** `getBonusByTime` determines the bonus percentage based on the current phase, while `getBonusByETH` calculates the bonus amount.
3. **Bonus Balances:** `balanceBonusOf` retrieves the stored bonus balance for an address, and `payBonusToAddress` transfers the bonus.
4. **Fallback Function:** Allows receiving Ether directly into the contract.

Ensure that `SafeMath.sol`, `Ownable.sol`, and `IcoPhase.sol` are correctly imported and compiled with Solidity version 0.4.18 as specified.