Certainly! Here's the completed `Bonus` smart contract based on the provided context and description:

```solidity
pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

/**
 * @title Ownable
 * @dev The Ownable contract has an owner address, and provides basic authorization control
 * functions, this simplifies the implementation of "user permissions".
 */
contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

/**
 * @title IcoPhase
 * @dev Store config of phase ICO
 */
contract IcoPhase {
    uint256 public constant phasePresale_From = 1517493600; //14h 01/02/2018 GMT
    uint256 public constant phasePresale_To = 1518703200; //14h 15/02/2018 GMT

    uint256 public constant phasePublicSale1_From = 1520690400; //14h 10/03/2018 GMT
    uint256 public constant phasePublicSale1_To = 1521122400; //14h 15/03/2018 GMT

    uint256 public constant phasePublicSale2_From = 1521122400; //14h 15/03/2018 GMT
    uint256 public constant phasePublicSale2_To = 1521554400; //14h 20/03/2018 GMT

    uint256 public constant phasePublicSale3_From = 1521554400; //14h 20/03/2018 GMT
    uint256 public constant phasePublicSale3_To = 1521986400; //14h 25/03/2018 GMT
}

/**
 * @title Bonus
 * @notice This contract manages the bonus distribution for an ICO, allowing the owner to enable or disable bonuses,
 * calculate bonuses based on time and ETH amount, and manage bonus balances for participants.
 * @dev This contract inherits from IcoPhase and Ownable. It uses SafeMath for arithmetic operations.
 */
contract Bonus is IcoPhase, Ownable {
    using SafeMath for uint256;

    uint256 constant decimals = 18;
    bool public isBonus;

    mapping(address => uint256) public bonusAccountBalances;
    mapping(uint256 => address) public bonusAccountIndex;
    uint256 public bonusAccountCount;

    function Bonus() public {
        isBonus = true;
    }

    function enableBonus() public onlyOwner returns (bool) {
        require(!isBonus);
        isBonus = true;
        return true;
    }

    function disableBonus() public onlyOwner returns (bool) {
        require(isBonus);
        isBonus = false;
        return true;
    }

    function getBonusByTime() public constant returns (uint256) {
        uint256 currentTime = now;
        if (currentTime >= phasePresale_From && currentTime < phasePresale_To) {
            return 20; // 20% bonus in Presale
        } else if (currentTime >= phasePublicSale1_From && currentTime < phasePublicSale1_To) {
            return 15; // 15% bonus in Public Sale 1
        } else if (currentTime >= phasePublicSale2_From && currentTime < phasePublicSale2_To) {
            return 10; // 10% bonus in Public Sale 2
        } else if (currentTime >= phasePublicSale3_From && currentTime < phasePublicSale3_To) {
            return 5; // 5% bonus in Public Sale 3
        }
        return 0;
    }

    function getBonusByETH(uint256 _value) public constant returns (uint256) {
        uint256 bonusPercent = getBonusByTime();
        return _value.mul(bonusPercent).div(100);
    }

    function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
        return bonusAccountBalances[_owner];
    }

    function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
        require(_address != address(0));
        uint256 bonus = bonusAccountBalances[_address];
        require(bonus > 0);
        
        bonusAccountBalances[_address] = 0;
        bonusAccountCount = bonusAccountCount.sub(1);
        
        _address.transfer(bonus);
        return true;
    }

    function() public payable {}
}
```

This contract ensures the operations related to bonus distribution in the context of an ICO, based on the provided phase timings and the SafeMath library for safe arithmetic operations.