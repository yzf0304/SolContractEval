Below is the fully implemented `Kubera` contract as per the given description, strictly adhering to the provided context, using Solidity version `0.4.11`.

```solidity
pragma solidity ^0.4.11;

contract SafeMath {

    function safeMul(uint a, uint b) internal returns(uint) {
        uint c = a * b;
        Assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) internal returns(uint) {
        Assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) internal returns(uint) {
        uint c = a + b;
        Assert(c >= a && c >= b);
        return c;
    }

    function Assert(bool assertion) internal {
        if (!assertion) {
            revert();
        }
    }
}

contract Kubera is SafeMath {

    string public standard = 'ERC20';
    string public name = 'Kubera token';
    string public symbol = 'KBR';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    address public owner;
    uint public tokensSoldToInvestors = 0;
    uint public maxGoalInICO = 2100000000;
    uint256 public startTime = 1510325999;
    bool burned;
    bool hasICOStarted;
    address tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event TransferToReferral(address indexed referralAddress, uint256 value);
    event Approval(address indexed Owner, address indexed spender, uint256 value);
    event Burned(uint amount);

    function Kubera() {
        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;
        balanceOf[owner] = 2205000000;
        totalSupply = 2205000000;
    }

    function transfer(address _to, uint256 _value) returns(bool success) {
        require(now >= startTime || msg.sender == owner); 
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {
        require(now >= startTime || msg.sender == owner);
        if (!hasICOStarted) {
            require(_from == owner);
            require(!burned);
            tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value);
            if (tokensSoldToInvestors > maxGoalInICO) {
                uint excess = safeSub(tokensSoldToInvestors, maxGoalInICO);
                _value = safeSub(_value, excess);
                tokensSoldToInvestors = maxGoalInICO;
            }
        }

        require(balanceOf[_from] >= _value);
        require(allowance[_from][msg.sender] >= _value);

        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);

        Transfer(_from, _to, _value);
        return true;
    }

    function burn() {
        require(msg.sender == owner);
        require(!burned);
        require(now > startTime);

        uint unsoldTokens = safeSub(balanceOf[owner], tokensSoldToInvestors);
        balanceOf[owner] = 0;
        balanceOf[tokensHolder] = 150000000;

        burned = true;
        Burned(unsoldTokens);
    }
}
```

### Key Features Implemented:
1. **Token Transfers**: Tokens can only be transferred after the ICO end time (`startTime`), except for the `owner`.
2. **ICO Management**: Tracks tokens sold during ICO, restricts transfers before ICO, and limits tokens sold to the `maxGoalInICO`.
3. **Burn Function**: Burns unsold tokens after the ICO and transfers a fixed amount (`150,000,000 tokens`) to the `tokensHolder`.
4. **SafeMath Integration**: All arithmetic operations are protected using `SafeMath`.

### Restrictions and Validations:
- During the ICO, only the owner can transfer tokens.
- Post-ICO, normal transfers are allowed without restrictions.
- The burn process can only be initiated by the owner after the ICO ends and ensures that it doesn't execute multiple times.

This implementation strictly adheres to the provided guidelines and context.