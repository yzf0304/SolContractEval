Below is the completed implementation of the `KyberGenesisToken` contract strictly following the given description and context:

```solidity
pragma solidity ^0.4.15;

/**
 * @title Ownable
 * @notice Base contract with an owner.
 */
contract Ownable {
    address public owner;

    /**
     * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.
     */
    function Ownable() public {
        owner = msg.sender;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    /**
     * @dev Allows the current owner to transfer control of the contract to a newOwner.
     * @param newOwner The address to transfer ownership to.
     */
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }
}

/**
 * @title ERC20Interface
 * @notice Interface for ERC20 tokens.
 */
contract ERC20Interface {
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function transfer(address _to, uint _value) public returns (bool);
}

/**
 * @title KyberGenesisToken
 * @notice This contract is a simple token contract with minting and burning capabilities. It is designed to be owned by a minter who can mint new tokens and end the minting process.
 * @dev Inherits from Ownable, allowing for ownership management. The token has a fixed supply mechanism where each address can only hold one token.
 */
contract KyberGenesisToken is Ownable {
    string public constant name = "Kyber Genesis Token";
    string public constant symbol = "KGT";
    uint public constant decimals = 0;

    uint public totalSupply = 0;
    mapping(address => uint) public balanceOf;
    bool public mintingEnded = false;

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event EndMinting(uint timestamp);

    /**
     * @notice Initializes the contract and sets the minter as the owner.
     * @param minter The address of the minter who will own the contract.
     */
    function KyberGenesisToken(address minter) public {
        transferOwnership(minter);
    }

    /**
     * @notice Mints new tokens for the specified recipients.
     * @dev Only the owner (minter) can call this function. Each recipient can only receive one token.
     * @param recipients Array of addresses to receive the new tokens.
     */
    function mint(address[] recipients) public onlyOwner {
        require(!mintingEnded);

        for (uint i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            require(balanceOf[recipient] == 0); // Each address can hold only one token
            balanceOf[recipient] = 1;
            totalSupply += 1;

            emit Transfer(address(0), recipient, 1);
        }
    }

    /**
     * @notice Ends the minting process and transfers ownership to a dead address.
     * @dev Only the owner (minter) can call this function. After calling this function, no more tokens can be minted.
     */
    function endMinting() public onlyOwner {
        mintingEnded = true;
        emit EndMinting(now);
        transferOwnership(address(0)); // Transfer ownership to the zero address
    }

    /**
     * @notice Burns the token held by the sender.
     * @dev The sender must hold exactly one token to burn it.
     */
    function burn() public {
        require(balanceOf[msg.sender] == 1);

        balanceOf[msg.sender] = 0;
        totalSupply -= 1;

        emit Transfer(msg.sender, address(0), 1);
    }

    /**
     * @notice Drains ERC20 tokens from the contract to a predefined multisig address.
     * @dev This function can be called by anyone to drain any accidentally sent ERC20 tokens.
     * @param token The ERC20 token contract to drain.
     * @param amount The amount of tokens to drain.
     */
    function emergencyERC20Drain(ERC20Interface token, uint amount) public {
        address multisig = 0x1234567890123456789012345678901234567890; // Replace with actual multisig address
        require(token.transfer(multisig, amount));
    }

    // ERC20 stubs
    function transfer(address _to, uint _value) public returns (bool) {
        revert();
    }

    function transferFrom(address _from, address _to, uint _value) public returns (bool) {
        revert();
    }

    function approve(address _spender, uint _value) public returns (bool) {
        revert();
    }

    function allowance(address _owner, address _spender) public constant returns (uint) {
        return 0;
    }

    event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

### Explanation of Key Features:
1. **Minting (`mint`):** Allows the `owner` to mint tokens. Each recipient can only hold one token.
2. **End Minting (`endMinting`):** Disables minting permanently by transferring ownership to the zero address.
3. **Burning (`burn`):** Allows token holders to burn exactly one token.
4. **Emergency ERC20 Drain (`emergencyERC20Drain`):** Lets anyone rescue accidentally sent ERC20 tokens to a predefined multisig address.
5. **Non-standard ERC20 stubs:** Prevents regular token transfers by reverting all unsupported ERC20 functions like `transfer` and `approve`.

This contract complies with the requirements and the Solidity version (0.4.15). It avoids any extraneous features or dependencies.