```solidity
/**
 * @title KyberGenesisToken
 * @notice This contract is a simple token contract with minting and burning capabilities. It is designed to be owned by a minter who can mint new tokens and end the minting process.
 * @dev Inherits from Ownable, allowing for ownership management. The token has a fixed supply mechanism where each address can only hold one token.
 */
contract KyberGenesisToken is Ownable {
    string public constant name = "Kyber Genesis Token";
    string public constant symbol = "KGT";
    uint public constant decimals = 0;

    uint public totalSupply = 0;
    mapping(address => uint) public balanceOf;

    /**
     * @notice Initializes the contract and sets the minter as the owner.
     * @param minter The address of the minter who will own the contract.
     */
    function KyberGenesisToken(address minter) {
        transferOwnership(minter);
    }

    /**
     * @notice Event emitted when tokens are transferred.
     * @param _from The address from which the tokens are sent.
     * @param _to The address to which the tokens are sent.
     * @param _value The amount of tokens transferred.
     */
    event Transfer(address indexed _from, address indexed _to, uint _value);

    /**
     * @notice Event emitted when the minting process is ended.
     * @param timestamp The block timestamp when the minting was ended.
     */
    event EndMinting(uint timestamp);

    /**
     * @notice Mints new tokens for the specified recipients.
     * @dev Only the owner (minter) can call this function. Each recipient can only receive one token.
     * @param recipients Array of addresses to receive the new tokens.
     */
    function mint(address[] recipients) onlyOwner {
        for (uint i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            require(balanceOf[recipient] == 0, "Recipient already owns a token");
            balanceOf[recipient] = 1;
            totalSupply += 1;
            emit Transfer(address(0), recipient, 1);
        }
    }

    /**
     * @notice Ends the minting process and transfers ownership to a dead address.
     * @dev Only the owner (minter) can call this function. After calling this function, no more tokens can be minted.
     */
    function endMinting() onlyOwner {
        emit EndMinting(block.timestamp);
        transferOwnership(address(0));
    }

    /**
     * @notice Burns the token held by the sender.
     * @dev The sender must hold exactly one token to burn it.
     */
    function burn() {
        require(balanceOf[msg.sender] == 1, "Sender does not own a token to burn");
        balanceOf[msg.sender] = 0;
        totalSupply -= 1;
        emit Transfer(msg.sender, address(0), 1);
    }

    /**
     * @notice Drains ERC20 tokens from the contract to a predefined multisig address.
     * @dev This function can be called by anyone to drain any accidentally sent ERC20 tokens.
     * @param token The ERC20 token contract to drain.
     * @param amount The amount of tokens to drain.
     */
    function emergencyERC20Drain(ERC20Interface token, uint amount) {
        address multisig = owner; // Assume `owner` acts as the predefined multisig address
        require(token.transfer(multisig, amount), "ERC20 transfer failed");
    }

    // ERC20 stubs
    /**
     * @notice Transfers tokens from the sender to the specified address.
     * @dev This function reverts as it is not implemented in this contract.
     * @param _to The address to which the tokens are transferred.
     * @param _value The amount of tokens to transfer.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function transfer(address _to, uint _value) returns (bool) {
        revert("transfer not supported");
    }

    /**
     * @notice Transfers tokens from one address to another.
     * @dev This function reverts as it is not implemented in this contract.
     * @param _from The address from which the tokens are transferred.
     * @param _to The address to which the tokens are transferred.
     * @param _value The amount of tokens to transfer.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        revert("transferFrom not supported");
    }

    /**
     * @notice Approves an address to spend a certain amount of tokens on behalf of the sender.
     * @dev This function reverts as it is not implemented in this contract.
     * @param _spender The address that is being approved to spend the tokens.
     * @param _value The amount of tokens to approve.
     * @return A boolean value indicating whether the operation succeeded.
     */
    function approve(address _spender, uint _value) returns (bool) {
        revert("approve not supported");
    }

    /**
     * @notice Returns the amount of tokens that an owner allowed to a spender.
     * @dev This function always returns 0 as it is not implemented in this contract.
     * @param _owner The address of the token owner.
     * @param _spender The address of the spender.
     * @return The amount of tokens allowed to the spender.
     */
    function allowance(address _owner, address _spender) constant returns (uint) {
        return 0;
    }

    /**
     * @notice Event emitted when an approval is made.
     * @param _owner The address of the token owner.
     * @param _spender The address of the spender.
     * @param _value The amount of tokens approved.
     */
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```