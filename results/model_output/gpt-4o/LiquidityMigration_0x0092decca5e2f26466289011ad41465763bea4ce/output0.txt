Certainly! Here's the completed Solidity contract for `LiquidityMigration` based on the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

contract LiquidityMigration is Timelocked, StrategyTypes {
    using SafeERC20 for IERC20;

    address public generic;
    address public controller;
    IStrategyProxyFactory public factory;

    mapping(address => bool) public adapters;
    mapping(address => uint256) public stakedCount;
    mapping(address => mapping(address => uint256)) public staked;
    mapping(address => bool) private _tempIsUnderlying;

    event Staked(address adapter, address strategy, uint256 amount, address account);
    event Migrated(address adapter, address lp, address strategy, address account);
    event Created(address adapter, address lp, address strategy, address account);
    event Refunded(address lp, uint256 amount, address account);

    modifier onlyRegistered(address _adapter) {
        require(adapters[_adapter], "LiquidityMigration: not registered adapter");
        _;
    }

    modifier onlyWhitelisted(address _adapter, address _lp) {
        require(IAdapter(_adapter).isWhitelisted(_lp), "LiquidityMigration: not whitelisted LP");
        _;
    }

    constructor(
        address[] memory adapters_,
        address generic_,
        IStrategyProxyFactory factory_,
        address controller_,
        uint256 _unlock,
        uint256 _modify,
        address _owner
    )
        Timelocked(_unlock, _modify, _owner)
    {
        for (uint256 i = 0; i < adapters_.length; i++) {
            adapters[adapters_[i]] = true;
        }
        generic = generic_;
        factory = factory_;
        controller = controller_;
    }

    function stake(
        address _lp,
        uint256 _amount,
        address _adapter
    ) public {
        _stake(_lp, _amount, _adapter);
        emit Staked(_adapter, _lp, _amount, msg.sender);
    }

    function buyAndStake(
        address _lp,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    ) external payable {
        _buyAndStake(_lp, msg.value, _adapter, _exchange, _minAmountOut, _deadline);
        emit Staked(_adapter, _lp, msg.value, msg.sender);
    }

    function batchStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter
    ) external {
        require(_lp.length == _amount.length && _amount.length == _adapter.length, "LiquidityMigration: invalid lengths");
        for (uint256 i = 0; i < _lp.length; i++) {
            _stake(_lp[i], _amount[i], _adapter[i]);
        }
    }

    function batchBuyAndStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter,
        address[] memory _exchange,
        uint256[] memory _minAmountOut,
        uint256 _deadline
    ) external payable {
        require(
            _lp.length == _amount.length &&
            _amount.length == _adapter.length &&
            _adapter.length == _exchange.length &&
            _exchange.length == _minAmountOut.length,
            "LiquidityMigration: invalid lengths"
        );
        uint256 totalEth = msg.value;
        for (uint256 i = 0; i < _lp.length; i++) {
            _buyAndStake(_lp[i], _amount[i], _adapter[i], _exchange[i], _minAmountOut[i], _deadline);
            totalEth -= _amount[i];
        }
        require(totalEth == 0, "LiquidityMigration: excessive ETH");
    }

    function migrate(
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    ) external onlyUnlocked {
        _migrate(msg.sender, _lp, _adapter, _strategy, _slippage);
    }

    function migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    ) external onlyOwner onlyUnlocked {
        _migrate(_user, _lp, _adapter, _strategy, _slippage);
    }

    function batchMigrate(
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    ) external onlyUnlocked {
        require(_lp.length == _adapter.length && _adapter.length == _strategy.length && _strategy.length == _slippage.length, "LiquidityMigration: invalid lengths");
        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(msg.sender, _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function batchMigrate(
        address[] memory _user,
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    ) external onlyOwner onlyUnlocked {
        require(
            _user.length == _lp.length &&
            _lp.length == _adapter.length &&
            _adapter.length == _strategy.length &&
            _strategy.length == _slippage.length,
            "LiquidityMigration: invalid lengths"
        );
        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(_user[i], _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function refund(address _user, address _lp) public onlyOwner {
        _refund(_user, _lp);
    }

    function batchRefund(address[] memory _users, address _lp) public onlyOwner {
        for (uint256 i = 0; i < _users.length; i++) {
            _refund(_users[i], _lp);
        }
    }

    function hasStaked(address _account, address _lp) external view returns (bool) {
        return staked[_account][_lp] > 0;
    }

    function getStakeCount(address _adapter) external view returns (uint256) {
        return stakedCount[_adapter];
    }

    function _refund(address _user, address _lp) internal {
        uint256 amount = staked[_user][_lp];
        require(amount > 0, "LiquidityMigration: nothing to refund");
        staked[_user][_lp] = 0;
        IERC20(_lp).safeTransfer(_user, amount);
        emit Refunded(_lp, amount, _user);
    }

    function _migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    ) internal onlyRegistered(_adapter) onlyWhitelisted(_adapter, _lp) {
        uint256 amount = staked[_user][_lp];
        require(amount > 0, "LiquidityMigration: no staked tokens");
        IERC20(_lp).safeTransfer(generic, amount);
        IAdapter.Call[] memory calls = IAdapter(_adapter).encodeMigration(generic, address(_strategy), _lp, amount);
        IStrategyController(controller).deposit(_strategy, IStrategyRouter(generic), amount, _slippage, abi.encode(calls));
        staked[_user][_lp] = 0;
        emit Migrated(_adapter, _lp, address(_strategy), _user);
    }

    function _stake(address _lp, uint256 _amount, address _adapter) internal onlyRegistered(_adapter) onlyWhitelisted(_adapter, _lp) {
        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);
        staked[msg.sender][_lp] += _amount;
        stakedCount[_adapter]++;
    }

    function _buyAndStake(
        address _lp,
        uint256 _amount,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    ) internal {
        IAdapter(_adapter).buy{value: _amount}(_lp, _exchange, _minAmountOut, _deadline);
        uint256 balance = IERC20(_lp).balanceOf(address(this));
        require(balance > 0, "LiquidityMigration: failed to buy LP token");
        staked[msg.sender][_lp] += balance;
        stakedCount[_adapter]++;
    }
}
```

This contract strictly adheres to the provided description and context, implementing every mentioned feature and function. Let me know if you need further clarifications or adjustments!