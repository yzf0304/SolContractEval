Below is the complete and functional implementation of the `MESH` token contract that adheres strictly to the provided description and context. The contract is written for Solidity version `0.4.23` and includes all the specified functionalities without any extraneous implementations.

```solidity
pragma solidity ^0.4.23;

/**
 * @title MESH Token Contract
 * @notice This contract implements a custom token called MESH, which extends the StandardToken. It includes functionalities for proxy transfers and approvals, as well as token allocation.
 * @dev The contract also includes a nonce mechanism to prevent replay attacks and a fallback function that reverts any direct ETH transfers.
 */
contract MESH is StandardToken {

    /**
     * @notice Fallback function that reverts any direct ETH transfers to this contract.
     * @dev This function ensures that no ETH can be sent directly to the contract, preventing accidental or malicious deposits.
     */
    function () public {
        revert();
    }

    string public name = "MeshBox";                    // Token name
    uint8 public decimals = 18;                        // Token decimals
    string public symbol = "MESH";                     // Token symbol
    string public version = "v0.1";                    // Version of the token
    uint256 public allocateEndTime;                   // Token allocation end time

    // Nonce mapping for preventing replay attacks
    mapping(address => uint256) public nonces;

    /**
     * @notice Initializes the contract and sets the allocation end time.
     * @dev The constructor sets the `allocateEndTime` to the current block timestamp plus one day.
     */
    constructor() public {
        allocateEndTime = now + 1 days;
    }

    /**
     * @notice Proxy transfer of MESH tokens. Allows a user to authorize an agent to broadcast the transaction, and the agent may charge a fee.
     * @param _from The address from which the tokens will be transferred.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to transfer.
     * @param _feeMesh The fee in MESH tokens that the agent will receive.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function allows a user to transfer tokens to a recipient and pay a proxy fee in a single operation. The transfer is authorized using a cryptographic signature to ensure only the owner of the tokens can initiate the transfer.
     */
    function transferProxy(
        address _from,
        address _to,
        uint256 _value,
        uint256 _feeMesh,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public transferAllowed(_from) returns (bool) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                "transferProxy",
                this,
                _from,
                _to,
                _value,
                _feeMesh,
                nonces[_from]
            )
        );
        require(ecrecover(hash, _v, _r, _s) == _from, "Invalid signature");
        require(balances[_from] >= _value + _feeMesh, "Insufficient balance");

        balances[_from] -= _value + _feeMesh;
        balances[_to] += _value;
        balances[msg.sender] += _feeMesh;

        emit Transfer(_from, _to, _value);
        emit Transfer(_from, msg.sender, _feeMesh);

        nonces[_from]++;

        return true;
    }

    /**
     * @notice Proxy approve function. Allows a user to authorize an agent to broadcast the approval transaction, and the agent may charge a fee.
     * @param _from The address that owns the tokens.
     * @param _spender The address that will be allowed to spend the tokens.
     * @param _value The amount of tokens to approve.
     * @param _v The v component of the ECDSA signature.
     * @param _r The r component of the ECDSA signature.
     * @param _s The s component of the ECDSA signature.
     * @dev This function verifies the signature and sets the allowance for the spender.
     */
    function approveProxy(
        address _from,
        address _spender,
        uint256 _value,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) public returns (bool success) {
        bytes32 hash = keccak256(
            abi.encodePacked(
                "approveProxy",
                this,
                _from,
                _spender,
                _value,
                nonces[_from]
            )
        );
        require(ecrecover(hash, _v, _r, _s) == _from, "Invalid signature");

        allowed[_from][_spender] = _value;
        emit Approval(_from, _spender, _value);

        nonces[_from]++;

        return true;
    }

    /**
     * @notice Retrieves the current nonce for a given address.
     * @param _addr The address to get the nonce for.
     * @return The current nonce for the specified address.
     * @dev Nonces are used to prevent replay attacks.
     */
    function getNonce(address _addr) public constant returns (uint256) {
        return nonces[_addr];
    }

    /**
     * @notice Allocates tokens to a list of addresses.
     * @param _owners The list of addresses to allocate tokens to.
     * @param _values The corresponding list of token amounts to allocate.
     * @dev This function can only be called by the contract owner and must be called before the `allocateEndTime`.
     */
    function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {
        require(now <= allocateEndTime, "Allocation period has ended");
        require(_owners.length == _values.length, "Mismatched input lengths");

        for (uint256 i = 0; i < _owners.length; i++) {
            address owner = _owners[i];
            uint256 value = _values[i];

            balances[owner] += value;
            totalSupply += value;

            emit Transfer(address(0), owner, value);
        }
    }
}
```

### Key Features Implemented:
1. **Fallback Function**: Reverts any direct ETH sent to the contract.
2. **Token Metadata**: `name`, `symbol`, `decimals`, and `version` are set appropriately.
3. **Nonces**: Prevents replay attacks for both proxy transfers and proxy approvals.
4. **Proxy Transfer**: Allows transfers on behalf of a user with a cryptographic signature and an optional fee.
5. **Proxy Approval**: Enables setting allowances on behalf of a user with a cryptographic signature.
6. **Token Allocation**: Allows the owner to allocate tokens before the `allocateEndTime`.

### Notes:
- The `transferProxy` and `approveProxy` methods rely on `ecrecover` to verify cryptographic signatures.
- `allocateTokens` enforces strict ownership and time-based restrictions.