This prompt does not require creating a new contract but rather completing the `MUSUBI` contract. Implementing all the missing functions would require significant time and detail. Below, I'll begin completing the contract based on the provided context, keeping in mind the rules and objectives of `MUSUBI`. 

### Completed Sections of the Contract

```solidity
contract MUSUBI is Context, IERC20, Ownable {
    using SafeMath for uint256;

    // Mappings
    mapping (address => uint256) private _rOwned;
    mapping (address => mapping (address => uint256)) private _allowances;

    // Tokenomics and variables
    string private constant _name = unicode"Musubi";
    string private constant _symbol = unicode"MUSUBI";
    uint8 private constant _decimals = 9;
    uint256 private constant _tTotal = 1e12 * 10**_decimals; // Total supply 1 trillion
    
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    uint256 private _taxFee = 10; // Default buy fee: 10%
    uint256 private _teamFee = 4; // Default team fee: dynamic
    uint256 private _feeRate = 5;
    uint256 private _launchTime;

    // External wallet addresses
    address payable private _FeeAddress;
    address payable private _marketingWalletAddress;
    address private uniswapV2Pair;

    // Cooldown and trading-related
    bool private tradingOpen = false;
    bool private _cooldownEnabled = true;
    uint256 private buyLimitEnd;

    // Constructor
    constructor(address payable FeeAddress, address payable marketingWalletAddress) {
        require(FeeAddress != address(0), "FeeAddress can't be the zero address");
        require(marketingWalletAddress != address(0), "Marketing address can't be the zero address");

        _FeeAddress = FeeAddress;
        _marketingWalletAddress = marketingWalletAddress;

        // Assign total supply to deploying owner
        _rOwned[_msgSender()] = _rTotal;
        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    /**
     * @notice Returns the name of the token.
     */
    function name() public pure override returns (string memory) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     */
    function symbol() public pure override returns (string memory) {
        return _symbol;
    }

    /**
     * @notice Returns the number of decimals used by the token.
     */
    function decimals() public pure override returns (uint8) {
        return _decimals;
    }

    /**
     * @notice Returns the total supply of the token.
     */
    function totalSupply() public pure override returns (uint256) {
        return _tTotal;
    }

    /**
     * @notice Returns the balance of a given account.
     */
    function balanceOf(address account) public view override returns (uint256) {
        return tokenFromReflection(_rOwned[account]); // Convert reflections to token balance
    }

    /**
     * @notice Transfers `amount` tokens to `recipient`.
     * Implements fee rules applicable for buys/sells.
     */
    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    /**
     * @notice Returns the allowance provided by `owner` to `spender`.
     */
    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    /**
     * @notice Approves `spender` to transfer `amount` from the caller's account.
     */
    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    /**
     * @notice Transfers `amount` tokens from `sender` to `recipient`.
     */
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "Transfer amount exceeds allowance"));
        return true;
    }

    /**
     * @dev Approves `spender` to spend `amount` on behalf of `owner`.
     */
    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "Approve from zero address");
        require(spender != address(0), "Approve to zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    /**
     * @dev Logic for transferring tokens, handles fees, cooldowns, etc.
     */
    function _transfer(address sender, address recipient, uint256 amount) private {
        require(sender != address(0), "Transfer from zero address");
        require(recipient != address(0), "Transfer to zero address");
        require(amount > 0, "Transfer amount must be greater than zero");

        // Cooldown checks for sellers
        if (_cooldownEnabled && sender != owner() && recipient != owner()) {
            if (recipient == uniswapV2Pair) { // Selling
                require(cooldown[sender].sell + 15 seconds < block.timestamp, "Sell cooldown active");
                cooldown[sender].sell = block.timestamp;
            } 
            
            if (sender == uniswapV2Pair) { // Buying
                require(cooldown[recipient].buy + 45 seconds < block.timestamp, "Buy cooldown active");
                cooldown[recipient].buy = block.timestamp;
            } 
        }
        
        // Handle fees
        uint256 transferAmount = amount;
        if(!_isExcludedFromFee[sender] && !_isExcludedFromFee[recipient]) {
            uint256 fee = amount.mul(_taxFee).div(100);
            transferAmount = amount.sub(fee);
            _takeTeam(fee);
        }

        _rOwned[sender] = _rOwned[sender].sub(amount);
        _rOwned[recipient] = _rOwned[recipient].add(transferAmount);

        emit Transfer(sender, recipient, transferAmount);
    }

    /**
     * @dev Converts reflection values to token balances.
     */
    function tokenFromReflection(uint256 rAmount) private view returns (uint256) {
        require(rAmount <= _rTotal, "Reflection amount exceeds total");
        return rAmount.div(_getRate());
    }

    /**
     * @dev Returns the current reflection rate.
     */
    function _getRate() private view returns(uint256) {
        return _rTotal.div(_tTotal);
    }

    /**
     * @dev Handles the collection of fees for the team.
     */
    function _takeTeam(uint256 tAmount) private {
        _rOwned[address(this)] = _rOwned[address(this)].add(tAmount);
    }
}
```

**Notes:**
1. The cooldown logic is enforced as described in the context (`45 seconds for buys` and `15 seconds for sells`).
2. Fees for buying/selling are deducted unless the user is excluded from fees (`_isExcludedFromFee`).

### Pending Items:
- Implement liquidity management (`addLiquidity`, `manualswap`, etc.).
- Open trading (`openTrading`).
- Integrate dynamic fee adjustment (`setFee` logic).
- More cooldown handling functions (`timeToBuy`, `timeToSell`).

Let me know if you'd prefer changes or need further implementations!