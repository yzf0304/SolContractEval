Below is the implementation for the `HEXToken` contract based on the provided context and description. This implementation assumes standard ERC-20 behavior for transferring and approving tokens and manages a basic staking mechanism:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract HEXToken {
    string public name = "HEXToken";
    string public symbol = "HEX";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;
    mapping(address => Stake[]) private stakes;

    struct Stake {
        uint256 amount;
        uint256 startDay;
        uint256 duration;
    }

    // Event declarations
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event StakeStarted(address indexed staker, uint256 amount, uint256 duration);
    event StakeEnded(address indexed staker, uint256 amount, uint256 stakeIndex);

    constructor(uint256 _initialSupply) {
        totalSupply = _initialSupply;
        balances[msg.sender] = _initialSupply;
    }

    function currentDay() external view returns (uint256) {
        return block.timestamp / 1 days;
    }

    function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external {
        require(newStakedHearts > 0, "Stake amount must be greater than zero");
        require(newStakedDays > 0, "Stake duration must be greater than zero");
        require(balances[msg.sender] >= newStakedHearts, "Insufficient balance");

        balances[msg.sender] -= newStakedHearts;
        stakes[msg.sender].push(Stake(newStakedHearts, block.timestamp / 1 days, newStakedDays));
        
        emit StakeStarted(msg.sender, newStakedHearts, newStakedDays);
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transfer(address recipient, uint256 amount) public returns (bool) {
        require(recipient != address(0), "Transfer to the zero address");
        require(balances[msg.sender] >= amount, "Insufficient balance");

        balances[msg.sender] -= amount;
        balances[recipient] += amount;

        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) public {
        require(stakeIndex < stakes[msg.sender].length, "Invalid stake index");
        Stake storage userStake = stakes[msg.sender][stakeIndex];
        require(userStake.amount > 0, "Stake already ended");

        // Check if the stakeIdParam matches the conditions or represents stake correctly
        // In a realistic scenario, stakeId might be used for additional validation
        require(currentDay() >= userStake.startDay + userStake.duration, "Stake duration not yet completed");

        uint256 stakedAmount = userStake.amount;
        balances[msg.sender] += stakedAmount;
        delete stakes[msg.sender][stakeIndex];
        
        emit StakeEnded(msg.sender, stakedAmount, stakeIndex);
    }

    function stakeCount(address stakerAddr) external view returns (uint256) {
        return stakes[stakerAddr].length;
    }
}
```

### Explanation:
- **currentDay:** Returns the current day since the Unix epoch, divided by 1 day.
- **stakeStart:** Allows users to stake HEX tokens by specifying an amount and a duration. The staked amount is deducted from the user's balance.
- **approve:** Sets the allowance for a spender to transfer tokens on behalf of the owner.
- **transfer:** Standard ERC-20 transfer functionality that checks for sufficient balance and updates balances accordingly.
- **stakeEnd:** Ends a stake if the specified stake's duration is completed. Restores the staked amount back to the user's balance.
- **stakeCount:** Provides the number of active stakes an address has. 

This implementation focuses on a simple staking mechanism and basic token transfer functionality, aligned with the provided context and description.