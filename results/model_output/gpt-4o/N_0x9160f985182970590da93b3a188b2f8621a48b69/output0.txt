Below is the completed implementation of the `N` smart contract based on the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title N
 * @notice A simple ERC721 token contract that allows minting of a single token, with ownership transfer and URI setting functionalities.
 * @dev Implements IERC721, IERC721Metadata, and IERC165 interfaces.
 */
contract N {
    uint public tokenId;
    mapping(address => uint) public collectors; // Stores the balance of tokens for each collector
    address private _owner; // Contract owner
    address private _tokenOwner; // Token owner
    string private _uri; // Token URI

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
    }

    /**
     * @notice Checks if the contract implements the given interface.
     * @dev Supports IERC721, IERC721Metadata, and IERC165 interfaces.
     * @param interfaceId The interface identifier, as specified in ERC-165.
     * @return bool True if the contract implements the interface, false otherwise.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return (
            interfaceId == 0x80ac58cd || // IERC721
            interfaceId == 0x5b5e139f || // IERC721Metadata
            interfaceId == 0x01ffc9a7    // IERC165
        );
    }

    /**
     * @notice Returns the owner of the specified token ID.
     * @dev Throws if the token ID is invalid.
     * @param _tokenId The ID of the token to query the owner of.
     * @return address The owner of the token.
     */
    function ownerOf(uint256 _tokenId) public view virtual returns (address) {
        require(_tokenId == tokenId, "ERC721: invalid token ID");
        return _tokenOwner;
    }

    /**
     * @notice Returns the number of tokens in `owner`'s account.
     * @dev Since this contract only supports one token, the balance will always be either 0 or 1.
     * @param owner Address for whom to query the balance.
     * @return uint256 The number of tokens owned by `owner`.
     */
    function balanceOf(address owner) public view virtual returns (uint256) {
        return collectors[owner];
    }

    /**
     * @notice Mints a new token and assigns it to the caller.
     * @dev Only the contract owner can call this function initially. If a token already exists, it will be burned and re-minted.
     */
    function mint() external {
        require(msg.sender == _owner, "ERC721: unauthorized minting");

        if (_tokenOwner != address(0)) {
            // Burn existing token
            collectors[_tokenOwner] -= 1;
            emit Transfer(_tokenOwner, address(0), tokenId);
        }

        // Mint new token
        tokenId += 1; // Increment token ID
        _tokenOwner = msg.sender;
        collectors[_tokenOwner] += 1;
        emit Transfer(address(0), _tokenOwner, tokenId);
    }

    /**
     * @notice Returns a URI for a given token ID.
     * @dev The URI is constructed based on the token ID and the set URI.
     * @param _tokenId The ID of the token to generate a URI for.
     * @return string The URI of the token.
     */
    function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {
        require(_tokenId == tokenId, "ERC721: invalid token ID");

        return string(
            abi.encodePacked(
                "data:application/json;utf8,",
                '{"name":"N. #', toString(tokenId), '","created_by":"0xG","description":"","image":"',
                bytes(_uri).length > 0 ? _uri : 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJ5ZXMiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIHN0eWxlPSJ3aWR0aDogMTAwdmg7IGhlaWdodDogMTAwdmg7IG1heC13aWR0aDogMTAwJTsgbWF4LWhlaWdodDogMTAwJTsgbWFyZ2luOiBhdXRvIj4KICA8IS0tIE4uIOKAkyDCqSAweEcgLS0+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9IjB4R19iZyIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMTExIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSIweEdfbCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMDAwIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIHN0b3Atb3BhY2l0eT0iMCIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8ZmlsdGVyIGlkPSIweEdfbm9pc2UiPgogICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iNSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIgLz4KICAgICAgPGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIgLz4KICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICAgICAgPGZlRnVuY1IgdHlwZT0ibGluZWFyIiBzbG9wZT0iMC41IiAvPgogICAgICAgIDxmZUZ1bmNHIHR5cGU9ImxpbmVhciIgc2xvcGU9IjAuNSIgLz4KICAgICAgICA8ZmVGdW5jQiB0eXBlPSJsaW5lYXIiIHNsb3BlPSIwLjUiIC8+CiAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgICAgPGZlQmxlbmQgbW9kZT0ic2NyZWVuIiAvPgogICAgPC9maWx0ZXI+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSIxMDAwIiBoZWlnaHQ9IjEwMDAiIGZpbGw9InVybCgjMHhHX2JnKSIgLz4KICA8cmVjdCBoZWlnaHQ9IjUwMCIgd2lkdGg9IjUwMCIgeT0iMjUwIiB4PSIyNTAiIGZpbGw9InVybCgjMHhHX2wpIiAgLz4KICA8cmVjdCB3aWR0aD0iMTAwMCIgaGVpZ2h0PSIxMDAwIiBmaWx0ZXI9InVybCgjMHhHX25vaXNlKSIgb3BhY2l0eT0iMC4xIi8+Cjwvc3ZnPgo=',
                '"}'
            )
        );
    }

    /**
     * @notice Returns the name of the token.
     * @return string The name of the token.
     */
    function name() public view virtual returns (string memory) {
        return "N.";
    }

    /**
     * @notice Returns the symbol of the token.
     * @return string The symbol of the token.
     */
    function symbol() public view virtual returns (string memory) {
        return "N";
    }

    /**
     * @notice Returns the owner of the contract.
     * @return address The owner of the contract.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @notice Modifier to ensure that only the contract owner can call certain functions.
     */
    modifier onlyOwner {
        require(msg.sender == _owner, "Unauthorized");
        _;
    }

    /**
     * @notice Transfers the ownership of the contract to a new address.
     * @dev Only the current owner can call this function.
     * @param _new The new owner's address.
     */
    function transferOwnership(address _new) external virtual onlyOwner {
        require(_new != address(0), "Invalid address");
        emit OwnershipTransferred(_owner, _new);
        _owner = _new;
    }

    /**
     * @notice Sets the URI for the token.
     * @dev Only the contract owner can call this function.
     * @param _new The new URI.
     */
    function setUri(string calldata _new) external onlyOwner {
        _uri = _new;
    }

    /**
     * @notice Converts a uint256 to its ASCII string representation.
     * @dev This function is taken from "@openzeppelin/contracts/utils/Strings.sol".
     * @param value The value to convert.
     * @return string The ASCII string representation of the value.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
```

### Key Features:
1. **ERC721 Token:** Implements basic ERC721 functions for ownership, balance, and metadata.
2. **Single Token Minting:** Allows only one token to be minted or replaced by re-minting.
3. **Ownership:** Ownership of the token can be transferred.
4. **Custom URI:** Allows setting a custom token URI by the contract owner.
5. **Minimal Metadata Features:** Provides token `name`, `symbol`, and `tokenURI`.
