Here's the complete and functional implementation of the `N` contract strictly adhering to the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title N
 * @notice A simple ERC721 token contract that allows minting of a single token, with ownership transfer and URI setting functionalities.
 * @dev This contract is designed to be minimalistic and only supports the basic functionalities of an ERC721 token.
 */
contract N {
    uint public tokenId;
    mapping(address => uint) public collectors;
    address private _owner;
    address private _tokenOwner;
    string private _uri;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() {
        _owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == _owner, "Unauthorized");
        _;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return (
            interfaceId == 0x80ac58cd || // IERC721
            interfaceId == 0x5b5e139f || // IERC721Metadata
            interfaceId == 0x01ffc9a7    // IERC165
        );
    }

    function ownerOf(uint256 _tokenId) public view virtual returns (address) {
        require(_tokenId == tokenId && _tokenOwner != address(0), "ERC721: invalid token ID");
        return _tokenOwner;
    }

    function balanceOf(address owner) public view virtual returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return collectors[owner];
    }

    function mint() external {
        if (tokenId == 0) {
            tokenId = 1;
            _tokenOwner = msg.sender;
            collectors[msg.sender] = 1;
            emit Transfer(address(0), msg.sender, tokenId);
        } else {
            require(msg.sender == _tokenOwner, "Unauthorized: Only the current token owner can re-mint");
            _burn();
            _tokenOwner = msg.sender;
            collectors[msg.sender] = 1;
            emit Transfer(address(0), msg.sender, tokenId);
        }
    }

    function tokenURI(uint256 _tokenId) public view virtual returns (string memory) {
        require(_tokenId == tokenId, "ERC721: invalid token ID");

        return string(
            abi.encodePacked(
                "data:application/json;utf8,",
                '{"name":"N. #', toString(tokenId), '","created_by":"0xG","description":"","image":"',
                bytes(_uri).length > 0 ? _uri : 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJ5ZXMiPz4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAwIDEwMDAiIHN0eWxlPSJ3aWR0aDogMTAwdmg7IGhlaWdodDogMTAwdmg7IG1heC13aWR0aDogMTAwJTsgbWF4LWhlaWdodDogMTAwJTsgbWFyZ2luOiBhdXRvIj4KICA8IS0tIE4uIOKAkyDCqSAweEcgLS0+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9IjB4R19iZyIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMTExIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIC8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGxpbmVhckdyYWRpZW50IGlkPSIweEdfbCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIwJSIgeTI9IjEwMCUiPgogICAgICA8c3RvcCBvZmZzZXQ9IjAlIiBzdG9wLWNvbG9yPSIjMDAwIiAvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMDAiIHN0b3Atb3BhY2l0eT0iMCIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8ZmlsdGVyIGlkPSIweEdfbm9pc2UiPgogICAgICA8ZmVUdXJidWxlbmNlIHR5cGU9ImZyYWN0YWxOb2lzZSIgYmFzZUZyZXF1ZW5jeT0iNSIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIgLz4KICAgICAgPGZlQ29sb3JNYXRyaXggdHlwZT0ic2F0dXJhdGUiIHZhbHVlcz0iMCIgLz4KICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICAgICAgPGZlRnVuY1IgdHlwZT0ibGluZWFyIiBzbG9wZT0iMC41IiAvPgogICAgICAgIDxmZUZ1bmNH'));
    }

    function name() public view virtual returns (string memory) {
        return "N.";
    }

    function symbol() public view virtual returns (string memory) {
        return "N";
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    function transferOwnership(address _new) external virtual onlyOwner {
        require(_new != address(0), "New owner is the zero address");
        address previousOwner = _owner;
        _owner = _new;
        emit OwnershipTransferred(previousOwner, _new);
    }

    function setUri(string calldata _new) external onlyOwner {
        _uri = _new;
    }

    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function _burn() internal {
        require(_tokenOwner != address(0), "No token to burn");
        collectors[_tokenOwner] = 0;
        _tokenOwner = address(0);
    }
}
```