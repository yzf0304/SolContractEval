```solidity
pragma solidity ^0.4.20;

/**
 * @title Nicks
 * @notice A contract that allows users to set and unset unique nicknames. Each nickname is linked to a single Ethereum address.
 * @dev The contract ensures that each nickname is unique and can only be owned by one address at a time.
 */
contract Nicks {

    mapping (address => string) private nickOfOwner;
    mapping (string => address) private ownerOfNick;

    event Set(string indexed _nick, address indexed _owner);
    event Unset(string indexed _nick, address indexed _owner);

    /**
     * @notice Initializes the contract.
     * @dev The constructor does not perform any specific initialization in this contract.
     */
    function Nicks() public {
        // empty
    }

    /**
     * @notice Retrieves the nickname associated with a given address.
     * @param _owner The Ethereum address of the user.
     * @return _nick The nickname associated with the address.
     * @dev If the address has no nickname, an empty string will be returned.
     */
    function nickOf(address _owner) public view returns (string) {
        return nickOfOwner[_owner];
    }

    /**
     * @notice Retrieves the address associated with a given nickname.
     * @param _nick The nickname to look up.
     * @return _owner The Ethereum address associated with the nickname.
     * @dev If the nickname is not set, the zero address will be returned.
     */
    function ownerOf(string _nick) public view returns (address) {
        return ownerOfNick[_nick];
    }

    /**
     * @notice Sets a new nickname for the sender's address.
     * @param _nick The new nickname to set.
     * @dev The nickname must be more than 2 characters long and must not already be in use.
     *      If the sender already has a nickname, it will be unset before setting the new one.
     *      Emits a `Set` event on successful nickname assignment.
     */
    function set(string _nick) public {
        require(bytes(_nick).length > 2, "Nickname must be more than 2 characters long");
        require(ownerOfNick[_nick] == address(0), "Nickname is already in use");

        if (bytes(nickOfOwner[msg.sender]).length != 0) {
            // Unset the old nickname first
            unset();
        }

        nickOfOwner[msg.sender] = _nick;
        ownerOfNick[_nick] = msg.sender;

        emit Set(_nick, msg.sender);
    }

    /**
     * @notice Unsets the current nickname for the sender's address.
     * @dev The sender must have a nickname set to call this function.
     *      Emits an `Unset` event on successful unsetting of the nickname.
     */
    function unset() public {
        string storage currentNick = nickOfOwner[msg.sender];
        require(bytes(currentNick).length != 0, "No nickname set to unset");

        // Clear mappings
        delete ownerOfNick[currentNick];
        delete nickOfOwner[msg.sender];

        emit Unset(currentNick, msg.sender);
    }

    /**
     * @notice Fallback function to handle receiving Ether.
     * @dev This function is left empty as the contract does not handle Ether.
     */
    function() public payable {
        // empty
    }
}
```