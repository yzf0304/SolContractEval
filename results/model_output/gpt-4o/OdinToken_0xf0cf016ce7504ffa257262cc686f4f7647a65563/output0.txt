Hereâ€™s the completed `OdinToken` smart contract with the missing code implemented according to the provided description. Note that this is strictly designed for Solidity version `0.4.21`:

```solidity
pragma solidity ^0.4.21;

contract OdinToken is ERC20Interface, Owned {
    using SafeMath for uint256;

    string public symbol;
    string public name;
    uint8 public decimals;
    uint private _totalSupply;
    bool private _whitelistAll;

    struct balanceData {
        bool locked;
        uint balance;
        uint airDropQty;
    }

    mapping(address => balanceData) balances;
    mapping(address => mapping(address => uint)) allowed;

    function OdinToken() public {
        owner = msg.sender;
        symbol = "ODIN";
        name = "ODIN Token";
        decimals = 18;
        _whitelistAll = false;
        _totalSupply = 100000000000000000000000;
        balances[owner].balance = _totalSupply;

        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    function totalSupply() constant public returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner].balance;
    }

    function whitelistAddress(address to) onlyOwner public returns (bool) {
        require(to != address(0));
        balances[to].airDropQty = 0; // Whitelisting by setting airDropQty to zero
        return true;
    }

    function whitelistAllAddresses() onlyOwner public returns (bool) {
        _whitelistAll = true;
        return true;
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        require(to != address(0));
        require(to != msg.sender);
        require(tokens > 0);
        require(balances[msg.sender].balance >= tokens);

        if (msg.sender != owner && !_whitelistAll) {
            uint airDropQty = balances[msg.sender].airDropQty;
            if (airDropQty > 0) { // Air-dropped tokens have restrictions
                uint restrictedTokens = _restrictedTransferAmount(airDropQty);
                require(tokens <= balances[msg.sender].balance.sub(restrictedTokens));
            }
        }

        balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);

        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function _restrictedTransferAmount(uint airDropQty) internal view returns (uint restrictedTokens) {
        uint currentTime = now;

        if (currentTime < 1535760000) { // Before Sep 1, 2018
            restrictedTokens = airDropQty;
        } else if (currentTime < 1538352000) { // Sep 1 - Sep 30, 2018
            restrictedTokens = airDropQty.mul(9).div(10); // Max 10% transferable
        } else if (currentTime < 1546300800) { // Oct 1 - Dec 31, 2018
            restrictedTokens = airDropQty.mul(3).div(4); // Max 25% transferable
        } else if (currentTime < 1554076800) { // Jan 1 - Mar 31, 2019
            restrictedTokens = airDropQty.div(2); // Max 50% transferable
        } else if (currentTime < 1561939200) { // Apr 1 - Jun 30, 2019
            restrictedTokens = airDropQty.div(4); // Max 75% transferable
        } else { // After Jun 30, 2019
            restrictedTokens = 0; // No restrictions
        }
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        require(spender != address(0));
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        require(to != address(0));
        require(from != address(0));
        require(tokens > 0);
        require(balances[from].balance >= tokens);
        require(allowed[from][msg.sender] >= tokens);

        balances[from].balance = balances[from].balance.sub(tokens);
        balances[to].balance = balances[to].balance.add(tokens);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);

        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {
        require(spender != address(0));
        approve(spender, tokens);
        require(spender.call(data));
        return true;
    }

    function burn(uint256 tokens) onlyOwner public returns (bool) {
        require(tokens > 0);
        require(balances[owner].balance >= tokens);

        balances[owner].balance = balances[owner].balance.sub(tokens);
        _totalSupply = _totalSupply.sub(tokens);

        emit Burn(tokens);
        emit Transfer(owner, address(0), tokens);
        return true;
    }

    function () public {
        revert(); // Prevent accidental ether transfers
    }
}
```

### Explanation of Key Features:
1. **Airdrop Restrictions**:
   - Tokens distributed as airdrops are restricted in transfer based on the current time and percentage rules provided in the description.

2. **Whitelisting**:
   - Added methods for whitelisting individual addresses and enabling global whitelisting.

3. **Ownership**:
   - Owner has complete control to burn tokens, whitelist addresses, and whitelist all addresses.

4. **SafeMath**:
   - Arithmetic operations protect the contract against overflows/underflows.

5. **Fallback Function**:
   - Ensures the contract cannot receive ETH accidentally.

This contract strictly adheres to the specification and intended functionality for OdinToken. It is designed for Solidity version `0.4.21` and avoids introducing new contracts.