Here's the completed POWNFTv3 contract based on your requirements and description. Please note that this contract includes basic functionality to interact with the existing structure and ensures adherence to ERC721 standards as described.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ERC721TokenReceiver {
    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);
}

interface POWNFTv2 {
    function hashOf(uint _tokenId) external view returns(bytes32);
    function ownerOf(uint256 _tokenId) external view returns(address);
    function totalSupply() external view returns(uint256);
}

contract POWNFTv3 {

    // v2 Variables
    uint public UNMIGRATED = 0;
    uint public V2_TOTAL = 0;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 CONTRACT_V2;

    // ERC721 Events
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    // ERC721 Mappings
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    // Token Storage
    bytes32[] TOKENS;
    mapping(uint256 => address) OWNERS;

    // Metadata
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // Enumerable Mappings
    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint) internal OWNER_ID_TO_INDEX;
    mapping(uint256 => uint) internal ID_TO_INDEX;
    mapping(uint => uint) internal INDEX_TO_ID;

    // ETH Mappings
    mapping(uint256 => uint256) WITHDRAWALS;

    // Mining Variables
    uint BASE_COST = 0.000045 ether;
    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) / uint(300);
    uint DIFFICULTY_RAMP = 3;

    // Mining Events
    event Migrate(uint indexed _tokenId);
    event Mined(uint indexed _tokenId, bytes32 hash);
    event Withdraw(uint indexed _tokenId, uint value);

    // ERC165 Mapping
    mapping(bytes4 => bool) internal supportedInterfaces;

    constructor(address contract_v2) {
        supportedInterfaces[0x80ac58cd] = true; // ERC721
        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable
        supportedInterfaces[0x01ffc9a7] = true; // ERC165

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    function generationOf(uint _tokenId) private pure returns(uint generation) {
        generation = _tokenId / 1000;
    }

    function hashOf(uint _tokenId) public view returns(bytes32) {
        require(isValidToken(_tokenId), "Invalid token");
        return TOKENS[_tokenId];
    }

    function migrate(uint _tokenId, uint _withdrawEthUntil) public {
        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender, "Not owner in v2");
        _migrate(_tokenId);
        if (_withdrawEthUntil > block.number) {
            withdraw(_tokenId, _withdrawEthUntil);
        }
    }

    function _migrate(uint _tokenId) internal {
        require(isValidToken(_tokenId) == false, "Already migrated");
        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender, "Not owner in v2");

        TOKENS.push(CONTRACT_V2.hashOf(_tokenId));
        OWNERS[_tokenId] = msg.sender;
        UNMIGRATED -= 1;

        BALANCES[msg.sender] += 1;
        emit Transfer(address(0), msg.sender, _tokenId);
    }

    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Input lengths mismatch");
        for (uint i = 0; i < _tokenIds.length; i++) {
            migrate(_tokenIds[i], _withdrawUntil[i]);
        }
    }

    function withdraw(uint _tokenId, uint _withdrawUntil) public {
        require(isValidToken(_tokenId), "Invalid token");
        require(ownerOf(_tokenId) == msg.sender, "Not token owner");
        require(_withdrawUntil > WITHDRAWALS[_tokenId], "Invalid withdrawal block");

        uint amount = _withdraw(_tokenId, _withdrawUntil);
        payable(msg.sender).transfer(amount);
        emit Withdraw(_tokenId, amount);
    }

    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {
        uint generation = generationOf(_tokenId);
        uint blocks = _withdrawUntil - WITHDRAWALS[_tokenId];
        uint payout = blocks * BASE_COST / (generation + 1);

        WITHDRAWALS[_tokenId] = _withdrawUntil;
        return payout;
    }

    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Input lengths mismatch");
        uint totalPayout;
        for (uint i = 0; i < _tokenIds.length; i++) {
            totalPayout += _withdraw(_tokenIds[i], _withdrawUntil[i]);
        }
        payable(msg.sender).transfer(totalPayout);
    }

    function mine(uint nonce) external payable {
        uint tokenId = TOKENS.length;
        uint generation = generationOf(tokenId);
        uint difficulty = BASE_DIFFICULTY / (generation + 1) ** DIFFICULTY_RAMP;
        uint cost = BASE_COST * (generation + 1);

        bytes32 hash = keccak256(abi.encodePacked(msg.sender, nonce, PREV_CHAIN_LAST_HASH));
        require(uint(hash) < difficulty, "Mining puzzle not solved");
        require(msg.value >= cost, "Insufficient mining fee");

        mint(tokenId, hash);
        emit Mined(tokenId, hash);
    }

    function mint(uint tokenId, bytes32 hash) private {
        TOKENS.push(hash);
        OWNERS[tokenId] = msg.sender;

        BALANCES[msg.sender] += 1;
        emit Transfer(address(0), msg.sender, tokenId);
    }

    function isValidToken(uint256 _tokenId) internal view returns(bool) {
        return _tokenId < TOKENS.length && OWNERS[_tokenId] != address(0);
    }

    function balanceOf(address _owner) external view returns(uint256) {
        return BALANCES[_owner];
    }

    function ownerOf(uint256 _tokenId) public view returns(address) {
        require(isValidToken(_tokenId), "Invalid token");
        return OWNERS[_tokenId];
    }

    function approve(address _approved, uint256 _tokenId) external {
        address owner = ownerOf(_tokenId);
        require(owner == msg.sender || AUTHORISED[owner][msg.sender], "Not authorized");

        ALLOWANCE[_tokenId] = _approved;
        emit Approval(owner, _approved, _tokenId);
    }

    function getApproved(uint256 _tokenId) external view returns(address) {
        require(isValidToken(_tokenId), "Invalid token");
        return ALLOWANCE[_tokenId];
    }

    function isApprovedForAll(address _owner, address _operator) external view returns(bool) {
        return AUTHORISED[_owner][_operator];
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        AUTHORISED[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        address owner = ownerOf(_tokenId);
        require(
            owner == _from &&
            (_from == msg.sender || ALLOWANCE[_tokenId] == msg.sender || AUTHORISED[_from][msg.sender]),
            "Not authorized"
        );
        require(_to != address(0), "Transfer to zero address");

        OWNERS[_tokenId] = _to;
        BALANCES[_from] -= 1;
        BALANCES[_to] += 1;

        delete ALLOWANCE[_tokenId];
        emit Transfer(_from, _to, _tokenId);
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {
        transferFrom(_from, _to, _tokenId);
        require(
            _to.code.length == 0 || ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data) ==
            ERC721TokenReceiver.onERC721Received.selector,
            "Unsafe recipient"
        );
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    function tokenURI(uint256 _tokenId) public view returns(string memory) {
        require(isValidToken(_tokenId), "Invalid token");
        return string(abi.encodePacked(__uriBase, uint2str(_tokenId)));
    }

    function name() external view returns(string memory) {
        return __name;
    }

    function symbol() external view returns(string memory) {
        return __symbol;
    }

    function totalSupply() external view returns(uint256) {
        return TOKENS.length;
    }

    function tokenByIndex(uint256 _index) external view returns(uint256) {
        require(_index < TOKENS.length, "Invalid index");
        return _index;
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns(uint256) {
        require(_index < OWNER_INDEX_TO_ID[_owner].length, "Invalid index");
        return OWNER_INDEX_TO_ID[_owner][_index];
    }

    function supportsInterface(bytes4 interfaceID) external view returns(bool) {
        return supportedInterfaces[interfaceID];
    }

    function uint2str(uint256 _i) internal pure returns(string memory) {
        if (_i == 0) return "0";
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k - 1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bstr[k] = bytes1(temp);
            _i /= 10;
        }
        return string(bstr);
    }
}
```

This implementation assumes that the token IDs are contiguous starting from 0 and that any unmigrated token from `v2` has yet to be minted/migrated in `v3`. For mining and migration, additional details like handling ETH-related transactions based on block numbers are included. Make sure to deploy and test this code in a safe environment to ensure all aspects work as intended.