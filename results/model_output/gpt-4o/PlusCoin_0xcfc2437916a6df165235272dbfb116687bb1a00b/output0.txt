Here is the complete implementation of the `PlusCoin` contract based on the provided context and description:

```solidity
pragma solidity ^0.4.23;

/**
 * @title PlusCoin
 * @notice This contract implements the ERC-20 token standard and includes additional functionalities like ownership transfer and setting an allowed contract.
 */
contract PlusCoin {
    // State variables
    address public owner; // Token owner address
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) allowed;

    string public standard = "PlusCoin 2.0";
    string public constant name = "PlusCoin";
    string public constant symbol = "PLCN";
    uint public constant decimals = 18;
    uint public totalSupply;

    address public allowed_contract;

    //
    // Events
    //
    event Sent(address from, address to, uint amount);
    event Buy(address indexed sender, uint eth, uint fbt);
    event Withdraw(address indexed sender, address to, uint eth);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    //
    // Modifiers
    //

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyAllowedContract() {
        require(msg.sender == allowed_contract);
        _;
    }

    //
    // Constructor
    //
    constructor() public {
        owner = msg.sender;
        totalSupply = 28272323624 * 10**decimals; // 28272323624 tokens with 18 decimals
        balances[owner] = totalSupply; // Assign total supply to the owner
    }

    //
    // Functions
    //

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0)); // Ensure new owner address is not zero
        owner = newOwner;
    }

    function safeMul(uint a, uint b) internal pure returns (uint) {
        uint c = a * b;
        require(a == 0 || c / a == b); // Ensure no overflow
        return c;
    }

    function safeSub(uint a, uint b) internal pure returns (uint) {
        require(b <= a); // Ensure no underflow
        return a - b;
    }

    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a); // Ensure no overflow
        return c;
    }

    function setAllowedContract(address _contract_address) public onlyOwner returns (bool success) {
        require(_contract_address != address(0)); // Ensure the address is valid
        allowed_contract = _contract_address;
        return true;
    }

    function withdrawEther(address _to) public onlyOwner {
        require(_to != address(0)); // Ensure the recipient is valid
        _to.transfer(address(this).balance); // Transfer contract's Ether balance
        emit Withdraw(msg.sender, _to, address(this).balance);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_value > 0);
        require(balances[msg.sender] >= _value); // Ensure sender has enough balance

        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value > 0);
        require(balances[_from] >= _value); // Ensure sender has enough balance
        require(allowed[_from][msg.sender] >= _value); // Ensure allowance is sufficient

        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(_spender != address(0)); // Ensure the spender address is valid

        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
```

### Key Aspects:
1. **ERC-20 Compliance**: The contract adheres to the ERC-20 token standard, including `transfer`, `approve`, `transferFrom`, `balanceOf`, and `allowance` functions.
2. **Ownership Management**: Owners can transfer ownership using `transferOwnership` and set an allowed contract using `setAllowedContract`.
3. **Safe Arithmetic**: The `safeMul`, `safeSub`, and `safeAdd` functions prevent integer overflow and underflow for mathematical operations.
4. **Ether Withdrawal**: The `withdrawEther` function allows the owner to transfer the contract's Ether balance to a specified address.
5. **Events**: Emit relevant events like `Transfer` and `Approval` for better traceability on the blockchain.

This implementation respects the provided context while staying within the specified constraints.