Below is the complete and functional `PlusCoin` smart contract implemented according to the given context and description:

```solidity
pragma solidity ^0.4.23;

/**
 * @title PlusCoin
 * @notice This contract implements the ERC-20 token standard and includes additional functionalities like ownership transfer and setting an allowed contract.
 */
contract PlusCoin {
    address public owner; // Token owner address
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) allowed;

    string public standard = "PlusCoin 2.0";
    string public constant name = "PlusCoin";
    string public constant symbol = "PLCN";
    uint public constant decimals = 18;
    uint public totalSupply;

    address public allowed_contract;

    // Events
    event Sent(address from, address to, uint amount);
    event Buy(address indexed sender, uint eth, uint fbt);
    event Withdraw(address indexed sender, address to, uint eth);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    // Modifiers
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyAllowedContract() {
        require(msg.sender == allowed_contract);
        _;
    }

    // Constructor
    constructor() public {
        owner = msg.sender;
        totalSupply = 28272323624 * (10 ** uint(decimals));
        balances[owner] = totalSupply;
    }

    // Safely multiplies two numbers and checks for overflow.
    function safeMul(uint a, uint b) internal pure returns (uint) {
        uint c = a * b;
        require(a == 0 || c / a == b);
        return c;
    }

    // Safely subtracts one number from another and checks for underflow.
    function safeSub(uint a, uint b) internal pure returns (uint) {
        require(b <= a);
        return a - b;
    }

    // Safely adds two numbers and checks for overflow.
    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a);
        return c;
    }

    // Allows the current owner to transfer control of the contract to a new owner.
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        owner = newOwner;
    }

    // Sets the allowed contract address.
    function setAllowedContract(address _contract_address) public onlyOwner returns (bool success) {
        allowed_contract = _contract_address;
        return true;
    }

    // Transfers the contract's Ether balance to the specified address.
    function withdrawEther(address _to) public onlyOwner {
        require(_to != address(0));
        _to.transfer(address(this).balance);
        emit Withdraw(msg.sender, _to, address(this).balance);
    }

    // Transfers tokens from the caller's account to another account.
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    // Transfers tokens from one account to another, with approval.
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = safeSub(balances[_from], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);

        emit Transfer(_from, _to, _value);
        return true;
    }

    // Returns the balance of the specified address.
    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }

    // Approves the spender to spend a specified amount of tokens on behalf of the caller.
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    // Returns the remaining allowance of the spender for the owner.
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
```

This implementation follows the ERC-20 standard while adhering to the provided context and includes required functionalities such as ownership transfer, setting an allowed contract, and token operations (transfer, approve, allowance). Additionally, utility functions for safe mathematical operations (addition, subtraction, multiplication) have been implemented, as required.