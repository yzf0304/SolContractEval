Here's the complete implementation of the `Presale` contract based on the provided context and description:

```solidity
pragma solidity ^0.4.18;

/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,
 *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {

  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;

  /**
   * @notice Struct to store participant information.
   * @dev Contains whether the participant is authorized and their minimum tier.
   */
  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  /**************************************************************************
   * STORAGE / EVENTS
   *************************************************************************/

  SeeToken token;
  Discounts.Collection discounts;
  Limits.Window cap;
  mapping (address => Participant) participants;

  /**
   * @notice Emitted when a new tier is added.
   * @param discount The discount in basis points.
   * @param available The available supply at the tier.
   */
  event Tier(uint256 discount, uint256 available);

  /**************************************************************************
   * CONSTRUCTOR / LIFECYCLE
   *************************************************************************/

  function Presale(address _token)
    public
  {
    token = SeeToken(_token);
    paused = true;
  }

  /**
   * @notice Claims ownership of the token contract.
   * @dev This function should be called as part of the migration process.
   */
  function claimToken() public {
    token.claimOwnership();
  }

  /**
   * @notice Unpauses the contract, allowing purchases.
   * @dev Can only be called by the owner, and the contract must be paused, have a set rate, be capped, and own the token.
   */
  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  /**************************************************************************
   * ADMIN INTERFACE
   *************************************************************************/

  /**
   * @notice Sets the base purchase rate for the token.
   * @param _purchaseRate The number of tokens granted per wei.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    discounts.baseRate = _purchaseRate;
  }

  /**
   * @notice Specifies purchasing limits for a single account.
   * @param _amount The limit of tokens that a participant may purchase.
   * @param _duration The duration in blocks over which the limit applies.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    cap.amount = _amount;
    cap.duration = _duration;
  }

  /**
   * @notice Adds a new tier with a given discount and available supply.
   * @param _discount The discount in basis points.
   * @param _available The available supply at the tier.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    require(_discount <= Discounts.MAX_DISCOUNT);
    discounts.addTier(_discount, _available);
    Tier(_discount, _available);
  }

  /**
   * @notice Authorizes a group of participants for a specific tier.
   * @param _minimumTier The minimum tier for the list of participants.
   * @param _authorized An array of addresses to be authorized.
   * @dev Can only be called by the owner.
   */
  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    require(_minimumTier < discounts.tiers.length);
    for (uint256 i = 0; i < _authorized.length; i++) {
      participants[_authorized[i]] = Participant({
        authorized: true,
        minimumTier: _minimumTier
      });
    }
  }

  /**
   * @notice Withdraws the balance from the presale contract.
   * @dev Can only be called by the owner.
   */
  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(address(this).balance);
  }

  /**************************************************************************
   * PURCHASE INTERFACE
   *************************************************************************/

  /**
   * @notice Fallback function that forwards to `purchaseTokens()`.
   * @dev Accepts Ether and calls `purchaseTokens()`.
   */
  function ()
    public
    payable
  {
    purchaseTokens();
  }

  /**
   * @notice Public purchase interface for authorized participants.
   * @dev Purchases tokens starting from the authorized minimum tier.
   * Can only be called by an authorized participant and while the contract is not paused.
   */
  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    require(msg.value > 0);

    uint256 minTier = participants[msg.sender].minimumTier;
    uint256 purchased;
    uint256 remaining;

    (purchased, remaining) = discounts.purchaseTokens(
      msg.value,
      msg.sender,
      minTier
    );

    require(purchased > 0);

    // Record the purchase limit for this participant.
    cap.recordPurchase(msg.sender, purchased);

    // Issue the purchased tokens.
    token.issue(msg.sender, purchased);

    // Refund remaining funds if any.
    if (remaining > 0) {
      msg.sender.transfer(remaining);
    }
  }

  /**************************************************************************
   * PRICING / AVAILABILITY - VIEW INTERFACE
   *************************************************************************/

  /**
   * @notice Gets the terms for the purchasing limit window.
   * @return _amount The number of tokens allowed.
   * @return _duration The duration in blocks.
   */
  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    return (cap.amount, cap.duration);
  }

  /**
   * @notice Gets the tiers currently set up, with discounts and available supplies.
   * @return An array of tuples (discount, available).
   */
  function getTiers()
    public
    view
    returns (uint256[2][])
  {
    uint256[2][] memory tierData = new uint256[2][](discounts.tiers.length);
    for (uint256 i = 0; i < discounts.tiers.length; i++) {
      tierData[i][0] = discounts.tiers[i].discount;
      tierData[i][1] = discounts.tiers[i].available;
    }
    return tierData;
  }

  /**
   * @notice Gets the available supply for each tier for a given participant.
   * @param _participant The address of the participant.
   * @return An array of available supplies by tier index, zeroes for non-authorized participants.
   */
  function getAvailability(address _participant)
    public
    view
    returns (uint256[])
  {
    Participant storage participant = participants[_participant];
    if (!participant.authorized) {
      return new uint256[](discounts.tiers.length);
    }

    uint256[] memory availability = new uint256[](discounts.tiers.length);
    for (uint256 i = participant.minimumTier; i < discounts.tiers.length; i++) {
      availability[i] = discounts.tiers[i].available;
    }
    return availability;
  }

  /**************************************************************************
   * MODIFIERS
   *************************************************************************/

  /**
   * @dev Requires the participant to be whitelist-authorized.
   */
  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  /**
   * @dev Ensures the base rate is set (not zero).
   */
  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  /**
   * @dev Ensures the contract is capped (cap amount is not zero).
   */
  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  /**
   * @dev Ensures the contract owns the token.
   */
  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}
```

This implementation strictly adheres to the provided description and context, using the required libraries and managing the presale process efficiently. It provides administrative, participant purchase, and view functions, along with necessary modifiers to enforce conditions.