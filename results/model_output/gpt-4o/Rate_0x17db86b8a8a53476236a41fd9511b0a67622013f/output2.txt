The provided `RBInformationStore` contract is incomplete, as the functions do not have their logic implemented. Below is the complete implementation of the contract, ensuring all specified features are included and fully functional, strictly adhering to the provided context and using Solidity 0.4.18:

```solidity
pragma solidity ^0.4.18;

contract Ownable {
    address public owner;

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert();
        }
        _;
    }
}

contract RBInformationStore is Ownable {
    address public profitContainerAddress;
    address public companyWalletAddress;
    uint public etherRatioForOwner;
    address public multiSigAddress;
    address public accountAddressForSponsee;
    bool public isPayableEnabledForAll;

    modifier onlyMultiSig() {
        require(multiSigAddress == msg.sender);
        _;
    }

    function RBInformationStore(
        address _profitContainerAddress,
        address _companyWalletAddress,
        uint _etherRatioForOwner,
        address _multiSigAddress,
        address _accountAddressForSponsee
    ) public {
        profitContainerAddress = _profitContainerAddress;
        companyWalletAddress = _companyWalletAddress;
        etherRatioForOwner = _etherRatioForOwner;
        multiSigAddress = _multiSigAddress;
        accountAddressForSponsee = _accountAddressForSponsee;
        isPayableEnabledForAll = false; // Default state: not payable by all
    }

    function changeProfitContainerAddress(address _address) public onlyMultiSig {
        require(_address != address(0)); // Ensure valid address
        profitContainerAddress = _address;
    }

    function changeCompanyWalletAddress(address _address) public onlyMultiSig {
        require(_address != address(0)); // Ensure valid address
        companyWalletAddress = _address;
    }

    function changeEtherRatioForOwner(uint _value) public onlyMultiSig {
        etherRatioForOwner = _value;
    }

    function changeMultiSigAddress(address _address) public onlyMultiSig {
        require(_address != address(0)); // Ensure valid address
        multiSigAddress = _address;
    }

    function changeOwner(address _address) public onlyMultiSig {
        require(_address != address(0)); // Ensure valid address
        owner = _address;
    }

    function changeAccountAddressForSponsee(address _address) public onlyMultiSig {
        require(_address != address(0)); // Ensure valid address
        accountAddressForSponsee = _address;
    }

    function changeIsPayableEnabledForAll() public onlyMultiSig {
        isPayableEnabledForAll = !isPayableEnabledForAll; // Toggle boolean value
    }

    function() public payable {
        require(isPayableEnabledForAll); // Only accept Ether if payable by all is enabled
    }
}
```

### Key Features:
1. **Function Implementations**:
   - Functions that change addresses or other properties include validation to ensure the provided values are valid (e.g., non-zero addresses).
   - Changes to addresses or values are only allowed if the caller is the `multiSigAddress`.

2. **Payable Toggle**:
   - The `isPayableEnabledForAll` boolean determines whether the contract can accept Ether through its fallback function.

3. **Fallback Function**:
   - The fallback function enforces the `isPayableEnabledForAll` restriction, ensuring Ether can only be sent to the contract when this feature is enabled.

4. **Default Initialization**:
   - On deployment, `isPayableEnabledForAll` is set to `false` to ensure Ether cannot be sent inadvertently.

5. **Solidity Version Compatibility**:
   - The contract is compatible with Solidity version `0.4.18`, as required.

### Security Considerations:
- Functions restrict access to sensitive operations using the `onlyMultiSig` modifier, ensuring only the multi-signature wallet has control.
- Address validations are included to prevent setting invalid addresses (e.g., `0x0`).
- Ether ratio updates do not include restrictions on the range, allowing flexibility for the owner to decide on valid values. Ensure this is acceptable for the use case.

This implementation delivers a functional and complete `RBInformationStore` contract strictly adhering to the requirements and context provided.