Below is the implementation of the `Revolution` contract following the provided specifications and constraints. The implementation strictly adheres to the provided context and descriptions.

```solidity
pragma solidity 0.4.24;

contract Revolution is Accessibility, PaymentSystem {
    using Percent for Percent.percent;
    using SafeMath for uint;
    using Zero for *;
    using ToAddress for *;

    InvestorsStorage private m_investors;
    mapping(address => bool) private m_referrals;
    bool private m_nextWave;

    address public adminAddr;
    address public payerAddr;
    uint public waveStartup;
    uint public investmentsNum;
    uint public constant minInvesment = 10 finney; // 0.01 ETH
    uint public constant maxBalance = 333e5 ether; // 33,300,000 ETH
    uint public constant pauseOnNextWave = 168 hours;

    Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 3.33%
    Percent.percent private m_adminPercent = Percent.percent(1, 10); // 10%
    Percent.percent private m_payerPercent = Percent.percent(7, 100); // 7%
    Percent.percent private m_refPercent = Percent.percent(3, 100); // 3%

    event LogNewInvestor(address indexed addr, uint when, uint value);
    event LogNewInvesment(address indexed addr, uint when, uint value);
    event LogNewReferral(address indexed addr, uint when, uint value);
    event LogPayDividends(address indexed addr, uint when, uint value);
    event LogPayReferrerBonus(address indexed addr, uint when, uint value);
    event LogBalanceChanged(uint when, uint balance);
    event LogAdminAddrChanged(address indexed addr, uint when);
    event LogPayerAddrChanged(address indexed addr, uint when);
    event LogNextWave(uint when);

    modifier balanceChanged {
        _;
        emit LogBalanceChanged(now, address(this).balance);
    }

    modifier notOnPause() {
        require(waveStartup + pauseOnNextWave <= now, "pause on next wave not expired");
        _;
    }

    constructor() public {
        adminAddr = msg.sender;
        emit LogAdminAddrChanged(msg.sender, now);

        payerAddr = msg.sender;
        emit LogPayerAddrChanged(msg.sender, now);

        nextWave();
        waveStartup = waveStartup.sub(pauseOnNextWave);
    }

    function() public payable {
        if (msg.value == 0) {
            getMyDividends();
            return;
        }

        address a = msg.data.toAddr();
        address[3] memory refs;
        if (a.notZero()) {
            refs[0] = a;
            doInvest(refs); 
        } else {
            doInvest(refs);
        }
    }

    function investorsNumber() public view returns(uint) {
        return m_investors.size() - 1;
    }

    function balanceETH() public view returns(uint) {
        return address(this).balance;
    }

    function payerPercent() public view returns(uint numerator, uint denominator) {
        return (m_payerPercent.num, m_payerPercent.den);
    }

    function dividendsPercent() public view returns(uint numerator, uint denominator) {
        return (m_dividendsPercent.num, m_dividendsPercent.den);
    }

    function adminPercent() public view returns(uint numerator, uint denominator) {
        return (m_adminPercent.num, m_adminPercent.den);
    }

    function referrerPercent() public view returns(uint numerator, uint denominator) {
        return (m_refPercent.num, m_refPercent.den);
    }

    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {
        (uint keyIndex, uint invValue, uint invPaymentTime, uint invRefBonus) = m_investors.investorFullInfo(addr);
        value = invValue;
        paymentTime = invPaymentTime;
        refBonus = invRefBonus;
        isReferral = m_referrals[addr];
    }

    function latestPayout() public view returns(uint timestamp) {
        return m_paysys.latestTime;
    }

    function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {
        require(m_investors.contains(msg.sender), "investor not found");
        InvestorsStorage.investor memory inv = getMemInvestor(msg.sender);

        if (inv.value == 0 || address(this).balance == 0) {
            return;
        }

        uint256 payment = m_dividendsPercent.mul(inv.value).mul(now.sub(inv.paymentTime)) / 1 days;
        if (payment > address(this).balance) {
            nextWave();
            return;
        }

        m_investors.setPaymentTime(msg.sender, now);
        sendDividendsWithRefBonus(msg.sender, payment, inv.refBonus);
    }

    function doInvest(address[3] refs) public payable notOnPause balanceChanged {
        require(msg.value >= minInvesment, "investment below minimum");
        require(address(this).balance <= maxBalance, "contract balance exceeded");

        bool senderIsInvestor = m_investors.contains(msg.sender);
        if (!senderIsInvestor) {
            require(m_investors.insert(msg.sender, msg.value), "failed to add new investor");
            emit LogNewInvestor(msg.sender, now, msg.value);
        } else {
            require(m_investors.addValue(msg.sender, msg.value), "failed to add value to investor");
        }

        emit LogNewInvesment(msg.sender, now, msg.value);
        investmentsNum++;

        if (!senderIsInvestor) {
            uint refValue = m_refPercent.mul(msg.value);
            for (uint i = 0; i < refs.length; i++) {
                if (refs[i].notZeroNotSender(msg.sender) && !m_referrals[refs[i]]) {
                    m_referrals[refs[i]] = true;
                    require(m_investors.addRefBonus(refs[i], refValue), "failed to add ref bonus");
                    emit LogNewReferral(refs[i], now, refValue);
                    refValue = refValue / 2;
                } else {
                    break;
                }
            }
        }

        uint adminFee = m_adminPercent.mul(msg.value);
        adminAddr.transfer(adminFee);
        uint payerFee = m_payerPercent.mul(msg.value);
        payerAddr.transfer(payerFee);
    }

    function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {
        uint i = m_paysys.latestKeyIndex;
        uint time = m_paysys.latestTime;

        while (i < m_investors.size() && gasleft() > 50000) {
            address investorAddr = m_investors.keyFromIndex(i);
            InvestorsStorage.investor memory inv = getMemInvestor(investorAddr);

            if (inv.value > 0) {
                uint payment = m_dividendsPercent.mul(inv.value).mul(now.sub(time)) / 1 days;
                sendDividendsWithRefBonus(investorAddr, payment, inv.refBonus);
            }
            i++;
        }

        m_paysys.latestKeyIndex = i;
        if (i == m_investors.size()) {
            changePaymode(Paymode.Pull);
        }
    }

    function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {
        adminAddr = addr;
        emit LogAdminAddrChanged(addr, now);
    }

    function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {
        payerAddr = addr;
        emit LogPayerAddrChanged(addr, now);
    }

    function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {
        changePaymode(Paymode.Pull);
    }

    function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {
        (uint keyIndex, uint value, uint paymentTime, uint refBonus) = m_investors.investorFullInfo(addr);
        return InvestorsStorage.investor(keyIndex, value, paymentTime, refBonus);
    }

    function notZeroNotSender(address addr) internal view returns(bool) {
        return addr.notZero() && addr != msg.sender;
    }

    function sendDividends(address addr, uint value) private {
        if (value > 0) {
            addr.transfer(value);
            emit LogPayDividends(addr, now, value);
        }
    }

    function sendDividendsWithRefBonus(address addr, uint value, uint refBonus) private {
        if (refBonus > 0) {
            require(m_investors.setRefBonus(addr, 0), "failed to reset ref bonus");
        }
        sendDividends(addr, value.add(refBonus));
    }

    function nextWave() private {
        waveStartup = now;
        investmentsNum = 0;
        m_paysys.latestTime = 0;
        m_paysys.latestKeyIndex = 0;
        changePaymode(Paymode.Push);
        m_nextWave = true;
        emit LogNextWave(now);
    }
}
```

This implementation adheres to the requirements and constraints. Each feature is properly implemented, and the contract handles all operations related to investments, dividends, and referrals.