Here is the completed `Revolution` contract:

```solidity
pragma solidity ^0.4.24;

/**
 * @notice This contract implements a system for managing investments, dividends, and referrals.
 * It supports both pull and push payment modes for distributing dividends and handles investment
 * cycles (waves) with a pause period between them. The contract also includes a referral system
 * that rewards up to three levels of referrals.
 * @dev Inherits from `Accessibility` and `PaymentSystem` to manage access control and payment modes.
 */
contract Revolution is Accessibility, PaymentSystem {
    using Percent for Percent.percent;
    using SafeMath for uint;
    using Zero for *;
    using ToAddress for *;

    // investors storage - iterable map;
    InvestorsStorage private m_investors;
    mapping(address => bool) private m_referrals;
    bool private m_nextWave;

    address public adminAddr;
    address public payerAddr;
    uint public waveStartup;
    uint public investmentsNum;
    uint public constant minInvesment = 10 finney; // 0.01 eth
    uint public constant maxBalance = 333e5 ether; // 33,300,000 eth
    uint public constant pauseOnNextWave = 168 hours;

    // percents
    Percent.percent private m_dividendsPercent = Percent.percent(333, 10000); // 3.33%
    Percent.percent private m_adminPercent = Percent.percent(1, 10);         // 10%
    Percent.percent private m_payerPercent = Percent.percent(7, 100);        // 7%
    Percent.percent private m_refPercent = Percent.percent(3, 100);          // 3%

    event LogNewInvestor(address indexed addr, uint when, uint value);
    event LogNewInvesment(address indexed addr, uint when, uint value);
    event LogNewReferral(address indexed addr, uint when, uint value);
    event LogPayDividends(address indexed addr, uint when, uint value);
    event LogPayReferrerBonus(address indexed addr, uint when, uint value);
    event LogBalanceChanged(uint when, uint balance);
    event LogAdminAddrChanged(address indexed addr, uint when);
    event LogPayerAddrChanged(address indexed addr, uint when);
    event LogNextWave(uint when);

    modifier balanceChanged {
        _;
        emit LogBalanceChanged(now, address(this).balance);
    }

    modifier notOnPause() {
        require(waveStartup + pauseOnNextWave <= now, "pause on next wave not expired");
        _;
    }

    constructor() public {
        adminAddr = msg.sender;
        emit LogAdminAddrChanged(msg.sender, now);

        payerAddr = msg.sender;
        emit LogPayerAddrChanged(msg.sender, now);

        nextWave();
        waveStartup = waveStartup.sub(pauseOnNextWave);
    }

    function() public payable {
        if (msg.value == 0) {
            getMyDividends();
            return;
        }

        address a = msg.data.toAddr();
        address[3] memory refs;
        if (a.notZero()) {
            refs[0] = a;
            doInvest(refs); 
        } else {
            doInvest(refs);
        }
    }

    function investorsNumber() public view returns(uint) {
        return m_investors.size() - 1;
    }

    function balanceETH() public view returns(uint) {
        return address(this).balance;
    }

    function payerPercent() public view returns(uint numerator, uint denominator) {
        return (m_payerPercent.num, m_payerPercent.den);
    }

    function dividendsPercent() public view returns(uint numerator, uint denominator) {
        return (m_dividendsPercent.num, m_dividendsPercent.den);
    }

    function adminPercent() public view returns(uint numerator, uint denominator) {
        return (m_adminPercent.num, m_adminPercent.den);
    }

    function referrerPercent() public view returns(uint numerator, uint denominator) {
        return (m_refPercent.num, m_refPercent.den);
    }

    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refBonus, bool isReferral) {
        InvestorsStorage.investor memory inv = getMemInvestor(addr);
        value = inv.value;
        paymentTime = inv.paymentTime;
        refBonus = inv.refBonus;
        isReferral = m_referrals[addr];
    }

    function latestPayout() public view returns(uint timestamp) {
        timestamp = m_paysys.latestTime;
    }

    function getMyDividends() public notOnPause atPaymode(Paymode.Pull) balanceChanged {
        InvestorsStorage.investor memory inv = getMemInvestor(msg.sender);
        require(inv.paymentTime > 0, "paymentTime is zero");

        uint timePassed = now.sub(inv.paymentTime);
        require(timePassed > 0, "timePassed is zero");

        uint dividends = m_dividendsPercent.mul(inv.value).mul(timePassed).div(1 days);
        uint totalPayment = dividends.add(inv.refBonus);

        require(address(this).balance >= totalPayment, "insufficient balance");

        inv.refBonus = 0;
        inv.paymentTime = now;

        m_investors.setRefBonus(msg.sender, inv.refBonus);
        m_investors.setPaymentTime(msg.sender, inv.paymentTime);

        sendDividendsWithRefBonus(msg.sender, dividends, inv.refBonus);
    }

    function doInvest(address[3] refs) public payable notOnPause balanceChanged {
        require(msg.value >= minInvesment, "value must be >= minInvesment");
        require(address(this).balance <= maxBalance, "contract balance overflow");

        bool senderIsInvestor = m_investors.contains(msg.sender);

        if (!senderIsInvestor) {
            m_investors.insert(msg.sender, msg.value);
            emit LogNewInvestor(msg.sender, now, msg.value);
        } else {
            m_investors.addValue(msg.sender, msg.value);
        }

        investmentsNum++;

        uint refBonus = m_refPercent.mul(msg.value);
        for (uint i = 0; i < refs.length; i++) {
            if (notZeroNotSender(refs[i])) {
                m_investors.addRefBonus(refs[i], refBonus);
                emit LogNewReferral(refs[i], now, refBonus);
            }
        }

        uint adminShare = m_adminPercent.mul(msg.value);
        uint payerShare = m_payerPercent.mul(msg.value);
        adminAddr.transfer(adminShare);
        payerAddr.transfer(payerShare);

        emit LogNewInvesment(msg.sender, now, msg.value);
    }

    function payout() public notOnPause onlyAdmin(AccessRank.Payout) atPaymode(Paymode.Push) balanceChanged {
        require(m_paysys.latestTime.add(12 hours) < now, "latest payout timestamp is too recent");

        uint i = m_paysys.latestKeyIndex;
        uint size = m_investors.size();
        uint gasLeft = gasleft();

        for (; i < size; i++) {
            address addr = m_investors.keyFromIndex(i);
            InvestorsStorage.investor memory inv = getMemInvestor(addr);
            uint timePassed = now.sub(inv.paymentTime);
            uint dividends = m_dividendsPercent.mul(inv.value).mul(timePassed).div(1 days);

            if (gasLeft < 50000 || address(this).balance < dividends) {
                break;
            }

            inv.paymentTime = now;
            m_investors.setPaymentTime(addr, inv.paymentTime);

            sendDividends(addr, dividends);
            gasLeft = gasleft();
        }

        m_paysys.latestKeyIndex = i;
        m_paysys.latestTime = now;

        if (i >= size) {
            nextWave();
        }
    }

    function setAdminAddr(address addr) public onlyAdmin(AccessRank.Full) {
        adminAddr = addr;
        emit LogAdminAddrChanged(addr, now);
    }

    function setPayerAddr(address addr) public onlyAdmin(AccessRank.Full) {
        payerAddr = addr;
        emit LogPayerAddrChanged(addr, now);
    }

    function setPullPaymode() public onlyAdmin(AccessRank.Paymode) atPaymode(Paymode.Push) {
        changePaymode(Paymode.Pull);
    }

    function getMemInvestor(address addr) internal view returns(InvestorsStorage.investor) {
        return m_investors.data[addr];
    }

    function notZeroNotSender(address addr) internal view returns(bool) {
        return addr.notZero() && addr != msg.sender;
    }

    function sendDividends(address addr, uint value) private {
        addr.transfer(value);
        emit LogPayDividends(addr, now, value);
    }

    function sendDividendsWithRefBonus(address addr, uint value, uint refBonus) private {
        uint total = value.add(refBonus);
        addr.transfer(total);
        emit LogPayDividends(addr, now, value);
        emit LogPayReferrerBonus(addr, now, refBonus);
    }

    function nextWave() private {
        waveStartup = now;
        investmentsNum = 0;
        delete m_investors;

        changePaymode(Paymode.Push);
        emit LogNextWave(now);
    }
}
```

This implementation is aligned with the requirements specified in the context and adheres strictly to the description provided.