Below is the complete implementation of the `SaudiPotatoz` smart contract as per the requirements:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

// ERC721A Implementation from the provided context
contract SaudiPotatoz is ERC721A, Ownable, ReentrancyGuard {
    using Strings for uint256;
    using Address for address;

    string public baseURI;
    uint public price = 0 ether;
    uint public maxPerTx = 1;
    uint public maxPerWallet = 1;
    uint public totalFree = 0;
    uint public maxSupply = 5000;
    uint public nextOwnerToExplicitlySet;
    bool public mintEnabled;

    mapping(address => uint256) public freeMintedCount;
    mapping(address => uint256) public paidMintedCount;

    constructor() ERC721A("SaudiPotatoz", "SaudiPotatoz") {}

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function freeMint(uint256 amt) external callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(totalSupply() + amt <= totalFree, "Exceeds free mint supply");
        require(freeMintedCount[msg.sender] + amt <= maxPerWallet, "Exceeds free mint limit per wallet");
        require(amt > 0 && amt <= maxPerTx, "Invalid mint amount");

        freeMintedCount[msg.sender] += amt;
        _safeMint(msg.sender, amt);
    }

    function mint(uint256 amt) external payable callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
        require(paidMintedCount[msg.sender] + amt <= maxPerWallet, "Exceeds paid mint limit per wallet");
        require(amt > 0 && amt <= maxPerTx, "Invalid mint amount");
        require(msg.value >= amt * price, "Insufficient payment");

        paidMintedCount[msg.sender] += amt;
        _safeMint(msg.sender, amt);
    }

    function ownerBatchMint(uint256 amt) external onlyOwner {
        require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
        _safeMint(msg.sender, amt);
    }

    function toggleMinting() external onlyOwner {
        mintEnabled = !mintEnabled;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return freeMintedCount[owner] + paidMintedCount[owner];
    }

    function setBaseURI(string calldata baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setPrice(uint256 price_) external onlyOwner {
        price = price_;
    }

    function setTotalFree(uint256 totalFree_) external onlyOwner {
        totalFree = totalFree_;
    }

    function setMaxPerTx(uint256 maxPerTx_) external onlyOwner {
        maxPerTx = maxPerTx_;
    }

    function setMaxPerWallet(uint256 maxPerWallet_) external onlyOwner {
        maxPerWallet = maxPerWallet_;
    }

    function setmaxSupply(uint256 maxSupply_) external onlyOwner {
        maxSupply = maxSupply_;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseURI;
    }

    function withdraw() external onlyOwner nonReentrant {
        payable(owner()).transfer(address(this).balance);
    }

    function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
        _setOwnersExplicit(quantity);
    }

    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
        return ownershipOf(tokenId);
    }

    function _setOwnersExplicit(uint256 quantity) internal {
        require(quantity > 0, "Quantity must be nonzero");
        uint256 _nextOwnerToExplicitlySet = nextOwnerToExplicitlySet;
        require(_nextOwnerToExplicitlySet < currentIndex, "No tokens to set");

        uint256 endIndex = _nextOwnerToExplicitlySet + quantity > currentIndex
            ? currentIndex
            : _nextOwnerToExplicitlySet + quantity;

        for (uint256 i = _nextOwnerToExplicitlySet; i < endIndex; i++) {
            if (_ownerships[i].addr == address(0)) {
                TokenOwnership memory ownership = ownershipOf(i);
                _ownerships[i] = ownership;
            }
        }

        nextOwnerToExplicitlySet = endIndex;
    }
}
```

### Key Features:
1. **Minting Options**:
   - Free minting (`freeMint`) is allowed up to a certain total free limit (`totalFree`) and per-wallet limit (`maxPerWallet`).
   - Paid minting (`mint`) is subject to a price (`price`) and similar per-wallet and per-transaction limits.

2. **Admin Controls**:
   - Owner can batch mint tokens (`ownerBatchMint`).
   - Minting toggle enabled/disabled (`toggleMinting`).
   - Adjustable parameters like `price`, `totalFree`, `maxPerTx`, `maxPerWallet`, and `maxSupply`.

3. **Optimizations**:
   - Batch ownership setting via `setOwnersExplicit` to optimize `ownerOf()` calls for unprocessed tokens.

4. **Security**:
   - Uses `nonReentrant` guard on withdrawal and `setOwnersExplicit`.
   - Restricts minting to externally owned accounts via `callerIsUser`.

5. **Extensibility**:
   - Fully uses the `ERC721A` base contract provided for gas-efficient minting. 

This implementation strictly adheres to the provided context and contract specifications.