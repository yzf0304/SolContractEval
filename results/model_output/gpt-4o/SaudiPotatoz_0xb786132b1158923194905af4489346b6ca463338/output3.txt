Here is the complete implementation of the `SaudiPotatoz` smart contract as per the provided instructions:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./ERC721A.sol"; // Assuming ERC721A is in the same project directory.

contract SaudiPotatoz is ERC721A, Ownable, ReentrancyGuard {
    string public baseURI;
    uint256 public price = 0 ether;
    uint256 public maxPerTx = 1;
    uint256 public maxPerWallet = 1;
    uint256 public totalFree = 0;
    uint256 public maxSupply = 5000;
    uint256 public nextOwnerToExplicitlySet;
    bool public mintEnabled;

    constructor() ERC721A("SaudiPotatoz", "SaudiPotatoz") {}

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function freeMint(uint256 amt) external callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(totalSupply() + amt <= totalFree, "Exceeds total free supply");
        require(
            _numberMinted(msg.sender) + amt <= maxPerWallet,
            "Exceeds max per wallet"
        );
        _safeMint(msg.sender, amt);
    }

    function mint(uint256 amt) external payable callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
        require(
            amt <= maxPerTx && _numberMinted(msg.sender) + amt <= maxPerWallet,
            "Exceeds max per wallet or transaction"
        );
        require(msg.value >= amt * price, "Incorrect ETH amount");
        _safeMint(msg.sender, amt);
    }

    function ownerBatchMint(uint256 amt) external onlyOwner {
        require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
        _safeMint(msg.sender, amt);
    }

    function toggleMinting() external onlyOwner {
        mintEnabled = !mintEnabled;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return _numberMinted(owner);
    }

    function setBaseURI(string calldata baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setPrice(uint256 price_) external onlyOwner {
        price = price_;
    }

    function setTotalFree(uint256 totalFree_) external onlyOwner {
        totalFree = totalFree_;
    }

    function setMaxPerTx(uint256 maxPerTx_) external onlyOwner {
        maxPerTx = maxPerTx_;
    }

    function setMaxPerWallet(uint256 maxPerWallet_) external onlyOwner {
        maxPerWallet = maxPerWallet_;
    }

    function setmaxSupply(uint256 maxSupply_) external onlyOwner {
        maxSupply = maxSupply_;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseURI;
    }

    function withdraw() external onlyOwner nonReentrant {
        (bool success, ) = payable(owner()).call{value: address(this).balance}("");
        require(success, "Withdraw failed");
    }

    function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
        _setOwnersExplicit(quantity);
    }

    function getOwnershipData(uint256 tokenId)
        external
        view
        returns (TokenOwnership memory)
    {
        return ownershipOf(tokenId);
    }

    function _setOwnersExplicit(uint256 quantity) internal {
        require(quantity > 0, "Quantity must be nonzero");
        require(currentIndex > 0, "No tokens minted yet");

        uint256 endIndex = nextOwnerToExplicitlySet + quantity;

        if (endIndex > currentIndex) {
            endIndex = currentIndex;
        }

        for (uint256 i = nextOwnerToExplicitlySet; i < endIndex; i++) {
            if (_ownerships[i].addr == address(0) && _exists(i)) {
                _ownerships[i] = ownershipOf(i);
            }
        }

        nextOwnerToExplicitlySet = endIndex;
    }
}
```

### Explanation:

1. **Core Features:**
   - Implements both free and paid minting mechanisms with checks for max supply, wallet limits, and transaction limits.
   - The `callerIsUser` modifier ensures that only externally-owned accounts (EOAs) can interact with minting functions.

2. **Batch Minting:**
   - Used `_safeMint` from the `ERC721A` contract for efficient batch minting.
   - Owner-only minting for specific use cases like giveaways.

3. **Owner Controls:**
   - The owner can toggle minting, set price, adjust limits (max supply, free supply, wallet, and transaction limits), and withdraw the contract's balance.

4. **Optimizations:**
   - `setOwnersExplicit` allows the owner to pre-set ownership data, improving the efficiency of `ownerOf` calls.
   - No additional dependencies or contracts outside the provided context are used.

5. **Compliance:**
   - This contract strictly follows the description and the `ERC721A` standard for efficient NFT minting.

Let me know if you have further questions!