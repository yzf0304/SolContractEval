Here's the complete implementation of the `ScammerGold` smart contract, strictly adhering to the provided context and requirements. The methods are implemented as per the description:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.6;

contract ScammerGold is Context, Ownable, ERC20 {
    // sLoot contract address
    address public slootContractAddress = 0xb12F78434AE7D12Ae548c51A5cb734Ecc4536594;
    IERC721Enumerable public slootContract;

    // Amount of Scammer Gold per sLoot token ID
    uint256 public scammerGoldPerTokenId = 10000 * (10 ** decimals());

    // Start and end token IDs for sLoot
    uint256 public tokenIdStart = 1;
    uint256 public tokenIdEnd = 8000;

    // Current season for claiming Scammer Gold
    uint256 public season = 0;

    // Mapping to track claimed tokens within a season
    mapping(uint256 => mapping(uint256 => bool)) public seasonClaimedByTokenId;

    constructor() Ownable() ERC20("Scammer Gold", "SGLD") {
        transferOwnership(address(0)); // Transfer ownership to null address
        slootContract = IERC721Enumerable(slootContractAddress);
    }

    /// @notice Claim Scammer Gold for a given sLoot ID
    /// @param tokenId The tokenId of the sLoot NFT
    function claimById(uint256 tokenId) external {
        require(
            slootContract.ownerOf(tokenId) == _msgSender(),
            "Caller is not the owner of this token"
        );
        require(
            tokenId >= tokenIdStart && tokenId <= tokenIdEnd,
            "Token ID is out of range"
        );
        require(
            !seasonClaimedByTokenId[season][tokenId],
            "This token has already claimed for the current season"
        );

        seasonClaimedByTokenId[season][tokenId] = true;
        _claim(tokenId, _msgSender());
    }

    /// @notice Claim Scammer Gold for all tokens owned by the sender
    function claimAllForOwner() external {
        uint256 balance = slootContract.balanceOf(_msgSender());
        require(balance > 0, "Caller owns no tokens");

        for (uint256 i = 0; i < balance; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(_msgSender(), i);
            if (
                tokenId >= tokenIdStart &&
                tokenId <= tokenIdEnd &&
                !seasonClaimedByTokenId[season][tokenId]
            ) {
                seasonClaimedByTokenId[season][tokenId] = true;
                _claim(tokenId, _msgSender());
            }
        }
    }

    /**
     * @notice Claims tokens for the owner within a specified range of indices
     * @param ownerIndexStart Start index (inclusive)
     * @param ownerIndexEnd End index (inclusive)
     */
    function claimRangeForOwner(uint256 ownerIndexStart, uint256 ownerIndexEnd) external {
        uint256 balance = slootContract.balanceOf(_msgSender());
        require(balance > 0, "Caller owns no tokens");
        require(ownerIndexStart <= ownerIndexEnd, "Invalid index range");
        require(ownerIndexEnd < balance, "Index out of bounds");

        for (uint256 i = ownerIndexStart; i <= ownerIndexEnd; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(_msgSender(), i);
            if (
                tokenId >= tokenIdStart &&
                tokenId <= tokenIdEnd &&
                !seasonClaimedByTokenId[season][tokenId]
            ) {
                seasonClaimedByTokenId[season][tokenId] = true;
                _claim(tokenId, _msgSender());
            }
        }
    }

    /// @dev Internal function to mint Scammer Gold upon claiming
    function _claim(uint256 tokenId, address tokenOwner) internal {
        _mint(tokenOwner, scammerGoldPerTokenId);
    }

    /// @notice Allows the DAO to mint new tokens for use within the sLoot Ecosystem
    /// @param amountDisplayValue The amount of Scammer Gold to mint
    function daoMint(uint256 amountDisplayValue) external onlyOwner {
        _mint(_msgSender(), amountDisplayValue * (10 ** decimals()));
    }

    /// @notice Allows the DAO to set a new contract address for sLoot
    /// @param slootContractAddress_ The new contract address for sLoot
    function daoSetLootContractAddress(address slootContractAddress_) external onlyOwner {
        slootContractAddress = slootContractAddress_;
        slootContract = IERC721Enumerable(slootContractAddress_);
    }

    /// @notice Allows the DAO to set the token IDs eligible to claim sLoot
    /// @param tokenIdStart_ The start of the eligible token range
    /// @param tokenIdEnd_ The end of the eligible token range
    function daoSetTokenIdRange(uint256 tokenIdStart_, uint256 tokenIdEnd_) external onlyOwner {
        tokenIdStart = tokenIdStart_;
        tokenIdEnd = tokenIdEnd_;
    }

    /// @notice Allows the DAO to set a season for new Scammer Gold claims
    /// @param season_ The season to use for claiming Scammer Gold
    function daoSetSeason(uint256 season_) public onlyOwner {
        season = season_;
    }

    /// @notice Allows the DAO to set the amount of Scammer Gold claimed per token ID
    /// @param scammerGoldDisplayValue The amount of Scammer Gold per token ID
    function daoSetScammerGoldPerTokenId(uint256 scammerGoldDisplayValue) public onlyOwner {
        scammerGoldPerTokenId = scammerGoldDisplayValue * (10 ** decimals());
    }

    /// @notice Allows the DAO to set both the season and Scammer Gold amount
    /// @param season_ The new season
    /// @param scammerGoldDisplayValue The amount of Scammer Gold per token ID
    function daoSetSeasonAndScammerGoldPerTokenID(uint256 season_, uint256 scammerGoldDisplayValue) external onlyOwner {
        daoSetSeason(season_);
        daoSetScammerGoldPerTokenId(scammerGoldDisplayValue);
    }

    /// @notice Fallback function to receive Ether
    receive() external payable {}
}
```

### Key Highlights:
1. **Claiming Logic**: Users can claim Scammer Gold tokens by `tokenId`, all at once (`claimAllForOwner`), or in batches (`claimRangeForOwner`).
2. **DAO Controls**: The DAO (originally the contract owner) can manage the token range, season, and Scammer Gold allocation per token.
3. **Seasons**: Introduced seasons to allow for separate claim rounds while ensuring no double claims.
4. **Efficient Gas Use**: Batch processing (`claimRangeForOwner`) ensures users with large balances can claim in segments.

This implementation matches the requirements while leveraging modularity for maintainability and extensibility.