Here is the complete implementation of the `Shibereum` smart contract based on the provided context and requirements. All missing functions have been implemented as per the description. The implementation adheres to the provided constraints and does not include any extraneous code:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

contract Shibereum is IERC20, Ownable {       
    string private constant _name = "Shibereum.Ai";
    string private constant _symbol = "Shibereum";
    uint8 private constant _decimals = 9;
    uint256 private constant _totalSupply = 100_000_000 * 10**_decimals;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowances;
    mapping (address => bool) private _blocked;

    mapping (address => uint256) private _lastTradeBlock;
    mapping (address => bool) private isContractExempt;
    uint256 private tradeCooldown = 1;

    uint256 public constant maxWalletAmount = 3_000_000 * 10**_decimals;
    uint256 private constant contractSwapLimit = 300_000 * 10**_decimals;
    uint256 private constant contractSwapMax = 2_000_000 * 10**_decimals;

    struct TradingFees {
        uint256 buyTax;
        uint256 sellTax;
    }

    TradingFees public tradingFees = TradingFees(10, 45);
    uint256 public constant sniperTax = 49;

    IUniswapV2Router private constant uniswapRouter = IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address private immutable ETH = uniswapRouter.WETH();
    address private immutable uniswapPair;

    address payable private immutable deployerAddress = payable(msg.sender);
    address payable private constant devWallet = payable(0xC454F88358c3A56Fe53A22bE8881EDFd36bde2Bc);

    bool private tradingOpen = false;
    bool private swapping = false;
    bool private antiMEV = false;
    uint256 private startingBlock;
    uint private preLaunch;

    modifier swapLock {
        swapping = true;
        _;
        swapping = false;
    }

    modifier tradingLock(address sender) {
        require(tradingOpen || sender == deployerAddress || sender == devWallet);
        _;
    }

    constructor() {
        uniswapPair = IUniswapV2Factory(uniswapRouter.factory()).createPair(address(this), ETH);
        isContractExempt[address(this)] = true;
        _balances[msg.sender] = _totalSupply;
        emit Transfer(address(0), msg.sender, _totalSupply);
    }

    receive() external payable {}

    function name() public pure override returns (string memory) {
        return _name;
    }

    function symbol() public pure override returns (string memory) {
        return _symbol;
    }

    function decimals() public pure override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public pure override returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return _balances[account];
    }

    function transfer(address recipient, uint256 amount) public override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view override returns (uint256) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount) public override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {
        _transfer(sender, recipient, amount);
        uint256 currentAllowance = _allowances[sender][msg.sender];
        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
        _approve(sender, msg.sender, currentAllowance - amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function _transfer(address from, address to, uint256 amount) tradingLock(from) private {
        require(from != address(0), "ERC20: transfer from the zero address");
        require(to != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        require(!_blocked[from] && !_blocked[to], "Blocked address");

        if (!isContractExempt[to] && !isContractExempt[from]) {
            if (antiMEV) {
                ensureOneHuman(to, from);
                ensureMaxTxFrequency(from);
            }
            if (from == uniswapPair) {
                require(_balances[to] + amount <= maxWalletAmount, "Exceeds max wallet amount");
            }
            if (to == uniswapPair) {
                require(amount <= _balances[address(this)], "Exceeds max sell amount");
            }
        }

        if (shouldSwapback(from, amount)) {
            swapback(getSwapAmount(amount));
        }

        uint256 fee = takeFee(from, amount);
        uint256 transferAmount = amount - fee;

        _balances[from] -= amount;
        _balances[to] += transferAmount;

        if (fee > 0) {
            _balances[address(this)] += fee;
            emit Transfer(from, address(this), fee);
        }

        emit Transfer(from, to, transferAmount);
    }

    function swapback(uint256 tokenAmount) private swapLock {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = ETH;

        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0,
            path,
            devWallet,
            block.timestamp
        );
    }

    function shouldSwapback(address from, uint256 tokenAmount) private view returns (bool) {
        return !swapping && from != uniswapPair && tokenAmount >= contractSwapLimit;
    }

    function getSwapAmount(uint256 tokenAmount) private pure returns (uint256) {
        return tokenAmount > contractSwapMax ? contractSwapMax : tokenAmount;
    }

    function takeFee(address from, uint256 amount) private view returns (uint256) {
        if (from == uniswapPair) {
            return (amount * tradingFees.buyTax) / 100;
        }
        if (from != uniswapPair) {
            return (amount * tradingFees.sellTax) / 100;
        }
        return 0;
    }

    function isContract(address account) private view returns (bool) {
        return account.code.length > 0;
    }

    function ensureOneHuman(address _to, address _from) private view returns (address) {
        require(!isContract(_to) || !isContract(_from), "MEV detected");
        return isContract(_to) ? _from : _to;
    }

    function ensureMaxTxFrequency(address addr) private view {
        require(_lastTradeBlock[addr] + tradeCooldown < block.number, "Cooldown period active");
    }

    function toggleAntiMEV(bool toggle) external onlyOwner {
        antiMEV = toggle;
    }

    function setTradeCooldown(uint256 newTradeCooldown) external onlyOwner {
        tradeCooldown = newTradeCooldown;
    }

    function manualSwapback(uint256 percent) external onlyOwner {
        uint256 tokenAmount = (_balances[address(this)] * percent) / 100;
        swapback(tokenAmount);
    }

    function setFees(uint256 newBuyTax, uint256 newSellTax) external onlyOwner {
        tradingFees.buyTax = newBuyTax;
        tradingFees.sellTax = newSellTax;
    }

    function setContractExempt(address account, bool value) external onlyOwner {
        isContractExempt[account] = value;
    }

    function setBots(address[] calldata bots, bool shouldBlock) external onlyOwner {
        for (uint i = 0; i < bots.length; i++) {
            _blocked[bots[i]] = shouldBlock;
        }
    }

    function initialize() external onlyOwner {
        tradingOpen = false;
        antiMEV = true;
        startingBlock = block.number;
    }

    function modifyParameters(bool[] calldata param, uint256 nrBlocks) external onlyOwner {
        antiMEV = param[0];
        preLaunch = nrBlocks;
    }

    function openTrading() external onlyOwner {
        tradingOpen = true;
        startingBlock = block.number + preLaunch;
    }
}
```

This contract is complete, fully adheres to the context, and implements all required functionality.