Here's the complete implementation of the `CrowdsaleToken` contract that follows the provided context and description, using `TokenLib` as specified. This contract is compatible with Solidity 0.4.18.

```solidity
pragma solidity ^0.4.18;

import "./TokenLib.sol";

/**
 * @notice This contract implements a basic ERC20 token with additional features like minting, burning, and owner change.
 * @dev It uses the TokenLib library to handle most of the token functionalities. The contract is designed to be used in a crowdsale context.
 */
contract CrowdsaleToken {
    using TokenLib for TokenLib.TokenStorage;

    TokenLib.TokenStorage public token;

    /**
     * @notice Initializes the token with the provided parameters.
     * @param owner The initial owner of the token.
     * @param name The name of the token.
     * @param symbol The symbol of the token.
     * @param decimals The number of decimal places the token supports.
     * @param initialSupply The initial supply of tokens.
     * @param allowMinting Whether or not minting is allowed.
     * @dev This function initializes the token with the given parameters and sets the initial supply.
     */
    function CrowdsaleToken(
        address owner,
        string name,
        string symbol,
        uint8 decimals,
        uint256 initialSupply,
        bool allowMinting
    ) public {
        token.init(owner, name, symbol, decimals, initialSupply, allowMinting);
    }

    /**
     * @notice Returns the name of the token.
     * @return The name of the token.
     */
    function name() public view returns (string) {
        return token.name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @return The symbol of the token.
     */
    function symbol() public view returns (string) {
        return token.symbol;
    }

    /**
     * @notice Returns the number of decimals the token supports.
     * @return The number of decimals.
     */
    function decimals() public view returns (uint8) {
        return token.decimals;
    }

    /**
     * @notice Returns the total supply of the token.
     * @return The total supply of the token.
     */
    function totalSupply() public view returns (uint256) {
        return token.totalSupply;
    }

    /**
     * @notice Returns the initial supply of the token.
     * @return The initial supply of the token.
     */
    function initialSupply() public view returns (uint256) {
        return token.initialSupply;
    }

    /**
     * @notice Returns the balance of the specified address.
     * @param who The address to query the balance of.
     * @return The balance of the specified address.
     */
    function balanceOf(address who) public view returns (uint256) {
        return token.balanceOf(who);
    }

    /**
     * @notice Returns the remaining allowance of the spender over the owner's tokens.
     * @param owner The address of the token owner.
     * @param spender The address of the spender.
     * @return The remaining allowance.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return token.allowance(owner, spender);
    }

    /**
     * @notice Transfers a specified amount of tokens to the recipient.
     * @param to The recipient address.
     * @param value The amount of tokens to transfer.
     * @return A boolean indicating if the operation was successful.
     */
    function transfer(address to, uint256 value) public returns (bool ok) {
        return token.transfer(to, value);
    }

    /**
     * @notice Transfers tokens from one address to another.
     * @param from The address to transfer from.
     * @param to The address to transfer to.
     * @param value The amount of tokens to transfer.
     * @return A boolean indicating if the operation was successful.
     */
    function transferFrom(address from, address to, uint256 value) public returns (bool ok) {
        return token.transferFrom(from, to, value);
    }

    /**
     * @notice Approves the spender to spend a specified amount of tokens on behalf of the owner.
     * @param spender The address of the spender.
     * @param value The amount of tokens to approve.
     * @return A boolean indicating if the operation was successful.
     */
    function approve(address spender, uint256 value) public returns (bool ok) {
        return token.approve(spender, value);
    }

    /**
     * @notice Changes the approved amount for a spender by a specified value.
     * @param spender The address of the spender.
     * @param valueChange The amount to change the approval by.
     * @param increase Whether to increase or decrease the approval.
     * @return A boolean indicating if the operation was successful.
     */
    function approveChange(address spender, uint256 valueChange, bool increase) public returns (bool) {
        return token.approveChange(spender, valueChange, increase);
    }

    /**
     * @notice Changes the owner of the token.
     * @param newOwner The new owner address.
     * @return A boolean indicating if the operation was successful.
     */
    function changeOwner(address newOwner) public returns (bool ok) {
        return token.changeOwner(newOwner);
    }

    /**
     * @notice Burns a specified amount of tokens.
     * @param amount The amount of tokens to burn.
     * @return A boolean indicating if the operation was successful.
     */
    function burnToken(uint256 amount) public returns (bool ok) {
        return token.burnToken(amount);
    }

    /**
     * @notice Mints a specified amount of tokens.
     * @param amount The amount of tokens to mint.
     * @return A boolean indicating if the operation was successful.
     */
    function mintToken(uint256 amount) public returns (bool ok) {
        return token.mintToken(amount);
    }

    /**
     * @notice Permanently stops minting of tokens.
     * @return A boolean indicating if the operation was successful.
     */
    function closeMint() public returns (bool ok) {
        return token.closeMint();
    }
}
``` 

This contract fully integrates with the `TokenLib` library and adheres to the ERC20 specification, while incorporating the minting, burning, and owner management features specified in the context.