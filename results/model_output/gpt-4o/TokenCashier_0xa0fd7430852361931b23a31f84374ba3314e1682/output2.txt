Here's the complete implementation of the `TokenCashier` contract based strictly on the provided context and description:

```solidity
pragma solidity 0.5.12;

contract TokenCashier is Pausable {
    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);

    ITokenList[] public tokenLists;
    address[] public tokenSafes;
    mapping(address => uint256) public counts;
    uint256 public depositFee;
    IWrappedCoin public wrappedCoin;

    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {
        require(_tokenLists.length == _tokenSafes.length, "# of token lists is not equal to # of safes");
        wrappedCoin = _wrappedCoin;
        tokenLists = _tokenLists;
        tokenSafes = _tokenSafes;
    }

    function() external {
        revert();
    }

    function count(address _token) public view returns (uint256) {
        return counts[_token];
    }

    function setDepositFee(uint256 _fee) public onlyOwner {
        depositFee = _fee;
    }

    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {
        require(_to != address(0), "Invalid recipient");
        uint256 fee = depositFee;
        uint256 netAmount = _amount;

        if (_token == address(0)) {
            // Native currency (ETH)
            require(msg.value >= _amount + fee, "Insufficient msg.value");
            wrappedCoin.deposit.value(_amount)();
        } else {
            require(isWhitelisted(_token), "Token not whitelisted");
            require(netAmount >= minAmount(_token), "Amount below minimum");
            require(netAmount <= maxAmount(_token), "Amount exceeds maximum");

            require(safeTransferFrom(_token, msg.sender, address(this), _amount), "Token transfer failed");
        }

        if (fee > 0) {
            netAmount -= fee;
        }

        address safe = getTokenSafe(_token);
        if (safe != address(0)) {
            require(safeTransfer(_token, safe, netAmount), "Safe transfer failed");
        } else {
            require(burnToken(_token, netAmount), "Burn failed");
        }

        counts[_token]++;
        emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);
    }

    function deposit(address _token, uint256 _amount) public payable {
        depositTo(_token, msg.sender, _amount);
    }

    function withdraw() external onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function withdrawToken(address _token) public onlyOwner {
        bytes4 balanceOfSelector = bytes4(keccak256("balanceOf(address)"));
        bytes4 transferSelector = bytes4(keccak256("transfer(address,uint256)"));

        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(balanceOfSelector, address(this)));
        require(success, "BalanceOf call failed");

        uint256 balance = abi.decode(data, (uint256));
        if (balance > 0) {
            require(safeTransfer(_token, msg.sender, balance), "Token transfer failed");
        }
    }

    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {
        bytes4 transferFromSelector = bytes4(keccak256("transferFrom(address,address,uint256)"));
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(transferFromSelector, _from, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }

    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {
        bytes4 transferSelector = bytes4(keccak256("transfer(address,uint256)"));
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(transferSelector, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }

    function burnToken(address _token, uint256 _amount) internal returns (bool) {
        bytes4 burnSelector = bytes4(keccak256("burn(uint256)"));
        (bool success, ) = _token.call(abi.encodeWithSelector(burnSelector, _amount));
        return success;
    }

    function isWhitelisted(address _token) internal returns (bool) {
        for (uint256 i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                return true;
            }
        }
        return false;
    }

    function minAmount(address _token) internal returns (uint256) {
        for (uint256 i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                return tokenLists[i].minAmount(_token);
            }
        }
        return 0;
    }

    function maxAmount(address _token) internal returns (uint256) {
        for (uint256 i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                return tokenLists[i].maxAmount(_token);
            }
        }
        return uint256(-1); // Maximum uint256 value
    }

    function getTokenSafe(address _token) internal view returns (address) {
        for (uint256 i = 0; i < tokenLists.length; i++) {
            if (tokenLists[i].isAllowed(_token)) {
                return tokenSafes[i];
            }
        }
        return address(0);
    }
}
```

### Key Points:
1. Implements the logic strictly based on the description and requirements.
2. Supports both ERC20 tokens and native currency (ETH).
3. Handles deposit fees, whitelisting, and token safe routing.
4. Utilizes safeTransfer and safeTransferFrom functions for token transfers.
5. Provides owner-restricted functions for withdrawal and deposit fee management.
6. Includes fallback and revert behavior for direct ETH transfers.

This contract adheres to Solidity version `0.5.12` and avoids extraneous implementations.