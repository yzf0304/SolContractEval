```solidity
pragma solidity ^0.4.23;

/**
 * @notice This contract allows users to register an account with a public key and an SPHTX name.
 * @dev The contract ensures that each Ethereum address can only register one unique SPHTX name, and each SPHTX name is unique across the system.
 */
contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    /**
     * @notice Emitted when an account is registered.
     * @param ethAccount The Ethereum address of the user.
     * @param sphtxAccount The SPHTX name of the user.
     * @param pubKey The public key associated with the user's SPHTX name.
     */
    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    /**
     * @notice Registers an SPHTX name and associates it with a public key for the caller.
     * @param name The SPHTX name to be registered. Must meet specific formatting requirements.
     * @param pubKey The public key to be associated with the SPHTX name. Must meet length requirements.
     */
    function register(string memory name, string memory pubKey) public {
        require(bytes(name).length >= 3 && bytes(name).length <= 16, "Name must be between 3 and 16 characters");
        require(bytes(pubKey).length >= 50 && bytes(pubKey).length <= 64, "Public key must be between 50 and 64 characters");
        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address already registered");

        bytes memory nameBytes = bytes(name);
        require(
            (nameBytes[0] >= 'a' && nameBytes[0] <= 'z') || (nameBytes[0] >= '0' && nameBytes[0] <= '9'),
            "Name must start with a lowercase letter or digit"
        );

        for (uint i = 1; i < nameBytes.length; i++) {
            require(
                (nameBytes[i] >= 'a' && nameBytes[i] <= 'z') || (nameBytes[i] >= '0' && nameBytes[i] <= '9') || 
                nameBytes[i] == '-' || nameBytes[i] == '.',
                "Name contains invalid characters"
            );
        }

        require(bytes(_accountToPubKey[name]).length == 0, "Name already in use");

        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;

        emit AccountRegister(msg.sender, name, pubKey);
    }

    /**
     * @notice Returns the SPHTX name associated with the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The SPHTX name associated with the address.
     */
    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    /**
     * @notice Returns the public key associated with the SPHTX name of the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The public key associated with the SPHTX name.
     */
    function keys(address addr) public view returns (string memory) {
        string memory name = _ethToSphtx[addr];
        return _accountToPubKey[name];
    }

    /**
     * @notice Checks if a SPHTX name is available for registration.
     * @param name The SPHTX name to check availability for.
     * @return bool True if the name is available, false otherwise.
     */
    function nameAvailable(string memory name) public view returns (bool) {
        if (bytes(name).length < 3 || bytes(name).length > 16) {
            return false;
        }
        
        bytes memory nameBytes = bytes(name);
        if (!((nameBytes[0] >= 'a' && nameBytes[0] <= 'z') || (nameBytes[0] >= '0' && nameBytes[0] <= '9'))) {
            return false;
        }

        for (uint i = 1; i < nameBytes.length; i++) {
            if (!((nameBytes[i] >= 'a' && nameBytes[i] <= 'z') || (nameBytes[i] >= '0' && nameBytes[i] <= '9') || 
                nameBytes[i] == '-' || nameBytes[i] == '.')) {
                return false;
            }
        }

        return bytes(_accountToPubKey[name]).length == 0;
    }
}
```