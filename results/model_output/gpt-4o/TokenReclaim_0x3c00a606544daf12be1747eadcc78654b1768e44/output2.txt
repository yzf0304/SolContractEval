```solidity
pragma solidity ^0.4.23;

/**
 * @notice This contract allows users to register an account with a public key and an SPHTX name.
 * @dev The contract ensures that each Ethereum address can only register one unique SPHTX name, and each SPHTX name is unique across the system.
 */
contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    /**
     * @notice Emitted when an account is registered.
     * @param ethAccount The Ethereum address of the user.
     * @param sphtxAccount The SPHTX name of the user.
     * @param pubKey The public key associated with the user's SPHTX name.
     */
    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    /**
     * @notice Registers an SPHTX name and associates it with a public key for the caller.
     * @param name The SPHTX name to be registered. Must meet specific formatting requirements.
     * @param pubKey The public key to be associated with the SPHTX name. Must meet length requirements.
     */
    function register(string memory name, string memory pubKey) public {
        // Validate name length
        require(bytes(name).length >= 3 && bytes(name).length <= 16, "Invalid name length");

        // Validate name format
        require(validName(name), "Invalid name format");

        // Validate public key length
        require(bytes(pubKey).length >= 50 && bytes(pubKey).length <= 64, "Invalid public key length");

        // Ensure the caller's address is not already registered
        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address already registered");

        // Ensure the name is not already in use
        require(bytes(_accountToPubKey[name]).length == 0, "Name already in use");

        // Store the name-to-public key mapping
        _accountToPubKey[name] = pubKey;

        // Store the Ethereum address-to-SPHTX name mapping
        _ethToSphtx[msg.sender] = name;

        // Emit the account registration event
        emit AccountRegister(msg.sender, name, pubKey);
    }

    /**
     * @notice Returns the SPHTX name associated with the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The SPHTX name associated with the address.
     */
    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    /**
     * @notice Returns the public key associated with the SPHTX name of the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The public key associated with the SPHTX name.
     */
    function keys(address addr) public view returns (string memory) {
        string memory name = _ethToSphtx[addr];
        return _accountToPubKey[name];
    }

    /**
     * @notice Checks if a SPHTX name is available for registration.
     * @param name The SPHTX name to check availability for.
     * @return bool True if the name is available, false otherwise.
     */
    function nameAvailable(string memory name) public view returns (bool) {
        if (bytes(name).length < 3 || bytes(name).length > 16) {
            return false;
        }
        if (!validName(name)) {
            return false;
        }
        if (bytes(_accountToPubKey[name]).length != 0) {
            return false;
        }
        return true;
    }

    /**
     * @notice Validates the format of the given name.
     * @param name The SPHTX name to validate.
     * @return bool True if the name is valid, false otherwise.
     */
    function validName(string memory name) internal pure returns (bool) {
        bytes memory nameBytes = bytes(name);

        // Check the first character
        if (!(nameBytes[0] >= "a" && nameBytes[0] <= "z") && !(nameBytes[0] >= "0" && nameBytes[0] <= "9")) {
            return false;
        }

        // Check subsequent characters
        for (uint i = 1; i < nameBytes.length; i++) {
            bytes1 char = nameBytes[i];
            if (!((char >= "a" && char <= "z") || (char >= "0" && char <= "9") || char == "-" || char == ".")) {
                return false;
            }
        }
        return true;
    }
}
```