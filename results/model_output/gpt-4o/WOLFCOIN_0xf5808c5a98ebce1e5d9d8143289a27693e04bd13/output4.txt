Here's the complete implementation of the `Pausable` contract based on the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Pausable is Context, Ownable {
    event Pause();
    event Unpause();
    event PauserChanged(address indexed newAddress);

    address public pauser;
    bool public paused = false;

    /**
     * @dev Initializes the contract by setting the initial pauser as the owner.
     */
    constructor() {
        pauser = owner();
        emit PauserChanged(pauser);
    }

    /**
     * @dev Modifier to make a function callable only when the contract is not paused.
     * @notice Functions with this modifier will revert if the contract is paused.
     */
    modifier whenNotPaused() {
        require(!paused, "Network paused by administrator");
        _;
    }

    /**
     * @dev Modifier to restrict access to the pauser.
     * @notice Only the account with the pauser role can call functions with this modifier.
     */
    modifier onlyPauser() {
        require(_msgSender() == pauser, "Caller is not the pause administrator");
        _;
    }

    /**
     * @dev Allows the pauser to pause the contract, preventing any further actions until it is unpaused.
     * @notice Emits a {Pause} event.
     */
    function pause() external onlyPauser {
        require(!paused, "Contract is already paused");
        paused = true;
        emit Pause();
    }

    /**
     * @dev Allows the pauser to unpause the contract, allowing normal operations to resume.
     * @notice Emits an {Unpause} event.
     */
    function unpause() external onlyPauser {
        require(paused, "Contract is not paused");
        paused = false;
        emit Unpause();
    }

    /**
     * @dev Allows the owner to update the pauser role.
     * @notice Reverts if the new pauser is the zero address. Emits a {PauserChanged} event.
     */
    function updatePauser(address _newPauser) external onlyOwner {
        require(_newPauser != address(0), "New pauser cannot be the zero address");
        pauser = _newPauser;
        emit PauserChanged(_newPauser);
    }
}
```

### Key Highlights:
1. **Pause & Unpause Functionality**:
   - `pause()` and `unpause()` functions modify the `paused` state and emit corresponding events (`Pause` and `Unpause`).
   - These functions can only be called by the `pauser`.

2. **Pauser Role**:
   - The `pauser` is initialized to the contract owner (`owner()`) in the constructor.
   - The `updatePauser()` function lets the contract owner assign a new `pauser` address, ensuring the role can be managed securely.

3. **Modifiers**:
   - `whenNotPaused`: Ensures functionality is accessible only when the contract is not paused.
   - `onlyPauser`: Restricts access to functions to the current `pauser`.

4. **Events**:
   - `Pause`: Signals the contract has been paused.
   - `Unpause`: Signals the contract has been unpaused.
   - `PauserChanged`: Signals a change in the `pauser` role.

5. **Security**:
   - Prevents setting the `pauser` address to `address(0)`.
   - Verifies the appropriate permissions (`onlyOwner` and `onlyPauser`) on sensitive operations.

This implementation strictly adheres to the provided context and description.