Below is the completed implementation of the smart contract `Wagmipet`, strictly adhering to the provided context and contract description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/**
 * @title Wagmipet
 * @notice A simple pet simulation contract where the pet's needs (hunger, uncleanliness, boredom, sleepiness) must be managed.
 * @dev The pet's conditions deteriorate over time and must be maintained by calling specific functions. If any condition exceeds 100, the pet is no longer alive.
 */
contract Wagmipet {
    address private _owner;
    bool private _birthed;

    event CaretakerLoved(address indexed caretaker, uint256 indexed amount);

    uint256 private lastFeedBlock;
    uint256 private lastCleanBlock;
    uint256 private lastPlayBlock;
    uint256 private lastSleepBlock;

    uint8 internal hunger;
    uint8 internal uncleanliness;
    uint8 internal boredom;
    uint8 internal sleepiness;

    mapping(address => uint256) public love;

    /**
     * @dev Modifier to restrict function calls to the owner of the contract.
     */
    modifier onlyOwner() {
        require(msg.sender == _owner, "Caller is not the owner");
        _;
    }

    /**
     * @notice Initializes the contract, setting the owner and initial state of the pet.
     * @dev Sets the initial values for the pet's needs and the owner of the contract.
     */
    constructor() {
        _owner = msg.sender;
        lastFeedBlock = block.number;
        lastCleanBlock = block.number;
        lastPlayBlock = block.number;
        lastSleepBlock = block.number;

        hunger = 0;
        uncleanliness = 0;
        boredom = 0;
        sleepiness = 0;
    }

    /**
     * @notice Internal function to add love points to a caretaker.
     * @dev Emits an event when a caretaker is given love points.
     * @param caretaker The address of the caretaker.
     * @param amount The amount of love points to add.
     */
    function addLove(address caretaker, uint256 amount) internal {
        love[caretaker] += amount;
        emit CaretakerLoved(caretaker, amount);
    }

    /**
     * @notice Feeds the entity, resetting hunger and increasing other stats.
     * @dev Reverts if entity is dead, too bored, or too dirty to eat.
     */
    function feed() public {
        require(getAlive(), "Pet is no longer alive");
        require(boredom < 80, "Too bored to eat");
        require(uncleanliness < 80, "Too dirty to eat");

        hunger = 0;
        boredom += 10;
        uncleanliness += 3;
        lastFeedBlock = block.number;

        addLove(msg.sender, 1);
    }

    /**
     * @notice Cleans the entity, resetting uncleanliness.
     * @dev Reverts if entity is dead or already clean.
     */
    function clean() public {
        require(getAlive(), "Pet is no longer alive");
        require(uncleanliness > 0, "Already clean");

        uncleanliness = 0;
        lastCleanBlock = block.number;

        addLove(msg.sender, 1);
    }

    /**
     * @notice Lets the entity play, resetting boredom but increasing other stats.
     * @dev Reverts if entity is dead, too hungry, sleepy, or dirty to play.
     */
    function play() public {
        require(getAlive(), "Pet is no longer alive");
        require(hunger < 80, "Too hungry to play");
        require(sleepiness < 80, "Too sleepy to play");
        require(uncleanliness < 80, "Too dirty to play");

        boredom = 0;
        hunger += 10;
        sleepiness += 10;
        uncleanliness += 5;
        lastPlayBlock = block.number;

        addLove(msg.sender, 1);
    }

    /**
     * @notice Puts the entity to sleep, resetting sleepiness and increasing uncleanliness.
     * @dev Reverts if entity is not alive or too dirty, or not sleepy.
     */
    function sleep() public {
        require(getAlive(), "Pet is no longer alive");
        require(uncleanliness < 80, "Too dirty to sleep");
        require(sleepiness > 0, "Not sleepy");

        sleepiness = 0;
        uncleanliness += 5;
        lastSleepBlock = block.number;

        addLove(msg.sender, 1);
    }

    /**
     * @notice Retrieves the current status of the entity.
     * @return string The status message reflecting the entity's condition.
     */
    function getStatus() public view returns (string memory) {
        if (!getAlive()) {
            return "no longer with us";
        }
        if (sleepiness > 50) {
            return "I need sleep!";
        } else if (boredom > 50) {
            return "I'm bored!";
        } else if (uncleanliness > 50) {
            return "I feel dirty!";
        } else if (hunger > 50) {
            return "I'm hungry!";
        }

        string[4] memory goodStatuses = ["gm", "im feeling great", "all good", "i love u"];
        return goodStatuses[block.number % 4];
    }

    /**
     * @notice Checks if the pet is still alive.
     * @return A boolean indicating whether the pet is alive.
     */
    function getAlive() public view returns (bool) {
        return hunger < 101 && uncleanliness < 101 && boredom < 101 && sleepiness < 101;
    }

    /**
     * @notice Gets the current hunger level of the pet.
     * @return The current hunger level as a uint256.
     */
    function getHunger() public view returns (uint256) {
        return hunger + (uint8(block.number - lastFeedBlock) / 10);
    }

    /**
     * @notice Gets the current uncleanliness level of the pet.
     * @return The current uncleanliness level as a uint256.
     */
    function getUncleanliness() public view returns (uint256) {
        return uncleanliness + (uint8(block.number - lastCleanBlock) / 10);
    }

    /**
     * @notice Gets the current boredom level of the pet.
     * @return The current boredom level as a uint256.
     */
    function getBoredom() public view returns (uint256) {
        return boredom + (uint8(block.number - lastPlayBlock) / 10);
    }

    /**
     * @notice Gets the current sleepiness level of the pet.
     * @return The current sleepiness level as a uint256.
     */
    function getSleepiness() public view returns (uint256) {
        return sleepiness + (uint8(block.number - lastSleepBlock) / 10);
    }
}
``` 

### Key Points:
1. The contract strictly adheres to the provided requirements.
2. Time-based stat deterioration is calculated based on the difference between the current block number and the last interaction block.
3. The "alive" state of the pet is determined by checking if all stats are below 101.
4. The `addLove` and interaction functions properly emit the corresponding event and update state variables.