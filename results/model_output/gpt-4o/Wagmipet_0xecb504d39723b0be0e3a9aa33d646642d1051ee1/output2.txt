Here's the completed implementation of the `Wagmipet` smart contract based on the provided context and description, written for Solidity compiler version 0.8.7:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/**
 * @title Wagmipet
 * @notice A simple pet simulation contract where the pet's needs (hunger, uncleanliness, boredom, sleepiness) must be managed.
 * @dev The pet's conditions deteriorate over time and must be maintained by calling specific functions. If any condition exceeds 100, the pet is no longer alive.
 */
contract Wagmipet {
    address private _owner;
    bool private _birthed;

    event CaretakerLoved(address indexed caretaker, uint256 indexed amount);

    uint256 private lastFeedBlock;
    uint256 private lastCleanBlock;
    uint256 private lastPlayBlock;
    uint256 private lastSleepBlock;

    uint8 internal hunger;
    uint8 internal uncleanliness;
    uint8 internal boredom;
    uint8 internal sleepiness;

    mapping(address => uint256) public love;

    modifier onlyOwner() {
        require(msg.sender == _owner, "Only owner can call this function.");
        _;
    }

    constructor() {
        _owner = msg.sender;
        lastFeedBlock = block.number;
        lastCleanBlock = block.number;
        lastPlayBlock = block.number;
        lastSleepBlock = block.number;

        hunger = 0;
        uncleanliness = 0;
        boredom = 0;
        sleepiness = 0;

        _birthed = true;
    }

    function addLove(address caretaker, uint256 amount) internal {
        love[caretaker] += amount;
        emit CaretakerLoved(caretaker, amount);
    }

    function feed() public {
        require(getAlive(), "The pet is no longer alive.");
        require(boredom < 100, "The pet is too bored to eat.");
        require(uncleanliness < 100, "The pet is too dirty to eat.");

        hunger = 0;
        boredom += 10;
        uncleanliness += 3;

        lastFeedBlock = block.number;

        addLove(msg.sender, 1);
    }

    function clean() public {
        require(getAlive(), "The pet is no longer alive.");
        require(uncleanliness > 0, "The pet is already clean.");

        uncleanliness = 0;

        lastCleanBlock = block.number;

        addLove(msg.sender, 1);
    }

    function play() public {
        require(getAlive(), "The pet is no longer alive.");
        require(hunger < 100, "The pet is too hungry to play.");
        require(sleepiness < 100, "The pet is too sleepy to play.");
        require(uncleanliness < 100, "The pet is too dirty to play.");

        boredom = 0;
        hunger += 10;
        sleepiness += 10;
        uncleanliness += 5;

        lastPlayBlock = block.number;

        addLove(msg.sender, 1);
    }

    function sleep() public {
        require(getAlive(), "The pet is no longer alive.");
        require(uncleanliness < 80, "The pet is too dirty to sleep.");
        require(sleepiness > 0, "The pet is not sleepy.");

        sleepiness = 0;
        uncleanliness += 5;

        lastSleepBlock = block.number;

        addLove(msg.sender, 1);
    }

    function getStatus() public view returns (string memory) {
        if (!getAlive()) {
            return "no longer with us";
        }

        if (sleepiness > 50) {
            return "I need sleep!";
        } else if (boredom > 50) {
            return "I am bored!";
        } else if (uncleanliness > 50) {
            return "I feel dirty!";
        } else if (hunger > 50) {
            return "I am hungry!";
        }

        string[4] memory goodStatus = ["gm", "im feeling great", "all good", "i love u"];
        uint256 randomIndex = block.number % 4;
        return goodStatus[randomIndex];
    }

    function getAlive() public view returns (bool) {
        return hunger <= 100 && uncleanliness <= 100 && boredom <= 100 && sleepiness <= 100;
    }

    function getHunger() public view returns (uint256) {
        return hunger + uint8((block.number - lastFeedBlock) / 10);
    }

    function getUncleanliness() public view returns (uint256) {
        return uncleanliness + uint8((block.number - lastCleanBlock) / 10);
    }

    function getBoredom() public view returns (uint256) {
        return boredom + uint8((block.number - lastPlayBlock) / 10);
    }

    function getSleepiness() public view returns (uint256) {
        return sleepiness + uint8((block.number - lastSleepBlock) / 10);
    }
}
```

### Key Points:

1. **Condition Deterioration:** Hunger, uncleanliness, boredom, and sleepiness increase over time based on the block number since the last relevant action.
2. **Status Retrieval:** The `getStatus` function evaluates the pet's conditions and selects a status based on priority, or a random "good" status if all needs are below thresholds.
3. **Love Points System:** Calling functions like `feed`, `clean`, `play`, and `sleep` increases the caller's "love points."
4. **Modifiers and Checks:** The contract uses modifiers and requires checks to ensure proper functionality and conditions for actions.

This implementation strictly follows the provided context and does not introduce any extraneous dependencies or functionality.