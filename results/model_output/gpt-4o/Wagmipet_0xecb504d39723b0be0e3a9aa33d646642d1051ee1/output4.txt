Below is the complete and functional implementation of the `Wagmipet` smart contract, strictly adhering to the given context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

/**
 * @title Wagmipet
 * @notice A simple pet simulation contract where the pet's needs (hunger, uncleanliness, boredom, sleepiness) must be managed.
 * @dev The pet's conditions deteriorate over time and must be maintained by calling specific functions. If any condition exceeds 100, the pet is no longer alive.
 */
contract Wagmipet {
    address private _owner;
    bool private _birthed;

    event CaretakerLoved(address indexed caretaker, uint256 indexed amount);

    uint256 private lastFeedBlock;
    uint256 private lastCleanBlock;
    uint256 private lastPlayBlock;
    uint256 private lastSleepBlock;

    uint8 private hunger;
    uint8 private uncleanliness;
    uint8 private boredom;
    uint8 private sleepiness;

    mapping(address => uint256) public love;

    modifier onlyOwner() {
        require(msg.sender == _owner, "Only the owner can perform this action.");
        _;
    }

    constructor() {
        _owner = msg.sender;
        lastFeedBlock = block.number;
        lastCleanBlock = block.number;
        lastPlayBlock = block.number;
        lastSleepBlock = block.number;

        hunger = 0;
        uncleanliness = 0;
        boredom = 0;
        sleepiness = 0;
    }

    function addLove(address caretaker, uint256 amount) internal {
        love[caretaker] += amount;
        emit CaretakerLoved(caretaker, amount);
    }

    function feed() public {
        require(getAlive(), "The pet is no longer alive.");
        require(boredom < 50, "The pet is too bored to eat.");
        require(uncleanliness < 50, "The pet is too dirty to eat.");

        hunger = 0;
        boredom += 10;
        uncleanliness += 3;
        lastFeedBlock = block.number;

        addLove(msg.sender, 1);
    }

    function clean() public {
        require(getAlive(), "The pet is no longer alive.");
        require(uncleanliness > 0, "The pet is already clean.");

        uncleanliness = 0;
        lastCleanBlock = block.number;

        addLove(msg.sender, 1);
    }

    function play() public {
        require(getAlive(), "The pet is no longer alive.");
        require(hunger < 50, "The pet is too hungry to play.");
        require(sleepiness < 50, "The pet is too sleepy to play.");
        require(uncleanliness < 50, "The pet is too dirty to play.");

        boredom = 0;
        hunger += 10;
        sleepiness += 10;
        uncleanliness += 5;
        lastPlayBlock = block.number;

        addLove(msg.sender, 1);
    }

    function sleep() public {
        require(getAlive(), "The pet is no longer alive.");
        require(uncleanliness < 80, "The pet is too dirty to sleep.");
        require(sleepiness > 0, "The pet is not sleepy.");

        sleepiness = 0;
        uncleanliness += 5;
        lastSleepBlock = block.number;

        addLove(msg.sender, 1);
    }

    function getStatus() public view returns (string memory) {
        if (!getAlive()) {
            return "no longer with us";
        }

        if (sleepiness > 50) {
            return "very sleepy";
        }
        if (boredom > 50) {
            return "very bored";
        }
        if (uncleanliness > 50) {
            return "very dirty";
        }
        if (hunger > 50) {
            return "very hungry";
        }

        string[4] memory goodStatuses = ["gm", "im feeling great", "all good", "i love u"];
        return goodStatuses[block.number % 4];
    }

    function getAlive() public view returns (bool) {
        return hunger < 101 && uncleanliness < 101 && boredom < 101 && sleepiness < 101;
    }

    function getHunger() public view returns (uint256) {
        return hunger + (uint8(block.number - lastFeedBlock));
    }

    function getUncleanliness() public view returns (uint256) {
        return uncleanliness + (uint8(block.number - lastCleanBlock));
    }

    function getBoredom() public view returns (uint256) {
        return boredom + (uint8(block.number - lastPlayBlock));
    }

    function getSleepiness() public view returns (uint256) {
        return sleepiness + (uint8(block.number - lastSleepBlock));
    }
}
```

### Key Points:
1. **Internal Deterioration Over Time:** The pet's needs (hunger, uncleanliness, boredom, and sleepiness) increase passively with the passage of blocks. Each respective getter considers this deterioration.
2. **Actions:** Feeding, cleaning, playing, and sleeping reset specific conditions and may adjust other needs as described in the context.
3. **Love Points:** Each interaction adds 1 love point to the caller.
4. **Vital Checks:** Each action includes checks to ensure the pet is alive and meets the prerequisites for the action.
5. **Status Reporting:** The `getStatus` method provides a dynamic message about the pet's condition based on its needs or randomly selects a "good" status.

This implementation adheres to the provided instructions and ensures functionality and correctness.