The provided `WhiteList` contract is complete, functional, and adheres strictly to the given context and description. Here's a final review and analysis of the code:

1. **Inheritance from `Ownable`**:  
   The `WhiteList` contract correctly inherits the `Ownable` contract, ensuring that certain functions can only be executed by the owner of the contract.

2. **State Variables**:  
   - `whiteList`: A mapping that stores the whitelist status of addresses (`true` for whitelisted, `false` otherwise).  
   - `totalWhiteListed`: A `uint` counter to track the total number of whitelisted addresses.

3. **Events**:  
   The contract uses events to log important actions:
   - `LogWhiteListed`: Emitted when a single address is added to the whitelist.
   - `LogWhiteListedMultiple`: Emitted when multiple addresses are added to the whitelist.
   - `LogRemoveWhiteListed`: Emitted when an address is removed from the whitelist.

4. **Functions**:
   - `isWhiteListed`: A `view` function to check if an address is whitelisted.
   - `removeFromWhiteList`: Allows the owner to remove an address from the whitelist.
   - `addToWhiteList`: Allows the owner to add a single address to the whitelist.
   - `addToWhiteListMultiple`: Allows the owner to add multiple addresses to the whitelist in a single transaction.

5. **Implementation Details**:
   - `onlyOwner` modifier ensures that sensitive functions (`addToWhiteList`, `removeFromWhiteList`, and `addToWhiteListMultiple`) can only be called by the contract owner.
   - Checks are in place to avoid redundant whitelist entries and ensure the correctness of the `totalWhiteListed` count.
   - All functions are implemented with Solidity `0.4.18` syntax, including the use of events with `emit`, which is supported in this version.

6. **Gas Efficiency**:  
   - The `addToWhiteListMultiple` function iterates over the provided array of addresses but ensures no unnecessary state updates for addresses already whitelisted, improving gas efficiency.

### Final Delivery:
Here is the finalized code for the `WhiteList` contract:

```solidity
pragma solidity ^0.4.18;

contract Ownable {
    address public owner;
    
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract WhiteList is Ownable {

    mapping(address => bool) public whiteList;
    uint public totalWhiteListed;

    event LogWhiteListed(address indexed user, uint whiteListedNum);
    event LogWhiteListedMultiple(uint whiteListedNum);
    event LogRemoveWhiteListed(address indexed user);

    function isWhiteListed(address _user) external view returns (bool) {
        return whiteList[_user];
    }

    function removeFromWhiteList(address _user) external onlyOwner returns (bool) {
        require(whiteList[_user] == true);
        whiteList[_user] = false;
        totalWhiteListed--;
        emit LogRemoveWhiteListed(_user);
        return true;
    }

    function addToWhiteList(address _user) external onlyOwner returns (bool) {
        if (whiteList[_user] != true) {
            whiteList[_user] = true;
            totalWhiteListed++;
            emit LogWhiteListed(_user, totalWhiteListed);
        }
        return true;
    }

    function addToWhiteListMultiple(address[] _users) external onlyOwner returns (bool) {
        for (uint i = 0; i < _users.length; i++) {
            if (whiteList[_users[i]] != true) {
                whiteList[_users[i]] = true;
                totalWhiteListed++;
            }
        }
        emit LogWhiteListedMultiple(totalWhiteListed);
        return true;
    }
}
```

This code is concise, adheres strictly to the requirements, and avoids unnecessary complexities or external dependencies.