Hereâ€™s the completed `StandardToken` contract based on the provided description and context:

```solidity
pragma solidity ^0.4.19;

/**
 * @title SafeMath
 * @dev Provides safe mathematical operations that prevent integer overflows and underflows.
 */
contract SafeMath {

    function safeSub(uint a, uint b) pure internal returns (uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) pure internal returns (uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}

/**
 * @title ERC20
 * @dev Standard interface for ERC20-compatible tokens.
 */
contract ERC20 {
    uint public totalSupply;

    function balanceOf(address who) public constant returns (uint);
    function allowance(address owner, address spender) public constant returns (uint);
    function transfer(address to, uint value) public returns (bool ok);
    function transferFrom(address from, address to, uint value) public returns (bool ok);
    function approve(address spender, uint value) public returns (bool ok);

    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

/**
 * @title StandardToken
 * @dev Implementation of the basic standard token with ERC20 and SafeMath.
 * @notice This contract provides a standard implementation of an ERC20 token, including transfer, transferFrom, approve, and allowance functions.
 */
contract StandardToken is ERC20, SafeMath {

    mapping (address => uint) balances;                // Tracks token balances of each address.
    mapping (address => mapping (address => uint)) allowed;  // Tracks allowances for token transfers.

    /**
     * @notice Transfers `_value` amount of tokens from the message sender to `_to`.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to be transferred.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits a Transfer event and uses SafeMath for arithmetic operations.
     */
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0)); // Prevent transfer to 0x0 address.
        require(_value <= balances[msg.sender]); // Ensure sender has enough tokens.

        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);

        Transfer(msg.sender, _to, _value); // Emit transfer event.
        return true;
    }

    /**
     * @notice Transfers `_value` amount of tokens from `_from` to `_to`, using the allowance mechanism.
     * @param _from The address from which the tokens will be transferred.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to be transferred.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits a Transfer event, updates the allowance, and uses SafeMath for arithmetic operations.
     */
    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
        require(_to != address(0)); // Prevent transfer to 0x0 address.
        require(_value <= balances[_from]); // Ensure sender has enough tokens.
        require(_value <= allowed[_from][msg.sender]); // Ensure allowance is sufficient.

        balances[_to] = safeAdd(balances[_to], _value);
        balances[_from] = safeSub(balances[_from], _value);
        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);

        Transfer(_from, _to, _value); // Emit transfer event.
        return true;
    }

    /**
     * @notice Returns the balance of the `_owner` address.
     * @param _owner The address whose balance is to be queried.
     * @return The balance of the `_owner` address.
     * @dev This function is constant and does not modify the state.
     */
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

    /**
     * @notice Approves `_spender` to spend up to `_value` amount of tokens on behalf of the message sender.
     * @param _spender The address that is being approved to spend the tokens.
     * @param _value The maximum amount of tokens that can be spent.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits an Approval event. Be aware of the risks associated with setting the allowance to 0 before calling this function.
     */
    function approve(address _spender, uint _value) public returns (bool success) {
        require(_spender != address(0)); // Prevent approving 0x0 address.

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value); // Emit approval event.
        return true;
    }

    /**
     * @notice Returns the remaining amount of tokens that `_spender` is allowed to spend on behalf of `_owner`.
     * @param _owner The address that owns the tokens.
     * @param _spender The address that is allowed to spend the tokens.
     * @return The remaining amount of tokens that `_spender` is allowed to spend.
     * @dev This function is constant and does not modify the state.
     */
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
}
```

### Explanation of Changes:
1. **`require` Statements**:
   - Added `require` statements to ensure valid inputs and prevent potential issues such as transferring or approving for the zero address (`address(0)`).

2. **Event Emission**:
   - Properly emitting `Transfer` and `Approval` events for respective operations.

3. **SafeMath Integration**:
   - Used `safeSub` and `safeAdd` consistently to ensure arithmetic is protected against overflow/underflow.

4. **Gas Optimization**:
   - Made incremental optimizations without altering the logic structure.

This implementation matches the description provided and adheres strictly to the given context and Solidity 0.4.19 standards.