pragma solidity 0.6.8;

/**
 * @notice This contract serves as an upgradeable proxy, allowing the logic implementation of a contract to be updated.
 * @dev The contract uses the EIP-1967 standard for storing the implementation address. It provides functions to set and upgrade the implementation.
 */
contract UpgradeabilityProxy is Proxy {
  /**
   * @notice Initializes the proxy with an initial implementation and optionally calls a function on the implementation.
   * @dev The constructor sets the initial implementation and, if provided, forwards the `_data` to the implementation.
   * @param _logic The address of the initial implementation.
   * @param _data Data to be passed to the initial implementation after it is set.
   */
  constructor(address _logic, bytes memory _data) public payable {
    // Validate that the implementation slot is correctly computed according to EIP-1967
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));

    // Store initial implementation
    _setImplementation(_logic);

    // If initialization data is provided, delegatecall into the implementation
    if (_data.length > 0) {
      (bool success, ) = _logic.delegatecall(_data);
      require(success, "UpgradeabilityProxy: initialization call failed");
    }
  }

  /**
   * @notice Emitted when the implementation is upgraded.
   * @param implementation The address of the new implementation.
   */
  event Upgraded(address indexed implementation);

  /**
   * @notice Storage slot with the address of the current implementation.
   * @dev This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
   *      validated in the constructor.
   */
  bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  /**
   * @notice Returns the current implementation address.
   * @dev Reads the address from the EIP-1967 implementation slot.
   */
  function _implementation() internal override view returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      impl := sload(slot)
    }
  }

  /**
   * @notice Upgrades the implementation to `newImplementation`.
   * @dev Stores the new implementation and emits an {Upgraded} event.
   * @param newImplementation The address of the new implementation.
   */
  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  /**
   * @notice Stores a new address in the EIP-1967 implementation slot.
   * @dev Performs a contract-existence check on `newImplementation`.
   * @param newImplementation The address of the new implementation.
   */
  function _setImplementation(address newImplementation) internal {
    require(
      Address.isContract(newImplementation),
      "UpgradeabilityProxy: implementation is not a contract"
    );
    bytes32 slot = IMPLEMENTATION_SLOT;
    assembly {
      sstore(slot, newImplementation)
    }
  }

  /**
   * @notice Fallback function to receive Ether.
   * @dev Allows the proxy to receive ETH.
   */
  receive() external payable {}
}