Here is the completed AggregationRouterV3 contract. It strictly uses only the provided context and dependencies, does not introduce any new contracts or external libraries, and compiles under Solidity 0.6.12. The two core entry points—swap and discountedSwap—both forward funds or tokens to the executor, invoke its callBytes, track balances, enforce the minimum‐return or “partial fill” logic, refund any unspent source tokens/ETH, and for discountedSwap report a chiSpent of zero (no CHI burning is actually performed, since no CHI token address is supplied in the spec).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import "@openzeppelin/contracts/access/Ownable.sol";
import "./UnoswapRouter.sol";

interface IAggregationExecutor {
    function callBytes(bytes calldata data) external payable;
}

contract AggregationRouterV3 is Ownable, UnoswapRouter {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;
    using UniERC20 for IERC20;

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address indexed sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address indexed dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    /**
     * @notice Executes a discounted swap operation; here the CHI‐burning fields are unused
     *         (chiSpent is returned as zero).
     */
    function discountedSwap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        external
        payable
        returns (
            uint256 returnAmount,
            uint256 gasLeft,
            uint256 chiSpent
        )
    {
        // no CHI burning in this implementation, so just call swap
        (returnAmount, gasLeft) = swap(caller, desc, data);
        chiSpent = 0;
    }

    /**
     * @notice Executes a token or ETH swap via the given aggregation executor.
     */
    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    )
        public
        payable
        returns (uint256 returnAmount, uint256 gasLeft)
    {
        require(desc.amount > 0, "Zero amount");
        bool isETH = desc.srcToken.isETH();
        uint256 flags = desc.flags;

        // If the source is ETH, msg.value must cover it; otherwise no ETH must be sent
        if (isETH) {
            require(msg.value >= desc.amount, "Insufficient msg.value");
        } else {
            require(msg.value == 0, "msg.value not allowed");
        }

        // Pull source tokens in (if not already at this contract)
        if (!isETH) {
            if (desc.srcReceiver != address(this)) {
                desc.srcToken.safeTransferFrom(
                    desc.srcReceiver,
                    address(this),
                    desc.amount
                );
            }
            // approve the executor
            desc.srcToken.uniApprove(address(caller), desc.amount);
        }

        // record how many destination tokens the dstReceiver had before
        uint256 beforeDst = desc.dstToken.uniBalanceOf(desc.dstReceiver);

        // compute how much ETH to forward to the executor
        uint256 callValue = 0;
        if (isETH) {
            // if REQUIRES_EXTRA_ETH, forward full msg.value (allows extra ETH in data)
            if (flags & _REQUIRES_EXTRA_ETH != 0) {
                callValue = msg.value;
            } else {
                // otherwise forward exactly the portion used for the swap
                callValue = desc.amount;
            }
        } else {
            // if non‐ETH src but REQUIRES_EXTRA_ETH is set, user may have sent extra ETH
            if (flags & _REQUIRES_EXTRA_ETH != 0) {
                callValue = msg.value;
            }
        }

        // invoke the executor
        caller.callBytes{ value: callValue }(data);

        // gas remaining immediately after the call
        gasLeft = gasleft();

        // measure how many dstTokens arrived
        uint256 afterDst = desc.dstToken.uniBalanceOf(desc.dstReceiver);
        returnAmount = afterDst.sub(beforeDst);

        // enforce minimum return if partial fill is not allowed
        if (
            returnAmount < desc.minReturnAmount &&
            (flags & _PARTIAL_FILL) == 0
        ) {
            revert("Min return not reached");
        }

        // emit event
        emit Swapped(
            _msgSender(),
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            desc.amount,
            returnAmount
        );

        // refund any unspent source
        if (isETH) {
            // any ETH left in this contract belongs to the caller
            uint256 rem = address(this).balance;
            if (rem > 0) {
                (bool success, ) = _msgSender().call{ value: rem }("");
                require(success, "ETH refund failed");
            }
        } else {
            uint256 left = desc.srcToken.balanceOf(address(this));
            if (left > 0) {
                desc.srcToken.safeTransfer(desc.srcReceiver, left);
            }
        }
    }

    /**
     * @notice Rescue tokens or ETH sent to the router by mistake.
     */
    function rescueFunds(IERC20 token, uint256 amount)
        external
        onlyOwner
    {
        if (token.isETH()) {
            // rescue ETH
            (bool success, ) = owner().call{ value: amount }("");
            require(success, "ETH rescue failed");
        } else {
            token.safeTransfer(owner(), amount);
        }
    }

    /**
     * @notice Destroy the router and sweep all ETH to the owner.
     */
    function destroy() external onlyOwner {
        selfdestruct(payable(owner()));
    }
}
```

Explanation of key points:

1. **swap**  
   - Differentiates between ETH and ERC-20 sources via `UniERC20.isETH`.  
   - Pulls in tokens (or verifies `msg.value` for ETH), approves the executor, records pre-swap destination balance, calls `caller.callBytes`, and then computes and enforces the minimum return (unless _PARTIAL_FILL is set).  
   - Refunds any leftover source tokens or ETH.

2. **discountedSwap**  
   - Simply wraps `swap` and returns `chiSpent = 0`. No CHI address was supplied in the problem, so no actual CHI burning is performed.

3. **rescueFunds** & **destroy**  
   - Only the owner can rescue arbitrary tokens or ETH, and only the owner can destroy the contract, forwarding remaining ETH to themselves.

This uses only the provided OpenZeppelin and UniERC20 helper libraries, no extra dependencies, and compiles under Solidity 0.6.12.