pragma solidity 0.7.6;

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);
    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );
    event Exchange(address pair, uint256 amountOut, address output);

    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, "Router: EXPIRED");
        _;
    }

    constructor(address _WETH) public {
        WETH = _WETH;
    }

    receive() external payable {
        // allow only WETH contract to send ETH on withdraw
        require(msg.sender == WETH, "Router: only WETH");
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "Router: minReturnAmount must be > 0");
        require(data.length > 0, "Router: data is empty");

        bool srcIsETH = isETH(desc.srcToken);
        // Handle source deposit / approval
        if (srcIsETH) {
            require(msg.value == desc.amount, "Router: msg.value mismatch");
        } else {
            require(msg.value == 0, "Router: msg.value must be zero for ERC20");
            // permit if provided
            _permit(desc.srcToken, desc.amount, desc.permit);
            // pull tokens
            TransferHelper.safeTransferFrom(
                address(desc.srcToken),
                msg.sender,
                address(this),
                desc.amount
            );
            // approve executor
            TransferHelper.safeApprove(
                address(desc.srcToken),
                address(caller),
                desc.amount
            );
        }

        // record balance of destination token before swap
        uint256 balanceBefore = getBalance(desc.dstToken, address(this));

        // execute the swap
        if (srcIsETH) {
            // forward ETH to executor
            caller.callBytes{value: desc.amount}(data);
        } else {
            // ERC20-based swap
            caller.callBytes(data);
        }

        // compute return amount
        uint256 balanceAfter = getBalance(desc.dstToken, address(this));
        returnAmount = balanceAfter.sub(balanceBefore);

        // enforce min return if no partial fill flag
        if ((desc.flags & _PARTIAL_FILL) == 0) {
            require(
                returnAmount >= desc.minReturnAmount,
                "Router: returned too little"
            );
        }

        // transfer output to receiver
        if (isETH(desc.dstToken)) {
            // unwrap or direct ETH
            TransferHelper.safeTransferETH(desc.dstReceiver, returnAmount);
        } else {
            TransferHelper.safeTransfer(
                address(desc.dstToken),
                desc.dstReceiver,
                returnAmount
            );
        }

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            desc.amount,
            returnAmount
        );

        return returnAmount;
    }

    function getBalance(IERC20 token, address account)
        internal
        view
        returns (uint256)
    {
        if (isETH(token)) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    function rescueFunds(address token, uint256 amount)
        external
        onlyOwner
    {
        if (token == ETH_ADDRESS) {
            TransferHelper.safeTransferETH(owner(), amount);
        } else {
            TransferHelper.safeTransfer(token, owner(), amount);
        }
    }
}