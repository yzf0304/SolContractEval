Here is the completed AxpireToken contract, written for Solidity 0.4.20 and strictly following your provided context. It reuses the ERC20 transfer logic for balance‐updates and emits both the ERC20 and ERC223 Transfer events. When sending to a contract, it either calls tokenFallback or a custom fallback via low‐level call:

```solidity
pragma solidity ^0.4.20;

contract Ownable {
    address public owner;
    function Ownable() public {
        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;
    }
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

library SafeMath {
    function mul(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }
    function div(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a / b;
        return c;
    }
    function sub(uint256 a, uint256 b) internal constant returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal constant returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract TokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;
}

contract ERC20 is Ownable {
    using SafeMath for uint256;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function ERC20(
        uint256 _initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[0x2e1977127F682723C778bBcac576A4aF2c0e790d] = _initialSupply;
        totalSupply = _initialSupply;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        name = _tokenName;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        bool status = transferInternal(msg.sender, _to, _value);
        require(status == true);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        if (allowed[_from][msg.sender] < _value) {
            return false;
        }
        bool _success = transferInternal(_from, _to, _value);
        if (_success) {
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        }
        return _success;
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function setBalance(address _holder, uint256 _amount) internal {
        balances[_holder] = _amount;
    }

    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {
        if (_value == 0) {
            Transfer(_from, _to, _value);
            return true;
        }
        if (balances[_from] < _value) {
            return false;
        }
        setBalance(_from, balances[_from].sub(_value));
        setBalance(_to, balances[_to].add(_value));
        Transfer(_from, _to, _value);
        return true;
    }
}

contract ERC223 {
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
}

contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data) public;
}

/**
 * @title AxpireToken
 * @dev ERC20 + ERC223 with optional custom fallback
 */
contract AxpireToken is ERC223, ERC20 {
    uint256 initialSupply = 350000000 * 10**8;
    string tokenName = "aXpire Token";
    string tokenSymbol = "AXP";
    uint8 decimalUnits = 8;

    function AxpireToken() public
      ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol)
    {
        // owner, balances and totalSupply already set in ERC20 constructor,
        // but we re‐assign here to be explicit:
        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;
        balances[owner] = initialSupply;
        totalSupply = initialSupply;
    }

    // Standard ERC223 transfer with data
    function transfer(address to, uint256 value, bytes data) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data);
    }

    // ERC223 transfer with data + custom fallback name
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data, true, customFallback);
    }

    // Override ERC20’s transferFrom to emit ERC223 event if needed
    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(allowed[from][msg.sender] >= value);
        bool ret = transferInternal(from, to, value);
        if (ret) {
            allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);
        }
        return ret;
    }

    // Dispatch to ERC20.transferInternal + ERC223 logic
    function transferInternal(address from, address to, uint256 value) internal returns (bool success) {
        return transferInternal(from, to, value, bytes(""));
    }

    // Dispatch with data
    function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
        return transferInternal(from, to, value, data, false, "");
    }

    // Core transfer: update balances, then if recipient is a contract call fallback
    function transferInternal(
        address from,
        address to,
        uint256 value,
        bytes data,
        bool useCustomFallback,
        string customFallback
    )
        internal
        returns (bool success)
    {
        // 1) balance updates & ERC20 Transfer
        if (!ERC20.transferInternal(from, to, value)) {
            return false;
        }

        // 2) if contract, call tokenFallback or custom
        if (isContract(to)) {
            if (useCustomFallback) {
                bytes4 sig = bytes4(keccak256(bytes(customFallback)));
                require(to.call(sig, from, value, data));
            } else {
                ContractReceiver receiver = ContractReceiver(to);
                receiver.tokenFallback(from, value, data);
            }
        }

        // 3) ERC223 Transfer event
        Transfer(from, to, value, data);
        return true;
    }

    // Simple code‐size check
    function isContract(address _addr) private view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(_addr) }
        return size > 0;
    }
}
```

Explanation of key points:
1. We reuse `ERC20.transferInternal` for all balance updates and the standard 3‐arg `Transfer` event.  
2. We then check `isContract(to)` and invoke either `tokenFallback` or a custom fallback via `to.call(...)`.  
3. Finally we emit the ERC223 4‐param `Transfer` event.  
4. `transferFrom` is overridden to maintain allowances with SafeMath.  
5. No extra contracts or dependencies were introduced—everything is in one file and compiles under 0.4.20.