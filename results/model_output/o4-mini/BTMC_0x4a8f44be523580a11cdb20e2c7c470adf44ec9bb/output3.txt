```solidity
pragma solidity ^0.4.22;

contract BTMC is ERC20, Ownable, Pausable {
    using SafeMath for uint256;

    // Base information of the token
    string public constant name = "MinerCoin";
    string public constant symbol = "BTMC";
    string public constant version = "1.0";
    uint256 public constant decimals = 18;

    // Initial supply for the team
    uint256 public constant INIT_SUPPLY = 100000000 * 10**decimals;
    // Mining supply (not generated in the initial phase)
    uint256 public constant MINING_SUPPLY = 500000000 * 10**decimals;
    // Maximum supply for public funding
    uint256 public constant MAX_FUNDING_SUPPLY = 200000000 * 10**decimals;
    // Team keeping supply
    uint256 public constant TEAM_KEEPING = 200000000 * 10**decimals;
    // Total maximum supply
    uint256 public constant MAX_SUPPLY = INIT_SUPPLY
                                        .add(MINING_SUPPLY)
                                        .add(MAX_FUNDING_SUPPLY)
                                        .add(TEAM_KEEPING);

    // Public funding parameters
    uint256 public totalFundingSupply;
    uint256 public startTime;
    uint256 public endTime;
    uint256 public rate;

    // Team unfreezing parameters
    uint256 public constant TEAM_UNFREEZE = 40000000 * 10**decimals;
    bool public hasOneStepWithdraw;
    bool public hasTwoStepWithdraw;
    bool public hasThreeStepWithdraw;
    bool public hasFourStepWithdraw;
    bool public hasFiveStepWithdraw;

    // ERC20 balances and allowances
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    event CreateBTMC(address indexed _to, uint256 _value);

    /**
     * @notice Constructor initializes the token with the initial supply and funding parameters.
     */
    function BTMC() public {
        totalSupply = INIT_SUPPLY;
        balances[msg.sender] = INIT_SUPPLY;
        Transfer(address(0), msg.sender, INIT_SUPPLY);

        totalFundingSupply = 0;
        startTime = 1524499199; // 2018-04-23 23:59:59 UTC
        endTime   = 1526313600; // 2018-05-15 00:00:00 UTC
        rate      = 5000;

        hasOneStepWithdraw   = false;
        hasTwoStepWithdraw   = false;
        hasThreeStepWithdraw = false;
        hasFourStepWithdraw  = false;
        hasFiveStepWithdraw  = false;
    }

    /**
     * @dev Ensure totalSupply + (_value * _rate) <= MAX_SUPPLY.
     */
    modifier notReachTotalSupply(uint256 _value, uint256 _rate) {
        assert(MAX_SUPPLY >= totalSupply.add(_value.mul(_rate)));
        _;
    }

    /**
     * @dev Ensure totalFundingSupply + (_value * _rate) <= MAX_FUNDING_SUPPLY.
     */
    modifier notReachFundingSupply(uint256 _value, uint256 _rate) {
        assert(MAX_FUNDING_SUPPLY >= totalFundingSupply.add(_value.mul(_rate)));
        _;
    }

    /**
     * @dev Ensure a withdrawal flag is still false.
     */
    modifier assertFalse(bool withdrawStatus) {
        assert(!withdrawStatus);
        _;
    }

    /**
     * @dev Ensure now > targetTime.
     */
    modifier notBeforeTime(uint256 targetTime) {
        assert(now > targetTime);
        _;
    }

    /**
     * @dev Ensure now <= targetTime.
     */
    modifier notAfterTime(uint256 targetTime) {
        assert(now <= targetTime);
        _;
    }

    /**
     * @notice Owner can withdraw all collected ETH.
     */
    function etherProceeds() external onlyOwner {
        owner.transfer(address(this).balance);
    }

    /**
     * @dev Mint tokens, checking MAX_SUPPLY.
     */
    function processFunding(address receiver, uint256 _value, uint256 _rate)
        internal
        notReachTotalSupply(_value, _rate)
    {
        uint256 amount = _value.mul(_rate);
        totalSupply = totalSupply.add(amount);
        balances[receiver] = balances[receiver].add(amount);

        CreateBTMC(receiver, amount);
        Transfer(address(0), receiver, amount);
    }

    /**
     * @dev Handle public funding, checking MAX_FUNDING_SUPPLY.
     */
    function funding(address receiver, uint256 _value, uint256 _rate)
        internal
        whenNotPaused
        notReachFundingSupply(_value, _rate)
    {
        uint256 amount = _value.mul(_rate);
        totalFundingSupply = totalFundingSupply.add(amount);
        processFunding(receiver, _value, _rate);
    }

    /**
     * @notice Fallback function to participate in funding.
     */
    function () payable external
        notBeforeTime(startTime)
        notAfterTime(endTime)
    {
        funding(msg.sender, msg.value, rate);
    }

    /**
     * @notice First tranche of team tokens after 2020-04-23.
     */
    function withdrawForOneStep()
        external
        onlyOwner
        assertFalse(hasOneStepWithdraw)
        notBeforeTime(1587571200) // 2020-04-23 00:00:00 UTC
    {
        uint256 amount = TEAM_UNFREEZE;
        assert(totalSupply.add(amount) <= MAX_SUPPLY);
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);

        CreateBTMC(owner, amount);
        Transfer(address(0), owner, amount);

        hasOneStepWithdraw = true;
    }

    /**
     * @notice Second tranche of team tokens after 2020-10-22.
     */
    function withdrawForTwoStep()
        external
        onlyOwner
        assertFalse(hasTwoStepWithdraw)
        notBeforeTime(1603382400) // 2020-10-22 00:00:00 UTC
    {
        uint256 amount = TEAM_UNFREEZE;
        assert(totalSupply.add(amount) <= MAX_SUPPLY);
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);

        CreateBTMC(owner, amount);
        Transfer(address(0), owner, amount);

        hasTwoStepWithdraw = true;
    }

    /**
     * @notice Third tranche of team tokens after 2021-04-23.
     */
    function withdrawForThreeStep()
        external
        onlyOwner
        assertFalse(hasThreeStepWithdraw)
        notBeforeTime(1619107200) // 2021-04-23 00:00:00 UTC
    {
        uint256 amount = TEAM_UNFREEZE;
        assert(totalSupply.add(amount) <= MAX_SUPPLY);
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);

        CreateBTMC(owner, amount);
        Transfer(address(0), owner, amount);

        hasThreeStepWithdraw = true;
    }

    /**
     * @notice Fourth tranche of team tokens after 2021-10-22.
     */
    function withdrawForFourStep()
        external
        onlyOwner
        assertFalse(hasFourStepWithdraw)
        notBeforeTime(1634918400) // 2021-10-22 00:00:00 UTC
    {
        uint256 amount = TEAM_UNFREEZE;
        assert(totalSupply.add(amount) <= MAX_SUPPLY);
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);

        CreateBTMC(owner, amount);
        Transfer(address(0), owner, amount);

        hasFourStepWithdraw = true;
    }

    /**
     * @notice Fifth tranche of team tokens after 2022-04-23.
     */
    function withdrawForFiveStep()
        external
        onlyOwner
        assertFalse(hasFiveStepWithdraw)
        notBeforeTime(1650643200) // 2022-04-23 00:00:00 UTC
    {
        uint256 amount = TEAM_UNFREEZE;
        assert(totalSupply.add(amount) <= MAX_SUPPLY);
        totalSupply = totalSupply.add(amount);
        balances[owner] = balances[owner].add(amount);

        CreateBTMC(owner, amount);
        Transfer(address(0), owner, amount);

        hasFiveStepWithdraw = true;
    }

    /**
     * @notice Standard ERC20 transfer.
     */
    function transfer(address _to, uint256 _value)
        public
        whenNotPaused
        returns (bool)
    {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @notice Get balance of an address.
     */
    function balanceOf(address _owner)
        public
        view
        returns (uint256)
    {
        return balances[_owner];
    }

    /**
     * @notice Transfer tokens using an allowance.
     */
    function transferFrom(address _from, address _to, uint256 _value)
        public
        whenNotPaused
        returns (bool)
    {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].sub(_value);
        balances[_to]   = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @notice Approve spender to spend tokens.
     */
    function approve(address _spender, uint256 _value)
        public
        whenNotPaused
        returns (bool)
    {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @notice Get remaining allowance.
     */
    function allowance(address _owner, address _spender)
        public
        view
        returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    /**
     * @notice Owner sets a new funding rate.
     */
    function setupFundingRate(uint256 _rate)
        external
        onlyOwner
    {
        rate = _rate;
    }

    /**
     * @notice Owner sets new funding time window.
     */
    function setupFundingTime(uint256 _startTime, uint256 _endTime)
        external
        onlyOwner
    {
        require(_startTime < _endTime);
        startTime = _startTime;
        endTime   = _endTime;
    }
}
```