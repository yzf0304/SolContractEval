```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "./ERC721A.sol";
import "./Ownable.sol";
import "./Strings.sol";

contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;

    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    // tracks number of free mints used per address
    mapping(address => uint8) public NFTPerPublicAddress;

    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    function mint(uint8 _mintAmount) external payable {
        require(!paused, "The contract is paused");
        require(_mintAmount > 0, "Mint amount must be > 0");
        require(_mintAmount <= maxMintAmountPerTx, "Exceeds max per tx");
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");

        uint256 payableAmount = _mintAmount;
        uint8 freeLeft = 0;

        // calculate how many are free for this wallet
        if (NFTPerPublicAddress[msg.sender] < maxFreeMintAmountPerWallet) {
            freeLeft = maxFreeMintAmountPerWallet - NFTPerPublicAddress[msg.sender];
            if (_mintAmount <= freeLeft) {
                payableAmount = 0;
                NFTPerPublicAddress[msg.sender] += _mintAmount;
            } else {
                payableAmount = _mintAmount - freeLeft;
                NFTPerPublicAddress[msg.sender] = maxFreeMintAmountPerWallet;
            }
        }
        uint256 requiredValue = cost * payableAmount;
        require(msg.value >= requiredValue, "Insufficient funds");

        _safeMint(msg.sender, _mintAmount);
    }

    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(_mintAmount > 0, "Reserve amount must be > 0");
        require(totalSupply() + _mintAmount <= maxSupply, "Exceeds max supply");
        _safeMint(_receiver, _mintAmount);
    }

    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        require(_amountPerAddress > 0, "Airdrop amount must be > 0");
        uint256 total = uint256(addresses.length) * _amountPerAddress;
        require(totalSupply() + total <= maxSupply, "Exceeds max supply");
        for (uint256 i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        require(_maxSupply >= totalSupply(), "Can't set below totalSupply");
        maxSupply = _maxSupply;
    }

    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");
        if (!reveal) {
            return hiddenURL;
        }
        return string(abi.encodePacked(uriPrefix, _tokenId.toString(), uriSuffix));
    }

    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    function setHiddenUri(string memory _hiddenUri) external onlyOwner {
        hiddenURL = _hiddenUri;
    }

    function setPaused() external onlyOwner {
        paused = !paused;
    }

    function setCost(uint256 _cost) external onlyOwner {
        cost = _cost;
    }

    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    function withdraw() external onlyOwner {
        uint256 bal = address(this).balance;
        require(bal > 0, "No funds to withdraw");
        (bool success, ) = payable(owner()).call{value: bal}("");
        require(success, "Withdraw failed");
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return uriPrefix;
    }

    receive() external payable {}
}
```

Explanation of key points:

1. **Minting logic**  
   - Enforces `!paused`, per-tx and total supply limits.  
   - Calculates how many free mints the caller still has (`maxFreeMintAmountPerWallet - used`).  
   - Applies the free portion then charges `cost` for the remainder.  
   - Updates `NFTPerPublicAddress` only for the free portion.

2. **Owner functions**  
   - `Reserve` and `Airdrop` mint directly, ensuring the total never exceeds `maxSupply`.  
   - Parameter setters (`setCost`, `setMaxSupply`, etc.) are all `onlyOwner`.  
   - `setPaused` and `setRevealed` flip their respective booleans.  

3. **Token URI**  
   - While `reveal == false` it returns the single `hiddenURL`.  
   - After reveal it concatenates `uriPrefix + tokenId + uriSuffix`.  

4. **Withdraw**  
   - Allows only the owner to drain the contract balance safely.  

This contract strictly follows the provided context and uses Solidity 0.8.7.