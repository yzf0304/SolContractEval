```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "./ERC721A.sol";
import "./Ownable.sol";
import "./Strings.sol";

contract BankruptFTXYachtClub is ERC721A, Ownable {
    using Strings for uint256;

    string private uriPrefix;
    string private uriSuffix = ".json";
    string public hiddenURL;

    uint256 public cost = 0.0025 ether;
    uint16 public maxSupply = 6969;
    uint8 public maxMintAmountPerTx = 21;
    uint8 public maxFreeMintAmountPerWallet = 1;

    bool public paused = true;
    bool public reveal = false;

    // Tracks how many free mints each address has used
    mapping(address => uint8) public NFTPerPublicAddress;

    constructor() ERC721A("Bankrupt FTX Yacht Club", "BFTX") {}

    /**
     * @notice Public mint function with a single free mint per wallet.
     */
    function mint(uint8 _mintAmount) external payable {
        require(!paused, "Contract is paused");
        require(_mintAmount > 0, "Mint amount must be > 0");
        require(_mintAmount <= maxMintAmountPerTx, "Exceeds max per tx");
        uint256 supply = totalSupply();
        require(supply + _mintAmount <= maxSupply, "Exceeds max supply");

        // Calculate how many are free
        uint8 usedFree = NFTPerPublicAddress[msg.sender];
        uint8 freeLeft = 0;
        if (usedFree < maxFreeMintAmountPerWallet) {
            freeLeft = maxFreeMintAmountPerWallet - usedFree;
        }

        uint8 freeCount = _mintAmount <= freeLeft ? _mintAmount : freeLeft;
        uint8 paidCount = _mintAmount - freeCount;
        uint256 requiredValue = cost * paidCount;
        require(msg.value >= requiredValue, "Insufficient ETH sent");

        // Record free mints used
        if (freeCount > 0) {
            NFTPerPublicAddress[msg.sender] = usedFree + freeCount;
        }

        // Mint tokens
        _safeMint(msg.sender, _mintAmount);

        // Refund any excess ETH
        if (msg.value > requiredValue) {
            payable(msg.sender).transfer(msg.value - requiredValue);
        }
    }

    /**
     * @notice Owner can reserve NFTs for a given receiver.
     */
    function Reserve(uint16 _mintAmount, address _receiver) external onlyOwner {
        require(_mintAmount > 0, "Must mint at least 1");
        uint256 supply = totalSupply();
        require(supply + _mintAmount <= maxSupply, "Exceeds max supply");
        _safeMint(_receiver, _mintAmount);
    }

    /**
     * @notice Owner can airdrop NFTs to multiple addresses.
     */
    function Airdrop(uint8 _amountPerAddress, address[] calldata addresses) external onlyOwner {
        require(_amountPerAddress > 0, "Must airdrop at least 1");
        uint256 totalToMint = uint256(addresses.length) * _amountPerAddress;
        uint256 supply = totalSupply();
        require(supply + totalToMint <= maxSupply, "Exceeds max supply");

        for (uint256 i = 0; i < addresses.length; i++) {
            _safeMint(addresses[i], _amountPerAddress);
        }
    }

    /**
     * @notice Owner can update maxSupply (cannot set below current supply).
     */
    function setMaxSupply(uint16 _maxSupply) external onlyOwner {
        require(_maxSupply >= totalSupply(), "Cannot set below totalSupply");
        maxSupply = _maxSupply;
    }

    /**
     * @notice Token URI logic with hidden/revealed state.
     */
    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");
        if (!reveal) {
            return hiddenURL;
        }
        string memory base = _baseURI();
        return string(abi.encodePacked(base, _tokenId.toString(), uriSuffix));
    }

    /**
     * @notice Owner can set max free mints per wallet.
     */
    function setFreeMaxLimitPerAddress(uint8 _limit) external onlyOwner {
        maxFreeMintAmountPerWallet = _limit;
    }

    /**
     * @notice Owner can set URI prefix.
     */
    function setUriPrefix(string memory _uriPrefix) external onlyOwner {
        uriPrefix = _uriPrefix;
    }

    /**
     * @notice Owner can set hidden URI.
     */
    function setHiddenUri(string memory _hiddenUri) external onlyOwner {
        hiddenURL = _hiddenUri;
    }

    /**
     * @notice Owner can toggle paused state.
     */
    function setPaused() external onlyOwner {
        paused = !paused;
    }

    /**
     * @notice Owner can set mint cost.
     */
    function setCost(uint256 _cost) external onlyOwner {
        cost = _cost;
    }

    /**
     * @notice Owner can toggle reveal.
     */
    function setRevealed() external onlyOwner {
        reveal = !reveal;
    }

    /**
     * @notice Owner can set max mint amount per transaction.
     */
    function setMaxMintAmountPerTx(uint8 _maxtx) external onlyOwner {
        maxMintAmountPerTx = _maxtx;
    }

    /**
     * @notice Owner can withdraw contract balance.
     */
    function withdraw() external onlyOwner {
        uint256 bal = address(this).balance;
        require(bal > 0, "Nothing to withdraw");
        (bool success, ) = payable(owner()).call{value: bal}("");
        require(success, "Withdraw failed");
    }

    /**
     * @notice Base URI for computing {tokenURI}.
     */
    function _baseURI() internal view override returns (string memory) {
        return uriPrefix;
    }

    /**
     * @notice Receive function to accept ETH.
     */
    receive() external payable {}
}
```

Explanation of key points:

1. **Mint Logic**  
   - Checks `paused`, `_mintAmount` bounds, and max supply.  
   - Allows up to `maxFreeMintAmountPerWallet` free mints per address.  
   - Calculates number of free vs. paid mints, validates `msg.value` for paid portion, refunds any excess, and tracks free mints used.  

2. **Reserve & Airdrop**  
   - Owner-only functions that ensure the total supply stays within `maxSupply`.  
   - `Reserve` mints a specified amount to a single address; `Airdrop` distributes a fixed amount to each address in a list.  

3. **Configuration**  
   - Owner can update `maxSupply`, free mint limit, cost, URI prefix/suffix, hidden URI, paused/reveal toggles, and per-transaction mint limits.  

4. **tokenURI**  
   - Returns a single hidden URI when `reveal` is `false`; once toggled, it concatenates `uriPrefix + tokenId + uriSuffix`.  

5. **Withdrawal**  
   - Owner can pull all ETH from the contract with proper safety checks.  

All code strictly follows Solidity 0.8.7, extends `ERC721A` & `Ownable`, and uses only the supplied utilities.