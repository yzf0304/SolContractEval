```solidity
pragma solidity ^0.4.18;

/**
 *Submitted for verification at Etherscan.io on 2018-01-23
*/

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  function Ownable() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

/**
 *  Assume CappedToken is the OpenZeppelin CappedToken which
 *  inherits MintableToken and has mint/finishMinting, plus
 *  totalSupply, cap.
 */
contract CappedToken {
  using SafeMath for uint256;
  uint256 public cap;
  uint256 public totalSupply;
  mapping(address => uint256) public balanceOf;
  bool public mintingFinished = false;
  event Mint(address indexed to, uint256 amount);
  event MintFinished();

  modifier canMint() {
    require(!mintingFinished);
    _;
  }

  function CappedToken(uint256 _cap) public {
    require(_cap > 0);
    cap = _cap;
  }

  function mint(address _to, uint256 _amount) public canMint returns (bool) {
    require(totalSupply.add(_amount) <= cap);
    totalSupply = totalSupply.add(_amount);
    balanceOf[_to] = balanceOf[_to].add(_amount);
    Mint(_to, _amount);
    return true;
  }

  function finishMinting() public canMint returns (bool) {
    mintingFinished = true;
    MintFinished();
    return true;
  }
}

contract BeatToken is CappedToken {
  string public constant name = "BEAT Token";
  string public constant symbol = "BEAT";
  uint8 public constant decimals = 18;

  function BeatToken(uint256 _cap) CappedToken(_cap) public {}
  function getTotalSupply() public view returns (uint256) {
    return totalSupply;
  }
}

/**
 * @notice This contract is a crowdsale for BeatToken, which includes different ICO phases with varying bonus percentages.
 */
contract BeatTokenCrowdsale is Ownable {
  using SafeMath for uint256;

  enum Stages {
    Deployed,
    PreIco,
    IcoPhase1,
    IcoPhase2,
    IcoPhase3,
    IcoEnded,
    Finalized
  }
  Stages public stage;

  BeatToken public token;

  uint256 public contractStartTime;
  uint256 public preIcoEndTime;
  uint256 public icoPhase1EndTime;
  uint256 public icoPhase2EndTime;
  uint256 public icoPhase3EndTime;
  uint256 public contractEndTime;

  address public ethTeamWallet;
  address public beatTeamWallet;

  uint256 public ethWeiRaised;
  mapping(address => uint256) public balanceOf;

  uint public constant PRE_ICO_PERIOD   = 28 days;
  uint public constant ICO_PHASE1_PERIOD = 28 days;
  uint public constant ICO_PHASE2_PERIOD = 28 days;
  uint public constant ICO_PHASE3_PERIOD = 28 days;

  uint256 public constant PRE_ICO_BONUS_PERCENTAGE    = 100;
  uint256 public constant ICO_PHASE1_BONUS_PERCENTAGE = 75;
  uint256 public constant ICO_PHASE2_BONUS_PERCENTAGE = 50;
  uint256 public constant ICO_PHASE3_BONUS_PERCENTAGE = 25;

  uint256 public constant PRE_ICO_AMOUNT    = 5000 * (10 ** 6) * (10 ** 18);
  uint256 public constant ICO_PHASE1_AMOUNT = 7000 * (10 ** 6) * (10 ** 18);
  uint256 public constant ICO_PHASE2_AMOUNT = 10500 * (10 ** 6) * (10 ** 18);
  uint256 public constant ICO_PHASE3_AMOUNT = 11875 * (10 ** 6) * (10 ** 18);

  uint256 public constant PRE_ICO_LIMIT    = PRE_ICO_AMOUNT;
  uint256 public constant ICO_PHASE1_LIMIT = PRE_ICO_LIMIT.add(ICO_PHASE1_AMOUNT);
  uint256 public constant ICO_PHASE2_LIMIT = ICO_PHASE1_LIMIT.add(ICO_PHASE2_AMOUNT);
  uint256 public constant ICO_PHASE3_LIMIT = ICO_PHASE2_LIMIT.add(ICO_PHASE3_AMOUNT);

  uint256 public constant HARD_CAP = 230 * (10 ** 9) * (10 ** 18);

  uint256 public ethPriceInEuroCent;

  event BeatTokenPurchased(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 ethWeiAmount,
    uint256 beatWeiAmount
  );
  event BeatTokenEthPriceChanged(uint256 newPrice);
  event BeatTokenPreIcoStarted();
  event BeatTokenIcoPhase1Started();
  event BeatTokenIcoPhase2Started();
  event BeatTokenIcoPhase3Started();
  event BeatTokenIcoFinalized();

  function BeatTokenCrowdsale(address _ethTeamWallet, address _beatTeamWallet) public {
    require(_ethTeamWallet != address(0));
    require(_beatTeamWallet != address(0));

    token = new BeatToken(HARD_CAP);
    stage = Stages.Deployed;

    ethTeamWallet  = _ethTeamWallet;
    beatTeamWallet = _beatTeamWallet;
    ethPriceInEuroCent = 0;

    contractStartTime  = 0;
    preIcoEndTime      = 0;
    icoPhase1EndTime   = 0;
    icoPhase2EndTime   = 0;
    icoPhase3EndTime   = 0;
    contractEndTime    = 0;
  }

  function setEtherPriceInEuroCent(uint256 _ethPriceInEuroCent) onlyOwner public {
    require(_ethPriceInEuroCent > 0);
    ethPriceInEuroCent = _ethPriceInEuroCent;
    BeatTokenEthPriceChanged(_ethPriceInEuroCent);
  }

  function start() onlyOwner public {
    require(stage == Stages.Deployed);
    require(ethPriceInEuroCent > 0);

    stage = Stages.PreIco;
    contractStartTime = now;
    preIcoEndTime     = now.add(PRE_ICO_PERIOD);
    icoPhase1EndTime  = preIcoEndTime.add(ICO_PHASE1_PERIOD);
    icoPhase2EndTime  = icoPhase1EndTime.add(ICO_PHASE2_PERIOD);
    icoPhase3EndTime  = icoPhase2EndTime.add(ICO_PHASE3_PERIOD);
    contractEndTime   = icoPhase3EndTime;

    BeatTokenPreIcoStarted();
  }

  function finalize() onlyOwner public {
    require(stage != Stages.Finalized);
    require(now > contractEndTime || token.totalSupply() >= ICO_PHASE3_LIMIT);

    stage = Stages.Finalized;

    // Mint unsold tokens to beat team wallet
    uint256 unsold = HARD_CAP.sub(token.totalSupply());
    if (unsold > 0) {
      token.mint(beatTeamWallet, unsold);
    }
    token.finishMinting();

    // Transfer all ETH to eth team wallet
    ethTeamWallet.transfer(this.balance);

    BeatTokenIcoFinalized();
  }

  function() payable public {
    buyTokens(msg.sender);
  }

  function buyTokens(address beneficiary) payable public {
    require(isWithinValidIcoPhase());
    require(beneficiary != address(0));
    require(msg.value > 0);
    require(ethPriceInEuroCent > 0);

    uint256 beatWeiAmount = calculateBeatWeiAmount(msg.value);
    require(isWithinTokenAllocLimit(beatWeiAmount));

    // advance stage if needed
    determineCurrentStage(beatWeiAmount);

    // Mint tokens
    token.mint(beneficiary, beatWeiAmount);

    // track
    ethWeiRaised = ethWeiRaised.add(msg.value);
    balanceOf[beneficiary] = balanceOf[beneficiary].add(beatWeiAmount);

    // forward ETH
    ethTeamWallet.transfer(msg.value);

    BeatTokenPurchased(msg.sender, beneficiary, msg.value, beatWeiAmount);
  }

  function isWithinValidIcoPhase() internal view returns (bool) {
    return (
      stage == Stages.PreIco ||
      stage == Stages.IcoPhase1 ||
      stage == Stages.IcoPhase2 ||
      stage == Stages.IcoPhase3
    );
  }

  function calculateBeatWeiAmount(uint256 ethWeiAmount) internal view returns (uint256) {
    // base: 1 ETH (1e18 wei) * priceInEuroCent  => euro cents * 1e18 tokens
    uint256 baseAmount = ethWeiAmount.mul(ethPriceInEuroCent);

    uint256 bonusPercent = 0;
    if (stage == Stages.PreIco) {
      bonusPercent = PRE_ICO_BONUS_PERCENTAGE;
    } else if (stage == Stages.IcoPhase1) {
      bonusPercent = ICO_PHASE1_BONUS_PERCENTAGE;
    } else if (stage == Stages.IcoPhase2) {
      bonusPercent = ICO_PHASE2_BONUS_PERCENTAGE;
    } else if (stage == Stages.IcoPhase3) {
      bonusPercent = ICO_PHASE3_BONUS_PERCENTAGE;
    }

    // apply bonus: total = base * (100 + bonus) / 100
    uint256 totalWithBonus = baseAmount.mul(uint256(100).add(bonusPercent)).div(100);
    return totalWithBonus;
  }

  function isWithinTokenAllocLimit(uint256 beatWeiAmount) internal view returns (bool) {
    uint256 newSupply = token.totalSupply().add(beatWeiAmount);
    if (stage == Stages.PreIco) {
      return newSupply <= PRE_ICO_LIMIT;
    }
    if (stage == Stages.IcoPhase1) {
      return newSupply <= ICO_PHASE1_LIMIT;
    }
    if (stage == Stages.IcoPhase2) {
      return newSupply <= ICO_PHASE2_LIMIT;
    }
    if (stage == Stages.IcoPhase3) {
      return newSupply <= ICO_PHASE3_LIMIT;
    }
    return false;
  }

  function determineCurrentStage(uint256 beatWeiAmount) internal {
    // PreIco -> IcoPhase1
    if (stage == Stages.PreIco) {
      if (token.totalSupply().add(beatWeiAmount) > PRE_ICO_LIMIT || now > preIcoEndTime) {
        stage = Stages.IcoPhase1;
        BeatTokenIcoPhase1Started();
      }
    }
    // IcoPhase1 -> IcoPhase2
    if (stage == Stages.IcoPhase1) {
      if (token.totalSupply().add(beatWeiAmount) > ICO_PHASE1_LIMIT || now > icoPhase1EndTime) {
        stage = Stages.IcoPhase2;
        BeatTokenIcoPhase2Started();
      }
    }
    // IcoPhase2 -> IcoPhase3
    if (stage == Stages.IcoPhase2) {
      if (token.totalSupply().add(beatWeiAmount) > ICO_PHASE2_LIMIT || now > icoPhase2EndTime) {
        stage = Stages.IcoPhase3;
        BeatTokenIcoPhase3Started();
      }
    }
    // IcoPhase3 -> Ended
    if (stage == Stages.IcoPhase3) {
      if (token.totalSupply().add(beatWeiAmount) >= ICO_PHASE3_LIMIT || now > icoPhase3EndTime) {
        stage = Stages.IcoEnded;
      }
    }
  }
}
```