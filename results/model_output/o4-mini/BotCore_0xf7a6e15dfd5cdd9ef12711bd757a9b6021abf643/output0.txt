Below is the completed BotMinting contract. It honors the promo/gen0 limits, uses the COO as the default promo‐owner, computes the next gen0 price from the running average (with a floor), mints bots via the inherited _createBot, approves the sale‐auction to move the newly minted gen0, and then starts the auction:

```solidity
pragma solidity ^0.4.20;

contract BotMinting is BotAuction {

    uint256 public constant PROMO_CREATION_LIMIT   = 5000;
    uint256 public constant GEN0_CREATION_LIMIT    = 45000;
    uint256 public constant GEN0_STARTING_PRICE    = 10 finney;
    uint256 public constant GEN0_AUCTION_DURATION  = 1 days;

    uint256 public promoCreatedCount;
    uint256 public gen0CreatedCount;

    /**
     * @notice Creates a promo bot with the specified genes and assigns it to an owner.
     * @dev Only the COO can call this function. The bot owner defaults to the COO if not specified.
     * @param _genes The genetic makeup of the bot.
     * @param _owner The address of the owner of the new bot.
     */
    function createPromoBot(uint256 _genes, address _owner) external onlyCOO {
        require(promoCreatedCount < PROMO_CREATION_LIMIT);

        address botOwner = _owner;
        if (botOwner == address(0)) {
            botOwner = cooAddress;
        }

        promoCreatedCount++;
        // matronId = 0, sireId = 0, generation = 0
        _createBot(0, 0, 0, _genes, botOwner);
    }

    /**
     * @notice Creates a Gen0 bot with the specified genes and starts an auction for it.
     * @dev Only the COO can call this function. The bot is initially owned by the contract and then put up for auction.
     * @param _genes The genetic makeup of the bot.
     */
    function createGen0Auction(uint256 _genes) external onlyCOO {
        require(gen0CreatedCount < GEN0_CREATION_LIMIT);

        // Mint the Gen0 bot directly into this contract
        uint256 botId = _createBot(0, 0, 0, _genes, this);
        gen0CreatedCount++;

        // Compute starting price and approve the auction contract to take custody
        uint256 startingPrice = _computeNextGen0Price();
        _approve(botId, saleAuction);

        // Launch a descending‐price auction: from startingPrice down to GEN0_STARTING_PRICE
        saleAuction.createAuction(
            botId,
            startingPrice,
            GEN0_STARTING_PRICE,
            GEN0_AUCTION_DURATION,
            this
        );
    }

    /**
     * @notice Computes the next price for a Gen0 bot based on the average sale price.
     * @dev The price is average + 50% of average, floored at GEN0_STARTING_PRICE.
     * @return nextGen0Price The next sale price for a Gen0 bot.
     */
    function _computeNextGen0Price() internal view returns (uint256 nextGen0Price) {
        uint256 avgPrice = saleAuction.averageGen0SalePrice();
        nextGen0Price = avgPrice + (avgPrice / 2);
        if (nextGen0Price < GEN0_STARTING_PRICE) {
            nextGen0Price = GEN0_STARTING_PRICE;
        }
    }
}
```

Explanation of the key points:

• Promo bots  
  – Enforced by `require(promoCreatedCount < PROMO_CREATION_LIMIT)`.  
  – Defaults `_owner` → `cooAddress` when passed in as `0x0`.  
  – Uses `_createBot(0,0,0,genes,owner)` to mint.  

• Gen0 bots  
  – Enforced by `require(gen0CreatedCount < GEN0_CREATION_LIMIT)`.  
  – Minted into `this` contract, so we own them immediately.  
  – We then call `_approve(botId, saleAuction)` so the auction can escrow the token.  
  – `saleAuction.createAuction(...)` starts a descending auction from the computed `startingPrice` down to a floor of `GEN0_STARTING_PRICE` over `GEN0_AUCTION_DURATION`.  

• Price formula  
  – Retrieves the 5‐sale moving average via `averageGen0SalePrice()`.  
  – Marks up by 50% (`avg + avg/2`).  
  – If that markup is below the floor (`GEN0_STARTING_PRICE`), it uses the floor instead.