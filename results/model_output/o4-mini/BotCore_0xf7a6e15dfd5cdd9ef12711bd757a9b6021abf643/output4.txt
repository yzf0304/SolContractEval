Here is the completed BotMinting contract. It strictly follows the style and logic of the surrounding CryptoBots contracts and is written for Solidity 0.4.20:

```solidity
pragma solidity ^0.4.20;

contract BotMinting is BotAuction {

    uint256 public constant PROMO_CREATION_LIMIT = 5000;
    uint256 public constant GEN0_CREATION_LIMIT = 45000;
    uint256 public constant GEN0_STARTING_PRICE = 10 finney;
    uint256 public constant GEN0_AUCTION_DURATION = 1 days;

    uint256 public promoCreatedCount;
    uint256 public gen0CreatedCount;

    /**
     * @notice Creates a promo bot with the specified genes and assigns it to an owner.
     * @dev Only the COO can call this function. The bot owner defaults to the COO if not specified.
     * @param _genes The genetic makeup of the bot.
     * @param _owner The address of the owner of the new bot.
     */
    function createPromoBot(uint256 _genes, address _owner) 
        external 
        onlyCOO 
    {
        require(promoCreatedCount < PROMO_CREATION_LIMIT);

        address botOwner = _owner;
        if (botOwner == address(0)) {
            botOwner = cooAddress;
        }

        promoCreatedCount++;
        _createBot(
            0,        // matronId
            0,        // sireId
            0,        // generation
            _genes,   // genes
            botOwner  // owner
        );
    }

    /**
     * @notice Creates a Gen0 bot with the specified genes and starts an auction for it.
     * @dev Only the COO can call this function. The bot is initially owned by the contract.
     * @param _genes The genetic makeup of the bot.
     */
    function createGen0Auction(uint256 _genes) 
        external 
        onlyCOO 
    {
        require(gen0CreatedCount < GEN0_CREATION_LIMIT);

        // Mint the Gen0 bot to this contract
        uint256 botId = _createBot(
            0,           // matronId
            0,           // sireId
            0,           // generation
            _genes,      // genes
            address(this) // owner
        );

        // approve the auction to transfer this bot
        _approve(botId, saleAuction);

        // compute a suitable starting price and kick off the auction
        uint256 startPrice = _computeNextGen0Price();
        saleAuction.createAuction(
            botId,
            startPrice,
            0,
            GEN0_AUCTION_DURATION,
            address(this)
        );

        gen0CreatedCount++;
    }

    /**
     * @notice Computes the next price for a Gen0 bot based on the average sale price.
     * @dev Price = averageGen0SalePrice + 50% of that. Never below GEN0_STARTING_PRICE.
     * @return The next price for a Gen0 bot.
     */
    function _computeNextGen0Price() 
        internal 
        view 
        returns (uint256) 
    {
        uint256 avgPrice = saleAuction.averageGen0SalePrice();
        uint256 nextPrice = avgPrice + (avgPrice / 2);
        if (nextPrice < GEN0_STARTING_PRICE) {
            nextPrice = GEN0_STARTING_PRICE;
        }
        return nextPrice;
    }
}
```

Explanation of key points:

1. **createPromoBot**  
   - Checks the promo limit.  
   - Defaults `_owner` to the COO if zero.  
   - Increments `promoCreatedCount` and calls the internal `_createBot`.

2. **createGen0Auction**  
   - Checks the Gen0 mint limit.  
   - Mints the bot to the minting contract itself (`address(this)`).  
   - Approves the sale auction to transfer the token.  
   - Computes a dynamic starting price via `_computeNextGen0Price`.  
   - Opens a descending‐price auction (`endingPrice = 0`) for `1 days`.  
   - Increments `gen0CreatedCount`.

3. **_computeNextGen0Price**  
   - Pulls the 5‐sale moving average from `saleAuction.averageGen0SalePrice()`.  
   - Adds 50% on top.  
   - Ensures the result never dips below the fixed `GEN0_STARTING_PRICE`.