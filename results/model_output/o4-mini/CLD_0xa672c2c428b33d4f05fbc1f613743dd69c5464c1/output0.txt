```solidity
pragma solidity 0.5.17;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {
        c = a + b;
        require(c >= a, "SafeMath: addition overflow");
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b <= a, "SafeMath: subtraction overflow");
        c = a - b;
    }
}

contract Variable {
    string  public name;
    string  public symbol;
    uint256 public decimals;
    uint256 public totalSupply;
    address public owner;

    uint256 internal _decimals;
    bool    internal transferLock;

    mapping(address => bool)           public allowedAddress;
    mapping(address => bool)           public blockedAddress;
    mapping(address => uint256)        public balanceOf;
    mapping(address => mapping(address => uint256)) internal allowed;

    constructor() public {
        name       = "Celloud";
        symbol     = "CLD";
        decimals   = 18;
        _decimals  = 10 ** uint256(decimals);
        totalSupply = _decimals * 1000000000;
        transferLock = true;
        owner = msg.sender;
        balanceOf[owner] = totalSupply;
        allowedAddress[owner] = true;
    }
}

contract Modifiers is Variable {
    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }
}

contract Event {
    event Transfer(address indexed from, address indexed to, uint256 value);
    event TokenBurn(address indexed from, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract Admin is Variable, Modifiers, Event {
    using SafeMath for uint256;

    /**
     * @notice Allows the owner to burn a specified amount of tokens from their balance.
     * @param _value The amount of tokens to be burned.
     * @return success A boolean indicating whether the operation was successful.
     */
    function tokenBurn(uint256 _value) public isOwner returns (bool success) {
        require(balanceOf[msg.sender] >= _value, "Admin: insufficient balance to burn");
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        emit TokenBurn(msg.sender, _value);
        return true;
    }

    /**
     * @notice Allows the owner to add an address to the list of allowed addresses.
     * @param _address The address to be added to the allowed list.
     */
    function addAllowedAddress(address _address) public isOwner {
        allowedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of allowed addresses.
     * @param _address The address to be removed from the allowed list.
     */
    function deleteAllowedAddress(address _address) public isOwner {
        require(_address != owner, "Admin: cannot remove owner from allowed list");
        allowedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to add an address to the list of blocked addresses.
     * @param _address The address to be added to the blocked list.
     */
    function addBlockedAddress(address _address) public isOwner {
        require(_address != owner, "Admin: cannot block owner");
        blockedAddress[_address] = true;
    }

    /**
     * @notice Allows the owner to remove an address from the list of blocked addresses.
     * @param _address The address to be removed from the blocked list.
     */
    function deleteBlockedAddress(address _address) public isOwner {
        blockedAddress[_address] = false;
    }

    /**
     * @notice Allows the owner to set or unset the transfer lock.
     * @param _transferLock The new state of the transfer lock.
     * @return success A boolean indicating whether the operation was successful.
     */
    function setTransferLock(bool _transferLock) public isOwner returns (bool success) {
        transferLock = _transferLock;
        return true;
    }
}
```