pragma solidity ^0.4.18;

/**
 * @title owned
 * @dev Basic contract to define an owner.
 */
contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

/**
 * @dev Minimal ERC20 interface for transferFrom.
 */
interface token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}

/**
 * @notice A smart contract to manage and control the locking and unlocking of CZR tokens.
 * @dev This contract allows the owner to add, remove, and unlock CZR token locks. It also includes functionality to withdraw ETH.
 */
contract CZRLocker is owned {
    /**
     * @notice Emitted when a new lock is added.
     * @param addr The address for which the lock is added.
     * @param index The index of the lock.
     * @param startLockTime The time when the lock starts.
     * @param lockMonth The duration of the lock in months.
     * @param lockedAmount The amount of CZR tokens that are locked.
     */
    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);

    /**
     * @notice Emitted when a lock is removed.
     * @param addr The address for which the lock is removed.
     * @param index The index of the lock.
     */
    event RemoveLock(address addr, uint index);

    /**
     * @notice Emitted when a lock is unlocked.
     * @param addr The address for which the lock is unlocked.
     * @param index The index of the lock.
     * @param unlockAmount The amount of CZR tokens that are unlocked.
     */
    event Unlock(address addr, uint index, uint unlockAmount);

    /**
     * @notice The address of the CZR token.
     */
    address public tokenAddr;

    /**
     * @notice The address of the unlocker.
     */
    address public unlocker;

    /**
     * @dev Structure to store the details of a locked CZR.
     */
    struct LockedCZR {
        uint startLockTime;
        uint lockMonth;
        uint lockedAmount;
        uint unlockedAmount;
    }

    /**
     * @dev Mapping from an address to an array of its locked CZR details.
     */
    mapping(address => LockedCZR[]) public lockedCZRMap;

    /**
     * @notice Constructor to initialize the contract with the token address and unlocker address.
     * @param _tokenAddr The address of the CZR token.
     * @param _unlocker The address of the unlocker.
     */
    function CZRLocker(address _tokenAddr, address _unlocker) public {
        require(_tokenAddr != address(0));
        require(_unlocker != address(0));
        tokenAddr = _tokenAddr;
        unlocker = _unlocker;
    }

    /**
     * @notice Removes a CZR lock by setting all fields to zero.
     * @param addr The address for which the lock is to be removed.
     * @param index The index of the lock to be removed.
     */
    function removeCZRLock(address addr, uint index) onlyOwner public {
        LockedCZR[] storage locks = lockedCZRMap[addr];
        require(index < locks.length);
        locks[index].startLockTime = 0;
        locks[index].lockMonth     = 0;
        locks[index].lockedAmount  = 0;
        locks[index].unlockedAmount= 0;
        emit RemoveLock(addr, index);
    }

    /**
     * @notice Adds a new CZR lock.
     * @param addr The address for which the lock is to be added.
     * @param startLockTime The time when the lock starts (0 for now).
     * @param amount The amount of CZR tokens to be locked.
     * @param lockMonth The duration of the lock in months.
     */
    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public {
        require(addr != address(0));
        require(amount > 0);
        require(lockMonth > 0);

        uint slt = startLockTime == 0 ? now : startLockTime;
        LockedCZR memory newLock = LockedCZR({
            startLockTime: slt,
            lockMonth:     lockMonth,
            lockedAmount:  amount,
            unlockedAmount: 0
        });

        lockedCZRMap[addr].push(newLock);
        uint idx = lockedCZRMap[addr].length - 1;

        // Transfer tokens from owner (msg.sender) into this contract
        require(token(tokenAddr).transferFrom(msg.sender, this, amount));

        emit AddLock(addr, idx, slt, lockMonth, amount);
    }

    /**
     * @dev Unlocks CZR tokens for a user based on lock duration.
     * @param addr Address of the user whose tokens are being unlocked.
     * @param limit Maximum number of locks to process (0 for unlimited).
     */
    function unlockCZR(address addr, uint limit) public {
        require(msg.sender == owner || msg.sender == unlocker);
        LockedCZR[] storage locks = lockedCZRMap[addr];
        uint len = locks.length;
        require(len > 0);

        uint processed = 0;
        for (uint i = 0; i < len; i++) {
            if (limit != 0 && processed >= limit) {
                break;
            }

            LockedCZR storage lc = locks[i];

            // skip removed locks or those not started yet
            if (lc.startLockTime == 0 || lc.lockMonth == 0 || now < lc.startLockTime) {
                continue;
            }

            // calculate how many full months have passed
            uint monthsElapsed = (now - lc.startLockTime) / 30 days;
            if (monthsElapsed > lc.lockMonth) {
                monthsElapsed = lc.lockMonth;
            }

            // total amount that should be unlocked by now
            uint totalUnlockable = lc.lockedAmount * monthsElapsed / lc.lockMonth;
            if (totalUnlockable <= lc.unlockedAmount) {
                continue;
            }

            // newly unlockable amount
            uint amount = totalUnlockable - lc.unlockedAmount;
            lc.unlockedAmount = totalUnlockable;

            // transfer unlocked tokens from this contract to user
            require(token(tokenAddr).transferFrom(this, addr, amount));

            emit Unlock(addr, i, amount);
            processed++;
        }
    }

    /**
     * @notice Withdraws ETH to a specified address.
     * @param to The address to receive the ETH.
     * @param value The amount of ETH to be transferred.
     */
    function withdrawEth(address to, uint256 value) onlyOwner public {
        require(to != address(0));
        to.transfer(value);
    }

    /**
     * @notice Fallback function to receive ETH.
     */
    function() payable public {
    }
}