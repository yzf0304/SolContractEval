```solidity
pragma solidity ^0.4.18;

contract CZRLocker is owned {
    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);
    event RemoveLock(address addr, uint index);
    event Unlock(address addr, uint index, uint unlockAmount);

    address public tokenAddr;
    address public unlocker;

    struct LockedCZR {
        uint startLockTime;
        uint lockMonth;
        uint lockedAmount;
        uint unlockedAmount;
    }

    mapping(address => LockedCZR[]) public lockedCZRMap;

    function CZRLocker(address _tokenAddr, address _unlocker) public {
        tokenAddr = _tokenAddr;
        unlocker = _unlocker;
    }

    function removeCZRLock(address addr, uint index) onlyOwner public {
        require(index < lockedCZRMap[addr].length);
        delete lockedCZRMap[addr][index];
        RemoveLock(addr, index);
    }

    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth)
        onlyOwner
        public
    {
        if (startLockTime == 0) {
            startLockTime = now;
        }
        uint idx = lockedCZRMap[addr].length;
        lockedCZRMap[addr].push(
            LockedCZR({
                startLockTime: startLockTime,
                lockMonth: lockMonth,
                lockedAmount: amount,
                unlockedAmount: 0
            })
        );
        AddLock(addr, idx, startLockTime, lockMonth, amount);
    }

    function unlockCZR(address addr, uint limit) public {
        require(msg.sender == owner || msg.sender == unlocker);
        LockedCZR[] storage locks = lockedCZRMap[addr];
        uint len = locks.length;
        require(len > 0);

        uint processed = 0;
        for (uint i = 0; i < len; i++) {
            if (limit != 0 && processed >= limit) {
                break;
            }

            LockedCZR storage lc = locks[i];
            if (lc.lockedAmount == 0 || lc.unlockedAmount >= lc.lockedAmount) {
                continue;
            }

            uint elapsed = now > lc.startLockTime ? now - lc.startLockTime : 0;
            uint monthsPassed = elapsed / 30 days;
            if (monthsPassed > lc.lockMonth) {
                monthsPassed = lc.lockMonth;
            }

            uint totalUnlockedShould = (lc.lockedAmount * monthsPassed) / lc.lockMonth;
            if (totalUnlockedShould <= lc.unlockedAmount) {
                continue;
            }

            uint unlockAmt = totalUnlockedShould - lc.unlockedAmount;
            lc.unlockedAmount += unlockAmt;

            // transfer unlocked tokens from this contract to user
            token(tokenAddr).transferFrom(this, addr, unlockAmt);

            Unlock(addr, i, unlockAmt);
            processed++;
        }
    }

    function withdrawEth(address to, uint256 value) onlyOwner public {
        require(to != address(0));
        to.transfer(value);
    }

    function() payable public {
        // receive ETH
    }
}

interface token {
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}

contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}
```