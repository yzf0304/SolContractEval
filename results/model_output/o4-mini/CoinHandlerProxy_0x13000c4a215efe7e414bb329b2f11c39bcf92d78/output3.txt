pragma solidity 0.6.12;

interface marketManagerInterface {
    // Assumed to be defined elsewhere
}

interface interestModelInterface {
    // Assumed to be defined elsewhere
}

interface marketHandlerDataStorageInterface {
    // Assumed to be defined elsewhere
}

interface marketSIHandlerDataStorageInterface {
    // Assumed to be defined elsewhere
}

/**
 * @notice This contract serves as a proxy for interacting with a handler and a special interest (SI) handler.
 * @dev Uses delegatecall/staticcall to dispatch calls, with ownership and marketManager access control.
 */
contract proxy {
    address payable owner;
    uint256 handlerID;
    string tokenName = "ether";
    uint256 constant unifiedPoint = 10 ** 18;

    marketManagerInterface public marketManager;
    interestModelInterface public interestModelInstance;
    marketHandlerDataStorageInterface public handlerDataStorage;
    marketSIHandlerDataStorageInterface public SIHandlerDataStorage;

    address public handler;
    address public SI;

    string constant DEPOSIT = "deposit(uint256,bool)";
    string constant REDEEM  = "withdraw(uint256,bool)";
    string constant BORROW  = "borrow(uint256,bool)";
    string constant REPAY   = "repay(uint256,bool)";

    modifier onlyOwner {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    modifier onlyMarketManager {
        address msgSender = msg.sender;
        require(msgSender == address(marketManager) || msgSender == owner, "onlyMarketManager function");
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function ownershipTransfer(address _owner) onlyOwner external returns (bool) {
        require(_owner != address(0), "new owner is the zero address");
        owner = payable(_owner);
        return true;
    }

    function initialize(
        uint256 _handlerID,
        address handlerAddr,
        address marketManagerAddr,
        address interestModelAddr,
        address marketDataStorageAddr,
        address siHandlerAddr,
        address SIHandlerDataStorageAddr
    ) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        handler = handlerAddr;
        marketManager = marketManagerInterface(marketManagerAddr);
        interestModelInstance = interestModelInterface(interestModelAddr);
        handlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);
        SI = siHandlerAddr;
        SIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);
        return true;
    }

    function setHandlerID(uint256 _handlerID) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        return true;
    }

    function setHandlerAddr(address handlerAddr) onlyOwner public returns (bool) {
        handler = handlerAddr;
        return true;
    }

    function setSiHandlerAddr(address siHandlerAddr) onlyOwner public returns (bool) {
        SI = siHandlerAddr;
        return true;
    }

    function getHandlerID() public view returns (uint256) {
        return handlerID;
    }

    function getHandlerAddr() public view returns (address) {
        return handler;
    }

    function getSiHandlerAddr() public view returns (address) {
        return SI;
    }

    function migration(address payable target) onlyOwner public returns (bool) {
        require(target != address(0), "target is zero address");
        target.transfer(address(this).balance);
        return true;
    }

    fallback() external payable {
        require(msg.value > 0, "Deposit must be greater than zero");
    }

    function deposit(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        bytes memory callData = abi.encodeWithSignature(DEPOSIT, unifiedTokenAmount, flag);
        (bool success, bytes memory returnData) = handler.delegatecall{value: msg.value}(callData);
        require(success, "Delegatecall to deposit failed");
        return abi.decode(returnData, (bool));
    }

    function withdraw(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        bytes memory callData = abi.encodeWithSignature(REDEEM, unifiedTokenAmount, flag);
        (bool success, bytes memory returnData) = handler.delegatecall(callData);
        require(success, "Delegatecall to withdraw failed");
        return abi.decode(returnData, (bool));
    }

    function borrow(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        bytes memory callData = abi.encodeWithSignature(BORROW, unifiedTokenAmount, flag);
        (bool success, bytes memory returnData) = handler.delegatecall(callData);
        require(success, "Delegatecall to borrow failed");
        return abi.decode(returnData, (bool));
    }

    function repay(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        bytes memory callData = abi.encodeWithSignature(REPAY, unifiedTokenAmount, flag);
        (bool success, bytes memory returnData) = handler.delegatecall{value: msg.value}(callData);
        require(success, "Delegatecall to repay failed");
        return abi.decode(returnData, (bool));
    }

    function handlerProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = handler.delegatecall(data);
        return (success, returnData);
    }

    function handlerViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = handler.staticcall(data);
        return (success, returnData);
    }

    function siProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = SI.delegatecall(data);
        return (success, returnData);
    }

    function siViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory returnData) = SI.staticcall(data);
        return (success, returnData);
    }
}