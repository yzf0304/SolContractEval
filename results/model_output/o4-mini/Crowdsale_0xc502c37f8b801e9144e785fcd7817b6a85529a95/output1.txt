Here is the completed Crowdsale contract. It implements all of the required behaviors—time‐limited sales, adjustable price/end‐time by the owner, token locking until crowdsale end, and post‐sale release of tokens. It relies only on the provided SafeMath, Ownable and DragonToken interfaces.

```solidity
pragma solidity ^0.4.18;

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) { return 0; }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  function Ownable() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

contract DragonToken {
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);
}

contract Crowdsale is Ownable {
  using SafeMath for uint256;

  DragonToken public token;
  address public tokenReserve;
  uint256 public startTime;
  uint256 public endTime;
  address public wallet;
  uint256 public rate;          // wei per token
  uint256 public weiRaised;
  uint256 public tokensSold;

  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount,
    uint256 releaseTime
  );

  event EndTimeUpdated(uint256 previousEndTime, uint256 newEndTime);
  event DragonPriceUpdated(uint256 previousRate, uint256 newRate);
  event TokenReleased(address indexed holder, uint256 amount);

  mapping(address => uint256) private balances;
  mapping(address => uint256) private releaseTime;

  function Crowdsale() public {
    // override owner
    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    startTime = now;
    endTime = 1521187200; // 2018-03-16T00:00:00Z
    rate = 5000000000000000; // 0.005 ether per token
    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
  }

  // fallback buys tokens for msg.sender
  function () external payable {
    buyTokens(msg.sender);
  }

  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokens = getTokenAmount(weiAmount);

    // update state
    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokens);

    // assign and lock
    uint256 lockTimestamp = assignTokens(beneficiary, tokens);

    TokenPurchase(
      msg.sender,
      beneficiary,
      weiAmount,
      tokens,
      lockTimestamp
    );

    forwardFunds();
  }

  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount.div(rate);
  }

  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  function updateEndTime(uint256 newTime) external onlyOwner {
    // cannot move end time into the past or before start
    require(newTime >= now);
    require(newTime >= startTime);
    uint256 previous = endTime;
    endTime = newTime;
    EndTimeUpdated(previous, newTime);
  }

  function updateDragonPrice(uint256 weiAmount) external onlyOwner {
    require(weiAmount > 0);
    uint256 previous = rate;
    rate = weiAmount;
    DragonPriceUpdated(previous, weiAmount);
  }

  // lock until crowdsale end
  function assignTokens(address beneficiary, uint256 amount) private returns (uint256) {
    // set or extend lock only up to endTime
    // if first purchase, releaseTime is endTime
    if (releaseTime[beneficiary] < endTime) {
      releaseTime[beneficiary] = endTime;
    }
    balances[beneficiary] = balances[beneficiary].add(amount);
    return releaseTime[beneficiary];
  }

  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

  function unlockTime(address _owner) public view returns (uint256) {
    return releaseTime[_owner];
  }

  function releaseDragonTokens() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    require(now >= releaseTime[msg.sender]);

    // zero out before external call
    balances[msg.sender] = 0;
    releaseTime[msg.sender] = 0;

    require(token.transferFrom(tokenReserve, msg.sender, amount));
    TokenReleased(msg.sender, amount);
  }
}
```

Explanation of key points:

1. `rate` is interpreted as “wei per token,” so token amount = `msg.value.div(rate)`.  
2. Tokens purchased are not sent immediately – they’re credited in `balances` and locked until `endTime`.  
3. Only after `endTime` may a user call `releaseDragonTokens()`, which pulls tokens from the `tokenReserve` using `transferFrom`.  
4. The owner may push `endTime` forward (but never backward) and update `rate` at any time before or during the sale.  
5. All funds raised are immediately forwarded to the `wallet` address upon each purchase.