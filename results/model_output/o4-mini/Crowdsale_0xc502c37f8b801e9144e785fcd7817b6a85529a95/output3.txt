Here is the completed Crowdsale contract (Solidity 0.4.18) with all required methods filled in. Tokens purchased are time‐locked for 90 days before release. No extra contracts or dependencies have been introduced.

```solidity
pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) { return 0; }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  function Ownable() public { owner = msg.sender; }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

contract DragonToken {
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);
}

/**
 * @title Crowdsale
 * @notice This contract is designed to facilitate a token crowdsale, allowing users to purchase tokens with Ether.
 * Tokens are locked for 90 days after purchase before they can be released.
 */
contract Crowdsale is Ownable {
  using SafeMath for uint256;

  DragonToken public token;
  address public tokenReserve;
  uint256 public startTime;
  uint256 public endTime;
  address public wallet;
  uint256 public rate;         // token price in wei per token unit
  uint256 public weiRaised;
  uint256 public tokensSold;

  uint256 public constant lockDuration = 90 days;

  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount,
    uint256 releaseTime
  );
  event EndTimeUpdated();
  event DragonPriceUpdated();
  event TokenReleased(address indexed holder, uint256 amount);

  mapping(address => uint256) private balances;
  mapping(address => uint256) private releaseTime;

  function Crowdsale() public {
    // override owner set in Ownable
    owner        = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    startTime    = now;
    endTime      = 1521187200;               // March 16, 2018 UTC
    rate         = 5000000000000000;         // 0.005 ETH per token
    wallet       = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    token        = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
  }

  /**
   * @notice Fallback allows token purchase by sending ETH directly.
   */
  function () external payable {
    buyTokens(msg.sender);
  }

  /**
   * @notice Buy tokens for beneficiary.
   */
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokens    = getTokenAmount(weiAmount);

    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokens);

    uint256 releaseAt = assignTokens(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens, releaseAt);

    forwardFunds();
  }

  /**
   * @notice Has crowdsale ended?
   */
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  /**
   * @dev Convert wei to token amount.
   */
  function getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount.div(rate);
  }

  /**
   * @dev Forward funds to wallet.
   */
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  /**
   * @dev Validate incoming purchase.
   */
  function validPurchase() internal view returns (bool) {
    bool nonZeroPurchase = msg.value != 0;
    bool withinPeriod    = now >= startTime && now <= endTime;
    return nonZeroPurchase && withinPeriod;
  }

  /**
   * @notice Owner can extend the end time.
   */
  function updateEndTime(uint256 newTime) onlyOwner external {
    require(newTime >= now);
    endTime = newTime;
    EndTimeUpdated();
  }

  /**
   * @notice Owner can adjust token price.
   */
  function updateDragonPrice(uint256 weiAmount) onlyOwner external {
    require(weiAmount > 0);
    rate = weiAmount;
    DragonPriceUpdated();
  }

  /**
   * @dev Assign tokens to beneficiary and set release time.
   * @return timestamp when tokens unlock
   */
  function assignTokens(address beneficiary, uint256 amount) private returns (uint256) {
    uint256 unlockAt = now.add(lockDuration);
    balances[beneficiary]  = balances[beneficiary].add(amount);
    releaseTime[beneficiary] = unlockAt;
    return unlockAt;
  }

  /**
   * @notice View locked token balance.
   */
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

  /**
   * @notice View unlock timestamp.
   */
  function unlockTime(address _owner) public view returns (uint256) {
    return releaseTime[_owner];
  }

  /**
   * @notice Release locked tokens after lock period.
   */
  function releaseDragonTokens() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    require(now >= releaseTime[msg.sender]);

    // zero out first to prevent re‐entrancy
    balances[msg.sender] = 0;
    releaseTime[msg.sender] = 0;

    require(token.transferFrom(tokenReserve, msg.sender, amount));
    TokenReleased(msg.sender, amount);
  }
}
```

Explanation of key points:  
- `buyTokens` validates purchase, computes token amount, updates state, assigns tokens with a 90-day lock, emits `TokenPurchase`, and forwards Ether.  
- `assignTokens` locks tokens for exactly 90 days (`lockDuration`).  
- `releaseDragonTokens` lets users withdraw their locked tokens after the lock period; it pulls from `tokenReserve` via `transferFrom`, so be sure `tokenReserve` has approved this crowdsale contract for the full supply.  
- Owner‐only methods allow adjusting end time and token price.  
- `hasEnded`, `validPurchase`, and `getTokenAmount` implement the usual crowdsale checks and rate conversion.