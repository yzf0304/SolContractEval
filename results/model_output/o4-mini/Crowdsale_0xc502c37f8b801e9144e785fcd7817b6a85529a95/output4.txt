pragma solidity ^0.4.18;

contract Crowdsale is Ownable {
  using SafeMath for uint256;

  /**
   * @notice The token being sold in the crowdsale.
   */
  DragonToken public token;

  /**
   * @notice The address of the token reserves.
   */
  address public tokenReserve;

  /**
   * @notice The start and end timestamps where investments are allowed (both inclusive).
   */
  uint256 public startTime;
  uint256 public endTime;

  /**
   * @notice The address where funds are collected.
   */
  address public wallet;

  /**
   * @notice The token rate in wei (price per token).
   */
  uint256 public rate;

  /**
   * @notice The amount of raised money in wei.
   */
  uint256 public weiRaised;

  /**
   * @notice The total amount of tokens sold during the crowdsale.
   */
  uint256 public tokensSold;

  /**
   * @dev Event for logging token purchases.
   * @param purchaser The address that paid for the tokens.
   * @param beneficiary The address that received the tokens.
   * @param value The amount of wei paid for the purchase.
   * @param amount The amount of tokens purchased.
   * @param releaseTime The timestamp when the tokens will be unlocked.
   */
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount,
    uint256 releaseTime
  );

  /**
   * @dev Event for logging updates to the end time of the crowdsale.
   */
  event EndTimeUpdated();

  /**
   * @dev Event for logging updates to the token price.
   */
  event DragonPriceUpdated();

  /**
   * @dev Event for logging the release of tokens.
   * @param holder The address releasing the tokens.
   * @param amount The amount of tokens released.
   */
  event TokenReleased(address indexed holder, uint256 amount);

  mapping(address => uint256) private balances;
  mapping(address => uint256) private releaseTime;

  function Crowdsale() public {
    owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e; // overriding owner
    startTime = now;
    endTime = 1521187200;
    rate = 5000000000000000; // price in wei per token
    wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
    tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
  }

  /**
   * @notice Fallback function allows users to buy tokens by sending Ether directly to the contract.
   */
  function () external payable {
    buyTokens(msg.sender);
  }

  /**
   * @notice Allows users to buy tokens.
   * @param beneficiary The address that will receive the tokens.
   */
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;
    uint256 tokensAmount = getTokenAmount(weiAmount);

    weiRaised = weiRaised.add(weiAmount);
    tokensSold = tokensSold.add(tokensAmount);

    uint256 lockTimestamp = assignTokens(beneficiary, tokensAmount);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokensAmount, lockTimestamp);
    forwardFunds();
  }

  /**
   * @notice Checks if the crowdsale has ended.
   * @return A boolean indicating whether the crowdsale has ended.
   */
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  /**
   * @dev Calculates the amount of tokens to be created based on the wei amount.
   * @param weiAmount The amount of wei sent by the user.
   * @return The amount of tokens to be created.
   */
  function getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount.div(rate);
  }

  /**
   * @dev Transfers the funds to the collection wallet.
   */
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  /**
   * @dev Checks if the current transaction is a valid purchase.
   * @return A boolean indicating whether the purchase is valid.
   */
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  /**
   * @notice Updates the end time of the crowdsale.
   * @param newTime The new end time.
   */
  function updateEndTime(uint256 newTime) onlyOwner external {
    require(newTime > startTime && newTime > endTime);
    endTime = newTime;
    EndTimeUpdated();
  }

  /**
   * @notice Updates the price of the token in wei.
   * @param weiAmount The new price in wei.
   */
  function updateDragonPrice(uint256 weiAmount) onlyOwner external {
    require(weiAmount > 0);
    rate = weiAmount;
    DragonPriceUpdated();
  }

  /**
   * @dev Assigns tokens to the beneficiary and sets the release time to endTime.
   * @param beneficiary The address receiving the tokens.
   * @param amount The amount of tokens to assign.
   * @return The timestamp when the tokens will be unlocked.
   */
  function assignTokens(address beneficiary, uint256 amount) private returns (uint256) {
    balances[beneficiary] = balances[beneficiary].add(amount);
    releaseTime[beneficiary] = endTime;
    return releaseTime[beneficiary];
  }

  /**
   * @notice Gets the balance of the specified address.
   * @param _owner The address to query the balance of.
   * @return The balance of the specified address.
   */
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

  /**
   * @notice Gets the unlock time for the specified address.
   * @param _owner The address to query the unlock time of.
   * @return The unlock time for the specified address.
   */
  function unlockTime(address _owner) public view returns (uint256) {
    return releaseTime[_owner];
  }

  /**
   * @notice Releases the tokens held by timelock to the beneficiary.
   */
  function releaseDragonTokens() public {
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    require(now >= releaseTime[msg.sender]);

    balances[msg.sender] = 0;
    releaseTime[msg.sender] = 0;

    require(token.transferFrom(tokenReserve, msg.sender, amount));
    TokenReleased(msg.sender, amount);
  }
}