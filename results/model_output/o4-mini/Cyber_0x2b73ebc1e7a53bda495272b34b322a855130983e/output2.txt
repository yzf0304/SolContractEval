```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.14;

library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    function toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) { return "0"; }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) { digits++; temp /= 10; }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) { return "0x00"; }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) { length++; temp >>= 8; }
        return toHexString(value, length);
    }
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0"; buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

interface ILayerZeroUserApplicationConfig { /* omitted for brevity */ }
interface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {
    function send(
        uint16 _dstChainId,
        bytes calldata _destination,
        bytes calldata _payload,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes calldata _adapterParams
    ) external payable;
    function estimateFees(
        uint16 _dstChainId,
        address _userApplication,
        bytes calldata _payload,
        bool _payInZRO,
        bytes calldata _adapterParam
    ) external view returns (uint nativeFee, uint zroFee);
}

abstract contract ERC721Omni {
    using Strings for uint256;
    event Transfer(address indexed from, address indexed to, uint256 indexed id);
    event Approval(address indexed owner, address indexed spender, uint256 indexed id);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    string public name;
    string public symbol;
    address public owner;
    ILayerZeroEndpoint internal endpoint;

    struct FailedMessages { uint payloadLength; bytes32 payloadHash; }
    struct addressData { uint128 balance; uint128 huntlistMinted; }
    struct tokenData { address tokenHolder; uint96 timestampHolder; }

    mapping(uint256 => tokenData) internal _ownerOf;
    mapping(address => addressData) internal _addressData;
    mapping(uint16 => mapping(bytes => mapping(uint => FailedMessages))) public failedMessages;
    mapping(uint16 => bytes) public trustedRemoteLookup;
    mapping(uint256 => address) public getApproved;
    mapping(address => mapping(address => bool)) public isApprovedForAll;

    constructor(string memory _name, string memory _symbol) {
        name = _name;
        symbol = _symbol;
        _transferOwnership(msg.sender);
    }

    modifier onlyOwner() {
        require(owner == msg.sender, "CallerNotOwner");
        _;
    }

    function ownerOf(uint256 id) public view returns (address) {
        require(_ownerOf[id].tokenHolder != address(0), "Nonexistent Token");
        return _ownerOf[id].tokenHolder;
    }

    function balanceOf(address _owner) public view returns (uint256) {
        require(_owner != address(0), "Zero Address");
        return _addressData[_owner].balance;
    }

    function transferFrom(address from, address to, uint256 tokenId) public {
        require(from == _ownerOf[tokenId].tokenHolder, "Non Owner");
        require(to != address(0), "Zero Address");
        require(
            msg.sender == from ||
            isApprovedForAll[from][msg.sender] ||
            msg.sender == getApproved[tokenId],
            "Lacks Permissions"
        );
        unchecked {
            _addressData[from].balance--;
            _addressData[to].balance++;
        }
        _ownerOf[tokenId].tokenHolder = to;
        _ownerOf[tokenId].timestampHolder = uint96(block.timestamp);
        delete getApproved[tokenId];
        emit Transfer(from, to, tokenId);
    }

    function _mint(address to, uint256 tokenId) internal {
        require(to != address(0), "Zero Address");
        require(_ownerOf[tokenId].tokenHolder == address(0), "Already Exists");
        unchecked { _addressData[to].balance++; }
        _ownerOf[tokenId].tokenHolder = to;
        _ownerOf[tokenId].timestampHolder = uint96(block.timestamp);
        emit Transfer(address(0), to, tokenId);
    }

    function _safeMint(address to, uint256 tokenId) internal {
        _mint(to, tokenId);
        require(
            to.code.length == 0 ||
            ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), tokenId, "") ==
            ERC721TokenReceiver.onERC721Received.selector,
            "Unsafe Mint"
        );
    }

    function _burn(uint256 tokenId) internal {
        address _owner = _ownerOf[tokenId].tokenHolder;
        require(_owner != address(0), "Nonexistent Token");
        unchecked { _addressData[_owner].balance--; }
        delete _ownerOf[tokenId];
        delete getApproved[tokenId];
        emit Transfer(_owner, address(0), tokenId);
    }

    function baseURI() public view virtual returns (string memory) { return ""; }

    function _lzSend(
        uint16 _dstChainId,
        bytes memory _payload,
        address payable _refundAddress,
        address _zroPaymentAddress,
        bytes memory _txParam
    ) internal {
        endpoint.send{value: msg.value}(
            _dstChainId,
            trustedRemoteLookup[_dstChainId],
            _payload,
            _refundAddress,
            _zroPaymentAddress,
            _txParam
        );
    }

    function lzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) external {
        require(msg.sender == address(endpoint), "OnlyEndpoint");
        require(
            _srcAddress.length == trustedRemoteLookup[_srcChainId].length &&
            keccak256(_srcAddress) == keccak256(trustedRemoteLookup[_srcChainId]),
            "Invalid source"
        );
        try this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload) {
        } catch {
            failedMessages[_srcChainId][_srcAddress][_nonce] = FailedMessages(_payload.length, keccak256(_payload));
            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload);
        }
    }

    function onLzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) public {
        require(msg.sender == address(this), "Caller must be Bridge");
        _LzReceive(_srcChainId, _srcAddress, _nonce, _payload);
    }

    function _LzReceive(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes memory _payload
    ) internal virtual { }

    function retryMessage(
        uint16 _srcChainId,
        bytes memory _srcAddress,
        uint64 _nonce,
        bytes calldata _payload
    ) external payable {
        FailedMessages storage fm = failedMessages[_srcChainId][_srcAddress][_nonce];
        require(fm.payloadHash != bytes32(0), "No stored message");
        require(fm.payloadLength == _payload.length, "Invalid payload");
        require(fm.payloadHash == keccak256(_payload), "Payload mismatch");
        fm.payloadLength = 0;
        fm.payloadHash = bytes32(0);
        this.onLzReceive(_srcChainId, _srcAddress, _nonce, _payload);
    }

    function setTrustedRemote(uint16 _chainId, bytes calldata _trustedRemote) external onlyOwner {
        trustedRemoteLookup[_chainId] = _trustedRemote;
    }

    function _transferOwnership(address newOwner) internal {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

abstract contract ERC721TokenReceiver {
    function onERC721Received(
        address, address, uint256, bytes calldata
    ) external virtual returns (bytes4) {
        return ERC721TokenReceiver.onERC721Received.selector;
    }
}

contract Cyber is ERC721Omni {
    using Strings for uint256;

    string private _baseURI = "ipfs://QmS84uLAUvGLverNnvyU8YhsHKJi6E3WnfvuD7qmRmBos2/";
    uint256 private constant maximumSupply = 6600;
    uint256 public publicMintedCap = 1980;

    uint256 public totalSupply;
    uint256 public publicMinted;
    uint256 public gasForLzReceive = 350000;
    bool public depreciatedMint;
    bool public publicStatus;
    bool public huntlistStatus;
    bytes32 public merkleRoot = 0xd6fbbe52742f9b344f0cec438e6e560e182c4aec6a42bbf8e944f227632ba0b3;

    constructor(address _lzEndpoint) ERC721Omni("Cyber", "Hunters") {
        endpoint = ILayerZeroEndpoint(_lzEndpoint);
    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Contract Caller");
        _;
    }

    function donate() external payable { }

    function traverseChains(uint16 _chainId, uint tokenId) public payable {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        bytes memory remote = trustedRemoteLookup[_chainId];
        require(remote.length != 0, "Chain not enabled");

        // burn locally and adjust supply
        _burn(tokenId);
        totalSupply--;

        // prepare cross-chain payload
        bytes memory payload = abi.encode(msg.sender, tokenId);
        bytes memory adapterParams = abi.encodePacked(uint16(1), gasForLzReceive);

        // estimate fees and send
        (uint256 nativeFee, ) = endpoint.estimateFees(
            _chainId,
            address(this),
            payload,
            false,
            adapterParams
        );
        require(msg.value >= nativeFee, "Insufficient fee");
        _lzSend(_chainId, payload, payable(msg.sender), address(0), adapterParams);
    }

    function _LzReceive(
        uint16,
        bytes memory,
        uint64,
        bytes memory _payload
    ) override internal {
        // decode and mint
        (address to, uint256 tokenId) = abi.decode(_payload, (address, uint256));
        totalSupply++;
        _safeMint(to, tokenId);
    }

    function publicMint() external callerIsUser {
        require(publicStatus, "Public mint closed");
        require(!depreciatedMint, "Mint deprecated");
        require(publicMinted + 1 <= publicMintedCap, "Public cap reached");
        require(totalSupply + 1 <= maximumSupply, "Max supply reached");

        publicMinted++;
        totalSupply++;
        _safeMint(msg.sender, totalSupply);
    }

    function huntlistMint(bytes32[] calldata _proof) external callerIsUser {
        require(huntlistStatus, "Huntlist mint closed");
        require(!depreciatedMint, "Mint deprecated");
        require(verifyProof(_proof, merkleRoot, keccak256(abi.encodePacked(msg.sender))),
                "Not on huntlist");
        require(_addressData[msg.sender].huntlistMinted + 2 <= 2,
                "Huntlist allocation used");
        require(totalSupply + 2 <= maximumSupply, "Max supply reached");

        _addressData[msg.sender].huntlistMinted += 2;
        for (uint i = 0; i < 2; i++) {
            totalSupply++;
            _safeMint(msg.sender, totalSupply);
        }
    }

    function verifyProof(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        bytes32 computed = leaf;
        for (uint i = 0; i < proof.length; i++) {
            bytes32 p = proof[i];
            if (computed < p) {
                computed = keccak256(abi.encodePacked(computed, p));
            } else {
                computed = keccak256(abi.encodePacked(p, computed));
            }
        }
        return computed == root;
    }

    function burnHunter(uint256 tokenId) external {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        _burn(tokenId);
        totalSupply--;
    }

    function setPublicState(bool _state) external onlyOwner {
        publicStatus = _state;
    }

    function setHuntlistState(bool _state) external onlyOwner {
        huntlistStatus = _state;
    }

    function setPublicMintSupply(uint256 _supply) external onlyOwner {
        publicMintedCap = _supply;
    }

    function setRoot(bytes32 _newROOT) external onlyOwner {
        merkleRoot = _newROOT;
    }

    function depreciateMint() external onlyOwner {
        require(!depreciatedMint, "Already deprecated");
        depreciatedMint = true;
        publicStatus = false;
        huntlistStatus = false;
        // mint 66 to deployer
        for (uint i = 0; i < 66; i++) {
            require(totalSupply + 1 <= maximumSupply, "Max supply reached");
            totalSupply++;
            _safeMint(owner, totalSupply);
        }
    }

    function setBaseURI(string memory _newURI) external onlyOwner {
        _baseURI = _newURI;
    }

    function setGasForDestinationLzReceive(uint _newGasValue) external onlyOwner {
        gasForLzReceive = _newGasValue;
    }

    function setLzEndpoint(address _lzEndpoint) external onlyOwner {
        endpoint = ILayerZeroEndpoint(_lzEndpoint);
    }

    function baseURI() override public view returns (string memory) {
        return _baseURI;
    }

    function withdrawDonations() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}
```