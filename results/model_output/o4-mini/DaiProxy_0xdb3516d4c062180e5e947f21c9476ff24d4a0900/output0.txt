Here is the completed DaiProxy implementation, strictly targeting Solidity 0.5.12 and making no changes outside of filling in the missing logic. All required functionality—math, DAI/DSR integration, wrappers, reserve, and migration—is in place.

```solidity
pragma solidity 0.5.12;

// -- Interfaces from context ----------------------------------------------------------------

contract ReserveLike {
    function depositToken(address, string memory, bytes memory, uint) public;
}

contract WrappedDaiLike {
    function setProxy(address) public;
    function setReserve(address) public;

    uint public totalSupply;
    function approve(address, uint) public returns (bool);

    function mint(address, uint) public;
    function burn(address, uint) public;
}

contract DaiLike {
    function approve(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}

contract JoinLike {
    VatLike public vat;
    DaiLike public dai;

    function join(address, uint) public;
    function exit(address, uint) public;
}

contract PotLike {
    mapping(address => uint) public pie;
    uint public chi;

    VatLike public vat;
    uint public rho;

    function drip() public returns (uint);

    function join(uint) public;
    function exit(uint) public;
}

contract VatLike {
    mapping(address => uint) public dai;

    function hope(address) public;
    function move(address, address, uint) public;
}

// -- DaiProxy --------------------------------------------------------------------------------

/**
 * @title DaiProxy
 * @notice A proxy contract for managing DAI and its wrapped versions, including deposit,
 * withdrawal, and migration functionalities.
 * @dev This contract handles the lifecycle of DAI and its wrapped versions (eDai and oDai)
 *      with various state transitions and mathematical operations.
 */
contract DaiProxy {
    string public constant version = "0511";

    // --- Owner ---
    address public owner;
    modifier onlyOwner {
        require(msg.sender == owner, "DaiProxy/not-owner");
        _;
    }
    event SetOwner(address owner);
    function setOwner(address _owner) public onlyOwner {
        owner = _owner;
        emit SetOwner(_owner);
    }

    // --- Lifecycle ---
    enum State { Ready, Running, Killed }
    State public state = State.Ready;
    modifier notStarted { require(state == State.Ready, "DaiProxy/started"); _; }
    modifier notPaused { require(state == State.Running, "DaiProxy/not-running"); _; }

    // --- Math ---
    uint constant ONE = 10**27;
    function add(uint a, uint b) private pure returns (uint) {
        uint c = a + b;
        require(c >= a, "DaiProxy/add-overflow");
        return c;
    }
    function sub(uint a, uint b) private pure returns (uint) {
        require(b <= a, "DaiProxy/sub-underflow");
        return a - b;
    }
    function mul(uint a, uint b) private pure returns (uint) {
        if (a == 0) { return 0; }
        uint c = a * b;
        require(c / a == b, "DaiProxy/mul-overflow");
        return c;
    }
    function div(uint a, uint b) private pure returns (uint) {
        require(b > 0, "DaiProxy/div-zero");
        return a / b;
    }
    function ceil(uint a, uint b) private pure returns (uint) {
        require(b > 0, "DaiProxy/ceil-zero");
        return div(add(a, sub(b, 1)), b);
    }
    function muldiv(uint a, uint b, uint c) private pure returns (uint) {
        // compute (a * b) / c
        return div(mul(a, b), c);
    }

    // --- Contracts & State ---
    DaiLike     public Dai;
    JoinLike    public Join;
    PotLike     public Pot;
    VatLike     public Vat;
    ReserveLike public Reserve;
    WrappedDaiLike public EDai;
    WrappedDaiLike public ODai;

    DaiProxy public NewProxy;

    event SetReserve(address reserve);
    event SetNewProxy(address proxy);
    event StartProxy(address prev);
    event KillProxy(address next, bool mig);

    // --- Constructor ---
    constructor(
      address dai,
      address join,
      address pot,
      address vat,
      address eDai,
      address oDai
    ) public
    {
        owner = msg.sender;

        Dai  = DaiLike(dai);
        Join = JoinLike(join);
        Pot  = PotLike(pot);
        Vat  = VatLike(vat);

        EDai = WrappedDaiLike(eDai);
        ODai = WrappedDaiLike(oDai);

        // link wrappers to this proxy
        EDai.setProxy(address(this));
        ODai.setProxy(address(this));

        // sanity checks
        require(address(Join.dai()) == dai, "DaiProxy/join-dai-mismatch");
        require(address(Join.vat()) == vat, "DaiProxy/join-vat-mismatch");
        require(address(Pot.vat()) == vat, "DaiProxy/pot-vat-mismatch");

        // enable proxy to move DAI in vat to pot & join
        Vat.hope(pot);
        Vat.hope(join);

        // allow join adapter to pull DAI from this contract
        require(Dai.approve(join, uint(-1)), "DaiProxy/approve-join-failed");
    }

    /**
     * @notice Sets the reserve contract.
     * @param reserve The address of the new reserve.
     */
    function setReserve(address reserve) public onlyOwner {
        Reserve = ReserveLike(reserve);
        // inform wrappers
        EDai.setReserve(reserve);
        ODai.setReserve(reserve);
        // approve wrapper tokens to reserve
        require(EDai.approve(reserve, uint(-1)), "DaiProxy/approve-eDai-reserve");
        require(ODai.approve(reserve, uint(-1)), "DaiProxy/approve-oDai-reserve");
        emit SetReserve(reserve);
    }

    // --- Access control for withdrawals from reserve ---
    modifier onlyEDai { require(msg.sender == address(EDai), "DaiProxy/only-eDai"); _; }
    modifier onlyODai { require(msg.sender == address(ODai), "DaiProxy/only-oDai"); _; }

    // --- DSR integration helpers ---
    // update & fetch latest chi
    function chi() private returns (uint) {
        return Pot.drip();
    }
    // take raw DAI from caller, join into vat + DSR
    function joinDai(uint wad) private {
        require(Dai.transferFrom(msg.sender, address(this), wad), "DaiProxy/dai-transfer");
        Join.join(address(this), wad);
        Pot.join(wad);
    }
    // exit 'wad' amount of raw DAI from DSR to 'to'
    function exitDai(address to, uint wad) private {
        // compute pie such that pie * chi / ONE >= wad
        uint pie = ceil(mul(wad, ONE), chi());
        Pot.exit(pie);
        Join.exit(to, wad);
    }

    // mint oDai = (wad * ONE / chi) oDai tokens for "wad" DAI
    function mintODai(address to, uint wad) private returns (uint) {
        joinDai(wad);
        uint tokens = muldiv(wad, ONE, chi());
        ODai.mint(to, tokens);
        return tokens;
    }

    // --- Deposits to reserve ---
    function depositEDai(string memory toChain, uint wad, bytes memory to) public notPaused {
        joinDai(wad);
        EDai.mint(address(this), wad);
        Reserve.depositToken(address(EDai), toChain, to, wad);
    }
    function depositODai(string memory toChain, uint wad, bytes memory to) public notPaused {
        uint tokens = mintODai(address(this), wad);
        Reserve.depositToken(address(ODai), toChain, to, tokens);
    }

    // --- Swaps & Withdrawals ---
    // burn wrappers & exit DAI
    function swapFromEDai(address from, address to, uint wad) private {
        EDai.burn(from, wad);
        exitDai(to, wad);
    }
    function swapFromODai(address from, address to, uint tokens) private {
        ODai.burn(from, tokens);
        uint wad = muldiv(tokens, chi(), ONE);
        exitDai(to, wad);
    }

    // called by wrapper after burn
    function withdrawEDai(address to, uint wad) public onlyEDai notPaused {
        exitDai(to, wad);
    }
    function withdrawODai(address to, uint tokens) public onlyODai notPaused {
        uint wad = muldiv(tokens, chi(), ONE);
        exitDai(to, wad);
    }

    // user-facing swaps
    function swapToEDai(uint wad) public notPaused {
        joinDai(wad);
        EDai.mint(msg.sender, wad);
    }
    function swapToODai(uint wad) public notPaused {
        mintODai(msg.sender, wad);
    }
    function swapFromEDai(uint wad) public notPaused {
        swapFromEDai(msg.sender, msg.sender, wad);
    }
    function swapFromODai(uint tokens) public notPaused {
        swapFromODai(msg.sender, msg.sender, tokens);
    }

    // --- Migration & Lifecycle ---
    function setNewProxy(address proxy) public onlyOwner {
        NewProxy = DaiProxy(proxy);
        EDai.setProxy(proxy);
        ODai.setProxy(proxy);
        emit SetNewProxy(proxy);
    }

    function killProxy(address to) public notPaused onlyOwner {
        // drain DSR
        uint pie = Pot.pie(address(this));
        if (pie > 0) {
            uint wad = muldiv(pie, chi(), ONE);
            Pot.exit(pie);
            Join.exit(to, wad);
        }
        state = State.Killed;
        emit KillProxy(address(NewProxy), address(NewProxy) != address(0));
    }

    function migrateProxy() public notPaused onlyNewProxy {
        // called by new proxy; drain all DSR -> new proxy
        uint pie = Pot.pie(address(this));
        if (pie > 0) {
            uint wad = muldiv(pie, chi(), ONE);
            Pot.exit(pie);
            Join.exit(address(NewProxy), wad);
        }
        // point wrappers at new
        EDai.setProxy(address(NewProxy));
        ODai.setProxy(address(NewProxy));
    }

    function startProxy(address oldProxy) public notStarted onlyOwner {
        state = State.Running;
        if (oldProxy != address(0)) {
            // pull in funds from old
            DaiProxy(oldProxy).migrateProxy();
        }
        emit StartProxy(oldProxy);
    }
}
```

Explanation of the key additions:

1. **Math**: `add`, `sub`, `mul`, `div`, `ceil`, and `muldiv` with overflow/underflow checks.  
2. **DSR Integration**:  
   - `chi()` calls `Pot.drip()`.  
   - `joinDai` pulls raw DAI from the user, joins it into the Vat, and then deposits it into the Pot.  
   - `exitDai` computes the required pie, exits from the Pot, and exits from the Join adapter back into raw DAI.  
3. **eDai / oDai mint & burn**:  
   - `depositEDai`/`depositODai` handle minting wrappers for Reserve deposits.  
   - `swapToEDai`/`swapToODai` let users convert raw DAI into wrappers.  
   - `swapFromEDai`/`swapFromODai` and the two `withdraw*` functions handle burns and redemption back into raw DAI.  
4. **Reserve Management**:  
   - `setReserve` registers the Reserve, informs both wrappers of the new reserve, and grants approval to deposit wrappers.  
5. **Migration**:  
   - `setNewProxy` lets the old proxy nominate a successor and updates wrappers' proxy pointers.  
   - `killProxy` allows the owner to drain out all DAI and disable the contract.  
   - `migrateProxy` is callable only by the designated new proxy to pull DAI out of the old proxy and reconfigure wrappers.  
   - `startProxy` begins normal operation on a new proxy, optionally pulling in funds from an old one.