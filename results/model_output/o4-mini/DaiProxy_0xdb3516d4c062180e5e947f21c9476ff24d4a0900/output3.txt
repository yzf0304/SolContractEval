Here is the completed `DaiProxy` contract for Solidity v0.5.12, with all functions implemented according to the given specification. No external dependencies or extra contracts have been introduced.

```solidity
pragma solidity 0.5.12;

contract ReserveLike {
    function depositToken(address, string memory, bytes memory, uint) public;
}

contract WrappedDaiLike {
    function setProxy(address) public;
    function setReserve(address) public;

    uint public totalSupply;
    function approve(address, uint) public returns (bool);

    function mint(address, uint) public;
    function burn(address, uint) public;
}

contract DaiLike {
    function approve(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}

contract JoinLike {
    VatLike public vat;
    DaiLike public dai;
    function join(address, uint) public;
    function exit(address, uint) public;
}

contract PotLike {
    mapping(address => uint) public pie;
    uint public chi;
    VatLike public vat;
    uint public rho;
    function drip() public returns (uint);
    function join(uint) public;
    function exit(uint) public;
}

contract VatLike {
    mapping(address => uint) public dai;
    function hope(address) public;
    function move(address, address, uint) public;
}

/// @title DaiProxy
/// @notice Proxy for DAI, eDai and oDai: deposit, withdraw, migrate, etc.
contract DaiProxy {
    string public constant version = "0511";

    // --- Owner ---
    address public owner;
    modifier onlyOwner {
        require(msg.sender == owner, "DaiProxy/only-owner");
        _;
    }
    event SetOwner(address owner);
    function setOwner(address _owner) public onlyOwner {
        require(_owner != address(0), "DaiProxy/zero-owner");
        owner = _owner;
        emit SetOwner(_owner);
    }

    // --- State ---
    enum State { Ready, Running, Killed }
    State public state = State.Ready;
    modifier notStarted {
        require(state == State.Ready, "DaiProxy/already-started");
        _;
    }
    modifier notPaused {
        require(state == State.Running, "DaiProxy/paused-or-killed");
        _;
    }

    // --- Math ---
    uint constant ONE = 10 ** 27;
    function add(uint a, uint b) private pure returns (uint) {
        uint c = a + b;
        require(c >= a, "DaiProxy/add-overflow");
        return c;
    }
    function sub(uint a, uint b) private pure returns (uint) {
        require(b <= a, "DaiProxy/sub-underflow");
        return a - b;
    }
    function mul(uint a, uint b) private pure returns (uint) {
        if (a == 0 || b == 0) return 0;
        uint c = a * b;
        require(c / a == b, "DaiProxy/mul-overflow");
        return c;
    }
    function div(uint a, uint b) private pure returns (uint) {
        require(b != 0, "DaiProxy/div-zero");
        return a / b;
    }
    function ceil(uint a, uint b) private pure returns (uint) {
        require(b != 0, "DaiProxy/ceil-div-zero");
        if (a == 0) return 0;
        return add(div(sub(a, 1), b), 1);
    }
    function muldiv(uint a, uint b, uint c) private pure returns (uint) {
        // (a * b) / c, with requirement c != 0
        require(c != 0, "DaiProxy/muldiv-div-zero");
        return div(mul(a, b), c);
    }

    // --- External contracts ---
    DaiLike   public Dai;
    JoinLike  public Join;
    PotLike   public Pot;
    VatLike   public Vat;
    ReserveLike   public Reserve;
    WrappedDaiLike public EDai;
    WrappedDaiLike public ODai;

    event SetReserve(address reserve);

    /// @notice Initialize, set approvals for join/pot
    constructor(
      address dai,
      address join,
      address pot,
      address vat,
      address eDai,
      address oDai
    ) public {
        owner = msg.sender;

        Dai  = DaiLike(dai);
        Join = JoinLike(join);
        Pot  = PotLike(pot);
        Vat  = VatLike(vat);

        EDai = WrappedDaiLike(eDai);
        ODai = WrappedDaiLike(oDai);

        // sanity checks
        require(address(Join.dai()) == dai, "DaiProxy/join-dai-mismatch");
        require(address(Join.vat()) == vat, "DaiProxy/join-vat-mismatch");
        require(address(Pot.vat()) == vat, "DaiProxy/pot-vat-mismatch");

        // allow join & pot to use our internal balance
        Vat.hope(pot);
        Vat.hope(join);

        // approve infinite DAI for join
        require(Dai.approve(join, uint(-1)), "DaiProxy/approve-join");
    }

    /// @notice Only EDai contract may call
    modifier onlyEDai {
        require(msg.sender == address(EDai), "DaiProxy/only-EDai");
        _;
    }
    /// @notice Only oDai contract may call
    modifier onlyODai {
        require(msg.sender == address(ODai), "DaiProxy/only-oDai");
        _;
    }

    // --- Reserve setup ---
    /// @notice Bind Reserve contract (bridge)
    function setReserve(address reserve) public onlyOwner {
        require(reserve != address(0), "DaiProxy/zero-reserve");
        Reserve = ReserveLike(reserve);
        // approve reserve to pull wrapper tokens
        require(EDai.approve(reserve, uint(-1)), "DaiProxy/approve-eDai");
        require(ODai.approve(reserve, uint(-1)), "DaiProxy/approve-oDai");
        emit SetReserve(reserve);
    }

    // --- Internal wrappers for Maker DSR ---
    /// @dev fetch up-to-date chi from Pot
    function chi() private returns (uint) {
        return Pot.drip();
    }
    /// @dev join raw DAI into Vat & Pot; returns the pie‐units
    function joinDai(uint wad) private returns (uint pie) {
        // pull DAI from msg.sender
        require(Dai.transferFrom(msg.sender, address(this), wad),
                "DaiProxy/transferFrom-failed");
        // to Vat
        Join.join(address(this), wad);
        // to Pot = normalize by chi
        uint _chi = chi();
        pie = muldiv(wad, ONE, _chi);
        Pot.join(pie);
    }
    /// @dev exit from Pot & Vat back to external DAI
    function exitDai(address to, uint wad) private {
        uint _chi = chi();
        // how many pie to burn to get wad DAI back?
        uint pie = ceil(mul(wad, ONE), _chi);
        Pot.exit(pie);
        Join.exit(to, wad);
    }

    /// @dev mint oDai tokens for `wad` DAI; returns the oDai‐units (pie)
    function mintODai(address to, uint wad) private returns (uint) {
        uint pie = joinDai(wad);
        ODai.mint(to, pie);
        return pie;
    }

    // --- deposit into bridge ---
    function depositEDai(
      string memory toChain,
      uint wad,
      bytes memory to
    ) public notPaused {
        // stake wad DAI to Pot
        uint pie = joinDai(wad);
        // rad in vat = pie * chi
        uint rad = mul(pie, chi());
        // mint eDai tokens = rad
        EDai.mint(address(this), rad);
        // deposit to bridge
        Reserve.depositToken(
          address(EDai),
          toChain,
          to,
          rad
        );
    }

    function depositODai(
      string memory toChain,
      uint wad,
      bytes memory to
    ) public notPaused {
        // mint oDai = pie
        uint pie = mintODai(address(this), wad);
        // deposit to bridge
        Reserve.depositToken(
          address(ODai),
          toChain,
          to,
          pie
        );
    }

    // --- swap / withdraw helpers ---
    function swapFromEDai(
      address from,
      address to,
      uint wad
    ) private {
        // burn EDai = wad * RAY
        uint rad = mul(wad, ONE);
        EDai.burn(from, rad);
        // send back DAI
        exitDai(to, wad);
    }

    function swapFromODai(
      address from,
      address to,
      uint pie
    ) private {
        // burn oDai
        ODai.burn(from, pie);
        // pie → wad
        uint wad = muldiv(pie, chi(), ONE);
        exitDai(to, wad);
    }

    // --- external withdraw / swap APIs ---
    function withdrawEDai(address to, uint wad)
      public onlyEDai notPaused
    {
        swapFromEDai(msg.sender, to, wad);
    }
    function withdrawODai(address to, uint pie)
      public onlyODai notPaused
    {
        swapFromODai(msg.sender, to, pie);
    }

    function swapToEDai(uint wad) public notPaused {
        // stake + mint to sender
        uint pie = joinDai(wad);
        uint rad = mul(pie, chi());
        EDai.mint(msg.sender, rad);
    }
    function swapToODai(uint wad) public notPaused {
        mintODai(msg.sender, wad);
    }
    function swapFromEDai(uint wad) public notPaused {
        swapFromEDai(msg.sender, msg.sender, wad);
    }
    function swapFromODai(uint pie) public notPaused {
        swapFromODai(msg.sender, msg.sender, pie);
    }

    // --- Migration to new proxy ---
    DaiProxy public NewProxy;
    event SetNewProxy(address proxy);
    event StartProxy(address prev);
    event KillProxy(address next, bool migrated);

    modifier onlyNewProxy {
        require(msg.sender == address(NewProxy), "DaiProxy/only-newProxy");
        _;
    }
    function setNewProxy(address proxy) public onlyOwner {
        require(proxy != address(0), "DaiProxy/zero-newProxy");
        NewProxy = DaiProxy(proxy);
        emit SetNewProxy(proxy);
    }

    /// @notice kill without migration (drain DAI out to `to`)
    function killProxy(address to)
      public notPaused onlyOwner
    {
        uint pie = Pot.pie(address(this));
        if (pie > 0) {
            // exit all from pot
            Pot.exit(pie);
            // convert to external DAI
            uint wad = muldiv(pie, chi(), ONE);
            Join.exit(to, wad);
        }
        state = State.Killed;
        emit KillProxy(address(NewProxy), false);
    }

    /// @notice migrate internal DAI (rad in vat) to NewProxy
    function migrateProxy()
      public notPaused onlyNewProxy
    {
        // exit yield‐bearing pie → vat
        uint pie = Pot.pie(address(this));
        if (pie > 0) {
            Pot.exit(pie);
        }
        // move all rad in vat to new
        uint rad = Vat.dai(address(this));
        if (rad > 0) {
            Vat.move(address(this), address(NewProxy), rad);
        }
        // point wrappers at new proxy
        EDai.setProxy(address(NewProxy));
        ODai.setProxy(address(NewProxy));

        state = State.Killed;
        emit KillProxy(address(NewProxy), true);
    }

    /// @notice start proxy, optionally pulling vat‐rad from oldProxy
    function startProxy(address oldProxy)
      public notStarted onlyOwner
    {
        if (oldProxy != address(0)) {
            // pull any rad from oldProxy
            uint rad = Vat.dai(oldProxy);
            if (rad > 0) {
                Vat.move(oldProxy, address(this), rad);
                // deposit back to pot
                uint pie = div(rad, chi());
                Pot.join(pie);
            }
        }
        state = State.Running;
        emit StartProxy(oldProxy);
    }
}
```

Explanation of the key points:

1. **Math**  
   We provide `add`, `sub`, `mul`, `div`, `ceil`, and `muldiv` to handle overflow/underflow and rounding.

2. **Maker DSR integration**  
   - `chi()` always calls `Pot.drip()` to get the up-to-date rate.  
   - `joinDai`: transfers DAI from sender → vat → pot, returning the normalized `pie`.  
   - `exitDai`: burns `pie` from pot → vat → DAI, then calls `Join.exit`.

3. **eDai vs. oDai**  
   - **eDai** tokens are minted/burned in “rad” units = `pie * chi()`.  
   - **oDai** tokens are minted/burned in “pie” units.

4. **Deposits**  
   - `depositEDai`: stakes into pot, mints rad‐based EDai, then calls `Reserve.depositToken`.  
   - `depositODai`: stakes into pot, mints pie‐based oDai, then calls `Reserve.depositToken`.

5. **Swaps/Withdraws**  
   - We overload `swapFromEDai` and `swapFromODai` both as private/utility and public user‐facing methods.

6. **Migration**  
   - **killProxy** drains all DAI out to an external address.  
   - **migrateProxy** exits all yield‐bearing DAI (`pie`) into the internal vat, then does `Vat.move` to the new proxy, and finally points the wrapper contracts at the new proxy.  
   - **startProxy** (from Ready state) optionally pulls any vat‐rad from the old proxy, re-deposits into pot, and transitions to Running.

All modifiers, events, and state transitions follow exactly the requested design.