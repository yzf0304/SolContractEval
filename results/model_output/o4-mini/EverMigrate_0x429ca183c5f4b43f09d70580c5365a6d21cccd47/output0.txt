pragma solidity 0.8.8;

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping(address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId;
    mapping(address => mapping(address => Transaction[])) private _userTxns;

    constructor() {
        // _txnId initialized to 0 by default
    }

    /**
     * @notice Adds a new token pair to the migration list.
     * @dev Only the contract owner can call this function.
     */
    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(sourceToken != address(0), "EverMigrate: sourceToken is zero");
        require(targetToken != address(0), "EverMigrate: targetToken is zero");
        require(devAddress != address(0), "EverMigrate: devAddress is zero");
        require(ratio > 0, "EverMigrate: ratio must be > 0");
        require(!_tokenList[sourceToken].isPresent, "EverMigrate: token already added");

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });
        _allTokens.push(sourceToken);

        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    /**
     * @notice Migrates tokens from the source token to the target token.
     */
    function migrateTokens(
        address sourceToken,
        address toAddress,
        uint256 amount
    ) external override {
        TokenDetails storage details = _tokenList[sourceToken];
        require(details.isPresent, "EverMigrate: token not supported");
        require(amount > 0, "EverMigrate: amount must be > 0");
        require(toAddress != address(0), "EverMigrate: toAddress is zero");

        // Transfer source tokens from sender to dev address
        bool sent = IERC20(sourceToken).transferFrom(_msgSender(), details.devAddress, amount);
        require(sent, "EverMigrate: source transfer failed");

        // Calculate and transfer target tokens to recipient
        uint256 amountOut = amount.mul(details.ratio);
        bool delivered = IERC20(details.targetToken).transfer(toAddress, amountOut);
        require(delivered, "EverMigrate: target transfer failed");

        // Record transaction
        _txnId += 1;
        _userTxns[sourceToken][_msgSender()].push(
            Transaction({
                amount: amount,
                timestamp: block.timestamp,
                txnId: _txnId
            })
        );

        emit TokensMigrated(sourceToken, details.targetToken, amount, amountOut);
    }

    /**
     * @notice Returns the number of transactions for a specific user and source token.
     */
    function userTransactionsLength(address sourceToken, address userAddress)
        external
        view
        returns (uint256)
    {
        return _userTxns[sourceToken][userAddress].length;
    }

    /**
     * @notice Returns the details of a specific transaction for a user.
     */
    function userTransaction(
        address sourceToken,
        address userAddress,
        uint256 position
    )
        external
        view
        returns (
            uint256 amount,
            uint256 timestamp,
            uint32 txnId
        )
    {
        Transaction storage txn = _userTxns[sourceToken][userAddress][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    /**
     * @notice Returns tokens to a specified address. Only owner.
     */
    function returnTokens(
        address sourceToken,
        address toAddress,
        uint256 amount
    ) external override onlyOwner {
        TokenDetails storage details = _tokenList[sourceToken];
        require(details.isPresent, "EverMigrate: token not supported");
        require(toAddress != address(0), "EverMigrate: toAddress is zero");
        require(amount > 0, "EverMigrate: amount must be > 0");

        address tgt = details.targetToken;
        bool returned = IERC20(tgt).transfer(toAddress, amount);
        require(returned, "EverMigrate: return transfer failed");

        emit TokensReturned(tgt, toAddress, amount);
    }

    /**
     * @notice Returns the migration details for a specific source token.
     */
    function tokenMigrateDetails(address sourceToken)
        external
        view
        override
        returns (address targetToken, uint256 ratio)
    {
        TokenDetails storage details = _tokenList[sourceToken];
        require(details.isPresent, "EverMigrate: token not supported");
        return (details.targetToken, details.ratio);
    }

    /**
     * @notice Returns an array of all supported source tokens.
     */
    function allSupportedTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return _allTokens;
    }

    /**
     * @notice Returns the number of supported source tokens.
     */
    function allSupportedTokensLength()
        external
        view
        override
        returns (uint256)
    {
        return _allTokens.length;
    }

    /**
     * @notice Checks if a specific source token is supported.
     */
    function supportsToken(address sourceToken)
        public
        view
        override
        returns (bool)
    {
        return _tokenList[sourceToken].isPresent;
    }
}