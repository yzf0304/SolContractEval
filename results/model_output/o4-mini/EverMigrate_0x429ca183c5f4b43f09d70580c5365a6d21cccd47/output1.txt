Here is the completed EverMigrate.sol contract strictly according to your specification (Solidity 0.8.8). It implements all IEverMigrate methods, uses SafeMath, Context and Ownable, tracks user transactions and emits the required events. No extra contracts or imports have been added.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }
    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external pure returns (uint8);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) { unchecked {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }}
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked {
        require(b <= a, errorMessage);
        return a - b;
    }}
    function mul(uint256 a, uint256 b) internal pure returns (uint256) { unchecked {
        if (a == 0) { return 0; }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }}
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked {
        require(b > 0, errorMessage);
        return a / b;
    }}
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }
    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { unchecked {
        require(b != 0, errorMessage);
        return a % b;
    }}
}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }
    function owner() public view returns (address) {
        return _owner;
    }   
    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is zero");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IEverMigrate {
    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external;
    function returnTokens(address sourceToken, address toAddress, uint256 amount) external;
    function tokenMigrateDetails(address sourceToken) external view returns (address targetToken, uint256 ratio);
    function allSupportedTokens() external view returns (address[] memory);
    function allSupportedTokensLength() external view returns (uint256);
    function supportsToken(address sourceToken) external view returns(bool);

    event TokenAdded(address fromToken, address toToken, uint256 ratio);
    event TokensMigrated(address fromToken, address toToken, uint256 amountIn, uint256 amountOut);
    event TokensReturned(address token, address toAddress, uint256 amount);
}

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping(address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId;
    mapping(address => mapping(address => Transaction[])) private _userTxns;

    constructor() {}

    /**
     * @notice Adds a new token pair to the migration list.
     */
    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(sourceToken != address(0), "Source token zero");
        require(targetToken != address(0), "Target token zero");
        require(devAddress   != address(0), "Dev address zero");
        require(ratio > 0,            "Ratio zero");
        require(!_tokenList[sourceToken].isPresent, "Already added");

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });
        _allTokens.push(sourceToken);

        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    /**
     * @notice Migrates tokens from the source to the target token.
     */
    function migrateTokens(
        address sourceToken,
        address toAddress,
        uint256 amount
    ) external override {
        require(_tokenList[sourceToken].isPresent, "Not supported");
        require(amount > 0, "Amount zero");

        TokenDetails memory td = _tokenList[sourceToken];
        uint256 amountOut = amount.mul(td.ratio);

        // pull source tokens
        bool okIn = IERC20(sourceToken).transferFrom(_msgSender(), td.devAddress, amount);
        require(okIn, "Source transfer failed");

        // send target tokens from this contract
        bool okOut = IERC20(td.targetToken).transfer(toAddress, amountOut);
        require(okOut, "Target transfer failed");

        _txnId++;
        _userTxns[sourceToken][_msgSender()].push(
            Transaction({ amount: amount, timestamp: block.timestamp, txnId: _txnId })
        );

        emit TokensMigrated(sourceToken, td.targetToken, amount, amountOut);
    }

    /**
     * @notice Number of user transactions for a source token.
     */
    function userTransactionsLength(address sourceToken, address userAddress)
        external
        view
        returns (uint256)
    {
        return _userTxns[sourceToken][userAddress].length;
    }

    /**
     * @notice Details of a specific user transaction.
     */
    function userTransaction(
        address sourceToken,
        address userAddress,
        uint256 position
    )
        external
        view
        returns (uint256 amount, uint256 timestamp, uint32 txnId)
    {
        Transaction storage txn = _userTxns[sourceToken][userAddress][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    /**
     * @notice Returns target tokens held by this contract back to an address.
     */
    function returnTokens(
        address sourceToken,
        address toAddress,
        uint256 amount
    ) external override onlyOwner {
        require(_tokenList[sourceToken].isPresent, "Not supported");
        TokenDetails memory td = _tokenList[sourceToken];

        bool ok = IERC20(td.targetToken).transfer(toAddress, amount);
        require(ok, "Return failed");

        emit TokensReturned(td.targetToken, toAddress, amount);
    }

    /**
     * @notice Migration details for a source token.
     */
    function tokenMigrateDetails(address sourceToken)
        external
        view
        override
        returns (address targetToken, uint256 ratio)
    {
        require(_tokenList[sourceToken].isPresent, "Not supported");
        TokenDetails memory td = _tokenList[sourceToken];
        return (td.targetToken, td.ratio);
    }

    /**
     * @notice List of all supported source tokens.
     */
    function allSupportedTokens()
        external
        view
        override
        returns (address[] memory)
    {
        return _allTokens;
    }

    /**
     * @notice Count of all supported source tokens.
     */
    function allSupportedTokensLength()
        external
        view
        override
        returns (uint256)
    {
        return _allTokens.length;
    }

    /**
     * @notice Checks if a source token is supported.
     */
    function supportsToken(address sourceToken)
        public
        view
        override
        returns (bool)
    {
        return _tokenList[sourceToken].isPresent;
    }
}
```