pragma solidity 0.8.7;

abstract contract ReentrancyGuard { 
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }
    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
}

library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
 
    function toString(uint256 value) internal pure returns (string memory) { 
        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 
    constructor() {
        _transferOwnership(_msgSender());
    }
 
    function owner() public view virtual returns (address) {
        return _owner;
    } 
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
 
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }
 
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
 
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

library Address { 
    function isContract(address account) internal view returns (bool) { 
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    } 
}

interface IERC721Receiver { 
    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

interface IERC165 { 
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

abstract contract ERC165 is IERC165 { 
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

interface IERC721 is IERC165 { 
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); 
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); 
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved); 
    function balanceOf(address owner) external view returns (uint256 balance); 
    function ownerOf(uint256 tokenId) external view returns (address owner); 
    function safeTransferFrom(address from, address to, uint256 tokenId) external; 
    function transferFrom(address from, address to, uint256 tokenId) external; 
    function approve(address to, uint256 tokenId) external;
    function getApproved(uint256 tokenId) external view returns (address operator); 
    function setApprovalForAll(address operator, bool _approved) external; 
    function isApprovedForAll(address owner, address operator) external view returns (bool); 
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
}

interface IERC721Enumerable is IERC721 { 
    function totalSupply() external view returns (uint256); 
    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId); 
    function tokenByIndex(uint256 index) external view returns (uint256);
}

interface IERC721Metadata is IERC721 { 
    function name() external view returns (string memory); 
    function symbol() external view returns (string memory); 
    function tokenURI(uint256 tokenId) external view returns (string memory);
}

contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using Address for address;
    using Strings for uint256;

    struct TokenOwnership {
        address addr;
        uint64 startTimestamp;
    }
    struct AddressData {
        uint128 balance;
        uint128 numberMinted;
    }

    uint256 private currentIndex = 1;
    uint256 internal immutable collectionSize;
    uint256 internal immutable maxBatchSize; 
    string private _name; 
    string private _symbol; 
    mapping(uint256 => TokenOwnership) private _ownerships; 
    mapping(address => AddressData) private _addressData; 
    mapping(uint256 => address) private _tokenApprovals; 
    mapping(address => mapping(address => bool)) private _operatorApprovals; 

    constructor(
        string memory name_,
        string memory symbol_,
        uint256 maxBatchSize_,
        uint256 collectionSize_
    ) {
        require(collectionSize_ > 0, "ERC721A: collection must have a nonzero supply");
        require(maxBatchSize_ > 0, "ERC721A: max batch size must be nonzero");
        _name = name_;
        _symbol = symbol_;
        maxBatchSize = maxBatchSize_;
        collectionSize = collectionSize_;
    }

    function totalSupply() public view override returns (uint256) {
        return currentIndex - 1;
    }

    function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), "ERC721A: global index out of bounds");
        return index;
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
        uint256 numMintedSoFar = totalSupply();
        uint256 tokenIdsIdx;
        address currOwnershipAddr;
        for (uint256 i; i < numMintedSoFar; i++) {
            TokenOwnership memory ownership = _ownerships[i];
            if (ownership.addr != address(0)) {
                currOwnershipAddr = ownership.addr;
            }
            if (currOwnershipAddr == owner) {
                if (tokenIdsIdx == index) {
                    return i;
                }
                tokenIdsIdx++;
            }
        }
        revert("ERC721A: unable to get token of owner by index");
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC721Enumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721A: balance query for the zero address");
        return uint256(_addressData[owner].balance);
    }

    function _numberMinted(address owner) internal view returns (uint256) {
        require(owner != address(0), "ERC721A: number minted query for the zero address");
        return uint256(_addressData[owner].numberMinted);
    }

    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        require(_exists(tokenId), "ERC721A: owner query for nonexistent token");
        uint256 lowestTokenToCheck;
        if (tokenId >= maxBatchSize) {
            lowestTokenToCheck = tokenId - maxBatchSize + 1;
        }
        for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {
            TokenOwnership memory ownership = _ownerships[curr];
            if (ownership.addr != address(0)) {
                return ownership;
            }
        }
        revert("ERC721A: unable to determine the owner of token");
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        return ownershipOf(tokenId).addr;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory base = _baseURI();
        return bytes(base).length > 0 ? string(abi.encodePacked(base, tokenId.toString())) : "";
    }

    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721A.ownerOf(tokenId);
        require(to != owner, "ERC721A: approval to current owner");
        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721A: approve caller is not owner nor approved for all"
        );
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }
    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), "ERC721A: approved query for nonexistent token");
        return _tokenApprovals[tokenId];
    }
    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != _msgSender(), "ERC721A: approve to caller");
        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        _transfer(from, to, tokenId);
    }
    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId, "");
    }
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public override {
        _transfer(from, to, tokenId);
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                require(retval == IERC721Receiver(to).onERC721Received.selector,
                    "ERC721A: transfer to non ERC721Receiver implementer"
                );
            } catch {
                revert("ERC721A: transfer to non ERC721Receiver implementer");
            }
        }
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < currentIndex;
    }

    function _safeMint(address to, uint256 quantity) internal {
        _beforeTokenTransfers(address(0), to, currentIndex, quantity);
        AddressData memory data = _addressData[to];
        _addressData[to] = AddressData(data.balance + uint128(quantity), data.numberMinted + uint128(quantity));
        _ownerships[currentIndex] = TokenOwnership(to, uint64(block.timestamp));
        for (uint256 i; i < quantity; i++) {
            emit Transfer(address(0), to, currentIndex + i);
        }
        currentIndex += quantity;
        _afterTokenTransfers(address(0), to, currentIndex - quantity, quantity);
    }

    function _transfer(address from, address to, uint256 tokenId) private {
        TokenOwnership memory prev = ownershipOf(tokenId);
        bool isApprovedOrOwner = (_msgSender() == prev.addr ||
            getApproved(tokenId) == _msgSender() ||
            isApprovedForAll(prev.addr, _msgSender()));
        require(isApprovedOrOwner, "ERC721A: transfer caller is not owner nor approved");
        require(prev.addr == from, "ERC721A: transfer from incorrect owner");
        require(to != address(0), "ERC721A: transfer to the zero address");
        
        _beforeTokenTransfers(from, to, tokenId, 1);
        _tokenApprovals[tokenId] = address(0);

        _addressData[from].balance -= 1;
        _addressData[to].balance += 1;
        _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));
        uint256 next = tokenId + 1;
        if (_ownerships[next].addr == address(0) && _exists(next)) {
            _ownerships[next] = TokenOwnership(prev.addr, prev.startTimestamp);
        }
        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    function _beforeTokenTransfers(address, address, uint256, uint256) internal virtual {}
    function _afterTokenTransfers(address, address, uint256, uint256) internal virtual {}
}

contract FORMLESS is Ownable, ERC721A, ReentrancyGuard {
    using Strings for uint256;

    uint256 public MAX_PER_Transtion = 1;
    uint256 public MAX_PER_Address = 1;
    uint256 public PRICE = 0.069 ether;
    uint256 private TotalCollectionSize_ = 500;
    uint256 private constant MaxMintPerBatch_ = 1;
    mapping(address => bool) private whitelistedAddressesForMint;
    string private _baseTokenURI;
    uint public status = 0; // 0 = paused, 1 = whitelist, 2 = public

    constructor()
        ERC721A("FORMLESS", "FORMLESS", MaxMintPerBatch_, TotalCollectionSize_)
    {
        _baseTokenURI = "https://gateway.pinata.cloud/ipfs/QmWT2u6UEeXJs5MWcSTQhHFyYC9wKevQNjXC4J3k67ymtQ/";
    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function mint(uint256 quantity) external payable callerIsUser {
        require(status != 0, "Sale is not active");
        require(quantity > 0 && quantity <= MAX_PER_Transtion, "Invalid quantity");
        require(totalSupply() + quantity <= TotalCollectionSize_, "Exceeds total supply");
        require(msg.value == PRICE * quantity, "Incorrect ETH value");
        if (status == 1) {
            require(isWhitelistedForMint(msg.sender), "Not whitelisted");
        }
        require(numberMinted(msg.sender) + quantity <= MAX_PER_Address,
            "Exceeds max per address"
        );
        _safeMint(msg.sender, quantity);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return string(abi.encodePacked(_baseURI(), tokenId.toString()));
    }

    function isWhitelistedForMint(address _user) public view returns (bool) {
        return whitelistedAddressesForMint[_user];
    }

    function addNewWhitelistUserForMint(address[] calldata _users)
        public
        onlyOwner
    {
        for (uint256 i; i < _users.length; i++) {
            whitelistedAddressesForMint[_users[i]] = true;
        }
    }

    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return _numberMinted(owner);
    }

    function getOwnershipData(uint256 tokenId)
        external
        view
        returns (TokenOwnership memory)
    {
        return ownershipOf(tokenId);
    }

    function withdrawMoney() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        (bool success, ) = msg.sender.call{value: balance}("");
        require(success, "Transfer failed");
    }

    function changeMAX_PER_Address(uint256 q) external onlyOwner {
        MAX_PER_Address = q;
    }

    function reserve(address _address, uint256 quantity) public onlyOwner {
        require(totalSupply() + quantity <= TotalCollectionSize_, "Exceeds total supply");
        _safeMint(_address, quantity);
    }

    function changeMintPrice(uint256 _newPrice) external onlyOwner {
        PRICE = _newPrice;
    }

    function changeCollectionSize(uint256 _collectionSize) external onlyOwner {
        require(_collectionSize >= totalSupply(), "New size too small");
        TotalCollectionSize_ = _collectionSize;
    }

    function changeMAX_PER_Transtion(uint256 q) external onlyOwner {
        MAX_PER_Transtion = q;
    }

    function giveaway(address a, uint256 q) public onlyOwner {
        require(totalSupply() + q <= TotalCollectionSize_, "Exceeds total supply");
        _safeMint(a, q);
    }

    function setStatus(uint256 s) external onlyOwner {
        require(s <= 2, "Invalid status");
        status = s;
    }

    function getStatus() public view returns (uint256) {
        return status;
    }

    function getcollectionSize() public view returns (uint256) {
        return TotalCollectionSize_;
    }
}