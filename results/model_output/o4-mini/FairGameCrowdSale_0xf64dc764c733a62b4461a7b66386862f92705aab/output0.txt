pragma solidity ^0.4.18;

/**
 * @title ERC20 interface
 */
contract ERC20 {
    uint256 public totalSupply;
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);

    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}

/**
 * @title Ownable
 */
contract Ownable {
    address public owner;
    event OwnerChanged(address oldOwner, address newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != owner);
        require(newOwner != address(0x0));
        address oldOwner = owner;
        owner = newOwner;
        OwnerChanged(oldOwner, newOwner);
    }
}

/**
 * @title CrowdSale
 * @dev Manages a crowd sale of an ERC20 token with staged bonuses and locked bonus tokens.
 */
contract CrowdSale is Ownable {
    // ERC20 Token
    ERC20 public token;

    // Address where funds are received
    address public beneficiary;
    // Address that provides tokens
    address public tokenHolder;

    // Rate of token units per wei (base rate)
    uint public rate;
    // Goal amount in wei
    uint public amountGoal;
    // Current amount of raised money in wei
    uint public amountRaised;
    // Amount of tokens issued (sold + unlocked bonus)
    uint public amountTokenIssued;

    // Important Time
    uint public startTime;
    uint public endTime;

    // Stages Info
    struct Stage {
        uint duration;      // Duration in seconds of the stage
        uint rate;          // Bonus rate percentage (e.g. 150 = 150%)
    }
    Stage[] public icoStages;
    Stage[] public lockStages;

    // Purchaser Info
    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    // ----- Events -----
    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    // ----- Modifiers -----
    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted());
        require(!isEnded());
        _;
    }

    /**
     * @notice Constructor initializes the CrowdSale with parameters and default stages.
     * @param beneficiaryAddr The address where ETH funds will be forwarded.
     * @param tokenHolderAddr The address which holds the tokens and has approved this contract.
     * @param tokenAddr The address of the ERC20 token.
     * @param tokenRate The base token rate per wei.
     */
    function CrowdSale(
        address beneficiaryAddr,
        address tokenHolderAddr,
        address tokenAddr,
        uint tokenRate
    )
        public
    {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    /**
     * @dev Internal: define ICO stages and lock stages here.
     */
    function _initStages() internal {
        // Example: three ICO stages with decreasing bonus
        icoStages.push(Stage(7 days, 150)); // 50% bonus for first week
        icoStages.push(Stage(7 days, 120)); // 20% bonus second week
        icoStages.push(Stage(7 days, 100)); // no bonus third week

        // Lock stages: bonuses unlocked after these delays from endTime
        lockStages.push(Stage(30 days, 0));
        lockStages.push(Stage(60 days, 0));
        lockStages.push(Stage(90 days, 0));
    }

    /**
     * @notice Returns the token contract address.
     */
    function getTokenAddress() public view returns(address) {
        return address(token);
    }

    /**
     * @notice Returns locked tokens for a purchaser at a given stage index.
     */
    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        if (stageIdx >= purchasers[_purchaser].lockedToken.length) {
            return 0;
        }
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    /**
     * @notice Checks whether bonus tokens for a given lock stage can be unlocked.
     */
    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        require(stageIndex < lockStages.length);
        // compute unlock time = endTime + sum of durations up to stageIndex
        uint unlockTime = endTime;
        for (uint i = 0; i <= stageIndex; i++) {
            unlockTime += lockStages[i].duration;
        }
        return now >= unlockTime;
    }

    /**
     * @notice Checks if sale has started.
     */
    function isStarted() public view returns(bool) {
        return (startTime > 0 && now >= startTime);
    }

    /**
     * @notice Checks if funding goal is reached.
     */
    function isReachedGoal() public view returns(bool) {
        return (amountRaised >= amountGoal && amountGoal > 0);
    }

    /**
     * @notice Checks if sale has ended.
     */
    function isEnded() public view returns(bool) {
        return (startTime > 0 && now > endTime);
    }

    /**
     * @notice Returns current ICO stage index or -1 if none.
     */
    function getCurrentStage() public view returns(int) {
        if (!isStarted()) {
            return -1;
        }
        uint elapsed = now - startTime;
        uint cum = 0;
        for (uint i = 0; i < icoStages.length; i++) {
            cum += icoStages[i].duration;
            if (elapsed < cum) {
                return int(i);
            }
        }
        return -1;
    }

    /**
     * @notice Remaining time in seconds until end.
     */
    function getRemainingTimeInSecond() public view returns(uint) {
        if (!isStarted() || now >= endTime) {
            return 0;
        }
        return endTime - now;
    }

    /**
     * @dev Adds a purchaser to the list on first purchase.
     */
    function _addPurchaser(address purchaser) internal {
        purchaserList.push(purchaser);
    }

    /**
     * @notice Starts the crowd sale. Calculate endTime and goal.
     * @param fundingGoalInEther The goal in whole ether (e.g., 100 = 100 ETH).
     */
    function start(uint fundingGoalInEther) public onlyOwner {
        require(!isStarted());
        // convert to wei
        amountGoal = fundingGoalInEther * 1 ether;
        startTime = now;
        // total duration = sum of icoStages durations
        uint totalDuration = 0;
        for (uint i = 0; i < icoStages.length; i++) {
            totalDuration += icoStages[i].duration;
        }
        endTime = startTime + totalDuration;
    }

    /**
     * @notice Stops the crowd sale immediately.
     */
    function stop() public onlyOwner {
        require(isStarted());
        require(!isEnded());
        endTime = now;
    }

    /**
     * @notice Fallback: buy tokens.
     */
    function () payable public onlyOpenTime {
        _buyTokens(msg.sender);
    }

    /**
     * @dev Internal purchase logic.
     */
    function _buyTokens(address purchaser) internal {
        require(purchaser != address(0));
        uint weiAmount = msg.value;
        require(weiAmount > 0);

        // determine stage
        int stageIdx = getCurrentStage();
        require(stageIdx >= 0);

        // calculate tokens
        uint baseTokens;
        uint bonusTokens;
        (baseTokens, bonusTokens) = _getTokenCount(weiAmount);

        require(baseTokens > 0);

        // record pre-raise to check goal event
        uint prevRaised = amountRaised;
        // update state
        amountRaised += weiAmount;
        amountTokenIssued += baseTokens;

        // record purchaser
        if (purchasers[purchaser].amountEtherSpent == 0) {
            _addPurchaser(purchaser);
        }
        purchasers[purchaser].amountEtherSpent += weiAmount;
        purchasers[purchaser].amountTokenTaken += baseTokens;
        purchasers[purchaser].lockedToken.push(bonusTokens);

        // token transfer: base immediately
        require(token.transferFrom(tokenHolder, purchaser, baseTokens));

        // emit purchase event
        TokenPurchase(purchaser, weiAmount, baseTokens, bonusTokens);

        // emit goal reached if crossed in this purchase
        if (prevRaised < amountGoal && amountRaised >= amountGoal) {
            GoalReached(amountRaised, amountTokenIssued);
        }
    }

    /**
     * @dev Calculates base and bonus token counts for a payment.
     */
    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        // base tokens
        buyTokenCount = amountInWei * rate;
        // bonus
        int idx = getCurrentStage();
        if (idx >= 0) {
            uint r = icoStages[uint(idx)].rate;
            if (r > 100) {
                bonusTokenCount = buyTokenCount * (r - 100) / 100;
            }
        }
        return (buyTokenCount, bonusTokenCount);
    }

    /**
     * @notice Withdraw collected ETH to beneficiary.
     */
    function safeWithdrawal() public onlyOwner {
        uint balance = this.balance;
        require(balance > 0);
        beneficiary.transfer(balance);
        FundingWithdrawn(beneficiary, balance);
    }

    /**
     * @notice Unlocks bonus tokens for purchasers over a range for a specific stage.
     */
    function unlockBonusTokens(
        uint stageIndex,
        uint purchaserStartIdx,
        uint purchaserEndIdx
    )
        public
        afterEnded
        onlyOwner
    {
        require(stageIndex < lockStages.length);
        require(purchaserStartIdx < purchaserEndIdx);
        require(purchaserEndIdx <= purchaserList.length);
        require(canTokenUnlocked(stageIndex));

        for (uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
            address p = purchaserList[i];
            uint locked = 0;
            if (stageIndex < purchasers[p].lockedToken.length) {
                locked = purchasers[p].lockedToken[stageIndex];
            }
            if (locked > 0) {
                purchasers[p].lockedToken[stageIndex] = 0;
                purchasers[p].amountTokenTaken += locked;
                amountTokenIssued += locked;
                require(token.transferFrom(tokenHolder, p, locked));
                UnlockToken(p, locked);
            }
        }
    }
}