pragma solidity ^0.4.18;

library SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  function Ownable() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

contract IcoPhase {
  uint256 public constant phasePresale_From     = 1517493600; // 14h 01/02/2018 GMT
  uint256 public constant phasePresale_To       = 1518703200; // 14h 15/02/2018 GMT
  uint256 public constant phasePublicSale1_From = 1520690400; // 14h 10/03/2018 GMT
  uint256 public constant phasePublicSale1_To   = 1521122400; // 14h 15/03/2018 GMT
  uint256 public constant phasePublicSale2_From = 1521122400; // 14h 15/03/2018 GMT
  uint256 public constant phasePublicSale2_To   = 1521554400; // 14h 20/03/2018 GMT
  uint256 public constant phasePublicSale3_From = 1521554400; // 14h 20/03/2018 GMT
  uint256 public constant phasePublicSale3_To   = 1521986400; // 14h 25/03/2018 GMT
}

/**
 * @notice This contract manages the bonus distribution for an ICO, allowing the owner to enable or disable bonuses,
 *         calculate bonuses based on time and ETH amount, and manage bonus balances for participants.
 */
contract Bonus is IcoPhase, Ownable {
  using SafeMath for uint256;

  // decimals of tokens (unused in simple ETH-to-wei bonus calculation)
  uint256 constant decimals = 18;

  // whether bonus system is enabled
  bool public isBonus;

  // per‐account bonus balances (in wei)
  mapping(address => uint256) public bonusAccountBalances;
  // index of addresses that have ever held a bonus
  mapping(uint256 => address) public bonusAccountIndex;
  uint256 public bonusAccountCount;

  /**
   * @notice Initializes the contract with bonuses enabled.
   */
  function Bonus() public {
    isBonus = true;
  }

  /**
   * @notice Enables the bonus system.
   */
  function enableBonus() public onlyOwner returns (bool) {
    require(!isBonus);
    isBonus = true;
    return true;
  }

  /**
   * @notice Disables the bonus system.
   */
  function disableBonus() public onlyOwner returns (bool) {
    require(isBonus);
    isBonus = false;
    return true;
  }

  /**
   * @notice Gets the bonus percentage based on the current time.
   * @return The bonus percentage (integer, e.g. 20 for 20%).
   */
  function getBonusByTime() public constant returns (uint256) {
    uint256 t = now;
    if (t >= phasePresale_From && t < phasePresale_To) {
      return 20;
    } else if (t >= phasePublicSale1_From && t < phasePublicSale1_To) {
      return 15;
    } else if (t >= phasePublicSale2_From && t < phasePublicSale2_To) {
      return 10;
    } else if (t >= phasePublicSale3_From && t < phasePublicSale3_To) {
      return 5;
    }
    return 0;
  }

  /**
   * @notice Calculates the bonus amount (in wei) based on the provided ETH value.
   * @param _value The amount of wei contributed.
   * @return The bonus amount in wei.
   */
  function getBonusByETH(uint256 _value) public constant returns (uint256) {
    if (!isBonus) {
      return 0;
    }
    uint256 pct = getBonusByTime();
    if (pct == 0) {
      return 0;
    }
    return _value.mul(pct).div(100);
  }

  /**
   * @notice Returns the bonus balance of a specific account.
   */
  function balanceBonusOf(address _owner) public constant returns (uint256 balance) {
    return bonusAccountBalances[_owner];
  }

  /**
   * @notice Pays out stored bonus (in wei) to a specified address.
   * @dev Transfers the ETH bonus to the address and resets its stored balance to zero.
   */
  function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
    require(isBonus);
    uint256 amount = bonusAccountBalances[_address];
    require(amount > 0);
    // zero it out before transfer to prevent re‐entrancy
    bonusAccountBalances[_address] = 0;
    _address.transfer(amount);
    return true;
  }

  /**
   * @notice Fallback function to receive Ether into the contract.
   */
  function() public payable {
    // Accept ETH for later distribution via payBonusToAddress
    if (bonusAccountBalances[msg.sender] == 0) {
      bonusAccountIndex[bonusAccountCount] = msg.sender;
      bonusAccountCount = bonusAccountCount.add(1);
    }
    bonusAccountBalances[msg.sender] = bonusAccountBalances[msg.sender].add(msg.value);
  }
}