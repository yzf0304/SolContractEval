pragma solidity 0.4.15;

contract Ownable {
  address public owner;

  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
}

contract ERC20Interface {
  function transferFrom(address _from, address _to, uint _value) returns (bool){}
  function transfer(address _to, uint _value) returns (bool){}
  function ERC20Interface(){}
}

contract KyberGenesisToken is Ownable {
  string  public  constant name     = "Kyber Genesis Token";
  string  public  constant symbol   = "KGT";
  uint    public  constant decimals = 0;

  uint                   public totalSupply = 0;
  mapping(address=>uint) public balanceOf;
  bool                   public mintingFinished = false;
  address                public emergencyMultisig;

  event Transfer(address indexed _from, address indexed _to, uint _value);
  event EndMinting(uint timestamp);
  event Approval(address indexed _owner, address indexed _spender, uint _value);

  function KyberGenesisToken(address minter) {
    // assign the minter as owner and as the emergency multisig
    transferOwnership(minter);
    emergencyMultisig = minter;
  }

  /**
   * @notice Mints one token to each recipient. Each address may only ever receive one.
   * @dev Only callable by owner while minting has not been finished.
   */
  function mint(address[] recipients) onlyOwner {
    require(!mintingFinished);
    for (uint i = 0; i < recipients.length; i++) {
      address to = recipients[i];
      require(to != address(0));
      require(balanceOf[to] == 0);
      balanceOf[to] = 1;
      totalSupply += 1;
      Transfer(address(0), to, 1);
    }
  }

  /**
   * @notice Ends the minting period forever and "burns" ownership.
   */
  function endMinting() onlyOwner {
    require(!mintingFinished);
    mintingFinished = true;
    EndMinting(block.timestamp);
    // remove ownership so no further owner-only calls are possible
    owner = address(0);
  }

  /**
   * @notice Burns exactly one token held by the caller.
   */
  function burn() {
    require(balanceOf[msg.sender] == 1);
    balanceOf[msg.sender] = 0;
    totalSupply -= 1;
    Transfer(msg.sender, address(0), 1);
  }

  /**
   * @notice Drains any ERC20 sent here by mistake to a predefined multisig.
   * @param token The ERC20 token to recover.
   * @param amount The amount to recover.
   */
  function emergencyERC20Drain(ERC20Interface token, uint amount) {
    token.transfer(emergencyMultisig, amount);
  }

  // The following ERC20 methods are non-functional stubs and always revert or return 0.
  function transfer(address _to, uint _value) returns (bool) {
    revert();
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool) {
    revert();
  }

  function approve(address _spender, uint _value) returns (bool) {
    revert();
  }

  function allowance(address /*_owner*/, address /*_spender*/) constant returns (uint) {
    return 0;
  }
}