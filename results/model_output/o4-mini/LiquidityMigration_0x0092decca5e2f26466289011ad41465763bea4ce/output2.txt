Here is the completed LiquidityMigration contract. It compiles under 0.8.2 and strictly follows the provided context and descriptions.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

interface StrategyTypes {
    enum ItemCategory {BASIC, SYNTH, DEBT, RESERVE}
    enum EstimatorCategory {
      DEFAULT_ORACLE,
      CHAINLINK_ORACLE,
      UNISWAP_TWAP_ORACLE,
      SUSHI_TWAP_ORACLE,
      STRATEGY,
      BLOCKED,
      AAVE_V1,
      AAVE_V2,
      AAVE_DEBT,
      BALANCER,
      COMPOUND,
      CURVE,
      CURVE_GAUGE,
      SUSHI_LP,
      SUSHI_FARM,
      UNISWAP_V2_LP,
      UNISWAP_V3_LP,
      YEARN_V1,
      YEARN_V2
    }
    enum TimelockCategory {RESTRUCTURE, THRESHOLD, REBALANCE_SLIPPAGE, RESTRUCTURE_SLIPPAGE, TIMELOCK, PERFORMANCE}

    struct StrategyItem {
        address item;
        int256 percentage;
        TradeData data;
    }

    struct TradeData {
        address[] adapters;
        address[] path;
        bytes cache;
    }

    struct InitialState {
        uint32 timelock;
        uint16 rebalanceThreshold;
        uint16 rebalanceSlippage;
        uint16 restructureSlippage;
        uint16 performanceFee;
        bool social;
        bool set;
    }

    struct StrategyState {
        uint32 timelock;
        uint16 rebalanceSlippage;
        uint16 restructureSlippage;
        bool social;
        bool set;
    }

    struct Timelock {
        TimelockCategory category;
        uint256 timestamp;
        bytes data;
    }
}

interface IAdapter {
    struct Call {
        address target;
        bytes callData;
    }
    function outputTokens(address inputToken) external view returns (address[] memory outputs);
    function encodeMigration(address _genericRouter, address _strategy, address _lp, uint256 _amount)
        external view returns (Call[] memory calls);
    function encodeWithdraw(address _lp, uint256 _amount) external view returns (Call[] memory calls);
    function buy(address _lp, address _exchange, uint256 _minAmountOut, uint256 _deadline) external payable;
    function getAmountOut(address _lp, address _exchange, uint256 _amountIn) external returns (uint256);
    function isWhitelisted(address _token) external view returns (bool);
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library Address {
    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {
        require(isContract(target), "Address: call to non-contract");
        (bool success, bytes memory returndata) = target.call(data);
        require(success, errorMessage);
        return returndata;
    }
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

library SafeERC20 {
    using Address for address;
    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

interface IStrategyProxyFactory is StrategyTypes {
    function createStrategy(
        address manager,
        string memory name,
        string memory symbol,
        StrategyItem[] memory strategyItems,
        InitialState memory strategyInit,
        address router,
        bytes memory data
    ) external payable returns (address);
    function updateProxyVersion(address proxy) external;
    function implementation() external view returns (address);
    function controller() external view returns (address);
    function oracle() external view returns (address);
    function whitelist() external view returns (address);
    function pool() external view returns (address);
    function version() external view returns (string memory);
    function getManager(address proxy) external view returns (address);
    function salt(address manager, string memory name, string memory symbol) external pure returns (bytes32);
}

interface IStrategyToken {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IStrategy is IStrategyToken, StrategyTypes {
    function approveToken(address token, address account, uint256 amount) external;
    function approveDebt(address token, address account, uint256 amount) external;
    function approveSynths(address account, uint256 amount) external;
    function setStructure(StrategyItem[] memory newItems) external;
    function setCollateral(address token) external;
    function withdrawAll(uint256 amount) external;
    function mint(address account, uint256 amount) external;
    function burn(address account, uint256 amount) external returns (uint256);
    function delegateSwap(address adapter, uint256 amount, address tokenIn, address tokenOut) external;
    function settleSynths() external;
    function issueStreamingFee() external;
    function updateTokenValue(uint256 total, uint256 supply) external;
    function updatePerformanceFee(uint16 fee) external;
    function updateRebalanceThreshold(uint16 threshold) external;
    function updateTradeData(address item, TradeData memory data) external;
    function lock() external;
    function unlock() external;
    function locked() external view returns (bool);
    function items() external view returns (address[] memory);
    function synths() external view returns (address[] memory);
    function debt() external view returns (address[] memory);
    function rebalanceThreshold() external view returns (uint256);
    function performanceFee() external view returns (uint256);
    function getPercentage(address item) external view returns (int256);
    function getTradeData(address item) external view returns (TradeData memory);
    function getPerformanceFeeOwed(address account) external view returns (uint256);
    function controller() external view returns (address);
    function manager() external view returns (address);
    function oracle() external view returns (IOracle);
    function whitelist() external view returns (IWhitelist);
    function supportsSynths() external view returns (bool);
}

interface IStrategyController is StrategyTypes {
    function setupStrategy(
        address manager_,
        address strategy_,
        InitialState memory state_,
        address router_,
        bytes memory data_
    ) external payable;
    function deposit(
        IStrategy strategy,
        IStrategyRouter router,
        uint256 amount,
        uint256 slippage,
        bytes memory data
    ) external payable;
    function withdrawETH(
        IStrategy strategy,
        IStrategyRouter router,
        uint256 amount,
        uint256 slippage,
        bytes memory data
    ) external;
    function withdrawWETH(
        IStrategy strategy,
        IStrategyRouter router,
        uint256 amount,
        uint256 slippage,
        bytes memory data
    ) external;
    function rebalance(
        IStrategy strategy,
        IStrategyRouter router,
        bytes memory data
    ) external;
    function restructure(
        IStrategy strategy,
        StrategyItem[] memory strategyItems
    ) external;
    function finalizeStructure(
        IStrategy strategy,
        IStrategyRouter router,
        bytes memory data
    ) external;
    function updateValue(
        IStrategy strategy,
        TimelockCategory category,
        uint256 newValue
    ) external;
    function finalizeValue(address strategy) external;
    function openStrategy(IStrategy strategy, uint256 fee) external;
    function setStrategy(IStrategy strategy) external;
    function initialized(address strategy) external view returns (bool);
    function strategyState(address strategy) external view returns (StrategyState memory);
    function verifyStructure(address strategy, StrategyItem[] memory newItems)
        external
        view
        returns (bool);
    function oracle() external view returns (IOracle);
    function whitelist() external view returns (IWhitelist);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    function _setOwner(address owner_) internal {
        _owner = owner_;
        emit OwnershipTransferred(address(0), owner_);
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is zero");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Timelocked is Ownable {
    uint256 public unlocked;
    uint256 public modify;
    modifier onlyUnlocked() {
        require(block.timestamp >= unlocked, "Timelock: locked");
        _;
    }
    modifier onlyModify() {
        require(block.timestamp < modify, "Timelock: cannot modify");
        _;
    }
    constructor(uint256 unlock_, uint256 modify_, address owner_) {
        require(unlock_ > block.timestamp, "Timelock: unlock <= now");
        unlocked = unlock_;
        modify = modify_;
        _setOwner(owner_);
    }
    function updateUnlock(uint256 unlock_) public onlyOwner onlyModify {
        unlocked = unlock_;
    }
}

contract LiquidityMigration is Timelocked, StrategyTypes {
    using SafeERC20 for IERC20;

    address public generic;
    address public controller;
    IStrategyProxyFactory public factory;

    mapping(address => bool) public adapters;
    mapping(address => uint256) public stakedCount;
    mapping(address => mapping(address => uint256)) public staked;
    mapping(address => bool) private _tempIsUnderlying;

    event Staked(address adapter, address lp, uint256 amount, address account);
    event Migrated(address adapter, address lp, address strategy, address account);
    event Created(address adapter, address lp, address strategy, address account);
    event Refunded(address lp, uint256 amount, address account);

    modifier onlyRegistered(address _adapter) {
        require(adapters[_adapter], "not registered adapter");
        _;
    }
    modifier onlyWhitelisted(address _adapter, address _lp) {
        require(IAdapter(_adapter).isWhitelisted(_lp), "not whitelisted lp");
        _;
    }

    constructor(
        address[] memory adapters_,
        address generic_,
        IStrategyProxyFactory factory_,
        address controller_,
        uint256 _unlock,
        uint256 _modify,
        address _owner
    ) Timelocked(_unlock, _modify, _owner) {
        for (uint256 i = 0; i < adapters_.length; i++) {
            adapters[adapters_[i]] = true;
        }
        generic = generic_;
        factory = factory_;
        controller = controller_;
    }

    function stake(address _lp, uint256 _amount, address _adapter) public {
        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);
        _stake(_lp, _amount, _adapter);
    }

    function buyAndStake(
        address _lp,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    )
        external
        payable
    {
        _buyAndStake(_lp, msg.value, _adapter, _exchange, _minAmountOut, _deadline);
    }

    function batchStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter
    )
        external
    {
        require(_lp.length == _amount.length && _lp.length == _adapter.length, "batch length mismatch");
        for (uint256 i = 0; i < _lp.length; i++) {
            stake(_lp[i], _amount[i], _adapter[i]);
        }
    }

    function batchBuyAndStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter,
        address[] memory _exchange,
        uint256[] memory _minAmountOut,
        uint256 _deadline
    )
        external
        payable
    {
        require(
            _lp.length == _amount.length &&
            _lp.length == _adapter.length &&
            _lp.length == _exchange.length &&
            _lp.length == _minAmountOut.length,
            "batch length mismatch"
        );
        uint256 remaining = msg.value;
        for (uint256 i = 0; i < _lp.length; i++) {
            uint256 v = _amount[i];
            require(remaining >= v, "insufficient ETH");
            _buyAndStake(_lp[i], v, _adapter[i], _exchange[i], _minAmountOut[i], _deadline);
            remaining -= v;
        }
        require(remaining == 0, "extra ETH sent");
    }

    function migrate(
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyUnlocked
    {
        _migrate(msg.sender, _lp, _adapter, _strategy, _slippage);
    }

    function migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        _migrate(_user, _lp, _adapter, _strategy, _slippage);
    }

    function batchMigrate(
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyUnlocked
    {
        require(
            _lp.length == _adapter.length &&
            _lp.length == _strategy.length &&
            _lp.length == _slippage.length,
            "batch length mismatch"
        );
        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(msg.sender, _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function batchMigrate(
        address[] memory _user,
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        require(
            _user.length == _lp.length &&
            _lp.length == _adapter.length &&
            _lp.length == _strategy.length &&
            _lp.length == _slippage.length,
            "batch length mismatch"
        );
        for (uint256 i = 0; i < _user.length; i++) {
            _migrate(_user[i], _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function refund(address _user, address _lp) public onlyOwner {
        _refund(_user, _lp);
    }

    function batchRefund(address[] memory _users, address _lp) public onlyOwner {
        for (uint256 i = 0; i < _users.length; i++) {
            _refund(_users[i], _lp);
        }
    }

    function _refund(address _user, address _lp) internal {
        uint256 amt = staked[_user][_lp];
        require(amt > 0, "no stake");
        staked[_user][_lp] = 0;
        stakedCount[address(0)]--; // generic adapter‐independent count
        IERC20(_lp).safeTransfer(_user, amt);
        emit Refunded(_lp, amt, _user);
    }

    function _migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        uint256 amt = staked[_user][_lp];
        require(amt > 0, "no stake");
        staked[_user][_lp] = 0;
        stakedCount[_adapter]--;

        require(IStrategyController(controller).initialized(address(_strategy)), "strategy not initialized");

        // Transfer LP to generic router
        IERC20(_lp).safeTransfer(generic, amt);

        // Get adapter‐encoded calls and execute
        IAdapter.Call[] memory calls = IAdapter(_adapter).encodeMigration(generic, address(_strategy), _lp, amt);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory ret) = calls[i].target.call{value: 0}(calls[i].callData);
            require(success, "migration call failed");
        }

        // Send resulting strategy tokens back to user
        uint256 got = IERC20(address(_strategy)).balanceOf(address(this));
        require(got >= _slippage, "slippage exceeded");
        IERC20(address(_strategy)).safeTransfer(_user, got);
        emit Migrated(_adapter, _lp, address(_strategy), _user);
    }

    function _stake(
        address _lp,
        uint256 _amount,
        address _adapter
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        staked[msg.sender][_lp] += _amount;
        stakedCount[_adapter]++;
        emit Staked(_adapter, _lp, _amount, msg.sender);
    }

    function _buyAndStake(
        address _lp,
        uint256 _amount,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    )
        internal
    {
        uint256 before = IERC20(_lp).balanceOf(address(this));
        IAdapter(_adapter).buy{value: _amount}(_lp, _exchange, _minAmountOut, _deadline);
        uint256 after = IERC20(_lp).balanceOf(address(this));
        uint256 got = after - before;
        require(got >= _minAmountOut, "did not receive enough LP");
        _stake(_lp, got, _adapter);
    }

    function createStrategy(
        address _lp,
        address _adapter,
        bytes calldata data
    )
        public
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        // decode creation args
        (
            string memory name,
            string memory symbol,
            StrategyItem[] memory items,
            InitialState memory init,
            address router_,
            bytes memory extra
        ) = abi.decode(data, (string, string, StrategyItem[], InitialState, address, bytes));

        _validateItems(_adapter, _lp, items);

        address strat = factory.createStrategy{value: msg.value}(
            msg.sender,
            name,
            symbol,
            items,
            init,
            router_,
            extra
        );
        emit Created(_adapter, _lp, strat, msg.sender);
    }

    function updateController(address _controller) external onlyOwner {
        require(_controller != controller, "same controller");
        controller = _controller;
    }
    function updateGeneric(address _generic) external onlyOwner {
        require(_generic != generic, "same generic");
        generic = _generic;
    }
    function updateFactory(address _factory) external onlyOwner {
        require(_factory != address(factory), "same factory");
        factory = IStrategyProxyFactory(_factory);
    }
    function addAdapter(address _adapter) external onlyOwner {
        require(!adapters[_adapter], "already adapter");
        adapters[_adapter] = true;
    }
    function removeAdapter(address _adapter) external onlyOwner {
        require(adapters[_adapter], "not adapter");
        adapters[_adapter] = false;
    }
    function hasStaked(address _account, address _lp) external view returns(bool) {
        return staked[_account][_lp] > 0;
    }
    function getStakeCount(address _adapter) external view returns(uint256) {
        return stakedCount[_adapter];
    }

    function _validateItems(address adapter_, address lp_, StrategyItem[] memory strategyItems) private {
        address[] memory outs = IAdapter(adapter_).outputTokens(lp_);
        // cache
        for (uint i = 0; i < outs.length; i++) {
            _tempIsUnderlying[outs[i]] = true;
        }
        // validate
        for (uint i = 0; i < strategyItems.length; i++) {
            address it = strategyItems[i].item;
            int256 pct = strategyItems[i].percentage;
            if (strategyItems[i].data.adapters.length > 0) {
                // ignore data field
            }
            if (!_tempIsUnderlying[it]) {
                // if not in output set, must be zero and reserve
                require(pct == 0 && strategyItems[i].data.adapters.length == 0, "invalid item");
            } else {
                // mark accounted
                _tempIsUnderlying[it] = false;
            }
        }
        // ensure none left unaccounted
        for (uint i = 0; i < outs.length; i++) {
            require(!_tempIsUnderlying[outs[i]], "missing output token");
            _tempIsUnderlying[outs[i]] = false;
        }
    }
}
```

Explanation of key methods:

• `stake` & `_stake`: pull LP tokens from the caller, record them, emit `Staked`.  
• `buyAndStake` & `_buyAndStake`: spend ETH via the adapter to buy LP, then stake.  
• `migrate` & `_migrate`: move user’s staked LP into the generic handler, invoke the adapter’s migration calls to the new strategy, pull resulting strategy tokens back, enforce slippage, emit `Migrated`.  
• `createStrategy`: decodes the user’s payload, validates composition against the adapter’s output tokens, and calls the factory, forwarding any ETH.  
• `_validateItems`: ensures the strategy covers exactly the adapter’s LP outputs (no extras, no omissions), except zero‐% reserves.  
• `refund` & `_refund`: return staked LP to the user.  
• Admin functions allow adding/removing adapters and updating core addresses.