pragma solidity 0.4.23;

contract MESH is StandardToken {

    // Prevent direct ETH transfers
    function () public {
        revert();
    }

    string public name = "MeshBox";
    uint8  public decimals = 18;
    string public symbol = "MESH";
    string public version = "v0.1";
    uint256 public allocateEndTime;

    // Nonces for replay protection
    mapping(address => uint256) private nonces;

    /**
     * @dev Set allocation window to now + 1 day
     */
    constructor() public {
        allocateEndTime = now + 1 days;
    }

    /**
     * @notice Proxy transfer of MESH tokens with a fee to the relayer
     * @dev Verifies an EIP-191 signature from _from over the parameters and current nonce.
     */
    function transferProxy(
        address _from,
        address _to,
        uint256 _value,
        uint256 _feeMesh,
        uint8   _v,
        bytes32 _r,
        bytes32 _s
    )
        public
        transferAllowed(_from)
        returns (bool)
    {
        // 1) construct the hash to sign:
        //    keccak256(_from, _to, _value, _feeMesh, nonce)
        bytes32 hash = keccak256(_from, _to, _value, _feeMesh, nonces[_from]);
        // 2) prefix & recover
        bytes32 prefixed = keccak256("\x19Ethereum Signed Message:\n32", hash);
        address signer = ecrecover(prefixed, _v, _r, _s);
        require(signer == _from);

        // 3) bump nonce
        nonces[_from]++;

        // 4) perform the transfers
        uint256 total = _value + _feeMesh;
        require(balances[_from] >= total);
        require(balances[_to] + _value >= balances[_to]);
        require(balances[msg.sender] + _feeMesh >= balances[msg.sender]);

        balances[_from]     -= total;
        balances[_to]       += _value;
        balances[msg.sender]+= _feeMesh;

        emit Transfer(_from, _to,       _value);
        emit Transfer(_from, msg.sender, _feeMesh);

        return true;
    }

    /**
     * @notice Proxy approve with relayer paying gas
     * @dev Verifies an EIP-191 signature and updates allowance
     */
    function approveProxy(
        address _from,
        address _spender,
        uint256 _value,
        uint8   _v,
        bytes32 _r,
        bytes32 _s
    )
        public
        returns (bool)
    {
        // 1) hash
        bytes32 hash = keccak256(_from, _spender, _value, nonces[_from]);
        // 2) prefix & recover
        bytes32 prefixed = keccak256("\x19Ethereum Signed Message:\n32", hash);
        address signer = ecrecover(prefixed, _v, _r, _s);
        require(signer == _from);

        // 3) bump nonce
        nonces[_from]++;

        // 4) set allowance
        allowed[_from][_spender] = _value;
        emit Approval(_from, _spender, _value);
        return true;
    }

    /**
     * @notice Query the current nonce for an address
     */
    function getNonce(address _addr) public view returns (uint256) {
        return nonces[_addr];
    }

    /**
     * @notice Owner can allocate tokens to a batch of addresses before end time
     */
    function allocateTokens(address[] _owners, uint256[] _values)
        public
        onlyOwner
    {
        require(now <= allocateEndTime);
        require(_owners.length == _values.length);

        for (uint256 i = 0; i < _owners.length; i++) {
            address to    = _owners[i];
            uint256 value = _values[i];

            // prevent overflow
            require(balances[to] + value >= balances[to]);
            require(totalSupply + value >= totalSupply);

            balances[to]      += value;
            totalSupply       += value;
            emit Transfer(address(0), to, value);
        }
    }
}