Here is the completed `MatBase` contract. It strictly follows your provided context, uses Solidity 0.4.17, and does not introduce any extraneous code or dependencies. All unimplemented functions have been filled in according to the described behavior.

```solidity
pragma solidity ^0.4.17;

/**
 *Submitted for verification at Etherscan.io on 2017-10-17
*/
library SafeMath {
  function mul(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }
  function div(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a / b;
    return c;
  }
  function sub(uint256 a, uint256 b) internal constant returns (uint256) {
    assert(b <= a);
    return a - b;
  }
  function add(uint256 a, uint256 b) internal constant returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  function Ownable() { owner = msg.sender; }
  modifier onlyOwner() { require(msg.sender == owner); _; }
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}

contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}

contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract BasicToken is ERC20Basic, Ownable {
  using SafeMath for uint256;
  mapping(address => uint256) balances;
  bool transferAllowed = false;
  function setTransferAllowed(bool _transferAllowed) public onlyOwner {
    transferAllowed = _transferAllowed;
  }
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);
    require(transferAllowed);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}

contract StandardToken is ERC20, BasicToken {
  using SafeMath for uint256;
  mapping (address => mapping (address => uint256)) internal allowed;
  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);
    require(transferAllowed);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
  }
  function approve(address _spender, uint256 _value) public returns (bool) {
    require((_value == 0) || (allowed[msg.sender][_spender] == 0));
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }
  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}

contract MatToken is Ownable, StandardToken {
  string public constant name = "MiniApps Token";
  string public constant symbol = "MAT";
  uint   public constant decimals = 18;

  uint256 public constant MAT_UNIT = 10**uint256(decimals);
  uint256 constant MILLION_MAT = 10**6 * MAT_UNIT;
  uint256 constant THOUSAND_MAT = 10**3 * MAT_UNIT;

  uint256 public constant MAT_CROWDSALE_SUPPLY_LIMIT = 10 * MILLION_MAT;
  uint256 public constant MAT_TEAM_SUPPLY_LIMIT = 7 * MILLION_MAT;
  uint256 public constant MAT_PARTNERS_SUPPLY_LIMIT = 3 * MILLION_MAT;
  uint256 public constant MAT_TOTAL_SUPPLY_LIMIT = MAT_CROWDSALE_SUPPLY_LIMIT
                                                   + MAT_TEAM_SUPPLY_LIMIT
                                                   + MAT_PARTNERS_SUPPLY_LIMIT;
}

contract MatBonus is MatToken {
  uint256 public constant TOTAL_SUPPLY_UPPER_BOUND = 14000 * THOUSAND_MAT;
  uint256 public constant TOTAL_SUPPLY_BOTTOM_BOUND = 11600 * THOUSAND_MAT;
  function calcBonus(uint256 tokens) internal returns (uint256) {
    if (totalSupply <= TOTAL_SUPPLY_BOTTOM_BOUND)
      return tokens.mul(8).div(100);
    else if (totalSupply <= TOTAL_SUPPLY_UPPER_BOUND)
      return tokens.mul(5).div(100);
    else
      return 0;
  }
}

/**
 * @title MatBase
 * @dev Base for crowdsale: minting, whitelist, purchases
 */
contract MatBase is Ownable, MatToken, MatBonus {
  using SafeMath for uint256;

  uint256 public constant _START_DATE = 1508284800;
  uint256 public constant _END_DATE   = 1513641600;
  uint256 public constant CROWDSALE_PRICE = 100; // MAT per ETH

  address public constant ICO_ADDRESS      = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;
  address public constant PARTNERS_WALLET = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;
  address public constant TEAM_WALLET     = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;

  uint256 public startTime;
  uint256 public endTime;

  function setStartTime(uint256 _startTime) onlyOwner public {
    require(_startTime < endTime);
    startTime = _startTime;
  }
  function setEndTime(uint256 _endTime) onlyOwner public {
    require(_endTime > startTime);
    endTime = _endTime;
  }

  address public wallet;
  address public p_wallet;
  address public t_wallet;

  uint256 public totalCollected;
  uint256 public rate;

  function hasEnded() public constant returns (bool) {
    return now > endTime;
  }

  event Mint(address indexed purchaser, uint256 amount);
  event Bonus(address indexed purchaser, uint256 amount);
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amountTokens,
    string referral
  );

  function mint(address _to, uint256 _tokens) internal returns (bool) {
    require(_to != address(0));
    require(_tokens > 0);
    require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);
    totalSupply = totalSupply.add(_tokens);
    balances[_to] = balances[_to].add(_tokens);
    Mint(_to, _tokens);
    return true;
  }

  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  function validPurchase() internal constant returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  function () payable public {
    buyTokens(msg.sender);
  }

  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 tokens = msg.value.mul(rate);
    if (isWhitelistOn && whitelist[beneficiary].status == WLS.listed) {
      // Whitelist purchase
      require(buyTokenWL(tokens));
      TokenPurchase(msg.sender, beneficiary, msg.value, tokens, "");
      totalCollected = totalCollected.add(msg.value);
      forwardFunds();
    } else {
      // Public purchase
      require(mint(beneficiary, tokens));
      uint256 bonus = calcBonus(tokens);
      if (bonus > 0) {
        require(mint(beneficiary, bonus));
        Bonus(beneficiary, bonus);
      }
      TokenPurchase(msg.sender, beneficiary, msg.value, tokens, "");
      totalCollected = totalCollected.add(msg.value);
      forwardFunds();
    }
  }

  function buyTokensReferral(address beneficiary, string referral) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 tokens = msg.value.mul(rate);
    if (isWhitelistOn && whitelist[beneficiary].status == WLS.listed) {
      require(buyTokenWL(tokens));
      TokenPurchase(msg.sender, beneficiary, msg.value, tokens, referral);
      totalCollected = totalCollected.add(msg.value);
      forwardFunds();
    } else {
      require(mint(beneficiary, tokens));
      uint256 bonus = calcBonus(tokens);
      if (bonus > 0) {
        require(mint(beneficiary, bonus));
        Bonus(beneficiary, bonus);
      }
      TokenPurchase(msg.sender, beneficiary, msg.value, tokens, referral);
      totalCollected = totalCollected.add(msg.value);
      forwardFunds();
    }
  }

  bool public isWhitelistOn;
  uint256 public whiteListLimit;

  enum WLS { notlisted, listed, fulfilled }
  struct FundReservation {
    WLS status;
    uint256 reserved;
  }
  mapping (address => FundReservation) public whitelist;

  event White(address indexed to, uint256 reservation);

  function stopWhitelistReservetion() onlyOwner public {
    whiteListLimit = 0;
  }
  function setWhiteListStatus(bool _isWhitelistOn) onlyOwner public {
    isWhitelistOn = _isWhitelistOn;
  }

  function buyTokenWL(uint256 tokens) internal returns (bool) {
    FundReservation storage r = whitelist[msg.sender];
    require(r.status == WLS.listed);
    require(tokens <= r.reserved);
    r.reserved = r.reserved.sub(tokens);
    r.status = WLS.fulfilled;
    // mint without bonus
    require(mint(msg.sender, tokens));
    return true;
  }

  function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool) {
    require(isWhitelistOn);
    require(wlmember != address(0));
    require(reservation > 0);
    require(whitelist[wlmember].status == WLS.notlisted);
    require(reservation <= whiteListLimit);
    whitelist[wlmember] = FundReservation(WLS.listed, reservation);
    whiteListLimit = whiteListLimit.sub(reservation);
    White(wlmember, reservation);
    return true;
  }

  address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;
  function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool) {
    require(_to != address(0));
    require(_tokens > 0);
    require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);
    totalSupply = totalSupply.add(_tokens);
    balances[_to] = balances[_to].add(_tokens);
    Mint(_to, _tokens);
    return true;
  }

  function MatBase() public {
    startTime = _START_DATE;
    endTime   = _END_DATE;
    wallet    = ICO_ADDRESS;
    rate      = CROWDSALE_PRICE;
    p_wallet  = PARTNERS_WALLET;
    t_wallet  = TEAM_WALLET;
    // pre-allocate partners and team
    balances[p_wallet] = MAT_PARTNERS_SUPPLY_LIMIT;
    balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;
    totalSupply = MAT_PARTNERS_SUPPLY_LIMIT.add(MAT_TEAM_SUPPLY_LIMIT);
    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;
  }
}
```

Explanation of key points:

1. **Minting (`mint`)**  
   - Ensures we never exceed `MAT_TOTAL_SUPPLY_LIMIT`.  
   - Updates `totalSupply` and `balances`, and emits `Mint`.

2. **Purchasing**  
   - `buyTokens` and `buyTokensReferral` check `validPurchase()`.  
   - If whitelist is on and the user is listed, they go through `buyTokenWL`, which deducts from their reservation and mints their reserved tokens (no bonus).  
   - Otherwise they mint at the public rate and receive any automatic bonus from `calcBonus`.  
   - Both paths forward ETH to `wallet`, update `totalCollected`, and emit `TokenPurchase`.

3. **Whitelist**  
   - Controlled by `isWhitelistOn`, managed by `setWhiteListStatus`.  
   - The owner registers addresses via `regWL`, specifying their reservation.  
   - `stopWhitelistReservetion` zeroes out any remaining whitelist capacity.  

4. **Presale Conversion**  
   - `convert` allows the owner to mint main‐sale tokens against presale tokens (no bonus), up to the global supply cap.

All parts strictly conform to the original Solidity 0.4.17 style and the provided structure.