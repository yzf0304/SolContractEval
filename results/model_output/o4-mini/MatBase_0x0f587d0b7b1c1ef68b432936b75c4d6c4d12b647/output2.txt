```solidity
pragma solidity ^0.4.17;

contract MatBase is Ownable, MatToken, MatBonus {
  using SafeMath for uint256;

  uint256 public constant _START_DATE = 1508284800;        // 18-Oct-17 00:00:00 UTC
  uint256 public constant _END_DATE   = 1513641600;        // 19-Dec-17 00:00:00 UTC
  uint256 public constant CROWDSALE_PRICE = 100;           // 100 MAT per ETH
  address public constant ICO_ADDRESS      = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;
  address public constant PARTNERS_WALLET  = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;
  address public constant TEAM_WALLET      = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;
  address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;

  uint256 public startTime;
  uint256 public endTime;
  address public wallet;
  address public p_wallet;
  address public t_wallet;
  uint256 public totalCollected;
  uint256 public rate;

  bool public isWhitelistOn;
  uint256 public whiteListLimit;

  enum WLS { notlisted, listed, fulfilled }
  struct FundReservation {
    WLS status;
    uint256 reserved;
  }
  mapping(address => FundReservation) public whitelist;

  event Mint(address indexed purchaser, uint256 amount);
  event Bonus(address indexed purchaser, uint256 amount);
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amountTokens,
    string referral
  );
  event White(address indexed to, uint256 reservation);

  function MatBase() public {
    startTime      = _START_DATE;
    endTime        = _END_DATE;
    wallet         = ICO_ADDRESS;
    rate           = CROWDSALE_PRICE;
    p_wallet       = PARTNERS_WALLET;
    t_wallet       = TEAM_WALLET;
    balances[p_wallet] = MAT_PARTNERS_SUPPLY_LIMIT;
    balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;
    totalSupply    = MAT_PARTNERS_SUPPLY_LIMIT.add(MAT_TEAM_SUPPLY_LIMIT);
    whiteListLimit = MAT_TOTAL_SUPPLY_LIMIT;
  }

  function setStartTime(uint256 _startTime) onlyOwner public {
    startTime = _startTime;
  }

  function setEndTime(uint256 _endTime) onlyOwner public {
    endTime = _endTime;
  }

  function hasEnded() public constant returns (bool) {
    return (now > endTime) || (totalSupply >= MAT_TOTAL_SUPPLY_LIMIT);
  }

  function mint(address _to, uint256 _tokens) internal returns (bool) {
    require(_to != address(0));
    // Ensure we do not exceed total supply cap
    require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);
    balances[_to] = balances[_to].add(_tokens);
    totalSupply   = totalSupply.add(_tokens);
    Mint(_to, _tokens);
    return true;
  }

  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  function validPurchase() internal constant returns (bool) {
    bool withinPeriod   = (now >= startTime) && (now <= endTime);
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

  function () public payable {
    buyTokens(msg.sender);
  }

  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 tokens = msg.value.mul(rate);
    // Mint base tokens
    require(mint(beneficiary, tokens));

    // Mint bonus if any
    uint256 bonus = calcBonus(tokens);
    if (bonus > 0) {
      require(mint(beneficiary, bonus));
      Bonus(beneficiary, bonus);
      tokens = tokens.add(bonus);
    }

    totalCollected = totalCollected.add(msg.value);
    TokenPurchase(msg.sender, beneficiary, msg.value, tokens, "");
    forwardFunds();
  }

  function buyTokensReferral(address beneficiary, string referral) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 tokens = msg.value.mul(rate);
    require(mint(beneficiary, tokens));

    uint256 bonus = calcBonus(tokens);
    if (bonus > 0) {
      require(mint(beneficiary, bonus));
      Bonus(beneficiary, bonus);
      tokens = tokens.add(bonus);
    }

    totalCollected = totalCollected.add(msg.value);
    TokenPurchase(msg.sender, beneficiary, msg.value, tokens, referral);
    forwardFunds();
  }

  function stopWhitelistReservetion() onlyOwner public {
    isWhitelistOn = false;
  }

  function setWhiteListStatus(bool _isWhitelistOn) onlyOwner public {
    isWhitelistOn = _isWhitelistOn;
  }

  function buyTokenWL(uint256 tokens) internal returns (bool) {
    require(isWhitelistOn);
    FundReservation storage fr = whitelist[msg.sender];
    require(fr.status == WLS.listed);
    require(tokens <= fr.reserved);
    // Ensure correct payment
    require(msg.value.mul(rate) == tokens);
    require(totalSupply.add(tokens) <= MAT_TOTAL_SUPPLY_LIMIT);

    // Mint base and bonus
    require(mint(msg.sender, tokens));
    uint256 bonus = calcBonus(tokens);
    if (bonus > 0) {
      require(mint(msg.sender, bonus));
      Bonus(msg.sender, bonus);
      tokens = tokens.add(bonus);
    }

    // Mark reservation fulfilled
    fr.reserved = fr.reserved.sub(tokens);
    fr.status   = WLS.fulfilled;

    totalCollected = totalCollected.add(msg.value);
    TokenPurchase(msg.sender, msg.sender, msg.value, tokens, "");
    forwardFunds();
    return true;
  }

  function regWL(address wlmember, uint256 reservation) onlyOwner public returns (bool) {
    require(wlmember != address(0));
    require(whitelist[wlmember].status == WLS.notlisted);
    require(reservation > 0 && reservation <= whiteListLimit);

    whitelist[wlmember] = FundReservation({
      status:   WLS.listed,
      reserved: reservation
    });

    whiteListLimit = whiteListLimit.sub(reservation);
    White(wlmember, reservation);
    return true;
  }

  function convert(address _to, uint256 _pretokens, uint256 _tokens) onlyOwner public returns (bool) {
    require(_to != address(0));
    require(_pretokens > 0 && _tokens > 0);
    require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);
    require(mint(_to, _tokens));
    return true;
  }
}
```