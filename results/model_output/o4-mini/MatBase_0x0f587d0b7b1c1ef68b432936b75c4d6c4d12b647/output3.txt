Here is the completed MatBase contract (compatible with Solidity 0.4.17), strictly following the provided context and requirements. It implements minting (with bonus), whitelist‐based reservations, presale conversion, crowdsale purchase (including referral), time checks, fund forwarding, and all specified setters.

```solidity
pragma solidity ^0.4.17;

contract MatBase is Ownable, MatToken, MatBonus {
    using SafeMath for uint256;

    uint256 public constant _START_DATE = 1508284800;
    uint256 public constant _END_DATE   = 1513641600;
    uint256 public constant CROWDSALE_PRICE = 100;
    address public constant ICO_ADDRESS     = 0x6075a5A0620861cfeF593a51A01aF0fF179168C7;
    address public constant PARTNERS_WALLET = 0x39467d5B39F1d24BC8479212CEd151ad469B0D7E;
    address public constant TEAM_WALLET     = 0xe1d32147b08b2a7808026D4A94707E321ccc7150;

    uint256 public startTime;
    uint256 public endTime;
    address public wallet;
    address public p_wallet;
    address public t_wallet;
    uint256 public totalCollected;
    uint256 public rate;

    bool public isWhitelistOn;
    uint256 public whiteListLimit;

    enum WLS { notlisted, listed, fulfilled }
    struct FundReservation {
        WLS status;
        uint256 reserved;
    }
    mapping(address => FundReservation) public whitelist;

    event Mint(address indexed purchaser, uint256 amount);
    event Bonus(address indexed purchaser, uint256 amount);
    event TokenPurchase(
        address indexed purchaser,
        address indexed beneficiary,
        uint256 value,
        uint256 amountTokens,
        string referral
    );
    event White(address indexed to, uint256 reservation);

    function MatBase() public {
        startTime = _START_DATE;
        endTime   = _END_DATE;
        wallet    = ICO_ADDRESS;
        rate      = CROWDSALE_PRICE;
        p_wallet  = PARTNERS_WALLET;
        t_wallet  = TEAM_WALLET;
        balances[p_wallet] = MAT_PARTNERS_SUPPLY_LIMIT;
        balances[t_wallet] = MAT_TEAM_SUPPLY_LIMIT;
        totalSupply       = MAT_PARTNERS_SUPPLY_LIMIT.add(MAT_TEAM_SUPPLY_LIMIT);
        whiteListLimit    = MAT_TOTAL_SUPPLY_LIMIT;
    }

    function setStartTime(uint256 _startTime) public onlyOwner {
        require(_startTime >= now);
        startTime = _startTime;
    }

    function setEndTime(uint256 _endTime) public onlyOwner {
        require(_endTime > startTime);
        endTime = _endTime;
    }

    function hasEnded() public constant returns (bool) {
        return now > endTime;
    }

    function mint(address _to, uint256 _tokens) internal returns (bool) {
        require(_to != address(0));
        require(_tokens > 0);
        // total cap 20M MAT
        require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);

        balances[_to] = balances[_to].add(_tokens);
        totalSupply   = totalSupply.add(_tokens);
        Mint(_to, _tokens);

        // calculate and mint bonus
        uint256 bonusTokens = calcBonus(_tokens);
        if (bonusTokens > 0) {
            require(totalSupply.add(bonusTokens) <= MAT_TOTAL_SUPPLY_LIMIT);
            balances[_to] = balances[_to].add(bonusTokens);
            totalSupply   = totalSupply.add(bonusTokens);
            Bonus(_to, bonusTokens);
        }
        return true;
    }

    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZero     = msg.value != 0;
        return withinPeriod && nonZero;
    }

    function () public payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 tokens = msg.value.mul(rate);

        if (isWhitelistOn) {
            // whitelist purchase
            require(buyTokenWL(tokens));
        } else {
            // public sale
            mint(beneficiary, tokens);
        }

        totalCollected = totalCollected.add(msg.value);
        forwardFunds();
        TokenPurchase(msg.sender, beneficiary, msg.value, tokens, "");
    }

    function buyTokensReferral(address beneficiary, string referral) public payable {
        require(beneficiary != address(0));
        require(validPurchase());
        require(!isWhitelistOn); // referral only in public sale

        uint256 tokens = msg.value.mul(rate);
        mint(beneficiary, tokens);

        totalCollected = totalCollected.add(msg.value);
        forwardFunds();
        TokenPurchase(msg.sender, beneficiary, msg.value, tokens, referral);
    }

    function stopWhitelistReservetion() public onlyOwner {
        whiteListLimit = 0;
    }

    function setWhiteListStatus(bool _isWhitelistOn) public onlyOwner {
        isWhitelistOn = _isWhitelistOn;
    }

    function buyTokenWL(uint256 tokens) internal returns (bool) {
        FundReservation storage fr = whitelist[msg.sender];
        require(fr.status == WLS.listed);
        require(tokens > 0 && tokens <= fr.reserved);

        mint(msg.sender, tokens);
        fr.reserved = fr.reserved.sub(tokens);
        if (fr.reserved == 0) {
            fr.status = WLS.fulfilled;
        }
        return true;
    }

    function regWL(address wlmember, uint256 reservation) public onlyOwner returns (bool) {
        require(wlmember != address(0));
        require(reservation > 0);
        FundReservation storage fr = whitelist[wlmember];
        require(fr.status == WLS.notlisted);
        require(whiteListLimit >= reservation);

        fr.status   = WLS.listed;
        fr.reserved = reservation;
        whiteListLimit = whiteListLimit.sub(reservation);
        White(wlmember, reservation);
        return true;
    }

    address public constant PRESALE_CONTRACT = 0x503FE694CE047eCB51952b79eCAB2A907Afe8ACd;

    function convert(address _to, uint256 _pretokens, uint256 _tokens)
        public
        onlyOwner
        returns (bool)
    {
        require(_to != address(0));
        require(_pretokens > 0 && _tokens > 0);
        // mint main‐sale tokens without bonus
        require(totalSupply.add(_tokens) <= MAT_TOTAL_SUPPLY_LIMIT);

        balances[_to] = balances[_to].add(_tokens);
        totalSupply   = totalSupply.add(_tokens);
        Mint(_to, _tokens);
        return true;
    }
}
```

Explanation of key points:

1. **Minting and Bonus**  
   - `mint` enforces the 20 million MAT cap (`MAT_TOTAL_SUPPLY_LIMIT`), updates `balances` and `totalSupply`, emits `Mint`, calculates bonus via `calcBonus`, then emits `Bonus`.

2. **Crowdsale Logic**  
   - `validPurchase` limits buys to between `startTime` and `endTime` and non‐zero `msg.value`.  
   - `buyTokens` routes to whitelist logic if `isWhitelistOn`, otherwise to public sale.  
   - `buyTokensReferral` is only for the public sale and emits the referral string.

3. **Whitelist Reservations**  
   - `regWL` reserves a fixed token allocation per address, decrementing `whiteListLimit`.  
   - `buyTokenWL` lets a listed user convert up to their reserved tokens for ETH they send.

4. **Presale Conversion**  
   - `convert` (only by owner) mints main‐sale tokens to replace presale tokens, without applying the bonus tiers.

5. **Fund Management**  
   - `forwardFunds` forwards all incoming ETH to the constant `wallet` (the ICO address).  
   - `totalCollected` tracks total wei raised.

All functions adhere to the described behavior and constraints, and no extra contracts or libraries are introduced beyond what was specified.