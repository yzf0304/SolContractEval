pragma solidity ^0.4.15;

contract ERC20 {
    function transfer(address _to, uint256 _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint256 balance);
}

contract MonethaBuyer {
    mapping(address => uint256) public balances;
    uint256 public buy_bounty;
    uint256 public withdraw_bounty;
    bool public bought_tokens;
    uint256 public contract_eth_value;
    bool public kill_switch;

    // SHA3 hash of kill switch password.
    bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;

    uint256 public earliest_buy_time = 1504188000;
    uint256 public eth_cap = 30000 ether;
    address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;

    address public sale;
    ERC20 public token;

    modifier onlyDeveloper() {
        require(msg.sender == developer);
        _;
    }

    /// @notice Allows the developer to set the crowdsale and token addresses (once).
    function set_addresses(address _sale, address _token) public onlyDeveloper {
        require(sale == address(0) && address(token) == address(0));
        require(_sale != address(0) && _token != address(0));
        sale = _sale;
        token = ERC20(_token);
    }

    /// @notice Emergency kill switch; developer or password-holder may call.
    /// Caller receives the remaining buy + withdraw bounty.
    function activate_kill_switch(string password) public {
        require(!kill_switch);
        if (msg.sender != developer) {
            // require correct password
            require(keccak256(password) == password_hash);
        }
        kill_switch = true;
        uint256 total_bounty = buy_bounty + withdraw_bounty;
        buy_bounty = 0;
        withdraw_bounty = 0;
        if (total_bounty > 0) {
            msg.sender.transfer(total_bounty);
        }
    }

    /// @notice Withdraw ETH or tokens on behalf of a user; caller earns a 1% bounty.
    function withdraw(address user) public {
        uint256 user_balance = balances[user];
        // nothing to do
        if (user_balance == 0) {
            return;
        }
        // mark as withdrawn
        balances[user] = 0;

        if (!bought_tokens) {
            // Refund ETH and pay caller a 1% bounty (from ETH bounty pool)
            uint256 reward = user_balance / 100;
            if (reward > withdraw_bounty) {
                reward = withdraw_bounty;
            }
            if (reward > 0) {
                withdraw_bounty -= reward;
                msg.sender.transfer(reward);
            }
            user.transfer(user_balance);
        } else {
            // Distribute proportional tokens
            uint256 totalTokens = token.balanceOf(this);
            // user's raw share
            uint256 rawShare = totalTokens * user_balance / contract_eth_value;

            // calculate fees & bounty
            uint256 dev_fee = rawShare / 100;    // 1% to developer
            uint256 caller_bounty = rawShare / 100; // 1% to caller
            uint256 user_tokens = rawShare - dev_fee - caller_bounty;

            // reduce tracked ETH value
            contract_eth_value -= user_balance;

            // distribute tokens
            if (dev_fee > 0) {
                token.transfer(developer, dev_fee);
            }
            if (caller_bounty > 0) {
                token.transfer(msg.sender, caller_bounty);
            }
            token.transfer(user, user_tokens);
        }
    }

    /// @notice Developer funds the buy bounty.
    function add_to_buy_bounty() public payable onlyDeveloper {
        buy_bounty += msg.value;
    }

    /// @notice Developer funds the withdraw bounty.
    function add_to_withdraw_bounty() public payable onlyDeveloper {
        withdraw_bounty += msg.value;
    }

    /// @notice Caller executes the token purchase; earns the buy bounty.
    function claim_bounty() public {
        require(!kill_switch);
        require(!bought_tokens);
        require(now >= earliest_buy_time);
        require(sale != address(0));

        bought_tokens = true;

        // total ETH to forward
        uint256 to_invest = this.balance;
        contract_eth_value = to_invest;

        // forward all ETH to crowdsale
        require(sale.call.value(to_invest)());

        // pay the bounty
        uint256 bounty = buy_bounty;
        buy_bounty = 0;
        if (bounty > 0) {
            msg.sender.transfer(bounty);
        }
    }

    /// @notice Default payable: accept deposits before purchase.
    function() public payable {
        require(!kill_switch);
        require(!bought_tokens);
        require(this.balance <= eth_cap);
        balances[msg.sender] += msg.value;
    }
}