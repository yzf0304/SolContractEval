pragma solidity 0.4.20;

contract Nicks {

  mapping(address => string) private nickOfOwner;
  mapping(string  => address) private ownerOfNick;

  event Set(string indexed _nick, address indexed _owner);
  event Unset(string indexed _nick, address indexed _owner);

  function Nicks() public {
    // empty constructor
  }

  function nickOf(address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  function ownerOf(string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  function set(string _nick) public {
    // nickname must be more than 2 characters
    require(bytes(_nick).length > 2);
    // must not already be in use
    require(ownerOfNick[_nick] == address(0));

    address sender = msg.sender;
    string storage currentNick = nickOfOwner[sender];

    // if sender already has a nickname, unset it first
    if (bytes(currentNick).length != 0) {
      delete ownerOfNick[currentNick];
      Unset(currentNick, sender);
    }

    // assign the new nickname
    nickOfOwner[sender] = _nick;
    ownerOfNick[_nick]   = sender;
    Set(_nick, sender);
  }

  function unset() public {
    address sender = msg.sender;
    string storage currentNick = nickOfOwner[sender];

    // sender must have a nickname to unset
    require(bytes(currentNick).length != 0);

    delete nickOfOwner[sender];
    delete ownerOfNick[currentNick];
    Unset(currentNick, sender);
  }

  // fallback to receive ether (does nothing with it)
  function() public payable {
    // no-op
  }
}