pragma solidity ^0.4.20;

contract Nicks {
    mapping (address => string) private nickOfOwner;
    mapping (string  => address) private ownerOfNick;

    event Set(string indexed _nick, address indexed _owner);
    event Unset(string indexed _nick, address indexed _owner);

    function Nicks() public {
        // empty
    }

    function nickOf(address _owner) public view returns (string _nick) {
        return nickOfOwner[_owner];
    }

    function ownerOf(string _nick) public view returns (address _owner) {
        return ownerOfNick[_nick];
    }

    function set(string _nick) public {
        // Nick must be longer than 2 characters
        require(bytes(_nick).length > 2);
        // Nick must not already be taken
        require(ownerOfNick[_nick] == address(0));

        // If sender already has a nick, unset it first
        string memory oldNick = nickOfOwner[msg.sender];
        if (bytes(oldNick).length != 0) {
            // remove old mapping
            delete ownerOfNick[oldNick];
            delete nickOfOwner[msg.sender];
            emit Unset(oldNick, msg.sender);
        }

        // assign new nick
        nickOfOwner[msg.sender] = _nick;
        ownerOfNick[_nick] = msg.sender;
        emit Set(_nick, msg.sender);
    }

    function unset() public {
        string memory currentNick = nickOfOwner[msg.sender];
        // Sender must have a nick to unset
        require(bytes(currentNick).length != 0);

        // remove mappings
        delete ownerOfNick[currentNick];
        delete nickOfOwner[msg.sender];
        emit Unset(currentNick, msg.sender);
    }

    // Fallback function to handle incoming Ether (no-op)
    function() public payable {
        // deliberately left empty
    }
}