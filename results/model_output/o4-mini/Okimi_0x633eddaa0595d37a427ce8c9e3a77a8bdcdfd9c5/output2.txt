```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "erc721a/contracts/ERC721A.sol";

/**
 * @title Okimi NFT Contract
 * @notice This contract implements an ERC721A NFT collection with a public sale mechanism, minting limits, and owner controls.
 * @dev Inherits from Ownable, ERC721A, and ReentrancyGuard to provide ownership, NFT, and reentrancy protection functionalities.
 */
contract Okimi is Ownable, ERC721A, ReentrancyGuard {
    uint256 public immutable maxPerAddressDuringMint;
    uint256 public immutable amountForDevs;
    uint256 public immutable amountForSaleAndDev;
    uint256 internal immutable collectionSize;
    uint256 internal immutable maxBatchSize;

    struct SaleConfig {
        uint32 publicSaleStartTime;
        uint64 publicPriceWei;
    }

    SaleConfig public saleConfig;

    // base uri for metadata
    string private baseTokenURI;

    /**
     * @notice Initializes the contract with default values for the NFT collection.
     * @dev Sets the maximum per address during mint, batch size, collection size, and initial sale configuration.
     */
    constructor()
        ERC721A("Okimi", "OKM")
    {
        maxPerAddressDuringMint = 5;
        maxBatchSize = 5;
        // for simplicity as given, all equal
        collectionSize = amountForDevs = amountForSaleAndDev = 1500;
        saleConfig.publicPriceWei = 5 ether / 1000;  // 0.005 ETH
        saleConfig.publicSaleStartTime = uint32(block.timestamp);
    }

    /**
     * @notice Modifier to ensure that the caller is not another contract.
     * @dev Prevents contracts from calling the function, allowing only EOA (Externally Owned Accounts).
     */
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    /**
     * @notice Allows users to mint a specified quantity of NFTs.
     * @dev Checks if the sale is active, ensures the mint does not exceed the max supply or per-address limit, and mints the NFTs.
     * @param quantity The number of NFTs to mint.
     */
    function mint(uint256 quantity)
        external
        payable
        callerIsUser
    {
        uint256 price = getPrice() * quantity;
        require(isSaleOn(saleConfig.publicPriceWei, saleConfig.publicSaleStartTime),
                "Public sale is not open");
        require(quantity > 0 && quantity <= maxBatchSize,
                "Invalid mint quantity");
        require(
            _totalMinted() + quantity <= collectionSize,
            "Reached max supply"
        );
        require(
            _numberMinted(msg.sender) + quantity <= maxPerAddressDuringMint,
            "Cannot mint this many"
        );

        refundIfOver(price);
        _safeMint(msg.sender, quantity);
    }

    /**
     * @notice Refunds the user if they sent more ETH than the required price.
     * @dev Ensures the user has sent at least the required amount and refunds any excess.
     * @param price The total price for the minted NFTs.
     */
    function refundIfOver(uint256 price) private {
        require(msg.value >= price, "Need to send more ETH.");
        if (msg.value > price) {
            uint256 refund = msg.value - price;
            (bool success, ) = msg.sender.call{value: refund}("");
            require(success, "Refund failed");
        }
    }

    /**
     * @notice Checks if the sale is currently active.
     * @dev Returns true if the sale has started and the price is non-zero.
     * @param _price The public price of the NFT.
     * @param _startTime The start time of the public sale.
     * @return bool True if the sale is active, false otherwise.
     */
    function isSaleOn(uint256 _price, uint256 _startTime)
        public
        view
        returns (bool)
    {
        return (_price != 0 && block.timestamp >= _startTime);
    }

    /**
     * @notice Gets the current public price of the NFT.
     * @dev Converts the stored public price to a uint256 and returns it.
     * @return uint256 The current public price of the NFT.
     */
    function getPrice() public view returns (uint256) {
        return uint256(saleConfig.publicPriceWei);
    }

    /**
     * @notice Sets the public sale configuration.
     * @dev Allows the owner to set the public sale start time and price.
     * @param timestamp The new start time for the public sale.
     * @param price The new public price for the NFT.
     */
    function setPublicSaleConfig(uint32 timestamp, uint64 price)
        external
        onlyOwner
    {
        saleConfig.publicSaleStartTime = timestamp;
        saleConfig.publicPriceWei = price;
    }

    /**
     * @notice Reserves a specified quantity of NFTs for the owner.
     * @dev Ensures the total supply does not exceed the dev mint limit and mints in batches.
     * @param quantity The number of NFTs to reserve.
     */
    function reserve(uint256 quantity) external onlyOwner {
        require(quantity > 0, "Must reserve at least one");
        require(
            _totalMinted() + quantity <= amountForDevs,
            "Not enough reserve left"
        );
        uint256 remaining = quantity;
        while (remaining > 0) {
            uint256 toMint = remaining > maxBatchSize ? maxBatchSize : remaining;
            _safeMint(msg.sender, toMint);
            remaining -= toMint;
        }
    }

    /**
     * @notice Sets the base URI for the NFT metadata.
     * @dev Allows the owner to set the base URI for the NFTs.
     * @param newBaseURI The new base URI for the NFT metadata.
     */
    function setBaseURI(string calldata newBaseURI) external onlyOwner {
        baseTokenURI = newBaseURI;
    }

    /**
     * @notice Withdraws the contract's balance to the owner's address.
     * @dev Uses the `call` method to send the entire contract balance to the owner, ensuring no reentrancy.
     */
    function withdraw() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No funds to withdraw");
        (bool success, ) = owner().call{value: balance}("");
        require(success, "Withdrawal failed");
    }

    /**
     * @notice Gets the number of NFTs minted by a specific address.
     * @dev Returns the number of NFTs minted by the given address.
     * @param ownerAddr The address to check.
     * @return uint256 The number of NFTs minted by the address.
     */
    function numberMinted(address ownerAddr)
        public
        view
        returns (uint256)
    {
        return _numberMinted(ownerAddr);
    }

    /**
     * @notice Gets the ownership data for a specific NFT token.
     * @dev Returns the ownership data for the specified token ID.
     * @param tokenId The ID of the NFT token.
     * @return TokenOwnership The ownership data for the token.
     */
    function getOwnershipData(uint256 tokenId)
        external
        view
        returns (TokenOwnership memory)
    {
        return _ownershipOf(tokenId);
    }

    /**
     * @notice Gets the total number of NFTs minted.
     * @dev Calculates the total number of NFTs minted by subtracting the start token ID from the current index.
     * @return uint256 The total number of NFTs minted.
     */
    function totalMinted() public view returns (uint256) {
        return _totalMinted();
    }

    /**
     * @notice Base URI override for ERC721A.
     */
    function _baseURI() internal view override returns (string memory) {
        return baseTokenURI;
    }

    /**
     * @notice Receives Ether and does nothing.
     * @dev This function is used to receive Ether without reverting.
     */
    receive() external payable {}
}
```

Explanation of the key points:

- **mint**: checks sale state, per‐tx and per‐wallet limits, supply cap, then mints and refunds any excess ETH.  
- **refundIfOver**: requires sufficient ETH and returns change via `call`.  
- **isSaleOn** / **getPrice**: expose sale configuration.  
- **reserve**: owner-only batch mint up to the dev allocation.  
- **setBaseURI** / **_baseURI**: manage metadata base URI.  
- **withdraw**: owner-only pull of contract balance with reentrancy guards.  
- **numberMinted**, **getOwnershipData**, **totalMinted**: read‐only helpers using `ERC721A` internals.