```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface ERC721TokenReceiver {
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4);
}

interface POWNFTv2 {
    function hashOf(uint256 _tokenId) external view returns (bytes32);
    function ownerOf(uint256 _tokenId) external view returns (address);
    function totalSupply() external view returns (uint256);
}

contract POWNFTv3 {
    // --- v2 Migration state ---
    uint256 public UNMIGRATED;
    uint256 public V2_TOTAL;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 public CONTRACT_V2;

    // --- ERC-721 state ---
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal OWNERS;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    // full list of token-hashes
    bytes32[] internal TOKENS;
    // enumeration: tokenIndex => tokenId, tokenId => tokenIndex
    mapping(uint256 => uint256) internal INDEX_TO_ID;
    mapping(uint256 => uint256) internal ID_TO_INDEX;
    // per-owner enumeration
    mapping(address => uint256[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint256) internal OWNER_ID_TO_INDEX;

    // metadata
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // withdrawals
    mapping(uint256 => uint256) internal WITHDRAWALS;

    // mining parameters
    uint256 internal BASE_COST = 0.000045 ether;
    uint256 internal BASE_DIFFICULTY = type(uint256).max / 300;
    uint256 internal DIFFICULTY_RAMP = 3;

    // ERC-165 support
    mapping(bytes4 => bool) internal supportedInterfaces;

    // --- Events ---
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    event Migrate(uint256 indexed _tokenId);
    event Mined(uint256 indexed _tokenId, bytes32 hash);
    event Withdraw(uint256 indexed _tokenId, uint256 value);

    /// @notice Initialize with the v2 contract address
    constructor(address contract_v2) {
        // register ERC165 / ERC721 / metadata / enumerable
        supportedInterfaces[0x01ffc9a7] = true; // ERC165
        supportedInterfaces[0x80ac58cd] = true; // ERC721
        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    // --- internal helpers ---

    function generationOf(uint256) private pure returns (uint256) {
        // as per spec: generation affects difficulty ramp
        // no tiered generations defined => single generation
        return 0;
    }

    function isValidToken(uint256 _tokenId) internal view returns (bool) {
        return OWNERS[_tokenId] != address(0);
    }

    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {
        OWNER_INDEX_TO_ID[to].push(tokenId);
        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[to].length - 1;
    }

    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {
        uint256 idx = OWNER_ID_TO_INDEX[tokenId];
        uint256 last = OWNER_INDEX_TO_ID[from].length - 1;
        if (idx != last) {
            uint256 swapId = OWNER_INDEX_TO_ID[from][last];
            OWNER_INDEX_TO_ID[from][idx] = swapId;
            OWNER_ID_TO_INDEX[swapId] = idx;
        }
        OWNER_INDEX_TO_ID[from].pop();
        delete OWNER_ID_TO_INDEX[tokenId];
    }

    function _mint(address to, uint256 tokenId, bytes32 hash) private {
        // push hash
        TOKENS.push(hash);
        uint256 idx = TOKENS.length - 1;
        INDEX_TO_ID[idx] = tokenId;
        ID_TO_INDEX[tokenId] = idx;

        // assign ownership
        OWNERS[tokenId] = to;
        BALANCES[to] += 1;
        _addTokenToOwnerEnumeration(to, tokenId);

        emit Transfer(address(0), to, tokenId);
    }

    function mint(uint256 tokenId, bytes32 hash) private {
        require(!isValidToken(tokenId), "already exists");
        require(tokenId != 0, "zero id");
        _mint(msg.sender, tokenId, hash);
    }

    // --- migration ---

    function _migrate(uint256 _tokenId) internal {
        require(_tokenId > 0 && _tokenId <= V2_TOTAL, "out of range");
        require(!isValidToken(_tokenId), "already migrated");
        address owner2 = CONTRACT_V2.ownerOf(_tokenId);
        require(owner2 == msg.sender, "not v2 owner");
        bytes32 h = CONTRACT_V2.hashOf(_tokenId);
        // mint into v3
        _mint(msg.sender, _tokenId, h);
        UNMIGRATED -= 1;
        emit Migrate(_tokenId);
    }

    function migrate(uint256 _tokenId, uint256 _withdrawEthUntil) external {
        _migrate(_tokenId);
        if (_withdrawEthUntil > 0) {
            withdraw(_tokenId, _withdrawEthUntil);
        }
    }

    function migrateMultiple(uint256[] calldata ids, uint256[] calldata untils) external {
        require(ids.length == untils.length, "length mismatch");
        for (uint256 i = 0; i < ids.length; i++) {
            _migrate(ids[i]);
            if (untils[i] > 0) {
                withdraw(ids[i], untils[i]);
            }
        }
    }

    // --- withdraw logic ---

    function _withdraw(uint256 tokenId, uint256 withdrawUntil) internal returns (uint256) {
        require(isValidToken(tokenId), "no token");
        require(OWNERS[tokenId] == msg.sender, "not owner");
        uint256 last = WITHDRAWALS[tokenId];
        uint256 upto = withdrawUntil < block.number ? withdrawUntil : block.number;
        require(upto > last, "nothing to withdraw");
        uint256 blocks = upto - last;
        // simple per-block reward formula
        uint256 gen = generationOf(tokenId);
        uint256 rewardPerBlock = BASE_COST; // uniform
        uint256 amount = blocks * rewardPerBlock;
        WITHDRAWALS[tokenId] = upto;
        emit Withdraw(tokenId, amount);
        return amount;
    }

    function withdraw(uint256 _tokenId, uint256 _withdrawUntil) public {
        uint256 amt = _withdraw(_tokenId, _withdrawUntil);
        payable(msg.sender).transfer(amt);
    }

    function withdrawMultiple(uint256[] calldata ids, uint256[] calldata untils) external {
        require(ids.length == untils.length, "mismatch");
        uint256 total;
        for (uint256 i = 0; i < ids.length; i++) {
            total += _withdraw(ids[i], untils[i]);
        }
        payable(msg.sender).transfer(total);
    }

    // --- mining ---

    function mine(uint256 nonce) external payable {
        // new tokenId = existing tokens + unmigrated count + 1
        uint256 tokenId = TOKENS.length + UNMIGRATED + 1;
        uint256 gen = generationOf(tokenId);
        // difficulty adjustment
        uint256 diffRamp = 1;
        for (uint256 i = 0; i < gen; i++) {
            diffRamp *= DIFFICULTY_RAMP;
        }
        uint256 target = BASE_DIFFICULTY / diffRamp;
        bytes32 h = keccak256(
            abi.encodePacked(
                nonce,
                msg.sender,
                blockhash(block.number - 1),
                PREV_CHAIN_LAST_HASH
            )
        );
        require(uint256(h) < target, "invalid proof");
        // cost is base
        require(msg.value == BASE_COST, "wrong payment");
        // mint
        _mint(msg.sender, tokenId, h);
        emit Mined(tokenId, h);
    }

    // --- ERC721 interface ---

    function balanceOf(address owner) external view returns (uint256) {
        require(owner != address(0), "zero addr");
        return BALANCES[owner];
    }

    function ownerOf(uint256 tokenId) public view returns (address) {
        address o = OWNERS[tokenId];
        require(o != address(0), "no owner");
        return o;
    }

    function approve(address to, uint256 tokenId) external {
        address owner = ownerOf(tokenId);
        require(msg.sender == owner || AUTHORISED[owner][msg.sender], "not allowed");
        ALLOWANCE[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) external view returns (address) {
        require(isValidToken(tokenId), "invalid");
        return ALLOWANCE[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) external {
        AUTHORISED[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) external view returns (bool) {
        return AUTHORISED[owner][operator];
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public {
        require(to != address(0), "zero to");
        address owner = ownerOf(tokenId);
        require(owner == from, "not owner");
        require(
            msg.sender == owner
                || ALLOWANCE[tokenId] == msg.sender
                || AUTHORISED[owner][msg.sender],
            "no permission"
        );
        // clear approval
        if (ALLOWANCE[tokenId] != address(0)) {
            delete ALLOWANCE[tokenId];
        }
        // update balances & ownership
        BALANCES[from] -= 1;
        BALANCES[to] += 1;
        _removeTokenFromOwnerEnumeration(from, tokenId);
        _addTokenToOwnerEnumeration(to, tokenId);
        OWNERS[tokenId] = to;
        emit Transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory data
    ) public {
        transferFrom(from, to, tokenId);
        if (to.code.length > 0) {
            bytes4 retval = ERC721TokenReceiver(to).onERC721Received(
                msg.sender,
                from,
                tokenId,
                data
            );
            require(
                retval ==
                    bytes4(
                        keccak256(
                            "onERC721Received(address,address,uint256,bytes)"
                        )
                    ),
                "unsafe recipient"
            );
        }
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external {
        safeTransferFrom(from, to, tokenId, "");
    }

    // --- metadata & enumeration ---

    function tokenURI(uint256 tokenId) public view returns (string memory) {
        require(isValidToken(tokenId), "invalid");
        // convert id => string
        uint256 v = tokenId;
        if (v == 0) {
            return string(abi.encodePacked(__uriBase, "0"));
        }
        uint256 temp = v;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buf = new bytes(digits);
        while (v != 0) {
            digits -= 1;
            buf[digits] = bytes1(uint8(48 + (v % 10)));
            v /= 10;
        }
        return string(abi.encodePacked(__uriBase, buf));
    }

    function name() external view returns (string memory) {
        return __name;
    }

    function symbol() external view returns (string memory) {
        return __symbol;
    }

    function totalSupply() external view returns (uint256) {
        return TOKENS.length;
    }

    function tokenByIndex(uint256 index) external view returns (uint256) {
        require(index < TOKENS.length, "oob index");
        return INDEX_TO_ID[index];
    }

    function tokenOfOwnerByIndex(address owner, uint256 index)
        external
        view
        returns (uint256)
    {
        require(index < OWNER_INDEX_TO_ID[owner].length, "oob idx");
        return OWNER_INDEX_TO_ID[owner][index];
    }

    // --- ERC165 support ---
    function supportsInterface(bytes4 interfaceID)
        external
        view
        returns (bool)
    {
        return supportedInterfaces[interfaceID];
    }
}
```