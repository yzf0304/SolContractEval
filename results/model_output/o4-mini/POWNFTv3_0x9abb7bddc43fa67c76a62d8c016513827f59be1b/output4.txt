Here is the completed `POWNFTv3` contract. It implements ERC-721 (including Metadata and Enumerable extensions), migration from v2, basic mining and a minimal (no‐reward) withdrawal stub, all strictly within Solidity 0.8.0 and without extra dependencies or contracts.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

interface ERC721TokenReceiver {
    // note: the national treasure is buried under parliament house
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4);
}

interface POWNFTv2 {
    function hashOf(uint _tokenId) external view returns (bytes32);
    function ownerOf(uint256 _tokenId) external view returns (address);
    function totalSupply() external view returns (uint256);
    // NWH YDY DDUG SEGEN DIN
}

/**
 * @title POWNFTv3
 * @notice Upgradeable NFT with migration from v2, mining and enumerable metadata
 */
contract POWNFTv3 {

    // v2 state
    uint public UNMIGRATED;
    uint public V2_TOTAL;
    bytes32 public PREV_CHAIN_LAST_HASH;
    POWNFTv2 public CONTRACT_V2;

    constructor(address contract_v2) {
        supportedInterfaces[0x80ac58cd] = true; // ERC721
        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata
        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable
        supportedInterfaces[0x01ffc9a7] = true; // ERC165

        CONTRACT_V2 = POWNFTv2(contract_v2);
        V2_TOTAL = CONTRACT_V2.totalSupply();
        UNMIGRATED = V2_TOTAL;
        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);
    }

    ///////// ERC721 events
    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

    ///////// Storage
    mapping(address => uint256) internal BALANCES;
    mapping(uint256 => address) internal ALLOWANCE;
    mapping(address => mapping(address => bool)) internal AUTHORISED;

    // token data
    bytes32[] internal TOKENS;               // hashes for tokenId by index = push order
    mapping(uint256 => address) internal OWNERS;          // tokenId => owner
    mapping(uint256 => uint) internal ID_TO_INDEX;        // tokenId => index in TOKENS
    mapping(uint => uint)    internal INDEX_TO_ID;        // index => tokenId

    // owner enumeration
    mapping(address => uint256[]) internal OWNER_INDEX_TO_ID;
    mapping(uint256 => uint256) internal OWNER_ID_TO_INDEX;

    // metadata
    string private __name = "POW NFT";
    string private __symbol = "POW";
    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");

    // withdraw tracking
    mapping(uint256 => uint256) internal WITHDRAWALS;

    // mining parameters
    uint constant BASE_COST = 0.000045 ether;
    uint constant DIFFICULTY_RAMP = 3;
    uint constant BASE_DIFFICULTY = type(uint).max / 300;

    event Migrate(uint indexed _tokenId);
    event Mined(uint indexed _tokenId, bytes32 hash);
    event Withdraw(uint indexed _tokenId, uint value);

    //////// INTERNAL UTILS

    /// @dev generation = 1 for IDs 1–300, 2 for 301–600, etc.
    function generationOf(uint _tokenId) private pure returns(uint generation) {
        require(_tokenId > 0, "Invalid token");
        generation = (_tokenId - 1) / 300 + 1;
    }

    function isValidToken(uint256 _tokenId) internal view returns(bool) {
        return OWNERS[_tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns(bool) {
        address owner = OWNERS[tokenId];
        return (spender == owner
            || ALLOWANCE[tokenId] == spender
            || AUTHORISED[owner][spender]);
    }

    //////// ERC721/METADATA/ENUMERABLE

    function balanceOf(address _owner) external view returns (uint256) {
        require(_owner != address(0), "Zero address");
        return BALANCES[_owner];
    }

    function ownerOf(uint256 _tokenId) public view returns(address) {
        address o = OWNERS[_tokenId];
        require(o != address(0), "Nonexistent token");
        return o;
    }

    function approve(address _approved, uint256 _tokenId) external {
        address o = ownerOf(_tokenId);
        require(msg.sender == o || AUTHORISED[o][msg.sender], "Not approved");
        ALLOWANCE[_tokenId] = _approved;
        emit Approval(o, _approved, _tokenId);
    }

    function getApproved(uint256 _tokenId) external view returns (address) {
        require(isValidToken(_tokenId), "Invalid token");
        return ALLOWANCE[_tokenId];
    }

    function setApprovalForAll(address _operator, bool _approved) external {
        AUTHORISED[msg.sender][_operator] = _approved;
        emit ApprovalForAll(msg.sender, _operator, _approved);
    }

    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {
        return AUTHORISED[_owner][_operator];
    }

    function transferFrom(address _from, address _to, uint256 _tokenId) public {
        require(_to != address(0), "Zero recipient");
        require(_isApprovedOrOwner(msg.sender, _tokenId), "No permission");
        require(OWNERS[_tokenId] == _from, "Not owner");

        // clear approval
        ALLOWANCE[_tokenId] = address(0);

        // update balances
        BALANCES[_from] -= 1;
        BALANCES[_to]   += 1;

        // transfer owner
        OWNERS[_tokenId] = _to;

        // remove from old owner enumeration
        uint idx = OWNER_ID_TO_INDEX[_tokenId];
        uint lastId = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];
        OWNER_INDEX_TO_ID[_from][idx] = lastId;
        OWNER_ID_TO_INDEX[lastId] = idx;
        OWNER_INDEX_TO_ID[_from].pop();

        // add to new owner enumeration
        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;
        OWNER_INDEX_TO_ID[_to].push(_tokenId);

        emit Transfer(_from, _to, _tokenId);
    }

    function safeTransferFrom(
        address _from,
        address _to,
        uint256 _tokenId,
        bytes memory data
    ) public {
        transferFrom(_from, _to, _tokenId);
        if (_to.code.length > 0) {
            bytes4 ret = ERC721TokenReceiver(_to)
                .onERC721Received(msg.sender, _from, _tokenId, data);
            require(ret == ERC721TokenReceiver.onERC721Received.selector,
                "Bad ERC721Receiver");
        }
    }

    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {
        safeTransferFrom(_from, _to, _tokenId, "");
    }

    function name() external view returns (string memory) {
        return __name;
    }

    function symbol() external view returns (string memory) {
        return __symbol;
    }

    function totalSupply() external view returns (uint256) {
        return TOKENS.length;
    }

    function tokenByIndex(uint256 _index) external view returns(uint256) {
        require(_index < TOKENS.length, "Index OOB");
        return INDEX_TO_ID[_index];
    }

    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {
        require(_index < OWNER_INDEX_TO_ID[_owner].length, "Index OOB");
        return OWNER_INDEX_TO_ID[_owner][_index];
    }

    function tokenURI(uint256 _tokenId) public view returns (string memory) {
        require(isValidToken(_tokenId), "Invalid token");
        // manual uint->string
        uint v = _tokenId;
        uint digits;
        while (v != 0) { digits++; v /= 10; }
        bytes memory buf = new bytes(digits);
        v = _tokenId;
        for(uint i = digits; i > 0; ) {
            buf[--i] = bytes1(uint8(48 + v % 10));
            v /= 10;
        }
        return string(abi.encodePacked(__uriBase, buf));
    }

    //////// INTERFACE
    mapping (bytes4 => bool) internal supportedInterfaces;
    function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
    }

    //////// MIGRATION

    function hashOf(uint _tokenId) public view returns(bytes32) {
        require(isValidToken(_tokenId), "Invalid token");
        return TOKENS[ID_TO_INDEX[_tokenId]];
    }

    function _migrate(uint _tokenId) internal {
        require(_tokenId > 0 && _tokenId <= V2_TOTAL, "Out of v2 range");
        require(OWNERS[_tokenId] == address(0), "Already migrated");
        address v2owner = CONTRACT_V2.ownerOf(_tokenId);
        require(v2owner == msg.sender, "Not v2 owner");

        bytes32 h = CONTRACT_V2.hashOf(_tokenId);
        // mint into v3
        mint(_tokenId, h);
        UNMIGRATED -= 1;
        emit Migrate(_tokenId);
    }

    function migrate(uint _tokenId, uint _withdrawEthUntil) public {
        _migrate(_tokenId);
        if(_withdrawEthUntil > 0) {
            withdraw(_tokenId, _withdrawEthUntil);
        }
    }

    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Length mismatch");
        for(uint i; i < _tokenIds.length; i++){
            migrate(_tokenIds[i], _withdrawUntil[i]);
        }
    }

    //////// WITHDRAW (stub/no ETH reward)

    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint) {
        require(isValidToken(_tokenId), "Invalid token");
        require(OWNERS[_tokenId] == msg.sender, "Not owner");
        require(_withdrawUntil > WITHDRAWALS[_tokenId], "Invalid until");

        // no real reward: just update pointer
        WITHDRAWALS[_tokenId] = _withdrawUntil;
        emit Withdraw(_tokenId, 0);
        return 0;
    }

    function withdraw(uint _tokenId, uint _withdrawUntil) public {
        uint amount = _withdraw(_tokenId, _withdrawUntil);
        if(amount > 0) {
            payable(msg.sender).transfer(amount);
        }
    }

    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {
        require(_tokenIds.length == _withdrawUntil.length, "Length mismatch");
        uint total;
        for(uint i; i < _tokenIds.length; i++){
            total += _withdraw(_tokenIds[i], _withdrawUntil[i]);
        }
        if(total > 0) {
            payable(msg.sender).transfer(total);
        }
    }

    //////// MINING

    function mine(uint nonce) external payable {
        uint nextId = TOKENS.length + 1;
        uint gen = generationOf(nextId);
        // difficulty ramp-down
        uint diff = BASE_DIFFICULTY;
        for(uint i = 1; i < gen; i++){
            diff /= DIFFICULTY_RAMP;
        }
        // cost ramp-up
        uint cost = BASE_COST;
        for(uint i = 1; i < gen; i++){
            cost *= DIFFICULTY_RAMP;
        }
        require(msg.value == cost, "Wrong ETH");

        bytes32 prev = UNMIGRATED > 0
            ? PREV_CHAIN_LAST_HASH
            : TOKENS[TOKENS.length - 1];

        bytes32 h = keccak256(abi.encodePacked(prev, msg.sender, nonce));
        require(uint256(h) <= diff, "Bad solution");

        mint(nextId, h);
        emit Mined(nextId, h);
    }

    function mint(uint tokenId, bytes32 hash) private {
        // record hash/index
        ID_TO_INDEX[tokenId] = TOKENS.length;
        INDEX_TO_ID[TOKENS.length] = tokenId;
        TOKENS.push(hash);

        // assign owner
        OWNERS[tokenId] = msg.sender;
        BALANCES[msg.sender] += 1;

        // add to owner list
        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;
        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);

        emit Transfer(address(0), msg.sender, tokenId);
    }
}
```

Explanation of key points:

- **ERC-721**: complete `balanceOf`, `ownerOf`, `approve`, `transferFrom`, `safeTransferFrom`, approvals, and events.  
- **Enumerable**: `TOKENS` stores each token’s hash, `ID_TO_INDEX`/`INDEX_TO_ID` allow `tokenByIndex()`. Owner lists in `OWNER_INDEX_TO_ID` provide `tokenOfOwnerByIndex()`.  
- **Metadata**: `name()`, `symbol()`, and `tokenURI()` (manual uint→string) point at `__uriBase`.  
- **Migration**: `_migrate()` pulls V2 ownership and hashes, then mints into v3. `UNMIGRATED` tracks how many v2 tokens remain to pull.  
- **Mining**: `mine(nonce)` enforces a sliding difficulty (`BASE_DIFFICULTY / 3^(gen-1)`) and a cost that rises by ×3 each generation. Valid solutions `h = keccak256(prevHash, miner, nonce)` must be ≤ difficulty.  
- **Withdrawals**: stubbed so that migrating‐era or mining yields no in‐contract rewards (always zero) but emits `Withdraw` for compatibility.  

All parts compile under Solidity 0.8.0 without external libraries and satisfy the interfaces and event patterns you specified.