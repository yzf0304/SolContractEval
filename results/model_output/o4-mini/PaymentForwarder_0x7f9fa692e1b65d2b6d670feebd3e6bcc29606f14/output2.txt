pragma solidity ^0.4.18;

contract PaymentForwarder is Haltable {
  /// @notice Who will get all ETH in the end
  address public teamMultisig;

  /// @notice Total incoming money
  uint public totalTransferred;

  /// @notice How many distinct customers we have that have made a payment
  uint public customerCount;

  /// @notice Total incoming money per centrally tracked customer id
  mapping(uint128 => uint) public paymentsByCustomer;

  /// @notice Total incoming money per benefactor address
  mapping(address => uint) public paymentsByBenefactor;

  /// @notice A customer has made a payment. Benefactor is the address where the tokens will be ultimately issued.
  event PaymentForwarded(address source, uint amount, uint128 customerId, address benefactor);

  /**
   * @notice Initializes the contract with the owner and team multisig addresses.
   * @param _owner The address of the contract owner.
   * @param _teamMultisig The address of the team multisig wallet.
   */
  function PaymentForwarder(address _owner, address _teamMultisig) public {
    require(_owner != address(0) && _teamMultisig != address(0));
    owner = _owner;
    teamMultisig = _teamMultisig;
  }

  /**
   * @notice Allows a customer to make a payment without a checksum.
   * @dev Records the payment, updates the total transferred, and forwards the payment to the team multisig address.
   * @param customerId The unique identifier for the customer.
   * @param benefactor The address that will benefit from the payment.
   */
  function payWithoutChecksum(uint128 customerId, address benefactor)
    public
    stopInEmergency
    payable
  {
    require(benefactor != address(0));
    require(msg.value > 0);

    // count new customer if first payment
    if (paymentsByCustomer[customerId] == 0) {
      customerCount++;
    }

    paymentsByCustomer[customerId] += msg.value;
    paymentsByBenefactor[benefactor] += msg.value;
    totalTransferred += msg.value;

    // emit payment event
    PaymentForwarded(msg.sender, msg.value, customerId, benefactor);

    // forward funds
    teamMultisig.transfer(msg.value);
  }

  /**
   * @notice Allows a customer to make a payment on behalf of an address with a checksum.
   * @dev Verifies the checksum and then calls `payWithoutChecksum` to process the payment.
   * @param customerId The unique identifier for the customer.
   * @param benefactor The address that will benefit from the payment.
   * @param checksum The checksum to verify the payment.
   */
  function pay(
    uint128 customerId,
    address benefactor,
    bytes1 checksum
  )
    public
    stopInEmergency
    payable
  {
    // simple 1‚Äêbyte checksum: first byte of keccak(customerId, benefactor)
    require(checksum == bytes1(keccak256(customerId, benefactor)));
    payWithoutChecksum(customerId, benefactor);
  }

  /**
   * @notice Allows a customer to make a payment on their own behalf with a checksum.
   * @dev Verifies the checksum and then calls `payWithoutChecksum` to process the payment.
   * @param customerId The unique identifier for the customer.
   * @param checksum The checksum to verify the payment.
   */
  function payForMyselfWithChecksum(uint128 customerId, bytes1 checksum)
    public
    stopInEmergency
    payable
  {
    // checksum over (customerId, msg.sender)
    require(checksum == bytes1(keccak256(customerId, msg.sender)));
    payWithoutChecksum(customerId, msg.sender);
  }

  /**
   * @notice Allows a customer to make a payment on their own behalf without a checksum.
   * @dev Calls `payWithoutChecksum` to process the payment.
   * @param customerId The unique identifier for the customer.
   */
  function payForMyself(uint128 customerId)
    public
    stopInEmergency
    payable
  {
    payWithoutChecksum(customerId, msg.sender);
  }

  /**
   * @notice Fallback function to receive Ether.
   * @dev Reverts if the contract receives Ether directly.
   */
  function() public payable {
    revert();
  }
}