pragma solidity ^0.8.15;

interface IERC721A {
    error ApprovalCallerNotOwnerNorApproved();
    error ApprovalQueryForNonexistentToken();
    error BalanceQueryForZeroAddress();
    error MintToZeroAddress();
    error MintZeroQuantity();
    error OwnerQueryForNonexistentToken();
    error TransferCallerNotOwnerNorApproved();
    error TransferFromIncorrectOwner();
    error TransferToNonERC721ReceiverImplementer();
    error TransferToZeroAddress();
    error URIQueryForNonexistentToken();
    error MintERC2309QuantityExceedsLimit();
    error OwnershipNotInitializedForExtraData();

    struct TokenOwnership {
        address addr;
        uint64 startTimestamp;
        bool burned;
        uint24 extraData;
    }

    function totalSupply() external view returns (uint256);
    function supportsInterface(bytes4 interfaceId) external view returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);
    function ownerOf(uint256 tokenId) external view returns (address owner);

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;

    function approve(address to, uint256 tokenId) external;
    function setApprovalForAll(address operator, bool _approved) external;

    function getApproved(uint256 tokenId) external view returns (address operator);
    function isApprovedForAll(address owner, address operator) external view returns (bool);

    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function tokenURI(uint256 tokenId) external view returns (string memory);

    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);
}

interface ERC721A__IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract ERC721A is IERC721A {
    struct TokenApprovalRef { address value; }

    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;
    uint256 private constant _BITPOS_NUMBER_MINTED = 64;
    uint256 private constant _BITPOS_NUMBER_BURNED = 128;
    uint256 private constant _BITPOS_AUX = 192;
    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;
    uint256 private constant _BITPOS_START_TIMESTAMP = 160;
    uint256 private constant _BITMASK_BURNED = 1 << 224;
    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;
    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;
    uint256 private constant _BITPOS_EXTRA_DATA = 232;
    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;
    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;
    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;
    bytes32 private constant _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;

    uint256 private _currentIndex;
    uint256 private _burnCounter;
    string private _name;
    string private _symbol;

    mapping(uint256 => uint256) private _packedOwnerships;
    mapping(address => uint256) private _packedAddressData;
    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _currentIndex = _startTokenId();
    }

    function _startTokenId() internal view virtual returns (uint256) { return 0; }
    function _nextTokenId() internal view virtual returns (uint256) { return _currentIndex; }

    function totalSupply() public view virtual override returns (uint256) {
        unchecked { return _currentIndex - _burnCounter - _startTokenId(); }
    }
    function _totalMinted() internal view virtual returns (uint256) {
        unchecked { return _currentIndex - _startTokenId(); }
    }
    function _totalBurned() internal view virtual returns (uint256) { return _burnCounter; }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;
    }
    function _numberMinted(address owner) internal view returns (uint256) {
        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;
    }
    function _numberBurned(address owner) internal view returns (uint256) {
        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;
    }
    function _getAux(address owner) internal view returns (uint64) {
        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);
    }
    function _setAux(address owner, uint64 aux) internal virtual {
        uint256 packed = _packedAddressData[owner];
        uint256 auxC;
        assembly { auxC := aux }
        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxC << _BITPOS_AUX);
        _packedAddressData[owner] = packed;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == 0x01ffc9a7 ||
               interfaceId == 0x80ac58cd ||
               interfaceId == 0x5b5e139f;
    }

    function name() public view virtual override returns (string memory) { return _name; }
    function symbol() public view virtual override returns (string memory) { return _symbol; }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();
        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';
    }
    function _baseURI() internal view virtual returns (string memory) { return ''; }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        return address(uint160(_packedOwnershipOf(tokenId)));
    }
    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {
        return _unpackedOwnership(_packedOwnershipOf(tokenId));
    }
    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {
        return _unpackedOwnership(_packedOwnerships[index]);
    }
    function _initializeOwnershipAt(uint256 index) internal virtual {
        if (_packedOwnerships[index] == 0) {
            _packedOwnerships[index] = _packedOwnershipOf(index);
        }
    }
    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {
        uint256 curr = tokenId;
        unchecked {
            if (_startTokenId() <= curr && curr < _currentIndex) {
                uint256 packed = _packedOwnerships[curr];
                if (packed & _BITMASK_BURNED == 0) {
                    while (packed == 0) {
                        packed = _packedOwnerships[--curr];
                    }
                    return packed;
                }
            }
        }
        revert OwnerQueryForNonexistentToken();
    }
    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {
        ownership.addr = address(uint160(packed));
        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);
        ownership.burned = packed & _BITMASK_BURNED != 0;
        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);
    }
    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {
        assembly {
            owner := and(owner, _BITMASK_ADDRESS)
            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))
        }
    }
    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {
        assembly { result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1)) }
    }

    function approve(address to, uint256 tokenId) public virtual override {
        address owner = ownerOf(tokenId);
        if (_msgSenderERC721A() != owner)
            if (!isApprovedForAll(owner, _msgSenderERC721A()))
                revert ApprovalCallerNotOwnerNorApproved();
        _tokenApprovals[tokenId].value = to;
        emit Approval(owner, to, tokenId);
    }
    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();
        return _tokenApprovals[tokenId].value;
    }
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _operatorApprovals[_msgSenderERC721A()][operator] = approved;
        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);
    }
    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }
    function _exists(uint256 tokenId) internal view virtual returns (bool) {
        return _startTokenId() <= tokenId &&
               tokenId < _currentIndex &&
               _packedOwnerships[tokenId] & _BITMASK_BURNED == 0;
    }
    function _isSenderApprovedOrOwner(address approvedAddress, address owner, address msgSender) private pure returns (bool result) {
        assembly {
            owner := and(owner, _BITMASK_ADDRESS)
            msgSender := and(msgSender, _BITMASK_ADDRESS)
            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))
        }
    }
    function _getApprovedSlotAndAddress(uint256 tokenId) private view returns (uint256 slot, address approvedAddress) {
        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];
        assembly {
            slot := tokenApproval.slot
            approvedAddress := sload(slot)
        }
    }

    function transferFrom(address from, address to, uint256 tokenId) public virtual override {
        uint256 prev = _packedOwnershipOf(tokenId);
        if (address(uint160(prev)) != from) revert TransferFromIncorrectOwner();
        (uint256 approvedSlot, address approved) = _getApprovedSlotAndAddress(tokenId);
        if (!_isSenderApprovedOrOwner(approved, from, _msgSenderERC721A()))
            if (!isApprovedForAll(from, _msgSenderERC721A()))
                revert TransferCallerNotOwnerNorApproved();
        if (to == address(0)) revert TransferToZeroAddress();
        _beforeTokenTransfers(from, to, tokenId, 1);
        assembly { if approved { sstore(approvedSlot, 0) } }
        unchecked {
            --_packedAddressData[from];
            ++_packedAddressData[to];
            _packedOwnerships[tokenId] = _packOwnershipData(
                to,
                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prev)
            );
            if (prev & _BITMASK_NEXT_INITIALIZED == 0) {
                uint256 next = tokenId + 1;
                if (_packedOwnerships[next] == 0 && next != _currentIndex) {
                    _packedOwnerships[next] = prev;
                }
            }
        }
        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }
    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
        transferFrom(from, to, tokenId);
        if (to.code.length != 0)
            if (!_checkContractOnERC721Received(from, to, tokenId, data))
                revert TransferToNonERC721ReceiverImplementer();
    }

    function _beforeTokenTransfers(address, address, uint256, uint256) internal virtual {}
    function _afterTokenTransfers(address, address, uint256, uint256) internal virtual {}

    function _checkContractOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {
        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, data)
            returns (bytes4 retval) {
            return retval == ERC721A__IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) revert TransferToNonERC721ReceiverImplementer();
            assembly { revert(add(32, reason), mload(reason)) }
        }
    }

    function _mint(address to, uint256 quantity) internal virtual {
        uint256 start = _currentIndex;
        if (quantity == 0) revert MintZeroQuantity();
        _beforeTokenTransfers(address(0), to, start, quantity);
        unchecked {
            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);
            _packedOwnerships[start] = _packOwnershipData(to, _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0));
            uint256 end = start + quantity;
            uint256 toMasked;
            assembly {
                toMasked := and(to, _BITMASK_ADDRESS)
                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, start)
                for { let tokenId := add(start, 1) } iszero(eq(tokenId, end)) { tokenId := add(tokenId, 1) } {
                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)
                }
            }
            if (toMasked == 0) revert MintToZeroAddress();
            _currentIndex = end;
        }
        _afterTokenTransfers(address(0), to, start, quantity);
    }
    function _mintERC2309(address to, uint256 quantity) internal virtual {
        uint256 start = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();
        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();
        _beforeTokenTransfers(address(0), to, start, quantity);
        unchecked {
            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);
            _packedOwnerships[start] = _packOwnershipData(to, _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0));
            emit ConsecutiveTransfer(start, start + quantity - 1, address(0), to);
            _currentIndex = start + quantity;
        }
        _afterTokenTransfers(address(0), to, start, quantity);
    }
    function _safeMint(address to, uint256 quantity, bytes memory data) internal virtual {
        _mint(to, quantity);
        unchecked {
            if (to.code.length != 0) {
                uint256 end = _currentIndex;
                uint256 idx = end - quantity;
                do {
                    if (!_checkContractOnERC721Received(address(0), to, idx++, data)) {
                        revert TransferToNonERC721ReceiverImplementer();
                    }
                } while (idx < end);
                if (_currentIndex != end) revert();
            }
        }
    }
    function _safeMint(address to, uint256 quantity) internal virtual {
        _safeMint(to, quantity, '');
    }

    function _burn(uint256 tokenId) internal virtual {
        _burn(tokenId, false);
    }
    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
        uint256 prev = _packedOwnershipOf(tokenId);
        address from = address(uint160(prev));
        (uint256 approvedSlot, address approved) = _getApprovedSlotAndAddress(tokenId);
        if (approvalCheck) {
            if (!_isSenderApprovedOrOwner(approved, from, _msgSenderERC721A()))
                if (!isApprovedForAll(from, _msgSenderERC721A()))
                    revert TransferCallerNotOwnerNorApproved();
        }
        _beforeTokenTransfers(from, address(0), tokenId, 1);
        assembly { if approved { sstore(approvedSlot, 0) } }
        unchecked {
            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;
            _packedOwnerships[tokenId] = _packOwnershipData(
                from,
                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prev)
            );
            if (prev & _BITMASK_NEXT_INITIALIZED == 0) {
                uint256 next = tokenId + 1;
                if (_packedOwnerships[next] == 0 && next != _currentIndex) {
                    _packedOwnerships[next] = prev;
                }
            }
        }
        emit Transfer(from, address(0), tokenId);
        _afterTokenTransfers(from, address(0), tokenId, 1);
        unchecked { _burnCounter++; }
    }

    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {
        uint256 packed = _packedOwnerships[index];
        if (packed == 0) revert OwnershipNotInitializedForExtraData();
        uint256 e;
        assembly { e := extraData }
        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (e << _BITPOS_EXTRA_DATA);
        _packedOwnerships[index] = packed;
    }
    function _extraData(address, address, uint24) internal view virtual returns (uint24) {}
    function _nextExtraData(address from, address to, uint256 prevPacked) private view returns (uint256) {
        uint24 extra = uint24(prevPacked >> _BITPOS_EXTRA_DATA);
        return uint256(_extraData(from, to, extra)) << _BITPOS_EXTRA_DATA;
    }

    function _msgSenderERC721A() internal view virtual returns (address) {
        return msg.sender;
    }

    function _toString(uint256 value) internal pure virtual returns (string memory str) {
        assembly {
            let m := mload(0x40)
            str := add(m, 0x80)
            mstore(0x40, str)
            let end := str
            for { let temp := value } 1 {} {
                str := sub(str, 1)
                mstore8(str, add(48, mod(temp, 10)))
                temp := div(temp, 10)
                if iszero(temp) { break }
            }
            let length := sub(end, str)
            str := sub(str, 0x20)
            mstore(str, length)
        }
    }
}

// OpenZeppelin Context & Ownable
abstract contract Context {
    function _msgSender() internal view virtual returns (address) { return msg.sender; }
    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() { _transferOwnership(_msgSender()); }
    modifier onlyOwner() { _checkOwner(); _; }
    function owner() public view virtual returns (address) { return _owner; }
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }
    function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

/**
 * @title PepeYogaClub
 * @notice A smart contract for the PepeYogaClub NFT collection, implementing ERC721A and Ownable.
 */
contract PepeYogaClub is ERC721A, Ownable {
    string public baseURI = "ipfs://QmTLWN9WPq5L9eS9EKcTn2rqUCzr9QK5sd8DYVkkL7yguL/";
    string public contractURI = "ipfs://QmUvB8sKL4XFTxbMkL9FykiqLgrXeBV1mUkdzWMWhachvD";

    uint256 public MAX_PER_WALLET = 11;
    uint256 public constant MAX_SUPPLY = 2069;
    uint256 public price = 0.0069 ether;

    bool public paused = true;

    constructor() ERC721A("PepeYogaClub", "PYC") {}

    function mint(uint256 _amount) external payable {
        require(!paused, "Minting is paused");
        require(_amount > 0, "Invalid mint amount");
        require(totalSupply() + _amount <= MAX_SUPPLY, "Exceeds max supply");
        require(minted(msg.sender) + _amount <= MAX_PER_WALLET, "Exceeds max per wallet");
        require(msg.value >= price * _amount, "Insufficient funds");
        _safeMint(msg.sender, _amount);
    }

    function _startTokenId() internal pure override returns (uint256) {
        return 1;
    }

    function minted(address _owner) public view returns (uint256) {
        return _numberMinted(_owner);
    }

    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance");
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Withdraw failed");
    }

    function teamMint(address[] memory _to, uint256[] memory _amount) external onlyOwner {
        require(_to.length == _amount.length, "Arrays mismatch");
        for (uint256 i = 0; i < _to.length; i++) {
            require(totalSupply() + _amount[i] <= MAX_SUPPLY, "Exceeds max supply");
            _safeMint(_to[i], _amount[i]);
        }
    }

    function setMaxPerWallet(uint256 _max) external onlyOwner {
        MAX_PER_WALLET = _max;
    }

    function setPrice(uint256 _price) external onlyOwner {
        price = _price;
    }

    function toggleMint() external onlyOwner {
        paused = !paused;
    }

    function setBaseURI(string memory baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setContractURI(string memory _contractURI) external onlyOwner {
        contractURI = _contractURI;
    }

    function tokenURI(uint256 _tokenId) public view override returns (string memory) {
        require(_exists(_tokenId), "URI query for nonexistent token");
        return string(abi.encodePacked(baseURI, _toString(_tokenId)));
    }
}