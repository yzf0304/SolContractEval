```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.6.6;

contract Context {
    constructor () internal { }
    function _msgSender() internal view returns (address payable) {
        return msg.sender;
    }
    function _msgData() internal view returns (bytes memory) {
        this;
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }
    function owner() public view returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(_msgSender() == _owner, "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint256 a, uint256 b, string memory errMsg) internal pure returns (uint256) {
        require(b <= a, errMsg);
        return a - b;
    }
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) { return 0; }
        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint256 a, uint256 b, string memory errMsg) internal pure returns (uint256) {
        require(b > 0, errMsg);
        return a / b;
    }
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }
    function mod(uint256 a, uint256 b, string memory errMsg) internal pure returns (uint256) {
        require(b != 0, errMsg);
        return a % b;
    }
}

interface IPepemonFactory {
    function balanceOf(address _owner, uint256 _id) external view returns (uint256);
    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);
    function mint(address _to, uint256 _id, uint256 _quantity, bytes calldata _data) external;
    function burn(address _account, uint256 _id, uint256 _amount) external;
    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;
    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;
}

contract PepemonStake is Ownable {
    using SafeMath for uint256;

    IPepemonFactory public pepemonFactory;

    struct StakingEvent {
        uint256[] cardIdList;
        uint256 cardAmountAny;
        uint256[] cardAmountList;
        uint256 cardRewardId;
        uint256 blockStakeLength;
        uint256 blockEventClose;
        uint256[] toBurnIdList;
        uint256[] toBurnAmountList;
    }

    struct UserInfo {
        bool isCompleted;
        uint256 blockEnd;
    }

    StakingEvent[] public stakingEvents;
    mapping(address => mapping(uint256 => UserInfo)) public userInfo;
    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) public cardsStaked;

    event StakingEventCreated(uint256 eventId);
    event StakingEventEntered(address indexed user, uint256 eventId);
    event StakingEventCompleted(address indexed user, uint256 eventId);
    event StakingEventCancelled(address indexed user, uint256 eventId);

    constructor(IPepemonFactory _pepemonFactoryAddress) public {
        pepemonFactory = _pepemonFactoryAddress;
    }

    // View functions
    function getStakingEventsLength() external view returns (uint256) {
        return stakingEvents.length;
    }

    function getAllEvents() public view returns (StakingEvent[] memory) {
        uint256 len = stakingEvents.length;
        StakingEvent[] memory evts = new StakingEvent[](len);
        for (uint256 i = 0; i < len; i++) {
            StakingEvent storage e = stakingEvents[i];
            evts[i].cardIdList = e.cardIdList;
            evts[i].cardAmountAny = e.cardAmountAny;
            evts[i].cardAmountList = e.cardAmountList;
            evts[i].cardRewardId = e.cardRewardId;
            evts[i].blockStakeLength = e.blockStakeLength;
            evts[i].blockEventClose = e.blockEventClose;
            evts[i].toBurnIdList = e.toBurnIdList;
            evts[i].toBurnAmountList = e.toBurnAmountList;
        }
        return evts;
    }

    function getActiveEvents() external view returns (uint256[] memory) {
        uint256 total = stakingEvents.length;
        uint256 count = 0;
        for (uint256 i = 0; i < total; i++) {
            if (block.number < stakingEvents[i].blockEventClose) {
                count++;
            }
        }
        uint256[] memory active = new uint256[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < total; i++) {
            if (block.number < stakingEvents[i].blockEventClose) {
                active[idx++] = i;
            }
        }
        return active;
    }

    function getClosedEvents() external view returns (uint256[] memory) {
        uint256 total = stakingEvents.length;
        uint256 count = 0;
        for (uint256 i = 0; i < total; i++) {
            if (block.number >= stakingEvents[i].blockEventClose) {
                count++;
            }
        }
        uint256[] memory closed = new uint256[](count);
        uint256 idx = 0;
        for (uint256 i = 0; i < total; i++) {
            if (block.number >= stakingEvents[i].blockEventClose) {
                closed[idx++] = i;
            }
        }
        return closed;
    }

    function getCardIdListOfEvent(uint256 _eventId) external view returns (uint256[] memory) {
        return stakingEvents[_eventId].cardIdList;
    }

    function getCardAmountListOfEvent(uint256 _eventId) external view returns (uint256[] memory) {
        return stakingEvents[_eventId].cardAmountList;
    }

    function getUserProgress(address _user, uint256 _eventId) external view returns (uint256) {
        UserInfo storage u = userInfo[_user][_eventId];
        if (u.blockEnd == 0) {
            return 0;
        }
        StakingEvent storage e = stakingEvents[_eventId];
        if (block.number >= u.blockEnd) {
            return 100000; // 100%
        }
        uint256 start = u.blockEnd.sub(e.blockStakeLength);
        uint256 elapsed = block.number.sub(start);
        return elapsed.mul(100000).div(e.blockStakeLength);
    }

    // Owner functions
    function createStakingEvent(
        uint256[] memory _cardIdList,
        uint256 _cardAmountAny,
        uint256[] memory _cardAmountList,
        uint256 _cardRewardId,
        uint256 _blockStakeLength,
        uint256 _blockEventClose,
        uint256[] memory _toBurnIdList,
        uint256[] memory _toBurnAmountList
    ) public onlyOwner {
        require(_blockEventClose > block.number, "close must be future");
        if (_cardAmountAny == 0) {
            require(_cardIdList.length == _cardAmountList.length && _cardIdList.length > 0, "ids/amounts mismatch");
        }
        require(_toBurnIdList.length == _toBurnAmountList.length, "burn lists mismatch");
        stakingEvents.push(
            StakingEvent({
                cardIdList: _cardIdList,
                cardAmountAny: _cardAmountAny,
                cardAmountList: _cardAmountList,
                cardRewardId: _cardRewardId,
                blockStakeLength: _blockStakeLength,
                blockEventClose: _blockEventClose,
                toBurnIdList: _toBurnIdList,
                toBurnAmountList: _toBurnAmountList
            })
        );
        emit StakingEventCreated(stakingEvents.length - 1);
    }

    function closeStakingEvent(uint256 _eventId) public onlyOwner {
        StakingEvent storage e = stakingEvents[_eventId];
        require(block.number < e.blockEventClose, "already closed");
        e.blockEventClose = block.number;
    }

    // User functions
    function stakeAny(uint256 _eventId, uint256[] memory _cardIdList, uint256[] memory _cardAmountList) public {
        StakingEvent storage e = stakingEvents[_eventId];
        require(block.number < e.blockEventClose, "event closed");
        require(userInfo[msg.sender][_eventId].blockEnd == 0, "already staking");
        require(e.cardAmountAny > 0, "not any-card event");
        require(_cardIdList.length == _cardAmountList.length && _cardIdList.length > 0, "input mismatch");
        uint256 total = 0;
        for (uint256 i = 0; i < _cardIdList.length; i++) {
            uint256 id = _cardIdList[i];
            uint256 amt = _cardAmountList[i];
            require(_isInArray(id, e.cardIdList), "card not accepted");
            cardsStaked[msg.sender][_eventId][id] = cardsStaked[msg.sender][_eventId][id].add(amt);
            total = total.add(amt);
        }
        require(total == e.cardAmountAny, "must stake exact total");
        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), _cardIdList, _cardAmountList, "");
        userInfo[msg.sender][_eventId] = UserInfo(false, block.number.add(e.blockStakeLength));
        emit StakingEventEntered(msg.sender, _eventId);
    }

    function stake(uint256 _eventId) public {
        StakingEvent storage e = stakingEvents[_eventId];
        require(block.number < e.blockEventClose, "event closed");
        require(userInfo[msg.sender][_eventId].blockEnd == 0, "already staking");
        require(e.cardAmountAny == 0, "use stakeAny");
        require(e.cardIdList.length == e.cardAmountList.length && e.cardIdList.length > 0, "event invalid");
        // record
        for (uint256 i = 0; i < e.cardIdList.length; i++) {
            uint256 id = e.cardIdList[i];
            uint256 amt = e.cardAmountList[i];
            cardsStaked[msg.sender][_eventId][id] = amt;
        }
        pepemonFactory.safeBatchTransferFrom(msg.sender, address(this), e.cardIdList, e.cardAmountList, "");
        userInfo[msg.sender][_eventId] = UserInfo(false, block.number.add(e.blockStakeLength));
        emit StakingEventEntered(msg.sender, _eventId);
    }

    function claim(uint256 _eventId) public {
        UserInfo storage u = userInfo[msg.sender][_eventId];
        StakingEvent storage e = stakingEvents[_eventId];
        require(u.blockEnd != 0, "not staking");
        require(block.number >= u.blockEnd, "not yet completed");
        require(!u.isCompleted, "already claimed");
        _withdrawCardsStaked(_eventId, true);
        // reward mint 1 unit
        pepemonFactory.mint(msg.sender, e.cardRewardId, 1, "");
        u.isCompleted = true;
        emit StakingEventCompleted(msg.sender, _eventId);
    }

    function cancel(uint256 _eventId) public {
        UserInfo storage u = userInfo[msg.sender][_eventId];
        require(u.blockEnd != 0, "not staking");
        require(block.number < u.blockEnd, "already ready");
        u.blockEnd = 0;
        _withdrawCardsStaked(_eventId, false);
        emit StakingEventCancelled(msg.sender, _eventId);
    }

    // Internal helpers
    function _withdrawCardsStaked(uint256 _eventId, bool _burn) internal {
        StakingEvent storage e = stakingEvents[_eventId];
        address user = msg.sender;

        // if burning, do burns
        if (_burn && e.toBurnIdList.length > 0) {
            for (uint256 i = 0; i < e.toBurnIdList.length; i++) {
                uint256 bid = e.toBurnIdList[i];
                uint256 bamt = e.toBurnAmountList[i];
                if (bamt > 0) {
                    pepemonFactory.burn(address(this), bid, bamt);
                }
            }
        }

        // prepare return lists
        uint256 n = e.cardIdList.length;
        uint256[] memory retIds = new uint256[](n);
        uint256[] memory retAmts = new uint256[](n);
        uint256 cnt = 0;

        for (uint256 i = 0; i < n; i++) {
            uint256 id = e.cardIdList[i];
            uint256 stakedAmt = cardsStaked[user][_eventId][id];
            if (stakedAmt == 0) { continue; }
            uint256 burnedAmt = 0;
            if (_burn) {
                // find if this id is in burn list
                for (uint256 j = 0; j < e.toBurnIdList.length; j++) {
                    if (e.toBurnIdList[j] == id) {
                        burnedAmt = e.toBurnAmountList[j];
                        break;
                    }
                }
            }
            uint256 toReturn = stakedAmt;
            if (_burn && burnedAmt <= stakedAmt) {
                toReturn = stakedAmt.sub(burnedAmt);
            }
            if (toReturn > 0) {
                retIds[cnt] = id;
                retAmts[cnt] = toReturn;
                cnt++;
            }
            // clear staked
            cardsStaked[user][_eventId][id] = 0;
        }

        if (cnt > 0) {
            // shrink arrays
            uint256[] memory ids2 = new uint256[](cnt);
            uint256[] memory ams2 = new uint256[](cnt);
            for (uint256 i = 0; i < cnt; i++) {
                ids2[i] = retIds[i];
                ams2[i] = retAmts[i];
            }
            pepemonFactory.safeBatchTransferFrom(address(this), user, ids2, ams2, "");
        }
    }

    function _isInArray(uint256 _value, uint256[] memory _array) internal pure returns (bool) {
        for (uint256 i = 0; i < _array.length; i++) {
            if (_array[i] == _value) {
                return true;
            }
        }
        return false;
    }

    // ERC1155 token receiver interface
    function onERC1155Received(
        address, address, uint256, uint256, bytes calldata
    ) external pure returns (bytes4) {
        return 0xf23a6e61;
    }

    function onERC1155BatchReceived(
        address, address, uint256[] calldata, uint256[] calldata, bytes calldata
    ) external pure returns (bytes4) {
        return 0xbc197c81;
    }

    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
        return  interfaceID == 0x01ffc9a7 ||
                interfaceID == 0x4e2312e0;
    }
}
```