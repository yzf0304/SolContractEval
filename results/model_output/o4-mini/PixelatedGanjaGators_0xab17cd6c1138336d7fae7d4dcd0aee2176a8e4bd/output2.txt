Below is a complete, self-contained ERC721A implementation (Solidity 0.8.7) that meets all of the requirements and fills in every function in your skeleton. It does not add any extra contracts or dependencies beyond those already in your provided context.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";

/**
 * @title ERC721A
 * @notice ERC-721 with efficient batch minting and on-chain enumeration.
 */
contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using Address for address;
    using Strings for uint256;

    // ============ STRUCTS ============

    struct TokenOwnership {
        address addr;
        uint64 startTimestamp;
    }

    struct AddressData {
        uint128 balance;
        uint128 numberMinted;
    }

    // ============ STATE ============

    // The next token ID to be minted.
    uint256 internal currentIndex;

    // Token name and symbol.
    string private _name;
    string private _symbol;

    // Mapping from token ID to ownership details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data.
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address.
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals.
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    // ============ CONSTRUCTOR ============

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    // ============ IERC721Enumerable ============

    function totalSupply() public view override returns (uint256) {
        return currentIndex;
    }

    function tokenByIndex(uint256 index) public view override returns (uint256) {
        require(index < totalSupply(), "ERC721A: global index out of bounds");
        return index;
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        require(index < balanceOf(owner), "ERC721A: owner index out of bounds");
        uint256 count;
        for (uint256 i = 0; i < currentIndex; i++) {
            TokenOwnership memory ownership = ownershipOf(i);
            if (ownership.addr == owner) {
                if (count == index) {
                    return i;
                }
                count++;
            }
        }
        revert("ERC721A: unable to get token of owner by index");
    }

    // ============ IERC165 ============

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC721Enumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    // ============ IERC721 ============

    function balanceOf(address owner) public view override returns (uint256) {
        require(owner != address(0), "ERC721A: balance query for zero address");
        return uint256(_addressData[owner].balance);
    }

    function ownerOf(uint256 tokenId) public view override returns (address) {
        return ownershipOf(tokenId).addr;
    }

    function approve(address to, uint256 tokenId) public override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721A: approval to current owner");
        require(
            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
            "ERC721A: approve caller is not owner nor approved for all"
        );
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    function getApproved(uint256 tokenId) public view override returns (address) {
        require(_exists(tokenId), "ERC721A: approved query for nonexistent token");
        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public override {
        require(operator != _msgSender(), "ERC721A: approve to caller");
        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public override {
        _transfer(from, to, tokenId);
        require(
            _checkOnERC721Received(from, to, tokenId, _data),
            "ERC721A: transfer to non ERC721Receiver implementer"
        );
    }

    // ============ IERC721Metadata ============

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721A: URI query for nonexistent token");
        string memory baseURI = _baseURI();
        // If base URI is empty, return just the tokenId
        return bytes(baseURI).length > 0
            ? string(abi.encodePacked(baseURI, tokenId.toString()))
            : tokenId.toString();
    }

    // Override default to empty string
    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    // ============ INTERNAL VIEWS ============

    function _numberMinted(address owner) internal view returns (uint256) {
        return uint256(_addressData[owner].numberMinted);
    }

    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        require(_exists(tokenId), "ERC721A: owner query for nonexistent token");

        // If explicit ownership info is present, return it.
        TokenOwnership memory ownership = _ownerships[tokenId];
        if (ownership.addr != address(0)) {
            return ownership;
        }

        // Otherwise iterate backwards until we find the prior ownership record.
        uint256 curr = tokenId;
        while (true) {
            curr--;
            ownership = _ownerships[curr];
            if (ownership.addr != address(0)) {
                return ownership;
            }
        }
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < currentIndex;
    }

    // ============ MINTING ============

    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, "");
    }

    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        _mint(to, quantity, _data, true);
    }

    function _mint(
        address to,
        uint256 quantity,
        bytes memory _data,
        bool safe
    ) internal {
        require(to != address(0), "ERC721A: mint to zero address");
        require(quantity > 0, "ERC721A: quantity must be > 0");

        uint256 startTokenId = currentIndex;

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Update address data
        AddressData storage ad = _addressData[to];
        ad.balance += uint128(quantity);
        ad.numberMinted += uint128(quantity);

        // Record ownership for the first token only
        _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));

        // Emit and (if applicable) checkReceiver for each new token
        for (uint256 i = 0; i < quantity; i++) {
            emit Transfer(address(0), to, startTokenId + i);
            if (safe) {
                require(
                    _checkOnERC721Received(address(0), to, startTokenId + i, _data),
                    "ERC721A: transfer to non ERC721Receiver"
                );
            }
        }

        currentIndex += quantity;
        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }

    // ============ TRANSFERS ============

    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prev = ownershipOf(tokenId);

        require(prev.addr == from, "ERC721A: transfer from incorrect owner");
        require(to != address(0), "ERC721A: transfer to zero address");

        bool isApprovedOrOwner = (_msgSender() == from ||
            isApprovedForAll(from, _msgSender()) ||
            getApproved(tokenId) == _msgSender());
        require(isApprovedOrOwner, "ERC721A: caller not owner nor approved");

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals
        _approve(address(0), tokenId, from);

        // Update balances
        {
            AddressData storage fromData = _addressData[from];
            AddressData storage toData = _addressData[to];
            fromData.balance -= 1;
            toData.balance += 1;
        }

        // Set new ownership
        _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));

        // If the next slot is uninitialized (and inside bounds), set it to maintain correctness for ownerOf(tokenId+1)
        uint256 nextTokenId = tokenId + 1;
        if (_ownerships[nextTokenId].addr == address(0) && nextTokenId < currentIndex) {
            _ownerships[nextTokenId] = TokenOwnership(from, prev.startTimestamp);
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }

    // ============ APPROVALS HELPERS ============

    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }

    // ============ ERC721 RECEIVER ============

    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (!to.isContract()) {
            return true;
        }
        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
            return retval == IERC721Receiver.onERC721Received.selector;
        } catch (bytes memory reason) {
            if (reason.length == 0) {
                revert("ERC721A: transfer to non ERC721Receiver implementer");
            }
            assembly {
                revert(add(32, reason), mload(reason))
            }
        }
    }

    // ============ HOOKS ============

    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}

    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}
```

Explanation of key points:

1. `currentIndex` is the next token ID to mint; tokens are numbered `0 .. currentIndex-1`.
2. `ownershipOf` walks backward from `tokenId` until it finds a nonzero ownership entry, matching Azuki’s ERC721A logic.
3. `totalSupply` is simply `currentIndex`.  
4. Enumeration (`tokenByIndex`, `tokenOfOwnerByIndex`) loops over minted IDs; it is O(n) but meets the interface.
5. Batch minting via `_mint` updates balances once, records one ownership slot, and emits `Transfer` for each token. Safe mints perform the `onERC721Received` check per token.
6. Transfers correctly clear approvals, update balances, write the new ownership, and maintain the “next ownership” slot so that subsequent `ownerOf(...)` calls stay correct.
7. All required interface functions, events, and hooks are implemented exactly as specified, with no external dependencies beyond OpenZeppelin’s Context, Address, Strings, and ERC165 utilities.