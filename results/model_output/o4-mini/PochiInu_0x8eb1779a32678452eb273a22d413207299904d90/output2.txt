```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.11;

contract PochiInu is ERC20, Ownable {
    uint256 public maxBuyAmount;
    uint256 public maxSellAmount;
    uint256 public maxWalletAmount;

    IDexRouter public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;

    bool private swapping;
    uint256 public swapTokensAtAmount;

    address public operationsAddress;
    address public yashaAddress;

    uint256 public tradingActiveBlock = 0;
    bool public limitsInEffect = true;
    bool public tradingActive = false;
    bool public swapEnabled = false;
    bool public transferDelayEnabled = true;

    uint256 public buyTotalFees;
    uint256 public buyOperationsFee;
    uint256 public buyLiquidityFee;
    uint256 public buyYashaFee;

    uint256 public sellTotalFees;
    uint256 public sellOperationsFee;
    uint256 public sellLiquidityFee;
    uint256 public sellYashaFee;

    uint256 public tokensForOperations;
    uint256 public tokensForLiquidity;
    uint256 public tokensForYasha;

    mapping(address => uint256) private _holderLastTransferTimestamp;
    mapping(address => bool) private _isExcludedFromFees;
    mapping(address => bool) public _isExcludedMaxTransactionAmount;
    mapping(address => bool) public automatedMarketMakerPairs;

    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);
    event EnabledTrading();
    event RemovedLimits();
    event ExcludeFromFees(address indexed account, bool isExcluded);
    event UpdatedMaxBuyAmount(uint256 newAmount);
    event UpdatedMaxSellAmount(uint256 newAmount);
    event UpdatedMaxWalletAmount(uint256 newAmount);
    event UpdatedOperationsAddress(address indexed newWallet);
    event UpdatedYashaAddress(address indexed newWallet);
    event MaxTransactionExclusion(address _address, bool excluded);
    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiquidity
    );
    event TransferForeignToken(address token, uint256 amount);

    constructor() ERC20("Pochi Inu", "POCHI") {
        address newOwner = msg.sender;

        IDexRouter _uniswapV2Router = IDexRouter(
            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
        );
        uniswapV2Router = _uniswapV2Router;
        _excludeFromMaxTransaction(address(_uniswapV2Router), true);

        uniswapV2Pair = IDexFactory(_uniswapV2Router.factory())
            .createPair(address(this), _uniswapV2Router.WETH());
        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);

        uint256 totalSupply = 100 * 1e9 * 1e18;

        maxBuyAmount = (totalSupply * 1) / 1000;
        maxSellAmount = (totalSupply * 1) / 1000;
        maxWalletAmount = (totalSupply * 3) / 1000;
        swapTokensAtAmount = (totalSupply * 25) / 100000; // 0.025%

        buyOperationsFee = 8;
        buyLiquidityFee = 3;
        buyYashaFee = 4;
        buyTotalFees = buyOperationsFee + buyLiquidityFee + buyYashaFee;

        sellOperationsFee = 8;
        sellLiquidityFee = 5;
        sellYashaFee = 2;
        sellTotalFees = sellOperationsFee + sellLiquidityFee + sellYashaFee;

        _excludeFromMaxTransaction(newOwner, true);
        _excludeFromMaxTransaction(address(this), true);
        _excludeFromMaxTransaction(address(0xdead), true);

        excludeFromFees(newOwner, true);
        excludeFromFees(address(this), true);
        excludeFromFees(address(0xdead), true);

        operationsAddress = newOwner;
        yashaAddress = newOwner;

        _createInitialSupply(newOwner, totalSupply);
        transferOwnership(newOwner);
    }

    receive() external payable {}

    function enableTrading() external onlyOwner {
        require(!tradingActive, "Trading already active");
        tradingActive = true;
        swapEnabled = true;
        tradingActiveBlock = block.number;
        emit EnabledTrading();
    }

    function removeLimits() external onlyOwner {
        require(limitsInEffect, "Limits already removed");
        limitsInEffect = false;
        emit RemovedLimits();
    }

    function disableTransferDelay() external onlyOwner {
        require(transferDelayEnabled, "Transfer delay already disabled");
        transferDelayEnabled = false;
    }

    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {
        require(
            newNum >= (totalSupply() * 1) / 1000,
            "Max buy must be >= 0.1%"
        );
        maxBuyAmount = newNum;
        emit UpdatedMaxBuyAmount(newNum);
    }

    function updateMaxSellAmount(uint256 newNum) external onlyOwner {
        require(
            newNum >= (totalSupply() * 1) / 1000,
            "Max sell must be >= 0.1%"
        );
        maxSellAmount = newNum;
        emit UpdatedMaxSellAmount(newNum);
    }

    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {
        require(
            newNum >= (totalSupply() * 3) / 1000,
            "Max wallet must be >= 0.3%"
        );
        maxWalletAmount = newNum;
        emit UpdatedMaxWalletAmount(newNum);
    }

    function updateSwapTokensAtAmount(uint256 newAmount)
        external
        onlyOwner
    {
        require(
            newAmount >= (totalSupply() * 1) / 100000 &&
                newAmount <= (totalSupply() * 1) / 1000,
            "Swap amount must be between 0.001% and 0.1%"
        );
        swapTokensAtAmount = newAmount;
    }

    function _excludeFromMaxTransaction(address updAds, bool isExcluded)
        private
    {
        _isExcludedMaxTransactionAmount[updAds] = isExcluded;
        emit MaxTransactionExclusion(updAds, isExcluded);
    }

    function airdropToWallets(
        address[] memory wallets,
        uint256[] memory amountsInTokens
    ) external onlyOwner {
        require(
            wallets.length == amountsInTokens.length,
            "Mismatched inputs"
        );
        require(wallets.length <= 200, "Too many wallets");
        for (uint256 i = 0; i < wallets.length; i++) {
            super._transfer(
                msg.sender,
                wallets[i],
                amountsInTokens[i]
            );
        }
    }

    function excludeFromMaxTransaction(address updAds, bool isEx)
        external
        onlyOwner
    {
        require(
            updAds != uniswapV2Pair,
            "Cannot remove pair from max txn"
        );
        _isExcludedMaxTransactionAmount[updAds] = isEx;
        emit MaxTransactionExclusion(updAds, isEx);
    }

    function setAutomatedMarketMakerPair(address pair, bool value)
        external
        onlyOwner
    {
        require(
            pair != uniswapV2Pair,
            "Cannot remove uniswap pair"
        );
        _setAutomatedMarketMakerPair(pair, value);
    }

    function _setAutomatedMarketMakerPair(address pair, bool value)
        private
    {
        automatedMarketMakerPairs[pair] = value;
        _excludeFromMaxTransaction(pair, value);
        emit SetAutomatedMarketMakerPair(pair, value);
    }

    function updateBuyFees(
        uint256 _operationsFee,
        uint256 _liquidityFee,
        uint256 _yashaFee
    ) external onlyOwner {
        uint256 total = _operationsFee + _liquidityFee + _yashaFee;
        require(total <= 15, "Buy fees <= 15%");
        buyOperationsFee = _operationsFee;
        buyLiquidityFee = _liquidityFee;
        buyYashaFee = _yashaFee;
        buyTotalFees = total;
    }

    function updateSellFees(
        uint256 _operationsFee,
        uint256 _liquidityFee,
        uint256 _yashaFee
    ) external onlyOwner {
        uint256 total = _operationsFee + _liquidityFee + _yashaFee;
        require(total <= 20, "Sell fees <= 20%");
        sellOperationsFee = _operationsFee;
        sellLiquidityFee = _liquidityFee;
        sellYashaFee = _yashaFee;
        sellTotalFees = total;
    }

    function excludeFromFees(address account, bool excluded)
        public
        onlyOwner
    {
        _isExcludedFromFees[account] = excluded;
        emit ExcludeFromFees(account, excluded);
    }

    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        require(from != address(0), "ERC20: zero from");
        require(to != address(0), "ERC20: zero to");
        if (amount == 0) {
            super._transfer(from, to, 0);
            return;
        }

        if (limitsInEffect) {
            if (
                from != owner() &&
                to != owner() &&
                !_isExcludedFromFees[from] &&
                !_isExcludedFromFees[to]
            ) {
                // trading active?
                require(
                    tradingActive,
                    "Trading is not active."
                );

                // transfer delay
                if (transferDelayEnabled) {
                    if (
                        to != address(uniswapV2Router) &&
                        to != address(uniswapV2Pair)
                    ) {
                        require(
                            _holderLastTransferTimestamp[tx.origin] <
                                block.number,
                            "Only one tx per block."
                        );
                        _holderLastTransferTimestamp[
                            tx.origin
                        ] = block.number;
                    }
                }

                // buy
                if (
                    automatedMarketMakerPairs[from] &&
                    !_isExcludedMaxTransactionAmount[to]
                ) {
                    require(
                        amount <= maxBuyAmount,
                        "Buy exceeds max"
                    );
                    require(
                        balanceOf(to) + amount <= maxWalletAmount,
                        "Exceeds max wallet"
                    );
                }
                // sell
                else if (
                    automatedMarketMakerPairs[to] &&
                    !_isExcludedMaxTransactionAmount[from]
                ) {
                    require(
                        amount <= maxSellAmount,
                        "Sell exceeds max"
                    );
                }
                // normal
                else if (
                    !_isExcludedMaxTransactionAmount[to]
                ) {
                    require(
                        balanceOf(to) + amount <= maxWalletAmount,
                        "Exceeds max wallet"
                    );
                }
            }
        }

        uint256 contractTokenBalance = balanceOf(address(this));
        bool canSwap = contractTokenBalance >= swapTokensAtAmount &&
            swapEnabled &&
            !swapping &&
            !automatedMarketMakerPairs[from] &&
            !_isExcludedFromFees[from] &&
            !_isExcludedFromFees[to];

        if (canSwap) {
            swapping = true;
            swapBack();
            swapping = false;
        }

        bool takeFee = !swapping &&
            _isExcludedFromFees[from] == false &&
            _isExcludedFromFees[to] == false;

        if (takeFee) {
            uint256 fees;
            if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {
                fees = (amount * sellTotalFees) / 100;
                tokensForLiquidity +=
                    (fees * sellLiquidityFee) /
                    sellTotalFees;
                tokensForOperations +=
                    (fees * sellOperationsFee) /
                    sellTotalFees;
                tokensForYasha +=
                    (fees * sellYashaFee) /
                    sellTotalFees;
            } else if (
                automatedMarketMakerPairs[from] && buyTotalFees > 0
            ) {
                fees = (amount * buyTotalFees) / 100;
                tokensForLiquidity +=
                    (fees * buyLiquidityFee) /
                    buyTotalFees;
                tokensForOperations +=
                    (fees * buyOperationsFee) /
                    buyTotalFees;
                tokensForYasha += (fees * buyYashaFee) / buyTotalFees;
            }

            if (fees > 0) {
                super._transfer(from, address(this), fees);
                amount -= fees;
            }
        }

        super._transfer(from, to, amount);
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        _approve(
            address(this),
            address(uniswapV2Router),
            tokenAmount
        );
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();
        uniswapV2Router
            .swapExactTokensForETHSupportingFeeOnTransferTokens(
                tokenAmount,
                0,
                path,
                address(this),
                block.timestamp
            );
    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount)
        private
    {
        _approve(
            address(this),
            address(uniswapV2Router),
            tokenAmount
        );
        uniswapV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0,
            0,
            owner(),
            block.timestamp
        );
    }

    function swapBack() private {
        uint256 contractBalance = balanceOf(address(this));
        uint256 totalTokensToSwap = tokensForLiquidity +
            tokensForOperations +
            tokensForYasha;
        if (
            contractBalance == 0 || totalTokensToSwap == 0
        ) {
            return;
        }

        if (contractBalance > swapTokensAtAmount * 10) {
            contractBalance = swapTokensAtAmount * 10;
        }

        uint256 liquidityTokens = (contractBalance *
            tokensForLiquidity) / totalTokensToSwap / 2;
        uint256 amountToSwapForETH = contractBalance -
            liquidityTokens;

        uint256 initialETHBalance = address(this).balance;
        swapTokensForEth(amountToSwapForETH);
        uint256 newETHBalance = address(this).balance -
            initialETHBalance;

        uint256 ethForOperations = (newETHBalance *
            tokensForOperations) /
            (totalTokensToSwap - (tokensForLiquidity / 2));
        uint256 ethForYasha = (newETHBalance *
            tokensForYasha) /
            (totalTokensToSwap - (tokensForLiquidity / 2));
        uint256 ethForLiquidity = newETHBalance -
            ethForOperations -
            ethForYasha;

        tokensForLiquidity = 0;
        tokensForOperations = 0;
        tokensForYasha = 0;

        if (liquidityTokens > 0 && ethForLiquidity > 0) {
            addLiquidity(liquidityTokens, ethForLiquidity);
            emit SwapAndLiquify(
                amountToSwapForETH,
                ethForLiquidity,
                liquidityTokens
            );
        }

        if (ethForOperations > 0) {
            (bool successOp, ) = operationsAddress.call{
                value: ethForOperations
            }("");
            require(successOp, "Ops transfer failed");
        }

        if (ethForYasha > 0) {
            (bool successYa, ) = yashaAddress.call{
                value: ethForYasha
            }("");
            require(successYa, "Yasha transfer failed");
        }
    }

    function transferForeignToken(address _token, address _to)
        external
        onlyOwner
        returns (bool _sent)
    {
        require(
            _token != address(this),
            "Cannot withdraw native token"
        );
        uint256 _contractBalance = IERC20(_token).balanceOf(
            address(this)
        );
        _sent = IERC20(_token).transfer(
            _to,
            _contractBalance
        );
        emit TransferForeignToken(_token, _contractBalance);
    }

    function withdrawStuckETH() external onlyOwner {
        uint256 _balance = address(this).balance;
        require(_balance > 0, "No ETH to withdraw");
        (bool success, ) = owner().call{value: _balance}("");
        require(success, "ETH withdraw failed");
    }

    function setOperationsAddress(address _operationsAddress)
        external
        onlyOwner
    {
        require(
            _operationsAddress != address(0),
            "Zero address"
        );
        operationsAddress = _operationsAddress;
        emit UpdatedOperationsAddress(_operationsAddress);
    }

    function setYashaAddress(address _yashaAddress)
        external
        onlyOwner
    {
        require(_yashaAddress != address(0), "Zero address");
        yashaAddress = _yashaAddress;
        emit UpdatedYashaAddress(_yashaAddress);
    }
}
```