pragma solidity ^0.4.18;

import "./Discounts.sol";
import "./Limits.sol";
import "./SeeToken.sol";
import "zeppelin-solidity/contracts/ownership/Claimable.sol";
import "zeppelin-solidity/contracts/lifecycle/Pausable.sol";

/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts,
 * purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and
 * Claimable contracts. It manages the sale of tokens, setting rates, adding
 * tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {
  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;

  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  /// @notice The SEE token being sold
  SeeToken public token;

  /// @notice Discount/tier information
  Discounts.Collection internal discounts;

  /// @notice Per-address purchase cap window
  Limits.Window internal cap;

  /// @notice Whitelist of participants
  mapping(address => Participant) internal participants;

  /// @notice Emitted when a new tier is added
  event Tier(uint256 discount, uint256 available);

  /**
   * @dev On deployment, set the token and pause sales until setup is complete
   * @param _token Address of the SEE token contract
   */
  function Presale(address _token) public {
    token = SeeToken(_token);
    paused = true;
  }

  /**
   * @notice Finish the two-step ownership transfer for the token contract
   * @dev The token must have had transferOwnership called to this contract
   */
  function claimToken() public {
    token.claimOwnership();
  }

  /**
   * @notice Unpause the presale
   * @dev Can only be called once rate and cap are set, the presale is paused,
   * and this contract owns the token
   */
  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  /**************************************************************************
   * ADMIN INTERFACE
   *************************************************************************/

  /**
   * @notice Set the base purchase rate (tokens per wei)
   * @param _purchaseRate Number of SEE tokens issued per wei
   */
  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    discounts.baseRate = _purchaseRate;
  }

  /**
   * @notice Configure the per-address purchase cap
   * @param _amount Maximum tokens per window
   * @param _duration Window duration in blocks
   */
  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    cap.amount = _amount;
    cap.duration = _duration;
  }

  /**
   * @notice Add a discount tier
   * @param _discount Discount in basis points (0..10000)
   * @param _available Tokens available at this tier
   */
  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    discounts.addTier(_discount, _available);
    Tier(_discount, _available);
  }

  /**
   * @notice Whitelist and assign minimum tier for a list of participants
   * @param _minimumTier Minimum tier index participants may purchase from
   * @param _authorized Addresses to authorize
   */
  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _authorized.length; i++) {
      address addr = _authorized[i];
      participants[addr].authorized = true;
      participants[addr].minimumTier = _minimumTier;
    }
  }

  /**
   * @notice Withdraw collected ether to owner
   */
  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(address(this).balance);
  }

  /**************************************************************************
   * PURCHASE INTERFACE
   *************************************************************************/

  /**
   * @notice Fallback forwards to purchaseTokens
   */
  function ()
    public
    payable
  {
    purchaseTokens();
  }

  /**
   * @notice Purchase SEE tokens, respecting tiers and caps
   */
  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    require(msg.value > 0);

    // Determine how many tokens this address may still buy in the window
    uint256 capLeft = cap.getLimit(msg.sender);
    require(capLeft > 0);

    // Compute tokens to purchase and leftover wei
    uint256 minTier = participants[msg.sender].minimumTier;
    (uint256 purchased, uint256 remaining) = discounts.purchaseTokens(
      discounts,
      capLeft,
      msg.value,
      minTier
    );

    require(purchased > 0);

    // Record against cap, issue tokens, and refund any excess wei
    cap.recordPurchase(cap, msg.sender, purchased);
    token.issue(msg.sender, purchased);

    if (remaining > 0) {
      msg.sender.transfer(remaining);
    }
  }

  /**************************************************************************
   * PRICING / AVAILABILITY - VIEW INTERFACE
   *************************************************************************/

  /**
   * @notice Return current purchase window parameters
   * @return _amount Max tokens per window
   * @return _duration Duration in blocks
   */
  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    _amount = cap.amount;
    _duration = cap.duration;
  }

  /**
   * @notice Return all configured tiers (discount, available)
   */
  function getTiers()
    public
    view
    returns (uint256[2][] tiersInfo)
  {
    uint256 len = discounts.tiers.length;
    tiersInfo = new uint256[2][](len);
    for (uint256 i = 0; i < len; i++) {
      Discounts.Tier storage t = discounts.tiers[i];
      tiersInfo[i][0] = t.discount;
      tiersInfo[i][1] = t.available;
    }
  }

  /**
   * @notice Get the remaining available tokens per tier for a participant
   * @param _participant Address to query
   */
  function getAvailability(address _participant)
    public
    view
    returns (uint256[] availability)
  {
    uint256 len = discounts.tiers.length;
    availability = new uint256[](len);

    if (participants[_participant].authorized) {
      uint256 start = participants[_participant].minimumTier;
      for (uint256 i = start; i < len; i++) {
        availability[i] = discounts.tiers[i].available;
      }
    }
  }

  /**************************************************************************
   * MODIFIERS
   *************************************************************************/

  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}