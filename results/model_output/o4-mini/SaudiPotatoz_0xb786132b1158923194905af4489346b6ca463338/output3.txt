pragma solidity ^0.8.7;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SaudiPotatoz is ERC721A, Ownable, ReentrancyGuard {
    string public baseURI;
    uint256 public price = 0 ether;
    uint256 public maxPerTx = 1;
    uint256 public maxPerWallet = 1;
    uint256 public totalFree = 0;
    uint256 public maxSupply = 5000;
    uint256 public nextOwnerToExplicitlySet;
    bool public mintEnabled;

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    constructor() ERC721A("SaudiPotatoz", "SaudiPotatoz") {}

    function freeMint(uint256 amt) external callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(amt > 0, "Must mint at least one");
        require(amt <= maxPerTx, "Exceeds max per transaction");
        uint256 supply = totalSupply();
        require(supply + amt <= totalFree, "Exceeds total free supply");
        require(numberMinted(msg.sender) + amt <= maxPerWallet, "Exceeds wallet limit");
        require(msg.value == 0, "Free mint does not accept ETH");
        _safeMint(msg.sender, amt);
    }

    function mint(uint256 amt) external payable callerIsUser {
        require(mintEnabled, "Minting is not enabled");
        require(amt > 0, "Must mint at least one");
        require(amt <= maxPerTx, "Exceeds max per transaction");
        uint256 supply = totalSupply();
        require(supply + amt <= maxSupply, "Exceeds max supply");
        require(numberMinted(msg.sender) + amt <= maxPerWallet, "Exceeds wallet limit");
        require(msg.value == price * amt, "Incorrect ETH amount");
        _safeMint(msg.sender, amt);
    }

    function ownerBatchMint(uint256 amt) external onlyOwner {
        require(amt > 0, "Must mint at least one");
        uint256 supply = totalSupply();
        require(supply + amt <= maxSupply, "Exceeds max supply");
        _safeMint(msg.sender, amt);
    }

    function toggleMinting() external onlyOwner {
        mintEnabled = !mintEnabled;
    }

    function numberMinted(address ownerAddr) public view returns (uint256) {
        return _numberMinted(ownerAddr);
    }

    function setBaseURI(string calldata baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setPrice(uint256 price_) external onlyOwner {
        price = price_;
    }

    function setTotalFree(uint256 totalFree_) external onlyOwner {
        totalFree = totalFree_;
    }

    function setMaxPerTx(uint256 maxPerTx_) external onlyOwner {
        maxPerTx = maxPerTx_;
    }

    function setMaxPerWallet(uint256 maxPerWallet_) external onlyOwner {
        maxPerWallet = maxPerWallet_;
    }

    function setmaxSupply(uint256 maxSupply_) external onlyOwner {
        maxSupply = maxSupply_;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseURI;
    }

    function withdraw() external onlyOwner nonReentrant {
        uint256 bal = address(this).balance;
        require(bal > 0, "No ETH to withdraw");
        (bool success, ) = payable(owner()).call{value: bal}("");
        require(success, "Withdraw failed");
    }

    function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
        _setOwnersExplicit(quantity);
    }

    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
        require(_exists(tokenId), "Query for nonexistent token");
        return ownershipOf(tokenId);
    }

    function _setOwnersExplicit(uint256 quantity) internal {
        require(quantity > 0, "Quantity must be nonzero");
        uint256 _next = nextOwnerToExplicitlySet;
        uint256 supply = totalSupply();
        require(supply > 0, "No tokens minted yet");
        uint256 end = _next + quantity;
        if (end > supply) {
            end = supply;
        }
        for (uint256 i = _next; i < end; i++) {
            if (_ownerships[i].addr == address(0)) {
                TokenOwnership memory ownership = ownershipOf(i);
                _ownerships[i] = TokenOwnership({
                    addr: ownership.addr,
                    startTimestamp: ownership.startTimestamp
                });
            }
        }
        nextOwnerToExplicitlySet = end;
    }
}