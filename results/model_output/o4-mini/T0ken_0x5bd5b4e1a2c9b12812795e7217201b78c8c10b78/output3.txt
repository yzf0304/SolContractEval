```solidity
pragma solidity 0.5.2;

import "./Ownable.sol";
import "./LockableDestroyable.sol";
import "./AdditiveMath.sol";
import "./AddressMap.sol";
import "./Compliance.sol";
import "./ERC20.sol";

contract T0ken is ERC20, Ownable, LockableDestroyable {
    using AdditiveMath for uint256;
    using AddressMap for AddressMap.Data;

    address constant internal ZERO_ADDRESS = address(0);
    string public constant name = "TZERO PREFERRED";
    string public constant symbol = "TZROP";
    uint8 public constant decimals = 0;

    AddressMap.Data public shareholders;
    Compliance public compliance;
    address public issuer;
    bool public issuingFinished = false;
    mapping(address => address) public cancellations;

    mapping(address => uint256) internal balances;
    uint256 internal totalSupplyTokens;

    mapping (address => mapping (address => uint256)) private allowed;

    modifier onlyIssuer() {
        require(msg.sender == issuer, "Only issuer allowed");
        _;
    }

    modifier canIssue() {
        require(!issuingFinished, "Issuing is already finished");
        _;
    }

    modifier isNotCancelled(address addr) {
        require(cancellations[addr] == ZERO_ADDRESS, "Address has been cancelled");
        _;
    }

    modifier hasFunds(address addr, uint256 tokens) {
        require(tokens <= balances[addr], "Insufficient funds");
        _;
    }

    event VerifiedAddressSuperseded(
        address indexed original,
        address indexed replacement,
        address indexed sender
    );
    event IssuerSet(address indexed previousIssuer, address indexed newIssuer);
    event Issue(address indexed to, uint256 tokens);
    event IssueFinished();
    event ShareholderAdded(address shareholder);
    event ShareholderRemoved(address shareholder);

    function transfer(address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(msg.sender, tokens)
        returns (bool)
    {
        _canTransfer(msg.sender, to, tokens, false);
        _transferTokens(msg.sender, to, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        uint256 currentAllowance = allowed[from][msg.sender];
        require(tokens <= currentAllowance, "Transfer amount exceeds allowance");
        allowed[from][msg.sender] = currentAllowance.subtract(tokens);

        _canTransfer(from, to, tokens, false);
        _transferTokens(from, to, tokens);
        return true;
    }

    function transferOverride(address from, address to, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(to)
        hasFunds(from, tokens)
        returns (bool)
    {
        _canTransfer(from, to, tokens, true);
        _transferTokens(from, to, tokens);
        return true;
    }

    function issueTokens(uint256 quantity)
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        require(compliance != Compliance(ZERO_ADDRESS), "Compliance not set");
        // check compliance for issuance: issuer, from=0x0, to=issuer
        require(compliance.canIssue(msg.sender, ZERO_ADDRESS, msg.sender, quantity), "Cannot issue");

        balances[msg.sender] = balances[msg.sender].add(quantity);
        totalSupplyTokens = totalSupplyTokens.add(quantity);

        // add shareholder if new
        if (shareholders.append(msg.sender)) {
            emit ShareholderAdded(msg.sender);
        }

        emit Issue(msg.sender, quantity);
        return true;
    }

    function finishIssuing()
        external
        isUnlocked
        onlyIssuer
        canIssue
        returns (bool)
    {
        issuingFinished = true;
        emit IssueFinished();
        return true;
    }

    function cancelAndReissue(address original, address replacement)
        external
        isUnlocked
        onlyIssuer
        isNotCancelled(replacement)
    {
        // original must be a current shareholder
        require(shareholders.exists(original), "Original not a shareholder");
        uint256 bal = balances[original];
        require(bal > 0, "Original has no tokens");
        require(replacement != ZERO_ADDRESS, "Replacement is zero address");

        // compliance override check
        _canTransfer(original, replacement, bal, true);
        _transferTokens(original, replacement, bal);

        // mark original as cancelled
        cancellations[original] = replacement;
        emit VerifiedAddressSuperseded(original, replacement, msg.sender);
    }

    function approve(address spender, uint256 tokens)
        external
        isUnlocked
        isNotCancelled(msg.sender)
        returns (bool)
    {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function setIssuer(address newIssuer)
        external
        isUnlocked
        onlyOwner
    {
        require(newIssuer != ZERO_ADDRESS, "Issuer is zero address");
        address prev = issuer;
        issuer = newIssuer;
        emit IssuerSet(prev, newIssuer);
    }

    function setCompliance(address newComplianceAddress)
        external
        isUnlocked
        onlyOwner
    {
        require(newComplianceAddress != ZERO_ADDRESS, "Compliance is zero address");
        compliance = Compliance(newComplianceAddress);
    }

    function totalSupply()
        external
        view
        returns (uint256)
    {
        return totalSupplyTokens;
    }

    function balanceOf(address addr)
        external
        view
        returns (uint256)
    {
        return balances[addr];
    }

    function allowance(address addrOwner, address spender)
        external
        view
        returns (uint256)
    {
        return allowed[addrOwner][spender];
    }

    function holderAt(int256 index)
        external
        view
        returns (address)
    {
        return shareholders.at(index);
    }

    function isHolder(address addr)
        external
        view
        returns (bool)
    {
        return shareholders.exists(addr);
    }

    function isSuperseded(address addr)
        external
        view
        returns (bool)
    {
        return cancellations[addr] != ZERO_ADDRESS;
    }

    function getSuperseded(address addr)
        external
        view
        returns (address)
    {
        address curr = addr;
        while (cancellations[curr] != ZERO_ADDRESS) {
            curr = cancellations[curr];
        }
        return curr;
    }

    // internal transfer and compliance helpers
    function _canTransfer(address from, address to, uint256 tokens, bool isOverride) private {
        require(compliance != Compliance(ZERO_ADDRESS), "Compliance not set");
        if (isOverride) {
            require(
                compliance.canOverride(msg.sender, from, to, tokens),
                "Override not allowed"
            );
        } else {
            require(
                compliance.canTransfer(msg.sender, from, to, tokens),
                "Transfer not allowed"
            );
        }
    }

    function _transferTokens(address from, address to, uint256 tokens) private {
        // update balances
        balances[from] = balances[from].subtract(tokens);
        balances[to] = balances[to].add(tokens);

        // add recipient as shareholder if new
        if (shareholders.append(to)) {
            emit ShareholderAdded(to);
        }
        // remove sender if zero balance
        if (balances[from] == 0) {
            if (shareholders.remove(from)) {
                emit ShareholderRemoved(from);
            }
        }

        emit Transfer(from, to, tokens);
    }
}
```

Explanation of key parts:

1. **Transfer Functions**:  
   - `transfer`, `transferFrom`, and `transferOverride` all route through `_canTransfer` (to enforce compliance rules) and `_transferTokens` (to update balances and manage the shareholder list).

2. **Issuance**:  
   - `issueTokens` checks `compliance.canIssue`, mints tokens to the issuer, updates `totalSupplyTokens`, and ensures the issuer is in the shareholder set.
   - `finishIssuing` makes issuance a one-way operation.

3. **Cancellation & Reissue**:  
   - `cancelAndReissue` ensures the original is a shareholder, validates the replacement, uses the override path in compliance, moves the full balance, marks the original as cancelled, and emits `VerifiedAddressSuperseded`.

4. **Shareholder Management**:  
   - The private `_transferTokens` function updates the `AddressMap` data structure, emitting `ShareholderAdded` when a new holder appears and `ShareholderRemoved` when a holderâ€™s balance goes to zero.

5. **Compliance Contract**:  
   - A `compliance` address must be set by the owner. All transfers and issuances call the appropriate compliance check.

6. **ERC20 Conformance**:  
   - Standard events (`Transfer`, `Approval`) and view methods (`totalSupply`, `balanceOf`, `allowance`) are implemented to satisfy the ERC20 interface.

This delivers the complete, functional `T0ken` contract per the provided spec, using Solidity 0.5.2 and no additional dependencies.