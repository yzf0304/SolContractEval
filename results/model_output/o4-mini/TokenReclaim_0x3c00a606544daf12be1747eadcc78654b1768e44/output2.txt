pragma solidity 0.4.23;

/**
 * @notice This contract allows users to register an account with a public key and an SPHTX name.
 * @dev The contract ensures that each Ethereum address can only register one unique SPHTX name,
 *      and each SPHTX name is unique across the system.
 */
contract TokenReclaim {
    mapping(address => string) internal _ethToSphtx;
    mapping(string => string) internal _accountToPubKey;

    /**
     * @notice Emitted when an account is registered.
     * @param ethAccount The Ethereum address of the user.
     * @param sphtxAccount The SPHTX name of the user.
     * @param pubKey The public key associated with the user's SPHTX name.
     */
    event AccountRegister(
        address indexed ethAccount,
        string sphtxAccount,
        string pubKey
    );

    /**
     * @notice Registers an SPHTX name and associates it with a public key for the caller.
     * @param name The SPHTX name to be registered. Must meet specific formatting requirements.
     * @param pubKey The public key to be associated with the SPHTX name. Must meet length requirements.
     */
    function register(string memory name, string memory pubKey) public {
        bytes memory nameBytes = bytes(name);
        uint nameLen = nameBytes.length;

        // 1. Validate name length
        require(nameLen >= 3 && nameLen <= 16, "Name must be 3-16 characters long");

        // 2. Validate name characters
        //   - First char: a-z or 0-9
        byte char0 = nameBytes[0];
        require(
            (char0 >= 0x30 && char0 <= 0x39) || (char0 >= 0x61 && char0 <= 0x7A),
            "Name must start with a lowercase letter or digit"
        );
        //   - Subsequent chars: a-z, 0-9, '-', or '.'
        for (uint i = 1; i < nameLen; i++) {
            byte c = nameBytes[i];
            bool validLetter = (c >= 0x61 && c <= 0x7A);
            bool validDigit = (c >= 0x30 && c <= 0x39);
            bool validDash  = (c == 0x2D);
            bool validDot   = (c == 0x2E);
            require(
                validLetter || validDigit || validDash || validDot,
                "Name contains invalid character"
            );
        }

        // 3. Validate pubKey length
        uint pkLen = bytes(pubKey).length;
        require(pkLen >= 50 && pkLen <= 64, "Public key must be 50-64 characters long");

        // 4. Ensure caller is not already registered
        //    Compare hashes against empty string to avoid storage optimization issues
        require(
            keccak256(_ethToSphtx[msg.sender]) == keccak256(""),
            "Address already registered"
        );

        // 5. Ensure the name is not already taken
        require(
            keccak256(_accountToPubKey[name]) == keccak256(""),
            "Name already in use"
        );

        // Store mappings
        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;

        // Emit registration event
        emit AccountRegister(msg.sender, name, pubKey);
    }

    /**
     * @notice Returns the SPHTX name associated with the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The SPHTX name associated with the address.
     * @dev If the address has not registered an SPHTX name, returns an empty string.
     */
    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    /**
     * @notice Returns the public key associated with the SPHTX name of the given Ethereum address.
     * @param addr The Ethereum address to query.
     * @return The public key associated with the SPHTX name.
     * @dev If the address has not registered an SPHTX name, returns an empty string.
     */
    function keys(address addr) public view returns (string memory) {
        string memory name = _ethToSphtx[addr];
        return _accountToPubKey[name];
    }

    /**
     * @notice Checks if an SPHTX name is available for registration.
     * @param name The SPHTX name to check availability for.
     * @return True if the name is available, false otherwise.
     * @dev Performs length and format validation, then checks if already registered.
     */
    function nameAvailable(string memory name) public view returns (bool) {
        bytes memory nameBytes = bytes(name);
        uint nameLen = nameBytes.length;

        // Validate length
        if (nameLen < 3 || nameLen > 16) {
            return false;
        }

        // Validate first character
        byte char0 = nameBytes[0];
        if (
            !((char0 >= 0x30 && char0 <= 0x39) ||
              (char0 >= 0x61 && char0 <= 0x7A))
        ) {
            return false;
        }

        // Validate subsequent characters
        for (uint i = 1; i < nameLen; i++) {
            byte c = nameBytes[i];
            bool validLetter = (c >= 0x61 && c <= 0x7A);
            bool validDigit = (c >= 0x30 && c <= 0x39);
            bool validDash  = (c == 0x2D);
            bool validDot   = (c == 0x2E);
            if (!(validLetter || validDigit || validDash || validDot)) {
                return false;
            }
        }

        // Check usage
        if (keccak256(_accountToPubKey[name]) != keccak256("")) {
            return false;
        }

        return true;
    }
}