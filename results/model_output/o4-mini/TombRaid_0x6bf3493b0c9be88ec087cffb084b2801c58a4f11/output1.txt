pragma solidity ^0.8.13;

interface IBoneheadz {
    function ownerOf(uint256 tokenId) external view returns (address);
    function totalSupply() external view returns (uint256);
}

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor() {
        _transferOwnership(_msgSender());
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

/**
 * @title TombRaid
 * @notice A smart contract for managing a raiding game where Boneheadz NFTs can be raided to increase their tier or get locked.
 * @dev The contract allows the owner to control the raid status, price, and other parameters. It also includes functions for raiding, viewing tiers, and locking statuses.
 */
contract TombRaid is Ownable {
    IBoneheadz public Boneheadz;
    uint256 internal cutoff;
    uint256 public immutable SEASON;
    uint256 public immutable MAX_TIER;
    uint256 public raidPrice = 0.005 ether;
    mapping(uint256 => uint256) public tokenTiers;
    mapping(uint256 => bool) public isLocked;
    bool public raidActive = false;

    event Locked(uint256 indexed tokenId);
    event TierUpdated(uint256 indexed tokenId, uint256 tier);

    /**
     * @notice Initializes the contract with the provided parameters.
     * @param boneheadz The address of the Boneheadz NFT contract.
     * @param _cutoff The cutoff value for the pseudo-random number generation.
     * @param maxTier The maximum tier a Boneheadz NFT can reach.
     * @param season The current season of the game.
     */
    constructor(
        address boneheadz,
        uint256 _cutoff,
        uint256 maxTier,
        uint256 season
    ) {
        Boneheadz = IBoneheadz(boneheadz);
        cutoff = _cutoff;
        MAX_TIER = maxTier;
        SEASON = season;
    }

    // MODIFIERS

    /**
     * @notice Modifier to ensure that only the owner of the specified token can call the function.
     * @param tokenId The ID of the token to check ownership for.
     */
    modifier onlyTokenOwner(uint256 tokenId) {
        require(msg.sender == Boneheadz.ownerOf(tokenId), "Caller is not the token owner");
        _;
    }

    // OWNER FUNCTIONS

    /**
     * @notice Toggles the raid status on or off.
     * @dev Only the contract owner can call this function.
     */
    function flipRaidStatus() external onlyOwner {
        raidActive = !raidActive;
    }

    /**
     * @notice Sets the price required to raid a Boneheadz NFT.
     * @param price The new raid price in wei.
     * @dev Only the contract owner can call this function.
     */
    function setRaidPrice(uint256 price) external onlyOwner {
        raidPrice = price;
    }

    /**
     * @notice Sets the cutoff value for the pseudo-random number generation.
     * @param _cutoff The new cutoff value.
     * @dev Only the contract owner can call this function.
     */
    function setCutoff(uint256 _cutoff) external onlyOwner {
        require(_cutoff > 0, "Cutoff must be positive");
        cutoff = _cutoff;
    }

    /**
     * @notice Toggles the lock status for an array of token IDs.
     * @param tokenIds An array of token IDs to toggle the lock status for.
     * @dev Only the contract owner can call this function.
     */
    function flipLockStatuses(uint256[] calldata tokenIds) public onlyOwner {
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 t = tokenIds[i];
            isLocked[t] = !isLocked[t];
            if (isLocked[t]) {
                emit Locked(t);
            }
        }
    }

    /**
     * @notice Transfers the contract's balance to the specified recipient.
     * @param recipient The address to receive the funds.
     * @dev Only the contract owner can call this function.
     */
    function withdraw(address recipient) external onlyOwner {
        require(recipient != address(0), "Invalid recipient");
        payable(recipient).transfer(address(this).balance);
    }

    // RAID FUNCTIONS

    /**
     * @notice Allows the owner of a Boneheadz NFT to raid it, potentially increasing its tier or getting it locked.
     * @param tokenId The ID of the token to raid.
     * @dev The caller must be the owner of the token, and the raid must be active.
     */
    function raid(uint256 tokenId) public payable onlyTokenOwner(tokenId) {
        require(raidActive, "Raid is not active");
        require(msg.value >= raidPrice, "Insufficient raid fee");
        require(!isLocked[tokenId], "Token is locked");

        uint256 rand = _genPseudoRandomNumber(tokenId) % cutoff;
        // If rand == 0, the token gets locked; otherwise it levels up (if not at max)
        if (rand == 0) {
            isLocked[tokenId] = true;
            emit Locked(tokenId);
        } else {
            uint256 current = tokenTiers[tokenId];
            if (current < MAX_TIER) {
                tokenTiers[tokenId] = current + 1;
                emit TierUpdated(tokenId, current + 1);
            }
        }
    }

    // VIEW FUNCTIONS

    /**
     * @notice Returns the number of tokens at each tier.
     * @return counts An array where each index represents the count of tokens at that tier.
     */
    function numPerTier() public view returns (uint256[] memory) {
        uint256 total = Boneheadz.totalSupply();
        uint256 size = MAX_TIER + 1;
        uint256[] memory counts = new uint256[](size);
        for (uint256 id = 1; id <= total; id++) {
            uint256 tier = tokenTiers[id];
            if (tier > MAX_TIER) {
                tier = MAX_TIER;
            }
            counts[tier]++;
        }
        return counts;
    }

    /**
     * @notice Returns the number of locked tokens at each tier.
     * @return counts An array where each index represents the count of locked tokens at that tier.
     */
    function numLockedPerTier() public view returns (uint256[] memory) {
        uint256 total = Boneheadz.totalSupply();
        uint256 size = MAX_TIER + 1;
        uint256[] memory counts = new uint256[](size);
        for (uint256 id = 1; id <= total; id++) {
            if (isLocked[id]) {
                uint256 tier = tokenTiers[id];
                if (tier > MAX_TIER) {
                    tier = MAX_TIER;
                }
                counts[tier]++;
            }
        }
        return counts;
    }

    /**
     * @notice Generates a pseudo-random number based on the block difficulty, timestamp, and token ID.
     * @param tokenId The ID of the token to generate the pseudo-random number for.
     * @return pseudoRandomHash The generated pseudo-random number.
     * @dev This function is private and used internally by the contract.
     */
    function _genPseudoRandomNumber(uint256 tokenId) private view returns (uint256) {
        return uint256(
            keccak256(
                abi.encodePacked(block.difficulty, block.timestamp, tokenId)
            )
        );
    }
}