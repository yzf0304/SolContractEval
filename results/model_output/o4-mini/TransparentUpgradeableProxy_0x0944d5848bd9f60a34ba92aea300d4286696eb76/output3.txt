```solidity
pragma solidity 0.6.12;

contract TransparentUpgradeableProxy is UpgradeableProxy {
    /**
     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and
     * optionally initialized with `_data`.
     */
    constructor(address _logic, address _admin, bytes memory _data) 
        public payable 
        UpgradeableProxy(_logic, _data) 
    {
        // EIP-1967 admin slot validation
        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));
        _setAdmin(_admin);
    }

    /// @dev Emitted when the admin account has changed.
    event AdminChanged(address previousAdmin, address newAdmin);

    // keccak256("eip1967.proxy.admin") - 1
    bytes32 private constant _ADMIN_SLOT =
        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

    /**
     * @dev If called through the proxy by the admin, run the function. Otherwise delegate.
     */
    modifier ifAdmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    /**
     * @notice Returns the current admin.
     * @dev Only callable by the admin.
     */
    function admin() external ifAdmin returns (address adm) {
        adm = _admin();
    }

    /**
     * @notice Returns the current implementation.
     * @dev Only callable by the admin.
     */
    function implementation() external ifAdmin returns (address impl) {
        impl = _implementation();
    }

    /**
     * @notice Changes the admin of the proxy.
     * @dev Only callable by the admin. Emits {AdminChanged}.
     */
    function changeAdmin(address newAdmin) external ifAdmin {
        address previous = _admin();
        _setAdmin(newAdmin);
        emit AdminChanged(previous, newAdmin);
    }

    /**
     * @notice Upgrades the implementation of the proxy.
     * @dev Only callable by the admin.
     */
    function upgradeTo(address newImplementation) external ifAdmin {
        _upgradeTo(newImplementation);
    }

    /**
     * @notice Upgrades the implementation, then delegates a call to the new implementation.
     * @dev Only callable by the admin.
     */
    function upgradeToAndCall(address newImplementation, bytes calldata data)
        external
        payable
        ifAdmin
    {
        _upgradeTo(newImplementation);
        (bool success, ) = newImplementation.delegatecall(data);
        require(success, "TransparentUpgradeableProxy: upgrade call failed");
    }

    /**
     * @dev Reads the admin slot.
     */
    function _admin() internal view returns (address adm) {
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            adm := sload(slot)
        }
    }

    /**
     * @dev Stores a new address in the admin slot.
     */
    function _setAdmin(address newAdmin) private {
        require(
            newAdmin != address(0),
            "TransparentUpgradeableProxy: new admin is the zero address"
        );
        bytes32 slot = _ADMIN_SLOT;
        assembly {
            sstore(slot, newAdmin)
        }
    }

    /**
     * @dev Prevents the admin from falling back to the implementation.
     */
    function _beforeFallback() internal override {
        require(
            msg.sender != _admin(),
            "TransparentUpgradeableProxy: admin cannot fallback to proxy target"
        );
        super._beforeFallback();
    }

    /**
     * @dev Fallback for plain ether transfers.
     */
    receive() external payable {
        _fallback();
    }
}
```