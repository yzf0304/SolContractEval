pragma solidity 0.8.2;

// SPDX-License-Identifier: Unlicense

/**
 * Submitted for verification at Etherscan.io on 2021-03-30
 * ERC20 functions for fallback tokens recovery
 */
abstract contract IERC20 {
    function balanceOf(address _owner)
        external
        virtual
        returns (uint256 balance);

    function transfer(address _to, uint256 _value) external virtual;
    // cannot 'returns (bool success);' because of USDT
    // and other tokens that do not follow ERC20 spec fully.
}

/**
 * @title UniqlyPresale4
 * @notice A smart contract for managing a presale of a token, allowing users to contribute ETH within certain limits and time frames.
 * @dev The contract ensures that the presale is conducted within specified parameters and allows for the withdrawal of funds by users or the owner.
 */
contract UniqlyPresale4 {
    // presale target - close presale when reached
    uint256 public immutable presaleLimit;
    // minimum pay-in per user
    uint256 public immutable minPerUser;
    // maximum pay-in per user
    uint256 public immutable maxPerUser;
    // timestamp ending presale
    uint256 public immutable presaleEnd;
    // failsafe time - fail if not properly closed after presaleEnd
    uint256 constant failSafeTime = 2 weeks;
    // owner address - will receive ETH if success
    address public owner;

    // flags for logic (false is default)
    bool public presaleStarted;
    bool public presaleEnded;
    bool public presaleFailed;

    // list of user balances (zero is default)
    mapping(address => uint256) private balances;

    // two-step ownership transfer
    address public newOwner;

    /**
     * @notice Initializes the presale contract with the given parameters.
     * @param _presaleLimit The maximum amount of ETH to be collected in the presale.
     * @param _minPerUser The minimum amount of ETH a user can contribute.
     * @param _maxPerUser The maximum amount of ETH a user can contribute.
     * @param _presaleEnd The Unix timestamp at which the presale ends.
     * @param _owner The address of the contract owner.
     */
    constructor(
        uint256 _presaleLimit,
        uint256 _minPerUser,
        uint256 _maxPerUser,
        uint256 _presaleEnd,
        address _owner
    ) {
        presaleLimit = _presaleLimit;
        minPerUser = _minPerUser;
        maxPerUser = _maxPerUser;
        presaleEnd = _presaleEnd;
        owner = _owner;
    }

    /**
     * @notice Allows users to contribute ETH to the presale.
     * @dev Users can send ETH to the contract, contributions are recorded. The presale ends if the limit is reached.
     */
    receive() external payable {
        require(presaleStarted, "Presale not started");
        require(!presaleEnded, "Presale ended");
        require(block.timestamp < presaleEnd, "Presale time's up");

        uint256 totalForUser = balances[msg.sender] + msg.value;
        require(totalForUser >= minPerUser, "Below buy-in");
        require(totalForUser <= maxPerUser, "Over buy-in");

        balances[msg.sender] = totalForUser;

        if (collected() >= presaleLimit) {
            presaleEnded = true;
        }
    }

    /**
     * @notice Starts the presale, allowing users to contribute.
     * @dev Only the contract owner can start the presale.
     */
    function start() external {
        require(msg.sender == owner, "Only owner");
        require(!presaleStarted, "Already started");
        presaleStarted = true;
    }

    /**
     * @notice Returns the balance of a specific user.
     * @param user The address of the user.
     * @return The balance of the user in the presale.
     */
    function balanceOf(address user) external view returns (uint256) {
        return balances[user];
    }

    /**
     * @notice Returns the balance of the caller.
     * @return The balance of the caller in the presale.
     */
    function balanceOf() external view returns (uint256) {
        return balances[msg.sender];
    }

    /**
     * @notice Returns the total amount of ETH collected in the presale.
     * @return The total amount of ETH collected.
     */
    function collected() public view returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice Allows withdrawal of funds based on presale status.
     * @dev
     * - If presale hasn't ended and fail-safe time has passed, marks presale as failed.
     * - If called by owner after successful presale, withdraws all contract balance.
     * - If presale failed, allows users to withdraw their contributed funds.
     * - Returns true if withdrawal was successful, false otherwise.
     * @return True if funds were withdrawn, false otherwise.
     */
    function withdraw() external returns (bool) {
        // If presale not ended and not yet failed, check fail-safe
        if (!presaleEnded && !presaleFailed) {
            if (block.timestamp > presaleEnd + failSafeTime) {
                presaleFailed = true;
            } else {
                return false; // presale ongoing
            }
        }

        // Successful presale (ended, not failed) => only owner
        if (presaleEnded && !presaleFailed) {
            if (msg.sender != owner) {
                return false;
            }
            uint256 bal = address(this).balance;
            if (bal == 0) {
                return true;
            }
            return send(owner, bal);
        }

        // Failed presale => contributors withdraw
        if (presaleFailed) {
            uint256 userBal = balances[msg.sender];
            if (userBal == 0) {
                return false;
            }
            balances[msg.sender] = 0;
            return send(msg.sender, userBal);
        }

        return false;
    }

    /**
     * @notice Sends ETH from the contract to a specified address.
     * @param user The address to send ETH to.
     * @param amount The amount of ETH to send.
     * @dev This function is used internally by the `withdraw` function.
     */
    function send(address user, uint256 amount) private returns (bool) {
        // use .send to match behavior requirements
        return payable(user).send(amount);
    }

    /**
     * @notice Allows the owner to withdraw any ERC20 tokens accidentally sent to the contract.
     * @param token The ERC20 token to withdraw.
     * @dev This function ensures that the owner can recover any ERC20 tokens sent to the contract.
     */
    function withdrawAnyERC20(IERC20 token) external {
        require(msg.sender == owner, "Only owner");
        uint256 tbal = token.balanceOf(address(this));
        if (tbal > 0) {
            token.transfer(owner, tbal);
        }
    }

    /**
     * @notice Allows the current owner to delegate ownership to a new address.
     * @param _newOwner The address of the new owner.
     * @dev Only the current owner can delegate ownership.
     */
    function giveOwnership(address _newOwner) external {
        require(msg.sender == owner, "Only owner");
        newOwner = _newOwner;
    }

    /**
     * @notice Allows the new owner to accept the ownership of the contract.
     * @dev The new owner must call this function to finalize the ownership transfer.
     */
    function acceptOwnership() external {
        require(msg.sender == newOwner, "Only new owner");
        owner = newOwner;
        newOwner = address(0);
    }
}