Certainly! Below is the completed `AggregationRouter` contract implementing all the specified functionalities, adhering to Solidity version 0.7.6:

```solidity
// SPDX-License-Identifier: MIT

pragma solidity 0.7.6;

interface IERC20Permit {
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

contract AggregationRouter is Permitable, Ownable {
    using SafeMath for uint256;

    address public immutable WETH;
    address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);

    uint256 private constant _PARTIAL_FILL = 0x01;
    uint256 private constant _REQUIRES_EXTRA_ETH = 0x02;
    uint256 private constant _SHOULD_CLAIM = 0x04;
    uint256 private constant _BURN_FROM_MSG_SENDER = 0x08;
    uint256 private constant _BURN_FROM_TX_ORIGIN = 0x10;

    struct SwapDescription {
        IERC20 srcToken;
        IERC20 dstToken;
        address srcReceiver;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    event Exchange(address pair, uint256 amountOut, address output);

    modifier ensure(uint256 deadline) {
        require(deadline >= block.timestamp, "Router: EXPIRED");
        _;
    }

    constructor(address _WETH) public {
        WETH = _WETH;
    }

    receive() external payable {
        require(msg.sender == WETH, "Only WETH can send ETH to this contract.");
    }

    function swap(
        IAggregationExecutor caller,
        SwapDescription calldata desc,
        bytes calldata data
    ) external payable ensure(block.timestamp) returns (uint256 returnAmount) {
        require(desc.minReturnAmount > 0, "minReturnAmount must be greater than 0");
        require(data.length != 0, "data cannot be empty");

        // Handle ETH <-> WETH conversion and approvals
        uint256 ethValue = desc.flags & _REQUIRES_EXTRA_ETH != 0 ? msg.value : 0;

        if (isETH(desc.srcToken)) {
            require(msg.value == desc.amount, "Insufficient ETH sent");
            IWETH(WETH).deposit{value: desc.amount}(); // Wrap ETH to WETH
        } else {
            // Approve the AggregationExecutor to spend srcToken
            _permit(desc.srcToken, desc.amount, desc.permit);
            require(
                desc.srcToken.transferFrom(msg.sender, address(this), desc.amount),
                "Failed to transfer tokens"
            );
            desc.srcToken.safeApprove(address(caller), desc.amount);
        }

        uint256 initialBalance = getBalance(desc.dstToken, address(this));
        caller.callBytes{value: ethValue}(data);
        returnAmount = getBalance(desc.dstToken, address(this)).sub(initialBalance);

        require(returnAmount >= desc.minReturnAmount, "Insufficient output amount");

        if (isETH(desc.dstToken)) {
            IWETH(WETH).withdraw(returnAmount); // Unwrap WETH to ETH
            (bool sent, ) = desc.dstReceiver.send(returnAmount);
            require(sent, "Failed to send ETH to dstReceiver");
        } else {
            desc.dstToken.safeTransfer(desc.dstReceiver, returnAmount);
        }

        emit Swapped(
            msg.sender,
            desc.srcToken,
            desc.dstToken,
            desc.dstReceiver,
            desc.amount,
            returnAmount
        );

        return returnAmount;
    }

    function getBalance(IERC20 token, address account)
        internal
        view
        returns (uint256)
    {
        return isETH(token) ? account.balance : token.balanceOf(account);
    }

    function isETH(IERC20 token) internal pure returns (bool) {
        return address(token) == ETH_ADDRESS;
    }

    function rescueFunds(address token, uint256 amount) external onlyOwner {
        if (token == ETH_ADDRESS) {
            (bool sent, ) = msg.sender.send(amount);
            require(sent, "Failed to send ETH");
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }
    }
}

interface IWETH {
    function deposit() external payable;
    function withdraw(uint wad) external;
}
```

### Explanation of Key Parts:

- **ETH Handling**: The contract wraps ETH into WETH when the source token is ETH and unwraps it back when the destination token is ETH.
- **Token Approvals**: Uses the `_permit` method to handle permit-based approvals and `transferFrom` for standard token transfers.
- **Safety Checks**: Ensures that the minimum return amount is met and handles edge cases like ETH balance checks.
- **Rescue Function**: Allows the owner to rescue any accidentally transferred funds, including ETH.
- **Event Emission**: Emits `Swapped` events to track successful swaps.

This implementation covers all the requirements specified in your comments, adhering strictly to Solidity 0.7.6 and the provided interfaces and libraries.