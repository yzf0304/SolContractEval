Below is the completed `AtomicSwap` smart contract implementing all the specified functionalities with the provided context:

```solidity
pragma solidity ^0.5.16;

/**
 * @title AtomicSwap
 * @author [Your Name]
 * @notice This contract facilitates atomic swaps between two parties using a hashed secret.
 * @dev Implements non-reentrancy guard and uses SafeMath and SafeERC20 for secure arithmetic and token operations.
 */

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction overflow");
        uint256 c = a - b;
        return c;
    }
}

interface IERC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
}

library SafeERC20 {
    using SafeMath for uint256;

    function safeTransfer(IERC20 token, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint256 value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

library Address {
    function isContract(address account) internal view returns (bool) {
        uint256 size;
        assembly { size := extcodesize(account) }
        return size > 0;
    }
}

contract ReentrancyGuard {
    bool private _notEntered;

    constructor () internal {
        _notEntered = true;
    }

    modifier nonReentrant() {
        require(_notEntered, "ReentrancyGuard: reentrant call");
        _notEntered = false;
        _;
        _notEntered = true;
    }
}

contract AtomicSwap is ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    enum State { Empty, Initiated, Redeemed, Refunded }

    struct Swap {
        bytes32 hashedSecret;
        bytes32 secret;
        address contractAddr;
        address participant;
        address payable initiator;
        uint256 refundTimestamp;
        uint256 countdown;
        uint256 value;
        uint256 payoff;
        bool active;
        State state;
    }

    event Initiated(
        bytes32 indexed _hashedSecret,
        address indexed _contract,
        address indexed _participant,
        address _initiator,
        uint256 _refundTimestamp,
        uint256 _countdown,
        uint256 _value,
        uint256 _payoff,
        bool _active
    );
    event Added(
        bytes32 indexed _hashedSecret,
        address _sender,
        uint256 _value  
    );
    event Activated(
        bytes32 indexed _hashedSecret
    );
    event Redeemed(
        bytes32 indexed _hashedSecret,
        bytes32 _secret
    );
    event Refunded(
        bytes32 indexed _hashedSecret
    );

    mapping(bytes32 => Swap) public swaps;

    modifier onlyByInitiator(bytes32 _hashedSecret) {
        require(msg.sender == swaps[_hashedSecret].initiator, "sender is not the initiator");
        _;
    }

    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint256 _refundTimestamp, uint256 _countdown) {
        require(_participant != address(0), "invalid participant address");
        require(swaps[_hashedSecret].state == State.Empty, "swap for this hash is initiated");
        require(block.timestamp <= _refundTimestamp, "invalid refundTimestamp");
        require(_countdown < _refundTimestamp, "invalid countdown");
        _;
    }

    modifier isInitiated(bytes32 _hashedSecret) {
        require(swaps[_hashedSecret].state == State.Initiated, "swap for this hash is empty or spent");
        _;
    }

    modifier isAddable(bytes32 _hashedSecret) {
        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, "refundTimestamp has come");
        _;
    }

    modifier isActivated(bytes32 _hashedSecret) {
        require(swaps[_hashedSecret].active, "swap is not active");
        _;
    }

    modifier isNotActivated(bytes32 _hashedSecret) {
        require(!swaps[_hashedSecret].active, "swap is active");
        _;
    }

    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {
        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, "refundTimestamp has come");
        require(keccak256(abi.encodePacked(_secret)) == swaps[_hashedSecret].hashedSecret, "secret is not correct");
        _;
    }

    modifier isRefundable(bytes32 _hashedSecret) {
        require(block.timestamp > swaps[_hashedSecret].refundTimestamp, "refundTimestamp has not come");
        _;
    }

    function initiate (
        bytes32 _hashedSecret, 
        address _contract, 
        address _participant, 
        uint256 _refundTimestamp, 
        uint256 _countdown, 
        uint256 _value, 
        uint256 _payoff, 
        bool _active
    ) 
        public 
        nonReentrant 
        isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)
    {
        swaps[_hashedSecret] = Swap({
            hashedSecret: _hashedSecret,
            secret: 0x0000000000000000000000000000000000000000000000000000000000000000,
            contractAddr: _contract,
            participant: _participant,
            initiator: msg.sender,
            refundTimestamp: _refundTimestamp,
            countdown: _countdown,
            value: _value,
            payoff: _payoff,
            active: _active,
            state: State.Initiated
        });
        emit Initiated(
            _hashedSecret,
            _contract,
            _participant,
            msg.sender,
            _refundTimestamp,
            _countdown,
            _value,
            _payoff,
            _active
        );
    }

    function add (bytes32 _hashedSecret, uint256 _value)
        public 
        nonReentrant 
        isInitiated(_hashedSecret) 
        isAddable(_hashedSecret)    
    {
        IERC20(swaps[_hashedSecret].contractAddr).safeTransferFrom(msg.sender, address(this), _value);
        swaps[_hashedSecret].value = swaps[_hashedSecret].value.add(_value);
        emit Added(_hashedSecret, msg.sender, _value);
    }

    function activate (bytes32 _hashedSecret)
        public 
        nonReentrant 
        isInitiated(_hashedSecret) 
        isNotActivated(_hashedSecret) 
        onlyByInitiator(_hashedSecret)
    {
        swaps[_hashedSecret].active = true;
        emit Activated(_hashedSecret);
    }

    function redeem(bytes32 _hashedSecret, bytes32 _secret) 
        public 
        nonReentrant 
        isInitiated(_hashedSecret) 
        isActivated(_hashedSecret) 
        isRedeemable(_hashedSecret, _secret) 
    {
        Swap storage swap = swaps[_hashedSecret];
        swap.secret = _secret;
        swap.state = State.Redeemed;

        if (block.timestamp > swap.refundTimestamp) {
            IERC20(swap.contractAddr).safeTransfer(swap.participant, swap.value);
            IERC20(swap.contractAddr).safeTransfer(swap.initiator, swap.payoff);
        } else {
            IERC20(swap.contractAddr).safeTransfer(swap.participant, swap.value.add(swap.payoff));
        }

        emit Redeemed(_hashedSecret, _secret);
        delete swaps[_hashedSecret];
    }

    function refund(bytes32 _hashedSecret)
        public 
        nonReentrant 
        isInitiated(_hashedSecret) 
        isRefundable(_hashedSecret) 
    {
        Swap storage swap = swaps[_hashedSecret];
        swap.state = State.Refunded;
        IERC20(swap.contractAddr).safeTransfer(swap.initiator, swap.value);
        emit Refunded(_hashedSecret);
        delete swaps[_hashedSecret];
    }
}
```

This contract implements all the specified functions and modifiers, ensuring that atomic swaps are handled securely and efficiently with the given constraints. Each function includes appropriate checks to ensure it operates within the rules defined in the problem statement and leverages the safety libraries (`SafeMath`, `SafeERC20`) for secure operations.