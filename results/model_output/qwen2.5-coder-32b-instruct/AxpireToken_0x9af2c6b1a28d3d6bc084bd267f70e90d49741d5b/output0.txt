Certainly! Below is the complete and functional `AxpireToken` contract, adhering to the ERC20 and ERC223 standards, as described in your context. I've implemented the necessary methods to ensure compatibility with both standards and have used the logic provided in your context where applicable.

```solidity
pragma solidity ^0.4.20;

/**
 *Submitted for verification at Etherscan.io on 2018-02-01
*/
//Owner Contract-For Defining Owner and Transferring Ownership
contract Ownable {
    address public owner;

    function Ownable() public {
        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract TokenRecipient {
    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;
}

//Token Format
contract ERC20 is Ownable {
    using SafeMath for uint256;

    //Public Variables of the token
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    /* This generates a public event on the blockchain that will notify clients */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    //Constructor
    function ERC20(
        uint256 _initialSupply,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[0x2e1977127F682723C778bBcac576A4aF2c0e790d] = _initialSupply;
        totalSupply = _initialSupply;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
        name = _tokenName;
    }

    /* public methods */
    function transfer(address _to, uint256 _value) public returns (bool) {
        bool status = transferInternal(msg.sender, _to, _value);
        require(status == true);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        TokenRecipient spender = TokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 _allowance = allowed[_from][msg.sender];
        require(_value <= _allowance);
        allowed[_from][msg.sender] = _allowance.sub(_value);
        bool _success = transferInternal(_from, _to, _value);
        return _success;
    }

    /*constant functions*/
    function totalSupply() public view returns (uint256) {
        return totalSupply;
    }

    function balanceOf(address _address) public view returns (uint256 balance) {
        return balances[_address];
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /* internal functions*/
    function setBalance(address _holder, uint256 _amount) internal {
        balances[_holder] = _amount;
    }

    function transferInternal(address _from, address _to, uint256 _value) internal returns (bool success) {
        if (_value == 0) {
            Transfer(_from, _to, _value);
            return true;
        }

        require(balances[_from] >= _value);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(_from, _to, _value);
        return true;
    }
}

contract ERC223 {
    event Transfer(address indexed from, address indexed to, uint value, bytes  data);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
}

contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data) public;
}

/**
 * @notice The AxpireToken contract is an implementation of the ERC20 and ERC223 standards, designed to create a token with the specified initial supply, name, symbol, and decimals.
 * @dev This contract extends the functionality of ERC20 and ERC223 by adding additional transfer methods and handling for contract recipients.
 */
contract AxpireToken is ERC223, ERC20 {
    uint256 initialSupply = 350000000 * 10**8;
    string tokenName = "aXpire Token";
    string tokenSymbol = "AXP";
    uint8 decimalUnits = 8;

    //Constructor
    function AxpireToken() public
        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol) {
        owner = 0x2e1977127F682723C778bBcac576A4aF2c0e790d;
        //Assigning total no of tokens
        balances[owner] = initialSupply;
        totalSupply = initialSupply;
    }

    function transfer(address to, uint256 value, bytes data) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data);
    }

    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool success) {
        return transferInternal(msg.sender, to, value, data, true, customFallback);
    }

    function transferInternal(address from, address to, uint256 value, bytes data) internal returns (bool success) {
        if (value == 0) {
            ERC223.Transfer(from, to, value, data);
            return true;
        }

        require(balances[from] >= value);
        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        ERC223.Transfer(from, to, value, data);

        if (isContract(to)) {
            ContractReceiver receiver = ContractReceiver(to);
            receiver.tokenFallback(from, value, data);
        }

        return true;
    }

    function transferInternal(
        address from,
        address to,
        uint256 value,
        bytes data,
        bool useCustomFallback,
        string customFallback
    ) internal returns (bool success) {
        if (value == 0) {
            ERC223.Transfer(from, to, value, data);
            return true;
        }

        require(balances[from] >= value);
        balances[from] = balances[from].sub(value);
        balances[to] = balances[to].add(value);
        ERC223.Transfer(from, to, value, data);

        if (isContract(to)) {
            if (useCustomFallback) {
                // Custom fallback function can be called here if needed
                // However, Solidity 0.4.20 does not support calling a method by name dynamically
                // So, we just call the default tokenFallback unless you have a specific implementation
            }
            ContractReceiver receiver = ContractReceiver(to);
            receiver.tokenFallback(from, value, data);
        }

        return true;
    }

    function isContract(address _addr) private returns (bool) {
        uint length;
        assembly {
            //retrieve the size of the code on target address, this needs assembly
            length := extcodesize(_addr)
        }
        return (length > 0);
    }
}
```

### Key Points:
- **ERC20 and ERC223 Compatibility**: The `AxpireToken` contract implements both ERC20 and ERC223 standards.
- **SafeMath**: Utilizes the `SafeMath` library to prevent overflows and underflows.
- **Transfer Functions**: Includes both standard ERC20 `transfer` and additional `transfer` methods as per ERC223, allowing for data to be sent alongside token transfers.
- **Contract Detection**: Includes a function to detect whether the recipient is a contract and calls the `tokenFallback` function if applicable.
- **Ownership**: The contract inherits from `Ownable` to allow for ownership management.