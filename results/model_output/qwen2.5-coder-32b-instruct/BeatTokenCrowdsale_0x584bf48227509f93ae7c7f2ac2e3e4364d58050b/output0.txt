Below is the complete implementation of the `BeatTokenCrowdsale` contract based on your requirements and the provided context. The contract handles different stages of the ICO, applies bonuses, and ensures that the token supply and sale periods are managed correctly.

```solidity
contract BeatTokenCrowdsale is Ownable {

    enum Stages {
        Deployed,
        PreIco,
        IcoPhase1,
        IcoPhase2,
        IcoPhase3,
        IcoEnded,
        Finalized
    }

    Stages public stage;

    using SafeMath for uint256;

    BeatToken public token;

    uint256 public contractStartTime;
    uint256 public preIcoEndTime;
    uint256 public icoPhase1EndTime;
    uint256 public icoPhase2EndTime;
    uint256 public icoPhase3EndTime;
    uint256 public contractEndTime;

    address public ethTeamWallet;
    address public beatTeamWallet;

    uint256 public ethWeiRaised;

    mapping(address => uint256) public balanceOf;

    uint public constant PRE_ICO_PERIOD = 28 days;
    uint public constant ICO_PHASE1_PERIOD = 28 days;
    uint public constant ICO_PHASE2_PERIOD = 28 days;
    uint public constant ICO_PHASE3_PERIOD = 28 days;

    uint256 public constant PRE_ICO_BONUS_PERCENTAGE = 100;
    uint256 public constant ICO_PHASE1_BONUS_PERCENTAGE = 75;
    uint256 public constant ICO_PHASE2_BONUS_PERCENTAGE = 50;
    uint256 public constant ICO_PHASE3_BONUS_PERCENTAGE = 25;

    uint256 public constant PRE_ICO_AMOUNT = 5000 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE1_AMOUNT = 7000 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE2_AMOUNT = 10500 * (10 ** 6) * (10 ** 18);
    uint256 public constant ICO_PHASE3_AMOUNT = 11875 * (10 ** 6) * (10 ** 18);

    uint256 public constant PRE_ICO_LIMIT = PRE_ICO_AMOUNT;
    uint256 public constant ICO_PHASE1_LIMIT = PRE_ICO_LIMIT + ICO_PHASE1_AMOUNT;
    uint256 public constant ICO_PHASE2_LIMIT = ICO_PHASE1_LIMIT + ICO_PHASE2_AMOUNT;
    uint256 public constant ICO_PHASE3_LIMIT = ICO_PHASE2_LIMIT + ICO_PHASE3_AMOUNT;

    uint256 public constant HARD_CAP = 230 * (10 ** 9) * (10 ** 18);

    uint256 public ethPriceInEuroCent;

    event BeatTokenPurchased(address indexed purchaser, address indexed beneficiary, uint256 ethWeiAmount, uint256 beatWeiAmount);
    event BeatTokenEthPriceChanged(uint256 newPrice);
    event BeatTokenPreIcoStarted();
    event BeatTokenIcoPhase1Started();
    event BeatTokenIcoPhase2Started();
    event BeatTokenIcoPhase3Started();
    event BeatTokenIcoFinalized();

    function BeatTokenCrowdsale(address _ethTeamWallet, address _beatTeamWallet) public {
        require(_ethTeamWallet != address(0));
        require(_beatTeamWallet != address(0));

        token = new BeatToken(HARD_CAP);
        stage = Stages.Deployed;
        ethTeamWallet = _ethTeamWallet;
        beatTeamWallet = _beatTeamWallet;
        ethPriceInEuroCent = 0;
    }

    function setEtherPriceInEuroCent(uint256 _ethPriceInEuroCent) onlyOwner public {
        ethPriceInEuroCent = _ethPriceInEuroCent;
        BeatTokenEthPriceChanged(_ethPriceInEuroCent);
    }

    function start() onlyOwner public {
        require(stage == Stages.Deployed);

        stage = Stages.PreIco;
        contractStartTime = now;
        preIcoEndTime = now.add(PRE_ICO_PERIOD);
        icoPhase1EndTime = preIcoEndTime.add(ICO_PHASE1_PERIOD);
        icoPhase2EndTime = icoPhase1EndTime.add(ICO_PHASE2_PERIOD);
        icoPhase3EndTime = icoPhase2EndTime.add(ICO_PHASE3_PERIOD);
        contractEndTime = icoPhase3EndTime;

        BeatTokenPreIcoStarted();
    }

    function finalize() onlyOwner public {
        require(stage != Stages.Finalized);
        require(now > contractEndTime || token.totalSupply() == HARD_CAP);

        uint256 unsoldTokens = HARD_CAP.sub(token.totalSupply());
        token.transfer(beatTeamWallet, unsoldTokens);
        stage = Stages.Finalized;
        BeatTokenIcoFinalized();
    }

    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address beneficiary) payable public {
        require(beneficiary != address(0));
        require(msg.value > 0);
        require(isWithinValidIcoPhase());

        uint256 ethWeiAmount = msg.value;
        uint256 beatWeiAmount = calculateBeatWeiAmount(ethWeiAmount);

        require(isWithinTokenAllocLimit(beatWeiAmount));

        ethWeiRaised = ethWeiRaised.add(ethWeiAmount);
        balanceOf[beneficiary] = balanceOf[beneficiary].add(beatWeiAmount);

        token.transfer(beneficiary, beatWeiAmount);
        ethTeamWallet.transfer(ethWeiAmount);

        BeatTokenPurchased(msg.sender, beneficiary, ethWeiAmount, beatWeiAmount);
        determineCurrentStage(beatWeiAmount);
    }

    function isWithinValidIcoPhase() internal view returns (bool) {
        return stage == Stages.PreIco || stage == Stages.IcoPhase1 || stage == Stages.IcoPhase2 || stage == Stages.IcoPhase3;
    }

    function calculateBeatWeiAmount(uint256 ethWeiAmount) internal view returns (uint256) {
        uint256 beatWeiAmount = ethWeiAmount.mul(ethPriceInEuroCent).mul(10 ** 18).div(100); // Assuming 1 BEAT = 0.01 Euro

        uint256 bonusPercentage = 0;
        if (stage == Stages.PreIco) {
            bonusPercentage = PRE_ICO_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase1) {
            bonusPercentage = ICO_PHASE1_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase2) {
            bonusPercentage = ICO_PHASE2_BONUS_PERCENTAGE;
        } else if (stage == Stages.IcoPhase3) {
            bonusPercentage = ICO_PHASE3_BONUS_PERCENTAGE;
        }

        uint256 bonusAmount = beatWeiAmount.mul(bonusPercentage).div(100);
        return beatWeiAmount.add(bonusAmount);
    }

    function isWithinTokenAllocLimit(uint256 beatWeiAmount) internal view returns (bool) {
        uint256 newTotalSupply = token.totalSupply().add(beatWeiAmount);
        return newTotalSupply <= HARD_CAP;
    }

    function determineCurrentStage(uint256 beatWeiAmount) internal {
        uint256 newTotalSupply = token.totalSupply().add(beatWeiAmount);

        if (stage == Stages.PreIco && (newTotalSupply > PRE_ICO_LIMIT || now >= preIcoEndTime)) {
            stage = Stages.IcoPhase1;
            BeatTokenIcoPhase1Started();
        } else if (stage == Stages.IcoPhase1 && (newTotalSupply > ICO_PHASE1_LIMIT || now >= icoPhase1EndTime)) {
            stage = Stages.IcoPhase2;
            BeatTokenIcoPhase2Started();
        } else if (stage == Stages.IcoPhase2 && (newTotalSupply > ICO_PHASE2_LIMIT || now >= icoPhase2EndTime)) {
            stage = Stages.IcoPhase3;
            BeatTokenIcoPhase3Started();
        } else if (stage == Stages.IcoPhase3 && (newTotalSupply > ICO_PHASE3_LIMIT || now >= icoPhase3EndTime)) {
            stage = Stages.IcoEnded;
        }
    }
}
```

### Key Points:
- **Phases Management**: The contract transitions through different phases based on the elapsed time and the amount of tokens sold.
- **Bonus Calculation**: Bonuses are applied based on the current phase.
- **Token Distribution**: Tokens are minted and transferred to the purchasers' addresses.
- **Finalization**: After the ICO ends, unsold tokens are transferred to the BEAT team wallet.
- **Events**: Various events are emitted for tracking the progress and key actions of the ICO.