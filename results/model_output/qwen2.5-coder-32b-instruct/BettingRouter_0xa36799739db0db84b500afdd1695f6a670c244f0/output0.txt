Below is the implementation of the `LeveragePool` contract based on the provided description and context. This contract includes all required functionalities, from depositing and withdrawing tokens, locking and unlocking collateral, and calculating the equivalent ETH value of a user's balance.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./SafeMath.sol";
import "./Ownable.sol";

interface IBettingPair {
    enum LPTOKENTYPE { ETH, USDT, USDC, SHIB, DOGE }
}

contract LeveragePool is Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) _ethPool;   // deposited ETH amounts per accounts
    mapping(address => uint256) _usdtPool;  // deposited USDT amounts per accounts
    mapping(address => uint256) _usdcPool;  // deposited USDC amounts per accounts
    mapping(address => uint256) _shibPool;  // deposited SHIB amounts per accounts
    mapping(address => uint256) _dogePool;  // deposited DOGE amounts per accounts

    mapping(address => uint256) _lockedEth;
    mapping(address => uint256) _lockedUsdt;
    mapping(address => uint256) _lockedUsdc;
    mapping(address => uint256) _lockedShib;
    mapping(address => uint256) _lockedDoge;

    IUniswapV2Pair _usdtEth = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);   // Uniswap USDT/ETH pair
    IUniswapV2Pair _usdcEth = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);   // Uniswap USDC/ETH pair
    IUniswapV2Pair _shibEth = IUniswapV2Pair(0x811beEd0119b4AfCE20D2583EB608C6F7AF1954f);   // Uniswap SHIB/ETH pair
    IUniswapV2Pair _dogeEth = IUniswapV2Pair(0xc0067d751FB1172DBAb1FA003eFe214EE8f419b6);   // Uniswap DOGE/ETH pair

    constructor() {}

    function getUserLPBalance(address account) external view returns (uint256, uint256, uint256, uint256, uint256) {
        return (_ethPool[account], _usdtPool[account], _usdcPool[account], _shibPool[account], _dogePool[account]);
    }

    function getUsdtPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = _usdtEth.getReserves();
        return reserve0.mul(1e18).div(reserve1);
    }

    function getUsdcPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = _usdcEth.getReserves();
        return reserve0.mul(1e18).div(reserve1);
    }

    function getShibPrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = _shibEth.getReserves();
        return reserve0.mul(1e18).div(reserve1);
    }

    function getDogePrice() internal view returns (uint256) {
        (uint112 reserve0, uint112 reserve1,) = _dogeEth.getReserves();
        return reserve0.mul(1e18).div(reserve1).div(1e10);
    }

    function depositEth(address player, uint256 amount) external payable onlyOwner {
        require(msg.value == amount, "Incorrect ETH amount sent.");
        _ethPool[player] = _ethPool[player].add(amount);
    }

    function depositErc20(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == IBettingPair.LPTOKENTYPE.USDT) {
            _usdtPool[player] = _usdtPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            _usdcPool[player] = _usdcPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            _shibPool[player] = _shibPool[player].add(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            _dogePool[player] = _dogePool[player].add(amount);
        }
    }

    function withdraw(address player, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == IBettingPair.LPTOKENTYPE.ETH) {
            require(_ethPool[player] >= amount, "Insufficient ETH balance.");
            _ethPool[player] = _ethPool[player].sub(amount);
            payable(player).transfer(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {
            require(_usdtPool[player] >= amount, "Insufficient USDT balance.");
            _usdtPool[player] = _usdtPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            require(_usdcPool[player] >= amount, "Insufficient USDC balance.");
            _usdcPool[player] = _usdcPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            require(_shibPool[player] >= amount, "Insufficient SHIB balance.");
            _shibPool[player] = _shibPool[player].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            require(_dogePool[player] >= amount, "Insufficient DOGE balance.");
            _dogePool[player] = _dogePool[player].sub(amount);
        }
    }

    function lock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        require(_ethPool[player] >= ethAmount, "Insufficient ETH balance.");
        require(_usdtPool[player] >= usdtAmount, "Insufficient USDT balance.");
        require(_usdcPool[player] >= usdcAmount, "Insufficient USDC balance.");
        require(_shibPool[player] >= shibAmount, "Insufficient SHIB balance.");
        require(_dogePool[player] >= dogeAmount, "Insufficient DOGE balance.");

        _ethPool[player] = _ethPool[player].sub(ethAmount);
        _usdtPool[player] = _usdtPool[player].sub(usdtAmount);
        _usdcPool[player] = _usdcPool[player].sub(usdcAmount);
        _shibPool[player] = _shibPool[player].sub(shibAmount);
        _dogePool[player] = _dogePool[player].sub(dogeAmount);

        _lockedEth[player] = _lockedEth[player].add(ethAmount);
        _lockedUsdt[player] = _lockedUsdt[player].add(usdtAmount);
        _lockedUsdc[player] = _lockedUsdc[player].add(usdcAmount);
        _lockedShib[player] = _lockedShib[player].add(shibAmount);
        _lockedDoge[player] = _lockedDoge[player].add(dogeAmount);
    }

    function unlock(address player, uint256 ethAmount, uint256 usdtAmount, uint256 usdcAmount, uint256 shibAmount, uint256 dogeAmount) external onlyOwner {
        require(_lockedEth[player] >= ethAmount, "Insufficient locked ETH.");
        require(_lockedUsdt[player] >= usdtAmount, "Insufficient locked USDT.");
        require(_lockedUsdc[player] >= usdcAmount, "Insufficient locked USDC.");
        require(_lockedShib[player] >= shibAmount, "Insufficient locked SHIB.");
        require(_lockedDoge[player] >= dogeAmount, "Insufficient locked DOGE.");

        _lockedEth[player] = _lockedEth[player].sub(ethAmount);
        _lockedUsdt[player] = _lockedUsdt[player].sub(usdtAmount);
        _lockedUsdc[player] = _lockedUsdc[player].sub(usdcAmount);
        _lockedShib[player] = _lockedShib[player].sub(shibAmount);
        _lockedDoge[player] = _lockedDoge[player].sub(dogeAmount);

        _ethPool[player] = _ethPool[player].add(ethAmount);
        _usdtPool[player] = _usdtPool[player].add(usdtAmount);
        _usdcPool[player] = _usdcPool[player].add(usdcAmount);
        _shibPool[player] = _shibPool[player].add(shibAmount);
        _dogePool[player] = _dogePool[player].add(dogeAmount);
    }

    function withdrawFromContract(address owner, IBettingPair.LPTOKENTYPE token, uint256 amount) external onlyOwner {
        if (token == IBettingPair.LPTOKENTYPE.ETH) {
            require(_ethPool[owner] >= amount, "Insufficient ETH balance.");
            _ethPool[owner] = _ethPool[owner].sub(amount);
            payable(owner).transfer(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDT) {
            require(_usdtPool[owner] >= amount, "Insufficient USDT balance.");
            _usdtPool[owner] = _usdtPool[owner].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.USDC) {
            require(_usdcPool[owner] >= amount, "Insufficient USDC balance.");
            _usdcPool[owner] = _usdcPool[owner].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.SHIB) {
            require(_shibPool[owner] >= amount, "Insufficient SHIB balance.");
            _shibPool[owner] = _shibPool[owner].sub(amount);
        } else if (token == IBettingPair.LPTOKENTYPE.DOGE) {
            require(_dogePool[owner] >= amount, "Insufficient DOGE balance.");
            _dogePool[owner] = _dogePool[owner].sub(amount);
        }
    }

    function getPlayerLPBalanceInEth(address player) external view returns (uint256) {
        uint256 ethBalance = _ethPool[player];
        ethBalance = ethBalance.add(_usdtPool[player].mul(1e18).div(getUsdtPrice()));
        ethBalance = ethBalance.add(_usdcPool[player].mul(1e18).div(getUsdcPrice()));
        ethBalance = ethBalance.add(_shibPool[player].mul(1e18).div(getShibPrice()));
        ethBalance = ethBalance.add(_dogePool[player].mul(1e18).div(getDogePrice().mul(1e10)));
        return ethBalance;
    }

    function calcLockTokenAmountsAsCollateral(address player, uint256 etherAmount) external view returns (uint256, uint256, uint256, uint256, uint256) {
        uint256 ethNeeded = etherAmount;
        uint256 usdtNeeded = 0;
        uint256 usdcNeeded = 0;
        uint256 shibNeeded = 0;
        uint256 dogeNeeded = 0;

        // Calculate ETH needed
        ethNeeded = ethNeeded.sub(_ethPool[player].min(ethNeeded));
        
        // Calculate USDT needed
        if (ethNeeded > 0) {
            usdtNeeded = ethNeeded.mul(getUsdtPrice()).div(1e18);
            usdtNeeded = usdtNeeded.min(_usdtPool[player]);
            ethNeeded = ethNeeded.sub(usdtNeeded.mul(1e18).div(getUsdtPrice()));
        }
        
        // Calculate USDC needed
        if (ethNeeded > 0) {
            usdcNeeded = ethNeeded.mul(getUsdcPrice()).div(1e18);
            usdcNeeded = usdcNeeded.min(_usdcPool[player]);
            ethNeeded = ethNeeded.sub(usdcNeeded.mul(1e18).div(getUsdcPrice()));
        }
        
        // Calculate SHIB needed
        if (ethNeeded > 0) {
            shibNeeded = ethNeeded.mul(getShibPrice()).div(1e18);
            shibNeeded = shibNeeded.min(_shibPool[player]);
            ethNeeded = ethNeeded.sub(shibNeeded.mul(1e18).div(getShibPrice()));
        }
        
        // Calculate DOGE needed
        if (ethNeeded > 0) {
            dogeNeeded = ethNeeded.mul(getDogePrice().mul(1e10)).div(1e18);
            dogeNeeded = dogeNeeded.min(_dogePool[player]);
            ethNeeded = ethNeeded.sub(dogeNeeded.mul(1e18).div(getDogePrice().mul(1e10)));
        }

        require(ethNeeded == 0, "Insufficient collateral.");

        return (_ethPool[player].min(etherAmount), usdtNeeded, usdcNeeded, shibNeeded, dogeNeeded);
    }

    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }
}
```

### Key Points:
1. **Deposit Functions**: Includes ETH and ERC20 token deposits. For ETH, the function ensures that the sent amount matches the specified amount.
2. **Withdraw Function**: Supports withdrawing both ETH and ERC20 tokens. For ETH, it sends the funds directly to the user.
3. **Lock/Unlock Functions**: Allow locking and unlocking tokens as collateral. Adjusts the user's token balances accordingly.
4. **Price Calculation**: Uses the reserves of Uniswap pairs to determine the price of each token in ETH.
5. **Balance Calculation**: Converts all user balances to their ETH equivalent for a total balance calculation.
6. **Collateral Calculation**: Determines how much of each token a user needs to lock up to meet a certain collateral requirement in ETH.

This contract assumes that you have implemented the `IBettingPair` interface and that the Uniswap pair addresses are correct. Adjust the interface and addresses as necessary for your deployment environment.