Below is the completed `CZRLocker` contract based on your requirements. The contract includes the implementation for adding, removing, and unlocking CZR token locks as well as withdrawing ETH. 

```solidity
/**
 * @notice A smart contract to manage and control the locking and unlocking of CZR tokens.
 * @dev This contract allows the owner to add, remove, and unlock CZR token locks. It also includes functionality to withdraw ETH.
 */
contract CZRLocker is owned {

    /**
     * @notice Emitted when a new lock is added.
     * @param addr The address for which the lock is added.
     * @param index The index of the lock.
     * @param startLockTime The time when the lock starts.
     * @param lockMonth The duration of the lock in months.
     * @param lockedAmount The amount of CZR tokens that are locked.
     */
    event AddLock(address addr, uint index, uint startLockTime, uint lockMonth, uint lockedAmount);

    /**
     * @notice Emitted when a lock is removed.
     * @param addr The address for which the lock is removed.
     * @param index The index of the lock.
     */
    event RemoveLock(address addr, uint index);

    /**
     * @notice Emitted when a lock is unlocked.
     * @param addr The address for which the lock is unlocked.
     * @param index The index of the lock.
     * @param unlockAmount The amount of CZR tokens that are unlocked.
     */
    event Unlock(address addr, uint index, uint unlockAmount);

    /**
     * @notice The address of the CZR token.
     */
    address public tokenAddr;

    /**
     * @notice The address of the unlocker.
     */
    address public unlocker;

    /**
     * @dev Structure to store the details of a locked CZR.
     */
    struct LockedCZR {
        uint startLockTime;
        uint lockMonth;
        uint lockedAmount;
        uint unlockedAmount;
    }

    /**
     * @dev Mapping from an address to an array of its locked CZR details.
     */
    mapping(address => LockedCZR[]) public lockedCZRMap;

    /**
     * @notice Constructor to initialize the contract with the token address and unlocker address.
     * @param _tokenAddr The address of the CZR token.
     * @param _unlocker The address of the unlocker.
     */
    function CZRLocker(address _tokenAddr, address _unlocker) public {
        tokenAddr = _tokenAddr;
        unlocker = _unlocker;
    }

    /**
     * @notice Removes a CZR lock by setting all fields to zero.
     * @param addr The address for which the lock is to be removed.
     * @param index The index of the lock to be removed.
     */
    function removeCZRLock(address addr, uint index) onlyOwner public {
        if (index >= lockedCZRMap[addr].length) return;
        lockedCZRMap[addr][index] = LockedCZR(0, 0, 0, 0);
        emit RemoveLock(addr, index);
    }

    /**
     * @notice Adds a new CZR lock.
     * @param addr The address for which the lock is to be added.
     * @param startLockTime The time when the lock starts (0 for now).
     * @param amount The amount of CZR tokens to be locked.
     * @param lockMonth The duration of the lock in months.
     */
    function addCZRLock(address addr, uint startLockTime, uint amount, uint lockMonth) onlyOwner public {
        if (startLockTime == 0) {
            startLockTime = now;
        }
        lockedCZRMap[addr].push(LockedCZR(startLockTime, lockMonth, amount, 0));
        emit AddLock(addr, lockedCZRMap[addr].length - 1, startLockTime, lockMonth, amount);
    }

    /**
     * @dev Unlocks CZR tokens for a user based on lock duration.
     * @param addr Address of the user whose tokens are being unlocked
     * @param limit Maximum number of locks to process (0 for unlimited)
     * @dev Requirements:
     *   - Only callable by contract owner or unlocker
     *   - User must have existing locked CZR records
     * @dev Behavior:
     *   - Calculates unlockable amount for each lock based on time passed
     *   - Processes up to 'limit' locks if specified
     *   - Transfers unlocked tokens to user's address
     *   - Emits Unlock event for each processed lock
     * @dev Notes:
     *   - Locks are processed in order (oldest first)
     *   - Monthly unlocking schedule is enforced
     *   - Requires sufficient token balance in contract
     * @dev Returns:
     *   - Number of locks processed (implicit via require check)
     */
    function unlockCZR(address addr, uint limit) public {
        require(msg.sender == owner || msg.sender == unlocker);
        LockedCZR[] storage locks = lockedCZRMap[addr];
        uint locksProcessed = 0;
        for (uint i = 0; i < locks.length; i++) {
            if (limit > 0 && locksProcessed >= limit) break;
            LockedCZR storage lock = locks[i];
            if (lock.lockedAmount == 0) continue;
            uint unlockableMonths = (now - lock.startLockTime) / 30 days;
            uint unlockableAmount = lock.lockedAmount * unlockableMonths / lock.lockMonth;
            if (unlockableAmount > lock.lockedAmount - lock.unlockedAmount) {
                unlockableAmount = lock.lockedAmount - lock.unlockedAmount;
            }
            if (unlockableAmount > 0) {
                lock.unlockedAmount += unlockableAmount;
                require(token(tokenAddr).transferFrom(this, addr, unlockableAmount));
                emit Unlock(addr, i, unlockableAmount);
                locksProcessed++;
            }
        }
    }

    /**
     * @notice Withdraws ETH to a specified address.
     * @param to The address to receive the ETH.
     * @param value The amount of ETH to be transferred.
     */
    function withdrawEth(address to, uint256 value) onlyOwner public {
        require(to != address(0));
        require(address(this).balance >= value);
        to.transfer(value);
    }

    /**
     * @notice Fallback function to receive ETH.
     */
    function() payable public {
    }
}
```

This contract uses a simple monthly unlocking schedule where tokens are released gradually over the lock period. The `unlockCZR` function checks how many months have passed since the lock was created to determine how many tokens can be unlocked. The contract also ensures that only the owner or the designated unlocker can initiate the unlocking process.