Here's the completed proxy contract based on the given context and description:

```solidity
pragma solidity 0.6.12;

interface marketManagerInterface {}
interface interestModelInterface {}
interface marketHandlerDataStorageInterface {}
interface marketSIHandlerDataStorageInterface {}

contract proxy  {
    address payable public owner;

    uint256 public handlerID;

    string public tokenName = "ether";

    uint256 constant unifiedPoint = 10 ** 18;

    marketManagerInterface public marketManager;

    interestModelInterface public interestModelInstance;

    marketHandlerDataStorageInterface public handlerDataStorage;

    marketSIHandlerDataStorageInterface public SIHandlerDataStorage;

    address public handler;

    address public SI;

    string private constant DEPOSIT = "deposit(uint256,bool)";
    string private constant REDEEM = "withdraw(uint256,bool)";
    string private constant BORROW = "borrow(uint256,bool)";
    string private constant REPAY = "repay(uint256,bool)";

    modifier onlyOwner {
        require(msg.sender == owner, "Ownable: caller is not the owner");
        _;
    }

    modifier onlyMarketManager {
        address msgSender = msg.sender;
        require((msgSender == address(marketManager)) || (msgSender == owner), "onlyMarketManager function");
        _;
    }

    constructor () public {
        owner = msg.sender;
    }

    function ownershipTransfer(address _owner) onlyOwner external returns (bool) {
        require(_owner != address(0), "Invalid owner address");
        owner = _owner;
        return true;
    }

    function initialize(uint256 _handlerID, address handlerAddr, address marketManagerAddr, address interestModelAddr, address marketDataStorageAddr, address siHandlerAddr, address SIHandlerDataStorageAddr) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        handler = handlerAddr;
        SI = siHandlerAddr;
        marketManager = marketManagerInterface(marketManagerAddr);
        interestModelInstance = interestModelInterface(interestModelAddr);
        handlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);
        SIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);
        return true;
    }

    function setHandlerID(uint256 _handlerID) onlyOwner public returns (bool) {
        handlerID = _handlerID;
        return true;
    }

    function setHandlerAddr(address handlerAddr) onlyOwner public returns (bool) {
        require(handlerAddr != address(0), "Invalid handler address");
        handler = handlerAddr;
        return true;
    }

    function setSiHandlerAddr(address siHandlerAddr) onlyOwner public returns (bool) {
        require(siHandlerAddr != address(0), "Invalid SI handler address");
        SI = siHandlerAddr;
        return true;
    }

    function getHandlerID() public view returns (uint256) {
        return handlerID;
    }

    function getHandlerAddr() public view returns (address) {
        return handler;
    }

    function getSiHandlerAddr() public view returns (address) {
        return SI;
    }

    function migration(address payable target) onlyOwner public returns (bool) {
        require(target != address(0), "Invalid target address");
        target.transfer(address(this).balance);
        return true;
    }

    fallback () external payable {
        require(msg.value > 0, "Amount must be greater than 0");
    }

    function deposit(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        require(msg.value == unifiedTokenAmount, "Invalid amount sent");
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(DEPOSIT, unifiedTokenAmount, flag));
        require(success, "Deposit failed");
        return true;
    }

    function withdraw(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(REDEEM, unifiedTokenAmount, flag));
        require(success, "Withdraw failed");
        return true;
    }

    function borrow(uint256 unifiedTokenAmount, bool flag) public returns (bool) {
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(BORROW, unifiedTokenAmount, flag));
        require(success, "Borrow failed");
        return true;
    }

    function repay(uint256 unifiedTokenAmount, bool flag) public payable returns (bool) {
        require(msg.value == unifiedTokenAmount, "Invalid amount sent");
        (bool success, ) = handler.delegatecall(abi.encodeWithSignature(REPAY, unifiedTokenAmount, flag));
        require(success, "Repay failed");
        return true;
    }

    function handlerProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory result) = handler.delegatecall(data);
        require(success, "Handler call failed");
        return (success, result);
    }

    function handlerViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory result) = handler.staticcall(data);
        require(success, "Handler static call failed");
        return (success, result);
    }

    function siProxy(bytes memory data) onlyMarketManager external returns (bool, bytes memory) {
        (bool success, bytes memory result) = SI.delegatecall(data);
        require(success, "SI Handler call failed");
        return (success, result);
    }

    function siViewProxy(bytes memory data) external returns (bool, bytes memory) {
        (bool success, bytes memory result) = SI.staticcall(data);
        require(success, "SI Handler static call failed");
        return (success, result);
    }
}
```

This contract includes all the required functionalities and follows the structure you described, with the appropriate access control mechanisms and `delegatecall`/`staticcall` usage for interacting with other contracts.