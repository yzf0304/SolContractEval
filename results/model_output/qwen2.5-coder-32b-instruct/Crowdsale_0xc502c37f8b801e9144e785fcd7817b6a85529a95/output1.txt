Here's the completed `Crowdsale` contract according to the provided context, ensuring compatibility with Solidity version 0.4.18:

```solidity
pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a / b;
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}

contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract DragonToken {
    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);
}

/**
 * @title Crowdsale
 * @author [Your Name]
 * @notice This contract is designed to facilitate a token crowdsale, allowing users to purchase tokens with Ether.
 * The sale has a defined start and end time, and the rate of token to Ether can be adjusted by the owner.
 * Tokens are locked for a period after purchase before they can be released.
 * @dev Inherits from Ownable, which provides basic authorization control functions.
 */
contract Crowdsale is Ownable {
    using SafeMath for uint256;

    DragonToken public token;
    address public tokenReserve;
    uint256 public startTime;
    uint256 public endTime;
    address public wallet;
    uint256 public rate;
    uint256 public weiRaised;
    uint256 public tokensSold;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 releaseTime);
    event EndTimeUpdated();
    event DragonPriceUpdated();
    event TokenReleased(address indexed holder, uint256 amount);

    function Crowdsale() public {
        owner = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
        startTime = now;
        endTime = 1521187200;
        rate = 5000000000000000; // price in wei
        wallet = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
        token = DragonToken(0x814F67fA286f7572B041D041b1D99b432c9155Ee);
        tokenReserve = 0xF615Ac471E066b5ae4BD211CC5044c7a31E89C4e;
    }

    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());

        uint256 weiAmount = msg.value;
        weiRaised = weiRaised.add(weiAmount);

        uint256 tokens = getTokenAmount(weiAmount);
        tokensSold = tokensSold.add(tokens);
        
        assignTokens(beneficiary, tokens);
        forwardFunds();
    }

    function hasEnded() public view returns (bool) {
        return now > endTime;
    }

    function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
        return weiAmount.mul(rate);
    }

    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    function validPurchase() internal view returns (bool) {
        bool withinPeriod = now >= startTime && now <= endTime;
        bool nonZeroPurchase = msg.value != 0;
        return withinPeriod && nonZeroPurchase;
    }

    function updateEndTime(uint256 newTime) onlyOwner external {
        require(newTime > now);
        endTime = newTime;
        EndTimeUpdated();
    }

    function updateDragonPrice(uint256 weiAmount) onlyOwner external {
        require(weiAmount > 0);
        rate = weiAmount;
        DragonPriceUpdated();
    }

    mapping(address => uint256) balances;
    mapping(address => uint256) releaseTime;

    function assignTokens(address beneficiary, uint256 amount) private returns(uint256 lockedFor) {
        balances[beneficiary] = balances[beneficiary].add(amount);
        releaseTime[beneficiary] = now + 1 days; // Lock tokens for 1 day for example purposes
        lockedFor = releaseTime[beneficiary];
        TokenPurchase(msg.sender, beneficiary, msg.value, amount, lockedFor);
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function unlockTime(address _owner) public view returns (uint256 time) {
        return releaseTime[_owner];
    }

    function releaseDragonTokens() public {
        uint256 _now = now;
        require(_now > releaseTime[msg.sender]);
        uint256 amount = balances[msg.sender];
        require(amount > 0);
        balances[msg.sender] = 0;
        token.transferFrom(tokenReserve, msg.sender, amount);
        TokenReleased(msg.sender, amount);
    }
}
```

### Key Points:
- **SafeMath Library**: Used for safe arithmetic operations.
- **Ownable Contract**: Manages contract ownership and includes an `onlyOwner` modifier.
- **Crowdsale Logic**:
  - Tokens can be bought via `buyTokens`.
  - Funds are transferred to the `wallet`.
  - The number of tokens bought is calculated using a `rate`.
  - Tokens are locked for a period before they can be released.
- **Events**: Emit events for key actions like token purchase, end time update, price update, and token release.
- **Mappings**: Store balances and release times for each participant.