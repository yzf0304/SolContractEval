Below is the complete and functional implementation of the `Cyber` contract based on the provided context, description, and modifiers:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;

import "./ERC721Omni.sol";

contract Cyber is ERC721Omni {
    using Address for address;
    using Strings for uint256;

    string private _baseURI = "ipfs://QmS84uLAUvGLverNnvyU8YhsHKJi6E3WnfvuD7qmRmBos2/";
    uint256 private constant maximumSupply = 6600;
    uint256 public publicMintedCap = 1980;

    uint256 public totalSupply;
    uint256 public publicMinted;
    uint256 public gasForLzReceive = 350000;
    bool public depreciatedMint;
    bool public publicStatus;
    bool public huntlistStatus;
    bytes32 public merkleRoot = 0xd6fbbe52742f9b344f0cec438e6e560e182c4aec6a42bbf8e944f227632ba0b3;

    constructor(address _lzEndpoint) ERC721Omni("Cyber", "Hunters") { 
        endpoint = ILayerZeroEndpoint(_lzEndpoint); 
    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Contract Caller");
        _;
    }

    function donate() external payable {}

    function traverseChains(uint16 _chainId, uint tokenId) public payable {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        require(trustedRemoteLookup[_chainId].length != 0, "Invalid destination chain");

        _burn(tokenId);
        totalSupply--;

        bytes memory payload = abi.encode(msg.sender, tokenId);
        (uint nativeFee, ) = endpoint.estimateFees(_chainId, address(this), payload, false, "");

        require(msg.value >= nativeFee, "Insufficient payment for LayerZero fees");
        endpoint.send{value: nativeFee}(
            _chainId,
            trustedRemoteLookup[_chainId],
            payload,
            payable(msg.sender),
            address(0),
            bytes("")
        );

        if (msg.value > nativeFee) {
            payable(msg.sender).transfer(msg.value - nativeFee);
        }
    }

    function _LzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) override internal {
        (address to, uint tokenId) = abi.decode(_payload, (address, uint));
        _mint(to, tokenId);
        totalSupply++;
    }

    function publicMint() external callerIsUser {
        require(publicStatus, "Public mint is not active");
        require(publicMinted < publicMintedCap, "Public mint cap reached");
        require(totalSupply < maximumSupply, "Maximum supply reached");

        _safeMint(msg.sender, totalSupply + 1);
        publicMinted++;
        totalSupply++;
    }

    function huntlistMint(bytes32[] calldata _proof) external callerIsUser {
        require(huntlistStatus, "Huntlist mint is not active");
        require(totalSupply < maximumSupply, "Maximum supply reached");
        require(verifyProof(_proof, merkleRoot, keccak256(abi.encodePacked(msg.sender))), "Invalid proof");

        _safeMint(msg.sender, totalSupply + 1);
        if (totalSupply + 2 <= maximumSupply) {
            _safeMint(msg.sender, totalSupply + 2);
            totalSupply += 2;
        } else {
            totalSupply++;
        }
    }

    function verifyProof(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
            } else {
                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
            }
        }
        return computedHash == root;
    }

    function burnHunter(uint256 tokenId) external {
        require(ownerOf(tokenId) == msg.sender, "Not the owner");
        _burn(tokenId);
        totalSupply--;
    }

    function setPublicState(bool _state) external onlyOwner {
        publicStatus = _state;
    }

    function setHuntlistState(bool _state) external onlyOwner {
        huntlistStatus = _state;
    }

    function setPublicMintSupply(uint256 _supply) external onlyOwner {
        require(_supply <= maximumSupply, "Exceeds maximum supply");
        publicMintedCap = _supply;
    }

    function setRoot(bytes32 _newROOT) external onlyOwner {
        merkleRoot = _newROOT;
    }

    function depreciateMint() external onlyOwner {
        require(!depreciatedMint, "Mint already deprecated");
        for (uint256 i = totalSupply + 1; i <= maximumSupply; i++) {
            _mint(owner, i);
        }
        depreciatedMint = true;
    }

    function setBaseURI(string memory _newURI) external onlyOwner {
        _baseURI = _newURI;
    }

    function setGasForDestinationLzReceive(uint _newGasValue) external onlyOwner {
        gasForLzReceive = _newGasValue;
    }

    function setLzEndpoint(address _lzEndpoint) external onlyOwner {
        endpoint = ILayerZeroEndpoint(_lzEndpoint);
    }

    function baseURI() override public view returns (string memory) {
        return _baseURI;
    }

    function withdrawDonations() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}
```

This contract implements all the functionalities as specified, including minting, burning, traversing across chains, and handling Merkle proofs for the huntlist. It also includes functions to manage various states and settings as well as to withdraw donations.