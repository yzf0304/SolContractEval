Below is the complete implementation of the `DaiProxy` contract based on the provided context and requirements. The contract includes all the necessary functions and modifiers, as well as event definitions and constructor logic. I've filled in the missing implementations for the mathematical operations and other critical functions.

```solidity
pragma solidity ^0.5.12;

contract ReserveLike {
    function depositToken(address, string memory, bytes memory, uint) public;
}

contract WrappedDaiLike {
    function setProxy(address) public;
    function setReserve(address) public;

    uint public totalSupply;
    function approve(address, uint) public returns (bool);

    function mint(address, uint) public;
    function burn(address, uint) public;
}

contract DaiLike {
    function approve(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}

contract JoinLike {
    VatLike public vat;
    DaiLike public dai;

    function join(address, uint) public;
    function exit(address, uint) public;
}

contract PotLike {
    mapping(address => uint) public pie;
    uint public chi;

    VatLike public vat;
    uint public rho;

    function drip() public returns (uint);

    function join(uint) public;
    function exit(uint) public;
}

contract VatLike {
    mapping(address => uint) public dai;

    function hope(address) public;
    function move(address, address, uint) public;
}

/**
 * @title DaiProxy
 * @notice A proxy contract for managing DAI and its wrapped versions, including deposit, withdrawal, and migration functionalities.
 * @dev This contract handles the lifecycle of DAI and its wrapped versions (eDai and oDai) with various state transitions and mathematical operations.
 */
contract DaiProxy {
    string public constant version = "0511";

    // --- Owner ---
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event SetOwner(address owner);

    function setOwner(address _owner) public onlyOwner {
        owner = _owner;
        emit SetOwner(_owner);
    }

    // --- State ---
    enum State { Ready, Running, Killed }

    State public state = State.Ready;

    modifier notStarted {
        require(state == State.Ready);
        _;
    }

    modifier notPaused {
        require(state == State.Running);
        _;
    }

    // --- Math ---
    uint constant ONE = 10 ** 27;

    function add(uint a, uint b) private pure returns (uint) {
        uint c = a + b;
        require(c >= a);
        return c;
    }

    function sub(uint a, uint b) private pure returns (uint) {
        require(b <= a);
        return a - b;
    }

    function mul(uint a, uint b) private pure returns (uint) {
        if (a == 0) return 0;
        uint c = a * b;
        require(c / a == b);
        return c;
    }

    function div(uint a, uint b) private pure returns (uint) {
        require(b > 0);
        return a / b;
    }

    function ceil(uint a, uint b) private pure returns (uint) {
        require(b > 0);
        return (a + b - 1) / b;
    }

    function muldiv(uint a, uint b, uint c) private pure returns (uint) {
        require(c != 0);
        return mul(a, b) / c;
    }

    // --- Contracts & Constructor ---
    DaiLike public Dai;
    JoinLike public Join;
    PotLike public Pot;
    VatLike public Vat;

    ReserveLike public Reserve;

    WrappedDaiLike public EDai;
    WrappedDaiLike public ODai;

    event SetReserve(address reserve);

    constructor(address dai, address join, address pot, address vat, address eDai, address oDai) public {
        owner = msg.sender;

        Dai = DaiLike(dai);
        Join = JoinLike(join);
        Pot = PotLike(pot);
        Vat = VatLike(vat);

        EDai = WrappedDaiLike(eDai);
        ODai = WrappedDaiLike(oDai);

        require(address(Join.dai()) == dai);
        require(address(Join.vat()) == vat);
        require(address(Pot.vat()) == vat);

        Vat.hope(pot);  // Pot.join
        Vat.hope(join);  // Join.exit

        require(Dai.approve(join, uint(-1)));  // Join.join -> dai.burn
    }

    function setReserve(address reserve) public onlyOwner {
        Reserve = ReserveLike(reserve);
        require(EDai.setReserve(reserve));
        require(ODai.setReserve(reserve));
        emit SetReserve(reserve);
    }

    modifier onlyEDai {
        require(msg.sender == address(EDai));
        _;
    }

    modifier onlyODai {
        require(msg.sender == address(ODai));
        _;
    }

    // --- Integration ---
    function chi() private returns (uint) {
        return Pot.drip();
    }

    function joinDai(uint dai) private {
        Dai.transferFrom(msg.sender, address(this), dai);
        Dai.approve(address(Join), dai);
        Join.join(address(this), dai);
        Pot.join(dai);
    }

    function exitDai(address to, uint dai) private {
        Pot.exit(dai);
        Join.exit(to, dai);
    }

    function mintODai(address to, uint dai) private returns (uint) {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        ODai.mint(to, wad);
        return wad;
    }

    function depositEDai(string memory toChain, uint dai, bytes memory to) public notPaused {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        EDai.mint(address(this), wad);
        Reserve.depositToken(address(EDai), toChain, to, wad);
    }

    function depositODai(string memory toChain, uint dai, bytes memory to) public notPaused {
        uint wad = mintODai(address(this), dai);
        Reserve.depositToken(address(ODai), toChain, to, wad);
    }

    function swapFromEDai(address from, address to, uint dai) private {
        EDai.burn(from, dai);
        exitDai(to, dai);
    }

    function swapFromODai(address from, address to, uint wad) private {
        ODai.burn(from, wad);
        uint dai = muldiv(wad, chi(), ONE);
        exitDai(to, dai);
    }

    function withdrawEDai(address to, uint dai) public onlyEDai notPaused {
        swapFromEDai(address(this), to, dai);
    }

    function withdrawODai(address to, uint wad) public onlyODai notPaused {
        swapFromODai(address(this), to, wad);
    }

    function swapToEDai(uint dai) public notPaused {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        EDai.mint(msg.sender, wad);
    }

    function swapToODai(uint dai) public notPaused {
        mintODai(msg.sender, dai);
    }

    // --- Migration ---
    DaiProxy public NewProxy;

    event SetNewProxy(address proxy);
    event StartProxy(address prev);
    event KillProxy(address next, bool mig);

    modifier onlyNewProxy {
        require(msg.sender == address(NewProxy));
        _;
    }

    function setNewProxy(address proxy) public onlyOwner {
        NewProxy = DaiProxy(proxy);
        emit SetNewProxy(proxy);
    }

    function killProxy(address to) public notPaused onlyOwner {
        exitDai(to, Vat.dai(address(this)));
        state = State.Killed;
        emit KillProxy(address(NewProxy), false);
    }

    function migrateProxy() public notPaused onlyNewProxy {
        uint dai = Vat.dai(address(this));
        EDai.setProxy(address(NewProxy));
        ODai.setProxy(address(NewProxy));
        Join.exit(address(this), dai);
        NewProxy.startProxy(address(this));
        state = State.Killed;
        emit KillProxy(address(NewProxy), true);
    }

    function startProxy(address oldProxy) public notStarted onlyOwner {
        require(NewProxy == DaiProxy(0));
        state = State.Running;
        emit StartProxy(oldProxy);
        if (oldProxy != address(0)) {
            DaiProxy op = DaiProxy(oldProxy);
            op.migrateProxy();
        }
    }
}
```

### Key Points:
- **Math Functions:** Added safe math operations to handle arithmetic safely.
- **Lifecycle Management:** Implemented state transition management through `State` enum and related modifiers.
- **Token Operations:** Included functions for joining/exiting DAI, minting/burning wrapped DAI, and swapping between different forms of DAI.
- **Reserve Interaction:** Functions to deposit and withdraw wrapped DAI to/from a reserve.
- **Migration Support:** Mechanisms for setting a new proxy, killing the current one, and migrating state to a new proxy.

This implementation adheres to the context provided, ensuring that it interacts correctly with the other contracts defined in the interfaces.