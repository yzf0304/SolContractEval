Here is the completed `DaiProxy` contract based on the provided context and requirements. The code includes all required functions and modifiers, adhering to the compiler version 0.5.12.

```solidity
pragma solidity 0.5.12;

contract ReserveLike {
    function depositToken(address, string memory, bytes memory, uint) public;
}

contract WrappedDaiLike {
    function setProxy(address) public;
    function setReserve(address) public;

    uint public totalSupply;
    function approve(address, uint) public returns (bool);

    function mint(address, uint) public;
    function burn(address, uint) public;
}

contract DaiLike {
    function approve(address, uint) public returns (bool);
    function transferFrom(address, address, uint) public returns (bool);
}

contract JoinLike {
    VatLike public vat;
    DaiLike public dai;

    function join(address, uint) public;
    function exit(address, uint) public;
}

contract PotLike {
    mapping(address => uint) public pie;
    uint public chi;

    VatLike public vat;
    uint public rho;

    function drip() public returns (uint);

    function join(uint) public;
    function exit(uint) public;
}

contract VatLike {
    mapping(address => uint) public dai;

    function hope(address) public;
    function move(address, address, uint) public;
}

contract DaiProxy {
    string public constant version = "0511";

    address public owner;
    
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event SetOwner(address owner);

    function setOwner(address _owner) public onlyOwner {
        owner = _owner;
        emit SetOwner(_owner);
    }

    enum State { Ready, Running, Killed }

    State public state = State.Ready;

    modifier notStarted {
        require(state == State.Ready);
        _;
    }

    modifier notPaused {
        require(state != State.Killed);
        _;
    }

    uint constant ONE = 10 ** 27;

    function add(uint a, uint b) private pure returns (uint) {
        uint c = a + b;
        require(c >= a, "add overflow");
        return c;
    }

    function sub(uint a, uint b) private pure returns (uint) {
        require(b <= a, "sub underflow");
        return a - b;
    }

    function mul(uint a, uint b) private pure returns (uint) {
        if (a == 0) return 0;
        uint c = a * b;
        require(c / a == b, "mul overflow");
        return c;
    }

    function div(uint a, uint b) private pure returns (uint) {
        require(b > 0, "div by zero");
        return a / b;
    }

    function ceil(uint a, uint b) private pure returns (uint) {
        require(b > 0, "ceil by zero");
        return (a + b - 1) / b;
    }

    function muldiv(uint x, uint y, uint z) private pure returns (uint) {
        return mul(x, y) / z;
    }

    DaiLike public Dai;
    JoinLike public Join;
    PotLike public Pot;
    VatLike public Vat;

    ReserveLike public Reserve;

    WrappedDaiLike public EDai;
    WrappedDaiLike public ODai;

    event SetReserve(address reserve);

    constructor(address dai, address join, address pot, address vat, address eDai, address oDai) public {
        owner = msg.sender;

        Dai = DaiLike(dai);
        Join = JoinLike(join);
        Pot = PotLike(pot);
        Vat = VatLike(vat);

        EDai = WrappedDaiLike(eDai);
        ODai = WrappedDaiLike(oDai);

        require(address(Join.dai()) == dai);
        require(address(Join.vat()) == vat);
        require(address(Pot.vat()) == vat);

        Vat.hope(pot);  // Pot.join
        Vat.hope(join);  // Join.exit

        require(Dai.approve(join, uint(-1)));  // Join.join -> dai.burn
    }

    function setReserve(address reserve) public onlyOwner {
        Reserve = ReserveLike(reserve);
        EDai.setReserve(reserve);
        ODai.setReserve(reserve);
        emit SetReserve(reserve);
    }

    modifier onlyEDai {
        require(msg.sender == address(EDai));
        _;
    }

    modifier onlyODai {
        require(msg.sender == address(ODai));
        _;
    }

    function chi() private returns (uint) {
        return Pot.drip();
    }

    function joinDai(uint dai) private {
        Dai.transferFrom(msg.sender, address(this), dai);
        Dai.approve(address(Join), dai);
        Join.join(msg.sender, dai);
        Pot.join(dai);
    }

    function exitDai(address to, uint dai) private {
        Pot.exit(dai);
        Join.exit(to, dai);
    }

    function mintODai(address to, uint dai) private returns (uint) {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        ODai.mint(to, wad);
        return wad;
    }

    function depositEDai(string memory toChain, uint dai, bytes memory to) public notPaused {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        EDai.mint(address(this), wad);
        EDai.approve(address(Reserve), wad);
        Reserve.depositToken(address(EDai), toChain, to, wad);
    }

    function depositODai(string memory toChain, uint dai, bytes memory to) public notPaused {
        uint wad = mintODai(address(this), dai);
        ODai.approve(address(Reserve), wad);
        Reserve.depositToken(address(ODai), toChain, to, wad);
    }

    function swapFromEDai(address from, address to, uint dai) private {
        EDai.burn(from, dai);
        exitDai(to, dai);
    }

    function swapFromODai(address from, address to, uint wad) private {
        ODai.burn(from, wad);
        uint dai = muldiv(wad, chi(), ONE);
        exitDai(to, dai);
    }

    function withdrawEDai(address to, uint dai) public onlyEDai notPaused {
        swapFromEDai(address(this), to, dai);
    }

    function withdrawODai(address to, uint wad) public onlyODai notPaused {
        swapFromODai(address(this), to, wad);
    }

    function swapToEDai(uint dai) public notPaused {
        joinDai(dai);
        uint wad = muldiv(dai, ONE, chi());
        EDai.mint(msg.sender, wad);
    }

    function swapToODai(uint dai) public notPaused {
        mintODai(msg.sender, dai);
    }

    function swapFromEDai(uint dai) public notPaused {
        swapFromEDai(msg.sender, msg.sender, dai);
    }

    function swapFromODai(uint wad) public notPaused {
        swapFromODai(msg.sender, msg.sender, wad);
    }

    DaiProxy public NewProxy;

    event SetNewProxy(address proxy);
    event StartProxy(address prev);
    event KillProxy(address next, bool mig);

    modifier onlyNewProxy {
        require(msg.sender == address(NewProxy));
        _;
    }

    function setNewProxy(address proxy) public onlyOwner {
        NewProxy = DaiProxy(proxy);
        emit SetNewProxy(proxy);
    }

    function killProxy(address to) public notPaused onlyOwner {
        uint dai = Vat.dai(address(this));
        uint chi_ = chi();
        uint wad = muldiv(dai, chi_, ONE);
        exitDai(to, div(dai, chi_));
        state = State.Killed;
        emit KillProxy(address(NewProxy), wad == 0);
    }

    function migrateProxy() public notPaused onlyNewProxy {
        address self = address(this);
        NewProxy.setReserve(address(Reserve));
        Vat.move(self, address(NewProxy), Vat.dai(self));
        EDai.setProxy(address(NewProxy));
        ODai.setProxy(address(NewProxy));
    }

    function startProxy(address oldProxy) public notStarted onlyOwner {
        if (oldProxy != address(0)) {
            DaiProxy proxy = DaiProxy(oldProxy);
            proxy.migrateProxy();
        }
        state = State.Running;
        emit StartProxy(oldProxy);
    }
}
```

This contract manages DAI and its wrapped versions (eDai and oDai) through various methods for deposit, withdrawal, and migration, while respecting access controls and state transitions.