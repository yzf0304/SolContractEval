Below is the complete implementation of the `ERC721` contract based on the provided context and description. This implementation adheres to the ERC721 and ERC721Metadata standards and includes functionality for minting, ownership transfer, and token URI management.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IERC165.sol";
import "./IERC721.sol";
import "./IERC721Metadata.sol";
import "./IERC721Receiver.sol";
import "./Address.sol";
import "./Strings.sol";

contract ERC721 is ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    uint256 private _totalMintsAllowed = 4;
    string private uriLink = "https://spicypumpkins.com/api/json";
    bool private _minting = true;
    address payable private _owner;
    uint256 private _count;
    string private _name;
    string private _symbol;

    mapping(uint256 => address) private _owners;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(address => uint256) private _minted;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, "ERC721: caller is not the owner");
        _;
    }

    modifier onlyIfMinting() {
        require(_minting, "ERC721: minting is disabled");
        _;
    }

    function setMinting(bool boolean) external onlyOwner {
        _minting = boolean;
    }

    function transferOwnership(address to) external onlyOwner {
        _owner = payable(to);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: owner query for nonexistent token");
        return _owners[tokenId];
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function totalSupply() external view override returns(uint256){
        return _count;
    }

    function tokenURI(uint256 tokenId) external view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return concat(uriLink, tokenId.toString());
    }

    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    function approve(address to, uint256 tokenId) external override {
        address owner = _owners[tokenId];
        require(to != owner, "ERC721: approval to current owner");

        require(
            msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != msg.sender, "ERC721: approve to caller");

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) external override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) external override {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = _owners[tokenId];
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function mint(address to) external payable onlyIfMinting returns(uint256 ID) {
        require(_minted[msg.sender] < _totalMintsAllowed, "ERC721: mint limit reached");
        _minted[msg.sender]++;
        return internalMint(to);
    }

    function internalMint(address to) internal returns(uint256 ID) {
        require(to != address(0), "ERC721: mint to the zero address");
        _count++;
        _balances[to] += 1;
        _owners[_count] = to;
        emit Transfer(address(0), to, _count);
        return _count;
    }

    function concat(string memory _base, string memory _value) pure internal returns (string memory) {
        bytes memory _baseBytes = bytes(_base);
        bytes memory _valueBytes = bytes(_value);

        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);
        bytes memory _newValue = bytes(_tmpValue);

        uint i;
        uint j;

        for(i = 0; i < _baseBytes.length; i++) {
            _newValue[j++] = _baseBytes[i];
        }

        for(i = 0; i < _valueBytes.length; i++) {
            _newValue[j++] = _valueBytes[i];
        }

        return string(_newValue);
    }

    function multiMint(address to, uint256 amount) external payable onlyIfMinting returns(uint256[] memory IDs) {
        require(to != address(0), "ERC721: mint to the zero address");
        require(_minted[msg.sender] + amount <= _totalMintsAllowed, "ERC721: mint limit reached");
        _minted[msg.sender] += amount;

        IDs = new uint256[](amount);
        for (uint i = 0; i < amount; i++) {
            _count++;
            IDs[i] = _count;
            _balances[to] += 1;
            _owners[_count] = to;
            emit Transfer(address(0), to, _count);
        }
        return IDs;
    }

    function changeMax(uint256 newMax) external onlyOwner {
        _totalMintsAllowed = newMax;
    }

    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(_owners[tokenId] == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        // Clear approvals from the previous owner
        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(_owners[tokenId], to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        private returns (bool)
    {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    // solhint-disable-next-line no-inline-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    receive() external payable {}
}
```

### Key Features Implemented:
- **Minting**: Includes both single and multi-mint functionalities.
- **Ownership Management**: Manages ownership and balances of tokens.
- **Token Metadata**: Provides metadata including `name`, `symbol`, and `tokenURI`.
- **Approval Mechanism**: Allows users to approve other accounts to manage their tokens.
- **Transfer Functions**: Includes both safe and unsafe transfer methods, ensuring compliance with the ERC721 standard.
- **Security**: Includes checks to prevent malicious behavior, such as attempting to mint more tokens than allowed or transferring tokens to the zero address.

Please ensure to test the contract thoroughly before deploying it on a live network.