Certainly! Below is the complete and functional implementation of the `ERC721` contract adhering to the provided context and requirements, using Solidity version 0.8.0:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

import "./IERC165.sol";
import "./IERC721.sol";
import "./IERC721Receiver.sol";
import "./IERC721Metadata.sol";
import "./Address.sol";
import "./Strings.sol";
import "./ERC165.sol";

contract ERC721 is ERC165, IERC721, IERC721Metadata {
    using Address for address;
    using Strings for uint256;

    uint256 private _totalMintsAllowed = 4;
    string private uriLink = "https://spicypumpkins.com/api/json";
    bool private _minting = true;
    address payable private _owner;
    uint256 private _count;
    string private _name;
    string private _symbol;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(uint256 => address) private _tokenApprovals;
    mapping(address => mapping(address => bool)) private _operatorApprovals;
    mapping(address => uint256) private _minted;

    constructor (string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
        _owner = payable(msg.sender);
    }

    modifier onlyOwner() {
        require(msg.sender == _owner, "Not the owner");
        _;
    }

    modifier canMint() {
        require(_minting, "Minting is disabled");
        _;
    }

    function setMinting(bool boolean) external onlyOwner {
        _minting = boolean;
    }

    function transferOwnership(address to) external onlyOwner {
        require(to != address(0), "New owner is the zero address");
        _owner = payable(to);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC721).interfaceId ||
               interfaceId == type(IERC721Metadata).interfaceId ||
               super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view virtual override returns (uint256) {
        require(owner != address(0), "ERC721: balance query for the zero address");
        return _balances[owner];
    }

    function ownerOf(uint256 tokenId) public view virtual override returns (address) {
        address owner = _owners[tokenId];
        require(owner != address(0), "ERC721: owner query for nonexistent token");
        return owner;
    }

    function name() public view virtual override returns (string memory) {
        return _name;
    }

    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }

    function totalSupply() external view override returns(uint256){
        return 4444; // Fixed supply as per your description
    }

    function tokenURI(uint256 tokenId) external view override returns (string memory) {
        require(_exists(tokenId), "ERC721: URI query for nonexistent token");
        return concat(uriLink, tokenId.toString());
    }

    function _baseURI() internal view virtual returns (string memory) {
        return "";
    }

    function approve(address to, uint256 tokenId) external override {
        address owner = ownerOf(tokenId);
        require(to != owner, "ERC721: approval to current owner");

        require(
            msg.sender == owner || isApprovedForAll(owner, msg.sender),
            "ERC721: approve caller is not owner nor approved for all"
        );

        _approve(to, tokenId);
    }

    function getApproved(uint256 tokenId) public view virtual override returns (address) {
        require(_exists(tokenId), "ERC721: approved query for nonexistent token");

        return _tokenApprovals[tokenId];
    }

    function setApprovalForAll(address operator, bool approved) public virtual override {
        require(operator != msg.sender, "ERC721: approve to caller");

        _operatorApprovals[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }

    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }

    function transferFrom(address from, address to, uint256 tokenId) external override {
        //solhint-disable-next-line max-line-length
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");

        _transfer(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) external override {
        safeTransferFrom(from, to, tokenId, "");
    }

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external override {
        require(_isApprovedOrOwner(msg.sender, tokenId), "ERC721: transfer caller is not owner nor approved");
        _safeTransfer(from, to, tokenId, _data);
    }

    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {
        _transfer(from, to, tokenId);
        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");
    }

    function _exists(uint256 tokenId) internal view returns (bool) {
        return _owners[tokenId] != address(0);
    }

    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {
        require(_exists(tokenId), "ERC721: operator query for nonexistent token");
        address owner = ownerOf(tokenId);
        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));
    }

    function mint(address to) external payable canMint returns(uint256 ID) {
        require(msg.value >= 0.1 ether, "Insufficient ETH sent for minting");
        require(_minted[msg.sender] < _totalMintsAllowed, "Exceeds minting limit");
        require(_count < 4444, "All NFTs are already minted");

        _minted[msg.sender]++;
        _count++;

        ID = _count;
        _mint(to, ID);

        _owner.transfer(msg.value);
    }

    function internalMint(address to) internal returns(uint256 ID) {
        _count++;
        ID = _count;
        _mint(to, ID);
    }

    function concat(string memory _base, string memory _value) pure internal returns (string memory) {
        return string(abi.encodePacked(_base, "/", _value));
    }

    function multiMint(address to, uint256 amount) external payable canMint returns(uint256[] memory IDs) {
        require(amount > 0 && amount <= _totalMintsAllowed, "Invalid amount");
        require(_minted[msg.sender] + amount <= _totalMintsAllowed, "Exceeds minting limit");
        require(_count + amount <= 4444, "Exceeds total supply");
        require(msg.value >= 0.1 ether * amount, "Insufficient ETH sent for minting");

        IDs = new uint256[](amount);
        for(uint256 i = 0; i < amount; i++) {
            IDs[i] = internalMint(to);
            _minted[msg.sender]++;
        }

        _owner.transfer(msg.value);
    }

    function changeMax(uint256 newMax) external onlyOwner {
        _totalMintsAllowed = newMax;
    }

    function _transfer(address from, address to, uint256 tokenId) internal virtual {
        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");
        require(to != address(0), "ERC721: transfer to the zero address");

        _approve(address(0), tokenId);

        _balances[from] -= 1;
        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);
    }

    function _approve(address to, uint256 tokenId) internal virtual {
        _tokenApprovals[tokenId] = to;
        emit Approval(ownerOf(tokenId), to, tokenId);
    }

    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)
        private returns (bool)
    {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) {
                    revert("ERC721: transfer to non ERC721Receiver implementer");
                } else {
                    // solhint-disable-next-line no-inline-assembly
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }

    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");

        _balances[to] += 1;
        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);
    }
}
```

This contract implements the core functionalities required by the ERC721 standard along with additional methods such as minting, changing the minting status, and managing ownership. Please ensure that the library imports (`./IERC165.sol`, `./IERC721.sol`, etc.) are correctly set up in your project structure.