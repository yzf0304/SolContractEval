Below is the completed implementation of the `EverMigrate` contract based on your provided specifications. This contract includes the necessary logic to add token details, migrate tokens, return tokens, and provide various details about supported tokens and user transactions.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.8;

abstract contract Context {
    function _msgSender() internal view virtual returns (address payable) {
        return payable(msg.sender);
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external pure returns (uint8);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return a % b;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view returns (address) {
        return _owner;
    }   

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IEverMigrate {
    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external;
    function returnTokens(address sourceToken, address toAddress, uint256 amount) external;
    function tokenMigrateDetails(address sourceToken) external view returns (address targetToken, uint256 ratio);
    function allSupportedTokens() external view returns (address[] memory);
    function allSupportedTokensLength() external view returns (uint256);
    function supportsToken(address sourceToken) external view returns(bool);
    
    event TokenAdded(address fromToken, address toToken, uint256 ratio);
    event TokensMigrated(address fromToken, address toToken, uint256 amountIn, uint256 amountOut);
    event TokensReturned(address token, address toAddress, uint256 amount);
}

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping (address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId = 0;
    mapping (address => mapping (address => Transaction[])) private _userTxns;

    constructor() {
    }

    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(sourceToken != address(0) && targetToken != address(0), "Invalid token addresses");
        require(ratio > 0, "Ratio must be greater than 0");

        if (!_tokenList[sourceToken].isPresent) {
            _allTokens.push(sourceToken);
        }

        _tokenList[sourceToken] = TokenDetails({
            sourceToken: sourceToken,
            targetToken: targetToken,
            devAddress: devAddress,
            ratio: ratio,
            isPresent: true
        });

        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {
        require(amount > 0, "Amount must be greater than 0");
        require(supportsToken(sourceToken), "Source token not supported");

        TokenDetails storage details = _tokenList[sourceToken];
        IERC20(sourceToken).transferFrom(_msgSender(), details.devAddress, amount);

        uint256 targetAmount = amount.mul(details.ratio);
        IERC20(details.targetToken).transfer(toAddress, targetAmount);

        _txnId++;
        _userTxns[_msgSender()][sourceToken].push(Transaction({
            amount: amount,
            timestamp: block.timestamp,
            txnId: _txnId
        }));

        emit TokensMigrated(sourceToken, details.targetToken, amount, targetAmount);
    }

    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {
        return _userTxns[userAddress][sourceToken].length;
    }

    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {
        require(position < _userTxns[userAddress][sourceToken].length, "Invalid position");

        Transaction storage txn = _userTxns[userAddress][sourceToken][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }

    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {
        require(supportsToken(sourceToken), "Source token not supported");

        TokenDetails storage details = _tokenList[sourceToken];
        IERC20(details.targetToken).transfer(toAddress, amount);

        emit TokensReturned(sourceToken, toAddress, amount);
    }

    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {
        require(supportsToken(sourceToken), "Source token not supported");

        TokenDetails storage details = _tokenList[sourceToken];
        return (details.targetToken, details.ratio);
    }

    function allSupportedTokens() external view returns (address[] memory) {
        return _allTokens;
    }

    function allSupportedTokensLength() external view returns (uint256) {
        return _allTokens.length;
    }

    function supportsToken(address sourceToken) public view override returns (bool) {
        return _tokenList[sourceToken].isPresent;
    }
}
```

### Key Features Implemented:
- **Token Pair Addition**: Owners can add new token pairs with their respective conversion ratios and developer addresses.
- **Token Migration**: Users can migrate tokens from a supported source token to its corresponding target token.
- **User Transactions Tracking**: The contract keeps track of each user's token migration transactions.
- **Token Return Functionality**: Owners can return target tokens to a specified address.
- **Token Details**: Provides access to migration details of each token.
- **Supported Tokens List**: Lists all tokens currently supported by the contract.

This implementation ensures that the `EverMigrate` contract adheres to the requirements and specifications given in your context.