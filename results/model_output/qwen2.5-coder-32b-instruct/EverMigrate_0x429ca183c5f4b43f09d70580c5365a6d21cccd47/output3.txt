Below is the completed `EverMigrate` contract implementing all the specified functionalities based on the provided interface and comments:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.8;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function decimals() external pure returns (uint8);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        return a + b;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        return a * b;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return a / b;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }   

    modifier onlyOwner() {
        require(_owner == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

interface IEverMigrate {
    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external;
    function returnTokens(address sourceToken, address toAddress, uint256 amount) external;
    function tokenMigrateDetails(address sourceToken) external view returns (address targetToken, uint256 ratio);
    function allSupportedTokens() external view returns (address[] memory);
    function allSupportedTokensLength() external view returns (uint256);
    function supportsToken(address sourceToken) external view returns(bool);
    
    event TokenAdded(address fromToken, address toToken, uint256 ratio);
    event TokensMigrated(address fromToken, address toToken, uint256 amountIn, uint256 amountOut);
    event TokensReturned(address token, address toAddress, uint256 amount);
}

contract EverMigrate is IEverMigrate, Context, Ownable {
    using SafeMath for uint256;

    struct TokenDetails {
        address sourceToken;
        address targetToken;
        address devAddress;
        uint256 ratio;
        bool isPresent;
    }

    struct Transaction {
        uint256 amount;
        uint256 timestamp;
        uint32 txnId;
    }

    mapping (address => TokenDetails) private _tokenList;
    address[] private _allTokens;

    uint32 private _txnId = 0;
    mapping (address => mapping (address => Transaction[])) private _userTxns;

    function addTokenDetails(
        address sourceToken,
        address targetToken,
        address devAddress,
        uint256 ratio
    ) external onlyOwner {
        require(!_tokenList[sourceToken].isPresent, "Token already added.");
        require(targetToken != address(0) && devAddress != address(0) && sourceToken != address(0), "Invalid address.");
        require(ratio > 0, "Ratio must be greater than zero.");

        _tokenList[sourceToken] = TokenDetails(sourceToken, targetToken, devAddress, ratio, true);
        _allTokens.push(sourceToken);
        emit TokenAdded(sourceToken, targetToken, ratio);
    }

    function migrateTokens(address sourceToken, address toAddress, uint256 amount) external {
        require(supportsToken(sourceToken), "Source token not supported.");
        require(toAddress != address(0) && amount > 0, "Invalid input.");

        IERC20 sourceTokenContract = IERC20(sourceToken);
        uint256 allowance = sourceTokenContract.allowance(_msgSender(), address(this));
        require(allowance >= amount, "Insufficient allowance.");

        uint256 targetAmount = SafeMath.mul(amount, _tokenList[sourceToken].ratio);
        
        // Transfer source tokens to dev address
        require(sourceTokenContract.transferFrom(_msgSender(), _tokenList[sourceToken].devAddress, amount), "Failed to transfer source tokens.");

        // Assume target token contract has sufficient allowance to be transferred directly (this contract should have pre-approved)
        IERC20 targetTokenContract = IERC20(_tokenList[sourceToken].targetToken);
        require(targetTokenContract.transfer(toAddress, targetAmount), "Failed to transfer target tokens.");

        // Log transaction details
        _userTxns[_msgSender()][sourceToken].push(Transaction(amount, block.timestamp, ++_txnId));

        emit TokensMigrated(sourceToken, _tokenList[sourceToken].targetToken, amount, targetAmount);
    }

    function returnTokens(address sourceToken, address toAddress, uint256 amount) external onlyOwner {
        require(supportsToken(sourceToken), "Source token not supported.");
        require(toAddress != address(0) && amount > 0, "Invalid input.");

        IERC20 targetTokenContract = IERC20(_tokenList[sourceToken].targetToken);
        require(targetTokenContract.transfer(toAddress, amount), "Failed to return tokens.");
        emit TokensReturned(sourceToken, toAddress, amount);
    }

    function tokenMigrateDetails(address sourceToken) external view returns (address, uint256) {
        require(supportsToken(sourceToken), "Source token not supported.");
        return (_tokenList[sourceToken].targetToken, _tokenList[sourceToken].ratio);
    }

    function allSupportedTokens() external view returns (address[] memory) {
        return _allTokens;
    }

    function allSupportedTokensLength() external view returns (uint256) {
        return _allTokens.length;
    }

    function supportsToken(address sourceToken) public view returns (bool) {
        return _tokenList[sourceToken].isPresent;
    }

    function userTransactionsLength(address sourceToken, address userAddress) external view returns (uint256) {
        return _userTxns[userAddress][sourceToken].length;
    }

    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32) {
        require(position < _userTxns[userAddress][sourceToken].length, "Invalid position.");
        Transaction memory txn = _userTxns[userAddress][sourceToken][position];
        return (txn.amount, txn.timestamp, txn.txnId);
    }
}
```

### Key Points:
- **Token Migration**: Users can migrate tokens by calling `migrateTokens`, which requires them to pre-approve the contract to spend their tokens.
- **Token Addition**: Only the contract owner can add new token mappings via `addTokenDetails`.
- **Return Tokens**: Only the owner can return tokens using the `returnTokens` function.
- **View Functions**: Functions like `tokenMigrateDetails`, `allSupportedTokens`, `allSupportedTokensLength`, `supportsToken`, `userTransactionsLength`, and `userTransaction` provide read-only access to token details and transaction histories.
- **Event Emission**: Events are emitted for significant actions like adding tokens, migrating tokens, and returning tokens to facilitate off-chain monitoring.