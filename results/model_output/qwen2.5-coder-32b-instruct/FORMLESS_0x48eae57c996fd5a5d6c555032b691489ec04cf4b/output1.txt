Certainly! Below is the complete implementation of the `FORMLESS` contract based on your specifications. It includes all necessary logic for minting, managing metadata, handling sales phases, and various administrative functionalities.

```solidity
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.7;

contract FORMLESS is Ownable, ERC721A, ReentrancyGuard {
    using Strings for uint256;

    uint256 public MAX_PER_Transtion = 1; // Maximum amount that user can mint per transaction
    uint256 public MAX_PER_Address = 1; // Maximum amount that a user can mint overall

    uint256 public PRICE = 0.069 ether; // Price for minting one NFT

    uint256 private TotalCollectionSize_ = 500; // Total number of NFTs
    uint256 private constant MaxMintPerBatch_ = 1; // Max mint per transaction

    mapping(address => bool) private whitelistedAddressesForMint;

    string private _baseTokenURI;

    uint public status = 0; // 0 - sale pause, 1 - whitelist sale, 2 - public sale

    constructor() ERC721A("FORMLESS", "FORMLESS", MaxMintPerBatch_, TotalCollectionSize_) {
        _baseTokenURI = "https://gateway.pinata.cloud/ipfs/QmWT2u6UEeXJs5MWcSTQhHFyYC9wKevQNjXC4J3k67ymtQ/";
    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function mint(uint256 quantity) external payable callerIsUser nonReentrant {
        require(quantity > 0 && quantity <= MAX_PER_Transtion, "Invalid mint amount");
        require(msg.value >= PRICE * quantity, "Insufficient funds");
        require(totalSupply() + quantity <= TotalCollectionSize_, "Max supply reached");
        require(numberMinted(msg.sender) + quantity <= MAX_PER_Address, "Address mint limit reached");

        if (status == 1) { // Whitelist sale
            require(whitelistedAddressesForMint[msg.sender], "Not whitelisted");
        } else if (status == 2) { // Public sale
            // No additional checks needed for public sale
        } else {
            revert("Sale is currently paused");
        }

        _safeMint(msg.sender, quantity);
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "Token does not exist");
        return string(abi.encodePacked(_baseTokenURI, tokenId.toString(), ".json"));
    }

    function isWhitelistedForMint(address _user) public view returns (bool) {
        return whitelistedAddressesForMint[_user];
    }

    function addNewWhitelistUserForMint(address[] calldata _users) public onlyOwner {
        for (uint256 i = 0; i < _users.length; i++) {
            whitelistedAddressesForMint[_users[i]] = true;
        }
    }

    function setBaseURI(string memory baseURI) external onlyOwner {
        _baseTokenURI = baseURI;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return _numberMinted(owner);
    }

    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
        return ownershipOf(tokenId);
    }

    function withdrawMoney() external onlyOwner nonReentrant {
        payable(owner()).transfer(address(this).balance);
    }

    function changeMAX_PER_Address(uint256 q) external onlyOwner {
        MAX_PER_Address = q;
    }

    function reserve(address _address, uint256 quantity) public onlyOwner {
        require(quantity <= TotalCollectionSize_ - totalSupply(), "Not enough supply");
        _safeMint(_address, quantity);
    }

    function changeMintPrice(uint256 _newPrice) external onlyOwner {
        PRICE = _newPrice;
    }

    function changeCollectionSize(uint256 _collectionSize) external onlyOwner {
        require(currentIndex <= _collectionSize, "Cannot reduce collection size below current supply");
        TotalCollectionSize_ = _collectionSize;
    }

    function changeMAX_PER_Transtion(uint256 q) external onlyOwner {
        MAX_PER_Transtion = q;
    }

    function giveaway(address a, uint256 q) public onlyOwner {
        require(q <= TotalCollectionSize_ - totalSupply(), "Not enough supply");
        _safeMint(a, q);
    }

    function setStatus(uint256 s) external onlyOwner {
        require(s == 0 || s == 1 || s == 2, "Invalid status");
        status = s;
    }

    function getStatus() public view returns (uint256) {
        return status;
    }

    function getcollectionSize() public view returns (uint256) {
        return TotalCollectionSize_;
    }
}
```

### Key Features Implemented:
- **Minting:** Users can mint tokens with a specified price and within limits.
- **Whitelist:** Supports a whitelist for specific minters during the whitelist phase.
- **Sales Management:** Supports different sales statuses and allows changing them.
- **Admin Controls:** Includes functions to manage whitelist, change mint price, reserve tokens, and withdraw funds.
- **Security:** Uses `ReentrancyGuard` and `Ownable` patterns for safety and control.

This contract should meet the specified requirements and can be further customized if necessary. Make sure to test thoroughly in a safe environment before deploying to production.