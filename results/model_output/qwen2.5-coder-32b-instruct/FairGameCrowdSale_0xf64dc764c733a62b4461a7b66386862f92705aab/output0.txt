Certainly! Below is the completed `CrowdSale` contract based on the provided context and description. The contract adheres to the Solidity version 0.4.18 and includes all necessary functionalities as described:

```solidity
pragma solidity ^0.4.18;

contract ERC20 {

    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}

contract Ownable {
    address public owner;

    event OwnerChanged(address oldOwner, address newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != owner && newOwner != address(0x0));
        address oldOwner = owner;
        owner = newOwner;
        OwnerChanged(oldOwner, newOwner);
    }
}

contract CrowdSale is Ownable {

    ERC20 public token;
    address public beneficiary;
    address public tokenHolder;

    uint public rate;
    uint public amountGoal;
    uint public amountRaised;
    uint public amountTokenIssued;

    uint public startTime;
    uint public endTime;

    struct Stage {
        uint duration;      
        uint rate;          
    }
    Stage[] public icoStages;
    Stage[] public lockStages;

    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    // ----- Events -----
    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    // ----- Modifiers -----
    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted());
        require(!isEnded());
        _;
    }

    // ----- Functions -----

    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    function _initStages() internal {
        // Example initialization, modify as needed
        icoStages.push(Stage(1 weeks, 120)); // 1 week with 120% reward
        icoStages.push(Stage(2 weeks, 110)); // 2 weeks with 110% reward
        lockStages.push(Stage(1 months, 0)); // Lock for 1 month
        lockStages.push(Stage(3 months, 0)); // Lock for 3 months
    }

    function getTokenAddress() public view returns(address) {
        return address(token);
    }

    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        require(stageIndex < lockStages.length);
        uint unlockTime = startTime + icoStages[0].duration + icoStages[1].duration + lockStages[stageIndex].duration;
        return now >= unlockTime;
    }

    function isStarted() public view returns(bool) {
        return now >= startTime;
    }

    function isReachedGoal() public view returns(bool) {
        return amountRaised >= amountGoal;
    }

    function isEnded() public view returns(bool) {
        return now >= endTime || isReachedGoal();
    }

    function getCurrentStage() public view returns(int) {
        if (!isStarted()) return -1;
        uint elapsed = now - startTime;
        uint totalDuration = 0;
        for (uint i = 0; i < icoStages.length; i++) {
            totalDuration += icoStages[i].duration;
            if (elapsed < totalDuration) {
                return int(i);
            }
        }
        return int(icoStages.length) - 1;
    }

    function getRemainingTimeInSecond() public view returns(uint) {
        if (isEnded()) return 0;
        return endTime - now;
    }

    function _addPurchaser(address purchaser) internal {
        purchasers[purchaser] = PurchaserInfo(0, 0, new uint[](lockStages.length));
        purchaserList.push(purchaser);
    }

    function start(uint fundingGoalInEther) public onlyOwner {
        require(startTime == 0); // Can only be called once
        amountGoal = fundingGoalInEther * 1 ether;
        startTime = now;
        endTime = startTime + icoStages[0].duration + icoStages[1].duration; // Total ico duration
    }

    function stop() public onlyOwner {
        endTime = now;
    }

    function () payable public onlyOpenTime {
        uint amount = msg.value;
        require(amount > 0);

        _addPurchaser(msg.sender);
        var (buyTokens, bonusTokens) = _getTokenCount(amount);
        uint totalTokens = buyTokens + bonusTokens;

        amountRaised += amount;
        amountTokenIssued += totalTokens;

        purchasers[msg.sender].amountEtherSpent += amount;
        purchasers[msg.sender].amountTokenTaken += totalTokens;

        emit TokenPurchase(msg.sender, amount, buyTokens, bonusTokens);

        // Lock bonus tokens
        for (uint i = 0; i < lockStages.length; i++) {
            purchasers[msg.sender].lockedToken[i] += bonusTokens / lockStages.length;
        }

        beneficiary.transfer(amount);
    }

    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        int stage = getCurrentStage();
        require(stage != -1);

        uint baseTokens = amountInWei * rate * icoStages[uint(stage)].rate / 100;
        uint bonusTokens = baseTokens * (icoStages[uint(stage)].rate - 100) / 100;

        return (baseTokens, bonusTokens);
    }

    function safeWithdrawal() public onlyOwner {
        require(isReachedGoal());
        beneficiary.transfer(amountRaised);
        emit FundingWithdrawn(beneficiary, amountRaised);
    }

    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {
        require(canTokenUnlocked(stageIndex));
        require(purchaserEndIdx <= purchaserList.length);

        for (uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
            address purchaser = purchaserList[i];
            uint tokensToUnlock = purchasers[purchaser].lockedToken[stageIndex];
            if (tokensToUnlock > 0) {
                purchasers[purchaser].lockedToken[stageIndex] -= tokensToUnlock;
                purchasers[purchaser].amountTokenTaken -= tokensToUnlock;
                amountTokenIssued -= tokensToUnlock;

                require(token.transferFrom(tokenHolder, purchaser, tokensToUnlock));
                emit UnlockToken(purchaser, tokensToUnlock);
            }
        }
    }
}
```

This contract includes all the necessary functions and modifiers to manage a crowd sale with multiple stages, bonuses, and token locking. Make sure to adjust the `_initStages` function to reflect the actual stages and conditions of your specific crowd sale.