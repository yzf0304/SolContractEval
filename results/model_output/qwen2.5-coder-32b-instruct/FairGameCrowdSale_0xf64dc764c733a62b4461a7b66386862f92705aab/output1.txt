Below is the complete implementation of the `CrowdSale` contract based on the provided context and specifications. The implementation includes all necessary functions and modifiers, with the assumption that the compiler version is 0.4.18:

```solidity
pragma solidity ^0.4.18;

contract ERC20 {
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}

contract Ownable {
    address public owner;

    event OwnerChanged(address oldOwner, address newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != owner && newOwner != address(0x0));
        address oldOwner = owner;
        owner = newOwner;
        OwnerChanged(oldOwner, newOwner);
    }
}

contract CrowdSale is Ownable {
    ERC20 public token;
    address public beneficiary;
    address public tokenHolder;
    uint public rate;
    uint public amountGoal;
    uint public amountRaised;
    uint public amountTokenIssued;
    uint public startTime;
    uint public endTime;

    struct Stage {
        uint duration;      
        uint rate;          
    }
    Stage[] public icoStages;
    Stage[] public lockStages;

    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted());
        require(!isEnded());
        _;
    }

    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    function _initStages() internal {
        // Sample initialization of icoStages and lockStages. 
        // Customize these values as needed.
        icoStages.push(Stage(2592000, 150));  // 30 days with 50% bonus
        icoStages.push(Stage(2592000, 125));  // 30 days with 25% bonus
        lockStages.push(Stage(7776000, 0));    // 90 days lock
        lockStages.push(Stage(7776000, 0));    // 90 days lock
    }

    function getTokenAddress() public view returns(address) {
        return token;
    }

    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        require(lockStages.length > stageIndex);
        uint lockEndTime = endTime + (stageIndex + 1) * lockStages[stageIndex].duration;
        return now > lockEndTime;
    }

    function isStarted() public view returns(bool) {
        return startTime > 0 && now >= startTime;
    }

    function isReachedGoal() public view returns(bool) {
        return amountRaised >= amountGoal;
    }

    function isEnded() public view returns(bool) {
        return endTime > 0 && (now > endTime || isReachedGoal());
    }

    function getCurrentStage() public view returns(int) {
        if (!isStarted()) return -1;
        if (isEnded()) return int(icoStages.length);

        uint elapsedTime = now - startTime;
        uint sumDuration = 0;
        for (uint i = 0; i < icoStages.length; i++) {
            sumDuration += icoStages[i].duration;
            if (elapsedTime < sumDuration) return int(i);
        }
        return int(icoStages.length);
    }

    function getRemainingTimeInSecond() public view returns(uint) {
        if (!isStarted()) return 0;
        if (isEnded()) return 0;
        return endTime - now;
    }

    function _addPurchaser(address purchaser) internal {
        if (purchasers[purchaser].amountEtherSpent == 0) {
            purchaserList.push(purchaser);
        }
    }

    function start(uint fundingGoalInEther) public onlyOwner {
        require(startTime == 0); // Sale has not started
        require(fundingGoalInEther > 0);

        amountGoal = fundingGoalInEther * 1 ether;
        startTime = now;
        endTime = now + icoStages[icoStages.length - 1].duration;
    }

    function stop() public onlyOwner {
        require(startTime > 0 && !isEnded()); // Sale started but has not ended
        endTime = now;
    }

    function () payable public onlyOpenTime {
        require(msg.value > 0);

        uint currentStageIdx = uint(getCurrentStage());
        require(currentStageIdx < icoStages.length); // Sale is still ongoing

        uint buyTokenCount;
        uint bonusTokenCount;

        (buyTokenCount, bonusTokenCount) = _getTokenCount(msg.value);

        uint totalTokens = buyTokenCount + bonusTokenCount;
        require(totalTokens > 0); // At least one token should be issued

        // Lock the bonus tokens
        purchasers[msg.sender].lockedToken.push(bonusTokenCount);

        // Update purchaser info
        purchasers[msg.sender].amountEtherSpent += msg.value;
        purchasers[msg.sender].amountTokenTaken += buyTokenCount;

        // Update totals
        amountRaised += msg.value;
        amountTokenIssued += totalTokens;

        // Log purchase
        TokenPurchase(msg.sender, msg.value, buyTokenCount, bonusTokenCount);

        // Add to purchaser list if it's first time
        _addPurchaser(msg.sender);

        // Forward the ETH to the beneficiary
        beneficiary.transfer(msg.value);

        if (isReachedGoal()) {
            GoalReached(amountRaised, amountTokenIssued);
        }
    }

    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        int currentStageIdx = getCurrentStage();
        require(currentStageIdx >= 0 && uint(currentStageIdx) < icoStages.length);

        uint totalRate = rate * icoStages[uint(currentStageIdx)].rate / 100;
        buyTokenCount = amountInWei * totalRate;
        bonusTokenCount = buyTokenCount / icoStages[uint(currentStageIdx)].rate;
    }

    function safeWithdrawal() public onlyOwner {
        require(isEnded()); // Sale has ended

        // Transfer the remaining balance to the beneficiary
        beneficiary.transfer(this.balance);
        FundingWithdrawn(beneficiary, this.balance);
    }

    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {
        require(lockStages.length > stageIndex);
        require(canTokenUnlocked(stageIndex));
        require(purchaserStartIdx <= purchaserEndIdx && purchaserEndIdx <= purchaserList.length);

        for (uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
            address purchaser = purchaserList[i];

            uint amountUnlockedTokens = purchasers[purchaser].lockedToken[stageIndex];
            if (amountUnlockedTokens > 0) {
                // Transfer tokens to the purchaser
                require(token.transferFrom(tokenHolder, purchaser, amountUnlockedTokens));

                // Update purchaser info
                purchasers[purchaser].amountTokenTaken += amountUnlockedTokens;
                purchasers[purchaser].lockedToken[stageIndex] = 0;

                // Emit event
                UnlockToken(purchaser, amountUnlockedTokens);
            }
        }
    }
}
```

### Key Features Implemented:
- **CrowdSale Lifecycle:** The contract manages the lifecycle of the crowd sale, including starting, stopping, and checking whether the sale is ongoing.
- **Token Purchase:** Allows participants to buy tokens by sending Ether, which are calculated based on the current rate.
- **Bonus Tokens:** Provides bonuses depending on the stage during which tokens are purchased.
- **Token Locking/Unlocking:** Supports locking tokens during certain stages and unlocking them when the locking period ends.
- **Funding Withdrawal:** Enables the owner to withdraw funds once the campaign ends.
- **Modularity:** The `_initStages()` function allows for customization of the stages and rates before the sale begins.

### Usage:
- Deploy the `CrowdSale` contract by providing the addresses of the beneficiary, token holder, and token contract, along with the initial rate of tokens per Wei.
- Start the sale by calling `start()`, specifying the funding goal in Ether.
- Participants can contribute by sending Ether directly to the contract.
- After the sale, the owner can withdraw the collected funds and unlock bonus tokens for contributors as per the defined lock stages.