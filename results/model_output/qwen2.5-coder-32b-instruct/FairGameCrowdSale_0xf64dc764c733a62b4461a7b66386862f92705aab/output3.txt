Certainly! Below is the completed `CrowdSale` contract based on your requirements and using the Solidity version `0.4.18`. The contract includes all necessary functions and modifiers to manage a crowd sale with multiple stages, different bonuses, and token locking/unlocking.

```solidity
contract CrowdSale is Ownable {
    ERC20 public token;
    address public beneficiary;
    address public tokenHolder;

    uint public rate;
    uint public amountGoal;
    uint public amountRaised;
    uint public amountTokenIssued;

    uint public startTime;
    uint public endTime;

    struct Stage {
        uint duration;      // Duration in seconds of the current stage
        uint rate;          // Bonus rate (100 = 100%)
    }
    Stage[] public icoStages;
    Stage[] public lockStages;

    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted());
        require(!isEnded());
        _;
    }

    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    function _initStages() internal {
        // Example initialization, can be replaced as per actual ICO stages
        icoStages.push(Stage({duration: 2 weeks, rate: 120}));
        icoStages.push(Stage({duration: 1 weeks, rate: 110}));
        icoStages.push(Stage({duration: 1 weeks, rate: 100}));

        // Example lock stages initialization, can be replaced as per actual lock stages
        lockStages.push(Stage({duration: 3 months, rate: 0})); // Lock tokens for 3 months
        lockStages.push(Stage({duration: 3 months, rate: 0})); // Release 1/3 tokens after 3 months
        lockStages.push(Stage({duration: 3 months, rate: 0})); // Release 1/3 tokens after 6 months
        lockStages.push(Stage({duration: 3 months, rate: 0})); // Release last 1/3 tokens after 9 months
    }

    function getTokenAddress() public view returns(address) {
        return token;
    }

    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        require(stageIndex < lockStages.length);
        uint stageEndTime = endTime + lockStages[stageIndex].duration;
        return now >= stageEndTime;
    }

    function isStarted() public view returns(bool) {
        return now >= startTime;
    }

    function isReachedGoal() public view returns(bool) {
        return amountRaised >= amountGoal;
    }

    function isEnded() public view returns(bool) {
        return now > endTime || amountRaised >= amountGoal;
    }

    function getCurrentStage() public view returns(int) {
        if (!isStarted()) {
            return -1;
        }
        if (now > endTime) {
            return int(icoStages.length);
        }
        uint timePassed = now - startTime;
        uint totalDuration = 0;
        for (uint i = 0; i < icoStages.length; i++) {
            totalDuration += icoStages[i].duration;
            if (timePassed < totalDuration) {
                return int(i);
            }
        }
        return int(icoStages.length);
    }

    function getRemainingTimeInSecond() public view returns(uint) {
        if (!isStarted() || isEnded()) {
            return 0;
        }
        return endTime - now;
    }

    function _addPurchaser(address purchaser) internal {
        if (purchasers[purchaser].amountEtherSpent == 0) {
            purchaserList.push(purchaser);
        }
    }

    function start(uint fundingGoalInEther) public onlyOwner {
        require(startTime == 0);
        startTime = now;
        endTime = startTime + 8 weeks; // Example end time
        amountGoal = fundingGoalInEther * 1 ether;
    }

    function stop() public onlyOwner {
        require(startTime > 0);
        endTime = now;
    }

    function () payable public onlyOpenTime {
        require(msg.value > 0);

        uint currentStageIdx = getCurrentStage();
        require(currentStageIdx >= 0 && currentStageIdx < int(icoStages.length));

        var (buyTokenCount, bonusTokenCount) = _getTokenCount(msg.value, uint(currentStageIdx));
        uint totalTokens = buyTokenCount + bonusTokenCount;
        require(totalTokens > 0);

        token.transferFrom(tokenHolder, msg.sender, totalTokens);
        purchasers[msg.sender].amountEtherSpent += msg.value;
        purchasers[msg.sender].amountTokenTaken += totalTokens;

        _addPurchaser(msg.sender);

        amountRaised += msg.value;
        amountTokenIssued += totalTokens;

        if (isReachedGoal()) {
            GoalReached(amountRaised, amountTokenIssued);
        }

        TokenPurchase(msg.sender, msg.value, buyTokenCount, bonusTokenCount);
    }

    function _getTokenCount(uint amountInWei, uint stageIdx) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        buyTokenCount = amountInWei * rate;
        bonusTokenCount = buyTokenCount * icoStages[stageIdx].rate / 100 - buyTokenCount;
        return (buyTokenCount, bonusTokenCount);
    }

    function safeWithdrawal() public onlyOwner {
        require(isReachedGoal());
        beneficiary.transfer(amountRaised);
        FundingWithdrawn(beneficiary, amountRaised);
    }

    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {
        require(stageIndex < lockStages.length);
        require(purchaserStartIdx < purchaserList.length);
        require(purchaserEndIdx <= purchaserList.length);
        require(purchaserStartIdx <= purchaserEndIdx);

        if (canTokenUnlocked(stageIndex)) {
            uint tokensToUnlockPerPurchaser = icoStages[getCurrentStage()].rate * amountGoal / (lockStages.length * 100); // Example logic

            for (uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
                address purchaser = purchaserList[i];
                if (purchasers[purchaser].lockedToken.length > stageIndex && purchasers[purchaser].lockedToken[stageIndex] > 0) {
                    uint unlockAmount = tokensToUnlockPerPurchaser; // Simplified logic for unlocking tokens
                    purchasers[purchaser].amountTokenTaken += unlockAmount;
                    purchasers[purchaser].lockedToken[stageIndex] -= unlockAmount;
                    token.transferFrom(tokenHolder, purchaser, unlockAmount);
                    UnlockToken(purchaser, unlockAmount);
                }
            }
        } else {
            revert("Tokens cannot be unlocked yet.");
        }
    }
}
```

### Key Points:
- **Initialization**: The `_initStages` method initializes example ICO and lock stages. You should replace these with actual durations and rates.
- **Token Purchase**: The fallback function allows buyers to send Ether to receive tokens. It calculates the number of tokens including bonuses based on the current stage.
- **Unlocking Tokens**: The `unlockBonusTokens` method unlocks tokens for purchasers at specific stages once those stages end.
- **Event Emissions**: Various events are emitted for critical actions like token purchases, reaching the funding goal, and unlocking tokens.
- **Security Considerations**: The contract uses modifiers to enforce restrictions, such as allowing withdrawals only after goals are met and enabling token unlocking only when applicable.

Make sure to review and modify the example logic for calculating and unlocking tokens as per your specific requirements.