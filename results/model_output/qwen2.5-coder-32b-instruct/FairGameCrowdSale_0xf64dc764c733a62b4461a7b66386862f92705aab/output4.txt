Below is the completed `CrowdSale` contract implementation based on the provided description and context. This implementation includes all necessary functions and logic to manage a crowdsale with stages, bonus tokens, and token locking/unlocking mechanics.

```solidity
pragma solidity ^0.4.18;

contract ERC20 {
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function balanceOf(address who) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
}

contract Ownable {
    address public owner;

    event OwnerChanged(address oldOwner, address newOwner);

    function Ownable() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != owner && newOwner != address(0x0));
        address oldOwner = owner;
        owner = newOwner;
        OwnerChanged(oldOwner, newOwner);
    }
}

contract CrowdSale is Ownable {
    ERC20 public token;
    address public beneficiary;
    address public tokenHolder;

    uint public rate;
    uint public amountGoal;
    uint public amountRaised;
    uint public amountTokenIssued;

    uint public startTime;
    uint public endTime;

    struct Stage {
        uint duration; 
        uint rate; 
    }
    Stage[] public icoStages;
    Stage[] public lockStages;

    struct PurchaserInfo {
        uint amountEtherSpent;
        uint amountTokenTaken;
        uint[] lockedToken;
    }
    mapping(address => PurchaserInfo) public purchasers;
    address[] public purchaserList;

    event TokenPurchase(address purchaser, uint value, uint buyTokens, uint bonusTokens);
    event GoalReached(uint totalAmountRaised, uint totalTokenIssued);
    event FundingWithdrawn(address beneficiaryAddress, uint value);
    event UnlockToken(address purchaser, uint amountUnlockedTokens);

    modifier afterEnded {
        require(isEnded());
        _;
    }

    modifier onlyOpenTime {
        require(isStarted());
        require(!isEnded());
        _;
    }

    function CrowdSale(address beneficiaryAddr, address tokenHolderAddr, address tokenAddr, uint tokenRate) public {
        require(beneficiaryAddr != address(0));
        require(tokenHolderAddr != address(0));
        require(tokenAddr != address(0));
        require(tokenRate > 0);

        beneficiary = beneficiaryAddr;
        tokenHolder = tokenHolderAddr;
        token = ERC20(tokenAddr);
        rate = tokenRate;

        _initStages();
    }

    function _initStages() internal {
        // Example initialization of stages. Modify as needed.
        icoStages.push(Stage(3 days, 120)); // First stage: 3 days, 120% bonus
        icoStages.push(Stage(2 days, 110)); // Second stage: 2 days, 110% bonus
        lockStages.push(Stage(30 days, 0)); // First lock period: 30 days
        lockStages.push(Stage(60 days, 0)); // Second lock period: 60 days
    }

    function getTokenAddress() public view returns(address) {
        return address(token);
    }

    function getLockedToken(address _purchaser, uint stageIdx) public view returns(uint) {
        return purchasers[_purchaser].lockedToken[stageIdx];
    }

    function canTokenUnlocked(uint stageIndex) public view returns(bool) {
        require(stageIndex < lockStages.length);
        uint stageStartTime = endTime + getLockStageStartTime(stageIndex);
        return now >= stageStartTime + lockStages[stageIndex].duration;
    }

    function isStarted() public view returns(bool) {
        return now >= startTime && now <= endTime;
    }

    function isReachedGoal() public view returns(bool) {
        return amountRaised >= amountGoal;
    }

    function isEnded() public view returns(bool) {
        return now > endTime || isReachedGoal();
    }

    function getCurrentStage() public view returns(int) {
        if (!isStarted()) return -1;
        uint elapsedTime = now - startTime;
        uint totalTime = 0;
        for(uint i = 0; i < icoStages.length; i++) {
            totalTime += icoStages[i].duration;
            if (elapsedTime < totalTime) return int(i);
        }
        return int(icoStages.length - 1);
    }

    function getRemainingTimeInSecond() public view returns(uint) {
        if (now >= endTime) return 0;
        return endTime - now;
    }

    function _addPurchaser(address purchaser) internal {
        if (purchasers[purchaser].amountEtherSpent == 0) {
            purchaserList.push(purchaser);
        }
    }

    function start(uint fundingGoalInEther) public onlyOwner {
        require(startTime == 0);
        startTime = now;
        endTime = startTime + getTotalIcoDuration();
        amountGoal = fundingGoalInEther * 1 ether;
    }

    function stop() public onlyOwner {
        endTime = now;
    }

    function () payable public onlyOpenTime {
        require(msg.value > 0);
        _addPurchaser(msg.sender);
        uint tokensToSend = msg.value * rate;
        uint bonusTokens = 0;
        int stageIdx = getCurrentStage();
        if (stageIdx >= 0) {
            bonusTokens = tokensToSend * (icoStages[uint(stageIdx)].rate - 100) / 100;
        }
        uint totalTokens = tokensToSend + bonusTokens;
        require(token.balanceOf(tokenHolder) >= totalTokens);
        
        purchasers[msg.sender].amountEtherSpent += msg.value;
        purchasers[msg.sender].amountTokenTaken += totalTokens;
        if (bonusTokens > 0) {
            for(uint i = 0; i < lockStages.length; i++) {
                purchasers[msg.sender].lockedToken.push(bonusTokens / lockStages.length);
            }
        }
        token.transferFrom(tokenHolder, msg.sender, totalTokens);
        amountRaised += msg.value;
        amountTokenIssued += totalTokens;
        TokenPurchase(msg.sender, msg.value, tokensToSend, bonusTokens);
        checkGoalReached();
    }

    function _getTokenCount(uint amountInWei) internal view returns(uint buyTokenCount, uint bonusTokenCount) {
        buyTokenCount = amountInWei * rate;
        int stageIdx = getCurrentStage();
        if (stageIdx >= 0) {
            bonusTokenCount = buyTokenCount * (icoStages[uint(stageIdx)].rate - 100) / 100;
        } else {
            bonusTokenCount = 0;
        }
    }

    function safeWithdrawal() public onlyOwner {
        if (!isReachedGoal()) revert();
        beneficiary.transfer(amountRaised);
        FundingWithdrawn(beneficiary, amountRaised);
    }

    function unlockBonusTokens(uint stageIndex, uint purchaserStartIdx, uint purchaserEndIdx) public afterEnded onlyOwner {
        require(canTokenUnlocked(stageIndex));
        require(purchaserEndIdx <= purchaserList.length);
        for(uint i = purchaserStartIdx; i < purchaserEndIdx; i++) {
            address purchaser = purchaserList[i];
            uint lockedTokenAmount = purchasers[purchaser].lockedToken[stageIndex];
            if (lockedTokenAmount > 0) {
                purchasers[purchaser].lockedToken[stageIndex] = 0;
                purchasers[purchaser].amountTokenTaken += lockedTokenAmount;
                token.transferFrom(tokenHolder, purchaser, lockedTokenAmount);
                amountTokenIssued += lockedTokenAmount;
                UnlockToken(purchaser, lockedTokenAmount);
            }
        }
    }

    function getTotalIcoDuration() internal view returns(uint) {
        uint total = 0;
        for(uint i = 0; i < icoStages.length; i++) {
            total += icoStages[i].duration;
        }
        return total;
    }

    function getLockStageStartTime(uint stageIndex) internal view returns(uint) {
        require(stageIndex < lockStages.length);
        uint total = 0;
        for(uint i = 0; i < stageIndex; i++) {
            total += lockStages[i].duration;
        }
        return total;
    }

    function checkGoalReached() internal {
        if (amountRaised >= amountGoal) {
            GoalReached(amountRaised, amountTokenIssued);
        }
    }
}
```

This contract follows the structure and functionalities described in your comments, including handling multiple stages of the ICO with different rates and bonus percentages, tracking and unlocking of bonus tokens according to predefined schedules, and ensuring security measures like only allowing the owner to start/stop the sale and withdraw funds when the goal is reached.