Below is the complete and functional implementation of the `GCUToken` contract adhering to the provided specification. Note that I've implemented the `SafeMath` library within the contract since it is not included in your provided context but is typically necessary for safe arithmetic operations in Solidity.

```solidity
pragma solidity ^0.4.26;

contract SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b > 0);
        uint256 c = a / b;
        return c;
    }
}

contract ERC223Interface {
    uint public totalSupply_;
    function balanceOf(address who) view returns (uint);
    function transfer(address to, uint value) returns (bool);
    function transfer(address to, uint value, bytes data) returns (bool);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data) public {}
}

/**
 * @title GCUToken
 * @dev This contract implements the ERC20 and ERC223 token standards.
 * It includes functionalities for transferring tokens, approving token transfers,
 * and handling token transfers to contracts that implement the `tokenFallback` function.
 */
contract GCUToken is ERC223Interface {
    using SafeMath for uint256;

    /* Contract Constants */
    string public constant _name = "Global Currency Unit";
    string public constant _symbol = "GCU";
    uint8 public constant _decimals = 18;

    /* Contract Variables */
    address public owner;
    uint256 public totalSupply_;

    mapping(address => uint256) public balances;
    mapping(address => mapping (address => uint256)) public allowed;

    /* Constructor initializes the owner's balance and the supply  */
    constructor (uint256 _amount, address _initialWallet) public {
        owner = _initialWallet;
        totalSupply_ = _amount * (uint256(10) ** _decimals);
        balances[_initialWallet] = totalSupply_;

        emit Transfer(address(0), _initialWallet, totalSupply_);
    }

    /* ERC223 Events */
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
    event Approval(address indexed from, address indexed to, uint256 value);

    /**
     * @notice Returns the total number of tokens in existence.
     * @dev This function returns the total supply of tokens.
     * @return The total supply of tokens.
     */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @notice Returns the balance of the specified address.
     * @dev This function returns the balance of the `_address`.
     * @param _address The address whose balance will be returned.
     * @return The balance of the `_address`.
     */
    function balanceOf(address _address) public view returns (uint256 balance) {
        return balances[_address];
    }

    /**
     * @notice Transfers the specified amount of tokens to the specified address.
     * @dev This function transfers `_value` tokens from the sender to `_to`.
     * If `_to` is a contract, it invokes the `tokenFallback` function.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @return A boolean indicating if the transfer was successful.
     */
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        if(isContract(_to)) {
            ContractReceiver receiver = ContractReceiver(_to);
            receiver.tokenFallback(msg.sender, _value, new bytes(0));
        }

        emit Transfer(msg.sender, _to, _value, new bytes(0));

        return true;
    }

    /**
     * @notice Transfers the specified amount of tokens from one address to another.
     * @dev This function transfers `_value` tokens from `_from` to `_to` on behalf of the sender.
     * @param _from The address to transfer tokens from.
     * @param _to The address to transfer tokens to.
     * @param _value The amount of tokens to transfer.
     * @return A boolean indicating if the transfer was successful.
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(allowed[_from][msg.sender] >= _value);

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        emit Transfer(_from, _to, _value);

        return true;
    }

    /**
     * @notice Approves the specified address to spend a certain amount of tokens on behalf of the sender.
     * @dev This function sets the allowance for `_spender` to spend `_allowance` tokens on behalf of the sender.
     * @param _spender The address that will be approved to spend tokens.
     * @param _allowance The amount of tokens that can be spent.
     * @return A boolean indicating if the approval was successful.
     */
    function approve(address _spender, uint256 _allowance) public returns (bool success) {
        allowed[msg.sender][_spender] = _allowance;
        emit Approval(msg.sender, _spender, _allowance);
        return true;
    }

    /**
     * @notice Returns the remaining allowance for a spender.
     * @dev This function returns the remaining allowance for `_spender` to spend on behalf of `_owner`.
     * @param _owner The address that set the allowance.
     * @param _spender The address that can spend the tokens.
     * @return The remaining allowance.
     */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * @notice Returns the name of the token.
     * @dev This function returns the token name.
     * @return The name of the token.
     */
    function name() public view returns (string name) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @dev This function returns the token symbol.
     * @return The symbol of the token.
     */
    function symbol() public view returns (string symbol) {
        return _symbol;
    }

    /**
     * @notice Returns the number of decimals used by the token.
     * @dev This function returns the number of decimals.
     * @return The number of decimals.
     */
    function decimals() public view returns (uint8 decimals) {
        return _decimals;
    }

    /**
     * @notice Transfers the specified amount of tokens to the specified address with additional data.
     * @dev This function transfers `_value` tokens from the sender to `_to` and passes `_data` to the recipient.
     * If `_to` is a contract, it invokes the `tokenFallback` function.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @param _data Additional data to pass to the recipient.
     * @return A boolean indicating if the transfer was successful.
     */
    function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        if(isContract(_to)) {
            ContractReceiver receiver = ContractReceiver(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }

        emit Transfer(msg.sender, _to, _value, _data);

        return true;
    }

    /**
     * @dev Internal function to transfer tokens to a regular address.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @param _data Additional data to pass to the recipient.
     * @return A boolean indicating if the transfer was successful.
     */
    function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }

    /**
     * @dev Internal function to transfer tokens to a contract address.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @param _data Additional data to pass to the recipient.
     * @return A boolean indicating if the transfer was successful.
     */
    function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) {
        transferToAddress(_to, _value, _data);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        return true;
    }

    /**
     * @dev Checks if the given address is a contract.
     * @param _address The address to check.
     * @return A boolean indicating if the address is a contract.
     */
    function isContract(address _address) internal view returns (bool is_contract) {
        uint256 length;
        assembly { length := extcodesize(_address) }
        return length > 0;
    }

    /**
     * @dev Prevents any attempt to send Ether to this contract.
     */
    function () public payable {
        revert();
    }
}
```

This contract implements both ERC20 and ERC223 standards, providing token transfer functionality with and without additional data. It includes SafeMath operations to prevent overflows and underflows during arithmetic operations, which is crucial for maintaining integrity in financial transactions. The `isContract` function checks if an address is a contract by checking the bytecode size at the given address. The contract also contains the fallback function that reverts transactions if Ether is sent directly to the contract address.