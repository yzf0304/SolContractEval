Here is the complete implementation of the `GCUToken` contract adhering to ERC20 and ERC223 standards using Solidity version 0.4.26. I've filled in the missing functions and added necessary imports and definitions. Note that since Solidity 0.4.26 does not support the `SafeMath` library by default, you'll need to define it yourself or import it from a reliable source if available.

```solidity
pragma solidity ^0.4.26;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }
        uint256 c = a * b;
        assert(c / a == b);
        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        // assert(b > 0); // Solidity automatically throws when dividing by 0
        uint256 c = a / b;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold
        return c;
    }
}


contract ERC223Interface {
    uint public totalSupply_;
    function balanceOf(address who) view returns (uint);
    function transfer(address to, uint value) returns (bool);
    function transfer(address to, uint value, bytes data)  returns (bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}

contract ContractReceiver {
    function tokenFallback(address _from, uint _value, bytes _data) public {
        _from;
        _value;
        _data;
    }
}

/**
 * @title GCUToken
 * @dev This contract implements the ERC20 and ERC223 token standards.
 * It includes functionalities for transferring tokens, approving token transfers,
 * and handling token transfers to contracts that implement the `tokenFallback` function.
 */
contract GCUToken is ERC223Interface {
    using SafeMath for uint256;

    /* Contract Constants */
    string public constant _name = "Global Currency Unit";
    string public constant _symbol = "GCU";
    uint8 public constant _decimals = 18;

    /* Contract Variables */
    address public owner;
    uint256 public totalSupply_;

    mapping(address => uint256) public balances;
    mapping(address => mapping (address => uint256)) public allowed;

    /* Constructor initializes the owner's balance and the supply  */
    function GCUToken(uint256 _amount, address _initialWallet) public {
        owner = _initialWallet;
        totalSupply_ = _amount.mul(uint256(10) ** _decimals);
        balances[_initialWallet] = totalSupply_;

        emit Transfer(address(0), _initialWallet, totalSupply_);
    }

    /* ERC20 Events */
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed from, address indexed to, uint256 value);

    /* ERC223 Events */
    event Transfer(address indexed from, address indexed to, uint value, bytes data);

    /**
     * @notice Returns the total number of tokens in existence.
     * @return The total supply of tokens.
     */
    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    /**
     * @notice Returns the balance of the specified address.
     * @param _address The address whose balance will be returned.
     * @return The balance of the `_address`.
     */
    function balanceOf(address _address) public view returns (uint256 balance) {
        return balances[_address];
    }

    /**
     * @notice Transfers the specified amount of tokens to the specified address.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @return A boolean indicating if the transfer was successful.
     */
    function transfer(address _to, uint _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        
        if(isContract(_to)) {
            bytes memory empty;
            ContractReceiver(_to).tokenFallback(msg.sender, _value, empty);
        }
        
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @notice Transfers the specified amount of tokens from one address to another.
     * @param _from The address to transfer tokens from.
     * @param _to The address to transfer tokens to.
     * @param _value The amount of tokens to transfer.
     * @return A boolean indicating if the transfer was successful.
     */
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[_from]);
        require(_value <= allowed[_from][msg.sender]);
        
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        
        if(isContract(_to)) {
            bytes memory empty;
            ContractReceiver(_to).tokenFallback(_from, _value, empty);
        }
        
        emit Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @notice Approves the specified address to spend a certain amount of tokens on behalf of the sender.
     * @param _spender The address that will be approved to spend tokens.
     * @param _allowance The amount of tokens that can be spent.
     * @return A boolean indicating if the approval was successful.
     */
    function approve(address _spender, uint256 _allowance) public returns (bool success) {
        allowed[msg.sender][_spender] = _allowance;
        emit Approval(msg.sender, _spender, _allowance);
        return true;
    }

    /**
     * @notice Returns the remaining allowance for a spender.
     * @param _owner The address that set the allowance.
     * @param _spender The address that can spend the tokens.
     * @return The remaining allowance.
     */
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    /**
     * @notice Returns the name of the token.
     * @return The name of the token.
     */
    function name() public view returns (string name) {
        return _name;
    }

    /**
     * @notice Returns the symbol of the token.
     * @return The symbol of the token.
     */
    function symbol() public view returns (string symbol) {
        return _symbol;
    }

    /**
     * @notice Returns the number of decimals used by the token.
     * @return The number of decimals.
     */
    function decimals() public view returns (uint8 decimals) {
        return _decimals;
    }

    /**
     * @notice Transfers the specified amount of tokens to the specified address with additional data.
     * @param _to The receiver address.
     * @param _value The amount of tokens to transfer.
     * @param _data Additional data to pass to the recipient.
     * @return A boolean indicating if the transfer was successful.
     */
    function transfer(address _to, uint _value, bytes _data) public returns (bool success) {
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        
        if(isContract(_to)) {
            ContractReceiver(_to).tokenFallback(msg.sender, _value, _data);
        }
        
        emit Transfer(msg.sender, _to, _value, _data);
        return true;
    }

    /**
     * @dev Internal function to check if the given address is a contract.
     * @param _address The address to check.
     * @return A boolean indicating if the address is a contract.
     */
    function isContract(address _address) internal returns (bool is_contract) {
        uint length;
        assembly { length := extcodesize(_address) }
        return length > 0;
    }

    /**
     * @dev Prevents any attempt to send Ether to this contract.
     */
    function () public payable {
        revert();
    }
}
```

This contract should compile and function correctly under Solidity 0.4.26, implementing the specified functionality for ERC20 and ERC223 token standards.