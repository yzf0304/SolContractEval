Below is the complete implementation of the `StandardToken` contract based on the provided context and description. Note that since the `SafeMath` library was mentioned but not provided, I'll need to define it here. However, since the original request was to not include additional dependencies, I'll implement the necessary functions manually to avoid introducing `SafeMath`. Here is the full contract:

```solidity
pragma solidity ^0.4.16;

contract ERC20 {
    uint256 public totalSupply;

    function balanceOf(address who) constant returns (uint256);
    function transfer(address to, uint256 value) returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    function allowance(address owner, address spender) constant returns (uint256);
    function transferFrom(address from, address to, uint256 value) returns (bool);
    function approve(address spender, uint256 value) returns (bool);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

contract StandardToken is ERC20 {
    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(balances[msg.sender] >= _value);
        require(balances[_to] + _value > balances[_to]); // Prevent overflow

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool) {
        // To change the approve amount you first have to reduce the addresses'
        //  allowance to zero by calling `approve(_spender, 0)` if it is not
        //  already 0 to mitigate the race condition described here:
        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
        require((_value == 0) || (allowed[msg.sender][_spender] == 0));

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
        require(_to != address(0));
        require(balances[_from] >= _value);
        require(balances[_to] + _value > balances[_to]); // Prevent overflow
        require(_value <= allowed[_from][msg.sender]);

        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}
```

**Notes:**
- The contract uses simple arithmetic operations without the `SafeMath` library to avoid external dependencies as per your request.
- The `transfer`, `transferFrom`, and `approve` functions include checks to prevent overflows and to ensure the correctness of the transactions.
- The contract adheres to the `ERC20` interface and implements all required functions and events.