Below is the complete implementation of the `HalloweenMinter` contract based on the provided description and context. This implementation includes the logic for minting NFTs with whitelist and public sale mechanisms, as well as the ability to configure various parameters by the owner.

```solidity
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

interface iNFTCollection {
    function externalMint(address _address, uint256 _amount) external payable;
    function totalSupply() external view returns (uint256);
    function balanceOf(address address_) external view returns (uint256);
    function ownerOf(uint256 tokenId_) external view returns (address);
    function tokensOfOwner(address _address) external view returns (uint256[] memory);
}

contract HalloweenMinter is Ownable {

    address public constant withdrawAddress = 0xdEcf4B112d4120B6998e5020a6B4819E490F7db6;
    iNFTCollection public NFTCollection = iNFTCollection(0x2d3C8D1A84cA778A3bba0F4fC389330AB96AF3Be); 

    uint256 public cost = 0;
    uint256 public maxSupply = 5000;
    uint256 public maxMintAmountPerTransaction = 3;
    uint256 public publicSaleMaxMintAmountPerAddress = 300;
    bool public paused = true;
    bool public onlyWhitelisted = true;
    bool public mintCount = true;
    mapping(address => uint256) public whitelistMintedAmount;
    mapping(address => uint256) public publicSaleMintedAmount;
    bytes32 public merkleRoot;

    /**
     * @notice Modifier to ensure that the function caller is an external user, not another contract.
     * @dev This modifier helps prevent reentrancy attacks and ensures that the function is called by an EOA.
     */
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract.");
        _;
    }

    /**
     * @notice Allows users to mint NFTs, with optional whitelisting and mint count restrictions.
     * @dev Users must provide a merkle proof if the contract is in the whitelist phase. The function checks various conditions before allowing the mint.
     * @param _mintAmount The number of NFTs to mint.
     * @param _maxMintAmount The maximum number of NFTs allowed for the user.
     * @param _merkleProof The merkle proof to verify the user's whitelist status.
     */
    function mint(uint256 _mintAmount, uint256 _maxMintAmount, bytes32[] calldata _merkleProof) public payable callerIsUser {
        require(!paused, "The contract is paused");
        require(msg.value >= cost * _mintAmount, "Insufficient funds provided");
        require(NFTCollection.totalSupply() + _mintAmount <= maxSupply, "Max supply exceeded");
        require(_mintAmount > 0 && _mintAmount <= maxMintAmountPerTransaction, "Invalid mint amount");

        if (onlyWhitelisted) {
            bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _maxMintAmount));
            require(MerkleProof.verify(_merkleProof, merkleRoot, leaf), "Not on whitelist or max mint amount reached for address");
            require(whitelistMintedAmount[msg.sender] + _mintAmount <= _maxMintAmount, "Exceeds max whitelist mint amount");
            whitelistMintedAmount[msg.sender] += _mintAmount;
        } else {
            require(publicSaleMintedAmount[msg.sender] + _mintAmount <= publicSaleMaxMintAmountPerAddress, "Exceeds max public mint amount");
            publicSaleMintedAmount[msg.sender] += _mintAmount;
        }

        NFTCollection.externalMint{value: msg.value}(msg.sender, _mintAmount);
    }

    /**
     * @notice Sets the maximum supply of NFTs.
     * @dev Only the contract owner can call this function.
     * @param _maxSupply The new maximum supply of NFTs.
     */
    function setMaxSupply(uint256 _maxSupply) public onlyOwner {
        maxSupply = _maxSupply;
    }

    /**
     * @notice Returns the total supply of NFTs.
     * @dev This function queries the NFT collection contract for the total supply.
     * @return The total supply of NFTs.
     */
    function totalSupply() public view returns(uint256) {
        return NFTCollection.totalSupply();
    }

    /**
     * @notice Sets the merkle root for the whitelist.
     * @dev Only the contract owner can call this function.
     * @param _merkleRoot The new merkle root for the whitelist.
     */
    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
        merkleRoot = _merkleRoot;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted per address during the public sale.
     * @dev Only the contract owner can call this function.
     * @param _publicSaleMaxMintAmountPerAddress The new maximum number of NFTs per address.
     */
    function setPublicSaleMaxMintAmountPerAddress(uint256 _publicSaleMaxMintAmountPerAddress) public onlyOwner {
        publicSaleMaxMintAmountPerAddress = _publicSaleMaxMintAmountPerAddress;
    }

    /**
     * @notice Sets the cost of minting one NFT.
     * @dev Only the contract owner can call this function.
     * @param _newCost The new cost of minting one NFT.
     */
    function setCost(uint256 _newCost) public onlyOwner {
        cost = _newCost;
    }

    /**
     * @notice Toggles whether only whitelisted addresses can mint NFTs.
     * @dev Only the contract owner can call this function.
     * @param _state The new state (true for only whitelisted, false for open to all).
     */
    function setOnlyWhitelisted(bool _state) public onlyOwner {
        onlyWhitelisted = _state;
    }

    /**
     * @notice Sets the maximum number of NFTs that can be minted in a single transaction.
     * @dev Only the contract owner can call this function.
     * @param _maxMintAmountPerTransaction The new maximum number of NFTs per transaction.
     */
    function setMaxMintAmountPerTransaction(uint256 _maxMintAmountPerTransaction) public onlyOwner {
        maxMintAmountPerTransaction = _maxMintAmountPerTransaction;
    }

    /**
     * @notice Pauses or unpauses the contract.
     * @dev Only the contract owner can call this function.
     * @param _state The new state (true for paused, false for unpaused).
     */
    function pause(bool _state) public onlyOwner {
        paused = _state;
    }

    /**
     * @notice Toggles whether the mint count should be enforced.
     * @dev Only the contract owner can call this function.
     * @param _state The new state (true for enforcing mint count, false for not enforcing).
     */
    function setMintCount(bool _state) public onlyOwner {
        mintCount = _state;
    }

    /**
     * @notice Sets the address of the NFT collection contract.
     * @dev Only the contract owner can call this function.
     * @param _address The new address of the NFT collection contract.
     */
    function setNFTCollection(address _address) public onlyOwner {
        NFTCollection = iNFTCollection(_address);
    }

    /**
     * @notice Withdraws the contract's balance to the specified withdrawal address.
     * @dev Only the contract owner can call this function.
     */
    function withdraw() public onlyOwner {
        payable(withdrawAddress).transfer(address(this).balance);
    }
}
```

This contract implements the required functionalities, including handling both whitelist and public sales, managing mint counts, and providing various administrative functions controlled by the owner.