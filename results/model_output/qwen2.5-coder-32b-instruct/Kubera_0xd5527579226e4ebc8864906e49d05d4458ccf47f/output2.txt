Below is the completed `Kubera` smart contract based on the provided context and description. It includes the necessary logic for ERC20 token standards along with the additional features such as the ICO management and the burn function. The contract has been written for Solidity compiler version 0.4.11:

```solidity
contract SafeMath {

    function safeMul(uint a, uint b) internal returns(uint) {
        uint c = a * b;
        assert(a == 0 || c / a == b);
        return c;
    }

    function safeSub(uint a, uint b) internal returns(uint) {
        assert(b <= a);
        return a - b;
    }

    function safeAdd(uint a, uint b) internal returns(uint) {
        uint c = a + b;
        assert(c >= a && c >= b);
        return c;
    }
}

contract Kubera is SafeMath {

    string public standard = 'ERC20';
    string public name = 'Kubera token';
    string public symbol = 'KBR';
    uint8 public decimals = 0;
    uint256 public totalSupply;
    address public owner;
    uint public tokensSoldToInvestors = 0;
    uint public maxGoalInICO = 2100000000;
    uint256 public startTime = 1510325999;
    bool burned;
    bool hasICOStarted;
    address tokensHolder = 0x94B4776F8331DF237E087Ed548A3c8b4932D131B;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event TransferToReferral(address indexed referralAddress, uint256 value);
    event Approval(address indexed Owner, address indexed spender, uint256 value);
    event Burned(uint amount);

    function Kubera() {
        owner = 0x084bf76c9ba9106d6114305fae9810fbbdb157d9;
        balanceOf[owner] = 2205000000;
        totalSupply      = 2205000000;
    }

    function transfer(address _to, uint256 _value) returns(bool success) {
        require(balanceOf[msg.sender] >= _value && _value > 0);
        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {
        require(allowance[_from][msg.sender] >= _value && balanceOf[_from] >= _value && _value > 0);
        
        if(now < startTime) {
            require(msg.sender == owner); // Only owner can transfer before ICO start
            if(_value > maxGoalInICO) { 
                uint extraTokens = safeSub(_value, maxGoalInICO);
                _value = maxGoalInICO; // Adjust value to max goal
                burn(); // Burn unsold tokens
            }
        } else {
            tokensSoldToInvestors = safeAdd(tokensSoldToInvestors, _value); // Track tokens sold during ICO
            require(tokensSoldToInvestors <= maxGoalInICO); // Ensure we do not exceed ICO goal
        }
        
        balanceOf[_from] = safeSub(balanceOf[_from], _value);
        balanceOf[_to] = safeAdd(balanceOf[_to], _value);
        allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn() {
        require(!burned && now >= startTime);
        uint remainingTokens = safeSub(balanceOf[owner], tokensSoldToInvestors);
        require(remainingTokens > 0);
        balanceOf[tokensHolder] = safeAdd(balanceOf[tokensHolder], remainingTokens); // Transfer to tokensHolder
        balanceOf[owner] = safeSub(balanceOf[owner], remainingTokens); // Reduce owner's balance
        Burned(remainingTokens);
        burned = true;
    }
}
```

This contract adheres to the described requirements and is suitable for deployment with Solidity version 0.4.11. Note that it includes the basic functionalities of an ERC20 token and extends them with specific ICO logic and token burning functionality.