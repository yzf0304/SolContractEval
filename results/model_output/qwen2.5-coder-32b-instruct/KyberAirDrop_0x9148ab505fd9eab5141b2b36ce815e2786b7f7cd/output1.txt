Below is the complete implementation of the `KyberGenesisToken` contract based on your provided specifications and context, suitable for Solidity version 0.4.15:

```solidity
contract Ownable {
  address public owner;

  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() {
    owner = msg.sender;
  }

  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
}

contract ERC20Interface {
  function transferFrom(address _from, address _to, uint _value) returns (bool){}
  function transfer(address _to, uint _value) returns (bool){}
}

contract KyberGenesisToken is Ownable {
  string  public  constant name     = "Kyber Genesis Token";
  string  public  constant symbol   = "KGT";
  uint    public  constant decimals = 0;

  uint                   public totalSupply = 0;
  mapping(address=>uint) public balanceOf;

  bool                   public mintingFinished = false;

  event Transfer(address indexed _from, address indexed _to, uint _value);
  event EndMinting(uint timestamp);

  function KyberGenesisToken(address minter) {
    transferOwnership(minter);
  }

  function mint(address[] recipients) onlyOwner {
    require(!mintingFinished);
    for(uint i = 0; i < recipients.length; i++) {
      require(recipients[i] != address(0));
      require(balanceOf[recipients[i]] == 0); // Ensures each recipient can only hold one token
      balanceOf[recipients[i]] = 1;
      totalSupply++;
      Transfer(address(this), recipients[i], 1);
    }
  }

  function endMinting() onlyOwner {
    require(!mintingFinished);
    mintingFinished = true;
    EndMinting(now);
  }

  function burn() {
    require(balanceOf[msg.sender] == 1);
    balanceOf[msg.sender] = 0;
    totalSupply--;
    Transfer(msg.sender, address(0), 1);
  }

  function emergencyERC20Drain(ERC20Interface token, uint amount) {
    require(token.transfer(owner, amount));
  }

  function transfer(address _to, uint _value) returns (bool) {
    revert(); // Not implemented
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool) {
    revert(); // Not implemented
  }

  function approve(address _spender, uint _value) returns (bool) {
    revert(); // Not implemented
  }

  function allowance(address _owner, address _spender) constant returns (uint) {
    return 0; // Always returns 0 as allowances are not implemented
  }

  event Approval(address indexed _owner, address indexed _spender, uint _value);
}
```

This contract includes all the required functionalities: minting tokens for specific recipients, ending the minting process, burning tokens, draining accidentally sent ERC20 tokens, and basic ERC20 method stubs that revert on calls. The contract also ensures that each address can only hold one token and prevents minting after the process has been ended.