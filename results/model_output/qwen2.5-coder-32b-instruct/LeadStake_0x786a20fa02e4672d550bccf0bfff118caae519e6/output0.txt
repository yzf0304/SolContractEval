Below is the complete implementation of the `LeadStake` contract based on your requirements and the provided context. This contract includes all the necessary functions and logic to handle staking, unstaking, rewards, and administrative tasks.

```solidity
/**
 * @title LeadStake
 * @notice A smart contract for staking LEAD tokens with various features like registration, staking, unstaking, and earning rewards.
 * @dev This contract includes a referral system, daily ROI, and tax mechanisms for staking and unstaking. It also allows the owner to manage certain parameters.
 */
contract LeadStake is Owned {
    
    using SafeMath for uint;

    //LEAD contract address
    address public lead;
    //total amount of staked lead
    uint public totalStaked;
    //tax rate for staking in percentage
    uint public stakingTaxRate;                     //10 = 1%
    //tax amount for registration
    uint public registrationTax;
    //daily return of investment in percentage
    uint public dailyROI;                         //100 = 1%
    //tax rate for unstaking in percentage 
    uint public unstakingTaxRate;                   //10 = 1%
    //minimum stakeable LEAD 
    uint public minimumStakeValue;
    //pause mechanism
    bool public active = true;
    
    //mapping of stakeholder's addresses to data
    mapping(address => uint) public stakes;
    mapping(address => uint) public referralRewards;
    mapping(address => uint) public referralCount;
    mapping(address => uint) public stakeRewards;
    mapping(address => uint) private lastClock;
    mapping(address => bool) public registered;
    
    //Events
    event OnWithdrawal(address sender, uint amount);
    event OnStake(address sender, uint amount, uint tax);
    event OnUnstake(address sender, uint amount, uint tax);
    event OnRegisterAndStake(address stakeholder, uint amount, uint totalTax , address _referrer);

    /**
     * @notice Initializes the contract with the provided parameters.
     * @param _token The address of the LEAD token.
     * @param _stakingTaxRate The tax rate for staking (10 = 1%).
     * @param _unstakingTaxRate The tax rate for unstaking (10 = 1%).
     * @param _dailyROI The daily return on investment (100 = 1%).
     * @param _registrationTax The registration tax amount.
     * @param _minimumStakeValue The minimum amount of LEAD that can be staked.
     */
    constructor(
        address _token,
        uint _stakingTaxRate, 
        uint _unstakingTaxRate,
        uint _dailyROI,
        uint _registrationTax,
        uint _minimumStakeValue) public {
            
        //set initial state variables
        lead = _token;
        stakingTaxRate = _stakingTaxRate;
        unstakingTaxRate = _unstakingTaxRate;
        dailyROI = _dailyROI;
        registrationTax = _registrationTax;
        minimumStakeValue = _minimumStakeValue;
    }
    
    //exclusive access for registered address
    modifier onlyRegistered() {
        require(registered[msg.sender] == true, "Stakeholder must be registered");
        _;
    }
    
    //exclusive access for unregistered address
    modifier onlyUnregistered() {
        require(registered[msg.sender] == false, "Stakeholder is already registered");
        _;
    }
        
    //make sure contract is active
    modifier whenActive() {
        require(active == true, "Smart contract is currently inactive");
        _;
    }

    /**
     * @dev Registers a new stakeholder and stakes LEAD tokens.
     * @param _amount Amount of LEAD to stake
     * @param _referrer Address of the referrer (optional)
     */
    function registerAndStake(uint _amount, address _referrer) external onlyUnregistered() whenActive() {
        require(_amount >= minimumStakeValue + registrationTax, "Insufficient amount for stake and registration tax");
        require(_referrer == address(0) || registered[_referrer], "Invalid referrer");

        uint totalTax = registrationTax;
        uint taxableAmount = _amount.sub(registrationTax);
        uint stakingTax = taxableAmount.mul(stakingTaxRate).div(1000);
        totalTax = totalTax.add(stakingTax);
        
        uint stakeAmount = taxableAmount.sub(stakingTax);
        
        if (_referrer != address(0)) {
            uint referralBonus = stakingTax.div(2); // Assume referrer gets 50% of staking tax
            referralRewards[_referrer] = referralRewards[_referrer].add(referralBonus);
            referralCount[_referrer] = referralCount[_referrer].add(1);
            stakingTax = stakingTax.sub(referralBonus);
        }
        
        require(IERC20(lead).transferFrom(msg.sender, address(this), _amount), "Failed to transfer tokens");

        registered[msg.sender] = true;
        lastClock[msg.sender] = block.timestamp;
        stakes[msg.sender] = stakes[msg.sender].add(stakeAmount);
        totalStaked = totalStaked.add(stakeAmount);
        
        emit OnRegisterAndStake(msg.sender, _amount, totalTax, _referrer);
    }

    /**
     * @notice Calculates the latest unclaimed earnings for a stakeholder.
     * @param _stakeholder The address of the stakeholder.
     * @return The calculated earnings.
     */
    function calculateEarnings(address _stakeholder) public view returns(uint) {
        uint stake = stakes[_stakeholder];
        if (stake == 0) return 0;

        uint elapsedTime = block.timestamp.sub(lastClock[_stakeholder]);
        uint dailyRate = dailyROI.div(86400); // Convert daily ROI to per second ROI
        uint earnings = stake.mul(dailyRate).mul(elapsedTime);

        return earnings;
    }

    /**
     * @dev Allows registered users to stake LEAD tokens with tax deductions.
     * @param _amount Amount of LEAD to stake
     */
    function stake(uint _amount) external onlyRegistered() whenActive() {
        require(_amount >= minimumStakeValue, "Amount less than minimum stake value");

        uint stakingTax = _amount.mul(stakingTaxRate).div(1000);
        uint stakeAmount = _amount.sub(stakingTax);

        require(IERC20(lead).transferFrom(msg.sender, address(this), _amount), "Failed to transfer tokens");

        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(calculateEarnings(msg.sender));
        lastClock[msg.sender] = block.timestamp;
        stakes[msg.sender] = stakes[msg.sender].add(stakeAmount);
        totalStaked = totalStaked.add(stakeAmount);

        emit OnStake(msg.sender, _amount, stakingTax);
    }

    /**
     * @dev Allows registered users to unstake LEAD tokens with tax deductions.
     * @param _amount Amount of LEAD to unstake
     */
    function unstake(uint _amount) external onlyRegistered() {
        require(_amount > 0 && _amount <= stakes[msg.sender], "Invalid amount to unstake");

        uint unstakingTax = _amount.mul(unstakingTaxRate).div(1000);
        uint amountToTransfer = _amount.sub(unstakingTax);

        stakeRewards[msg.sender] = stakeRewards[msg.sender].add(calculateEarnings(msg.sender));
        lastClock[msg.sender] = block.timestamp;

        stakes[msg.sender] = stakes[msg.sender].sub(_amount);
        totalStaked = totalStaked.sub(_amount);

        require(IERC20(lead).transfer(msg.sender, amountToTransfer), "Failed to transfer tokens");

        if (stakes[msg.sender] == 0) {
            registered[msg.sender] = false;
        }

        emit OnUnstake(msg.sender, _amount, unstakingTax);
    }

    /**
     * @dev Withdraws all accumulated rewards (referral + staking + earnings) to user's wallet.
     * @return success Boolean indicating successful withdrawal
     */
    function withdrawEarnings() external returns (bool success) {
        uint earnings = calculateEarnings(msg.sender);
        uint totalRewards = earnings.add(stakeRewards[msg.sender]).add(referralRewards[msg.sender]);

        require(totalRewards > 0, "No rewards to withdraw");

        referralRewards[msg.sender] = 0;
        stakeRewards[msg.sender] = 0;
        lastClock[msg.sender] = block.timestamp;

        require(IERC20(lead).transfer(msg.sender, totalRewards), "Failed to transfer tokens");

        emit OnWithdrawal(msg.sender, totalRewards);

        return true;
    }

    /**
     * @notice Views the current reward pool.
     * @dev Only the owner can call this function.
     * @return The claimable reward amount.
     */
    function rewardPool() external view onlyOwner() returns(uint claimable) {
        uint totalEarnings = 0;
        for (address _stakeholder in stakes.keys()) {
            totalEarnings = totalEarnings.add(calculateEarnings(_stakeholder));
        }
        return totalEarnings.add(stakeRewards.total()).add(referralRewards.total());
    }

    /**
     * @notice Pauses or starts the contract's functionalities.
     * @dev Only the owner can call this function.
     */
    function changeActiveStatus() external onlyOwner() {
        active = !active;
    }

    /**
     * @notice Sets the staking tax rate.
     * @dev Only the owner can call this function.
     * @param _stakingTaxRate The new staking tax rate.
     */
    function setStakingTaxRate(uint _stakingTaxRate) external onlyOwner() {
        stakingTaxRate = _stakingTaxRate;
    }

    /**
     * @notice Sets the unstaking tax rate.
     * @dev Only the owner can call this function.
     * @param _unstakingTaxRate The new unstaking tax rate.
     */
    function setUnstakingTaxRate(uint _unstakingTaxRate) external onlyOwner() {
        unstakingTaxRate = _unstakingTaxRate;
    }

    /**
     * @notice Sets the daily ROI.
     * @dev Only the owner can call this function.
     * @param _dailyROI The new daily ROI.
     */
    function setDailyROI(uint _dailyROI) external onlyOwner() {
        dailyROI = _dailyROI;
    }

    /**
     * @notice Sets the registration tax.
     * @dev Only the owner can call this function.
     * @param _registrationTax The new registration tax.
     */
    function setRegistrationTax(uint _registrationTax) external onlyOwner() {
        registrationTax = _registrationTax;
    }

    /**
     * @notice Sets the minimum stake value.
     * @dev Only the owner can call this function.
     * @param _minimumStakeValue The new minimum stake value.
     */
    function setMinimumStakeValue(uint _minimumStakeValue) external onlyOwner() {
        minimumStakeValue = _minimumStakeValue;
    }

    /**
     * @notice Withdraws '_amount' from the pool to the owner.
     * @dev Only the owner can call this function.
     * @param _amount The amount to withdraw.
     * @return True if the withdrawal is successful.
     */
    function filter(uint _amount) external onlyOwner returns (bool success) {
        require(_amount <= IERC20(lead).balanceOf(address(this)), "Insufficient balance");
        require(IERC20(lead).transfer(owner, _amount), "Failed to transfer tokens");
        return true;
    }
}
```

Please note that the `rewardPool()` function relies on `keys()` and `total()` methods which are not inherently available in Solidity mappings. These are placeholders for the sake of demonstration and should be replaced with appropriate logic to iterate over stakeholders and sum their rewards. In practice, you might need to maintain a list of stakeholders to implement these functionalities efficiently and securely.