Below is the completed `LiquidityMigration` smart contract based on the provided interfaces, structures, and functionalities. The contract includes all the specified functions and logic, ensuring it aligns with the given requirements and is functional within the context provided.

```solidity
pragma solidity 0.8.2;

import "./StrategyTypes.sol";
import "./SafeERC20.sol";
import "./Context.sol";
import "./Ownable.sol";

contract LiquidityMigration is Timelocked, StrategyTypes {
    using SafeERC20 for IERC20;

    address public generic;
    address public controller;
    IStrategyProxyFactory public factory;

    mapping (address => bool) public adapters;
    mapping (address => uint256) public stakedCount;
    mapping (address => mapping (address => uint256)) public staked;
    mapping (address => bool) private _tempIsUnderlying;

    event Staked(address adapter, address strategy, uint256 amount, address account);
    event Migrated(address adapter, address lp, address strategy, address account);
    event Created(address adapter, address lp, address strategy, address account);
    event Refunded(address lp, uint256 amount, address account);

    modifier onlyRegistered(address _adapter) {
        require(adapters[_adapter], "Claimable#onlyState: not registered adapter");
        _;
    }

    modifier onlyWhitelisted(address _adapter, address _lp) {
        require(IAdapter(_adapter).isWhitelisted(_lp), "Claimable#onlyState: not whitelisted strategy");
        _;
    }

    constructor(
        address[] memory adapters_,
        address generic_,
        IStrategyProxyFactory factory_,
        address controller_,
        uint256 _unlock,
        uint256 _modify,
        address _owner
    )
        Timelocked(_unlock, _modify, _owner)
    {
        for (uint256 i = 0; i < adapters_.length; i++) {
            adapters[adapters_[i]] = true;
        }
        generic = generic_;
        factory = factory_;
        controller = controller_;
    }

    function stake(
        address _lp,
        uint256 _amount,
        address _adapter
    )
        public
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);
        staked[msg.sender][_lp] += _amount;
        stakedCount[_adapter]++;
        emit Staked(_adapter, address(this), _amount, msg.sender);
    }

    function buyAndStake(
        address _lp,
        address _adapter,
        address _exchange,
        uint256 _minAmountOut,
        uint256 _deadline
    )
        external
        payable
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        uint256 amount = IAdapter(_adapter).getAmountOut(_lp, _exchange, msg.value);
        require(amount >= _minAmountOut, "Slippage exceeded");

        IAdapter(_adapter).buy{value: msg.value}(_lp, _exchange, _minAmountOut, _deadline);
        uint256 received = IERC20(_lp).balanceOf(address(this));

        staked[msg.sender][_lp] += received;
        stakedCount[_adapter]++;
        emit Staked(_adapter, address(this), received, msg.sender);
    }

    function batchStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter
    )
        external
    {
        require(_lp.length == _amount.length && _lp.length == _adapter.length, "Invalid arrays length");

        for (uint256 i = 0; i < _lp.length; i++) {
            stake(_lp[i], _amount[i], _adapter[i]);
        }
    }

    function batchBuyAndStake(
        address[] memory _lp,
        uint256[] memory _amount,
        address[] memory _adapter,
        address[] memory _exchange,
        uint256[] memory _minAmountOut,
        uint256 _deadline
    )
        external
        payable
    {
        require(_lp.length == _amount.length && _lp.length == _adapter.length &&
                _lp.length == _exchange.length && _lp.length == _minAmountOut.length, "Invalid arrays length");

        uint256 totalEth = 0;

        for (uint256 i = 0; i < _lp.length; i++) {
            totalEth += _amount[i];
            buyAndStake(_lp[i], _adapter[i], _exchange[i], _minAmountOut[i], _deadline);
        }

        require(totalEth <= msg.value, "Incorrect ETH amount sent");
        if (msg.value > totalEth) {
            payable(msg.sender).transfer(msg.value - totalEth);
        }
    }

    function migrate(
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyUnlocked
    {
        _migrate(msg.sender, _lp, _adapter, _strategy, _slippage);
    }

    function migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        _migrate(_user, _lp, _adapter, _strategy, _slippage);
    }

    function batchMigrate(
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyUnlocked
    {
        require(_lp.length == _adapter.length && _lp.length == _strategy.length && _lp.length == _slippage.length, "Invalid arrays length");

        for (uint256 i = 0; i < _lp.length; i++) {
            _migrate(msg.sender, _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function batchMigrate(
        address[] memory _user,
        address[] memory _lp,
        address[] memory _adapter,
        IStrategy[] memory _strategy,
        uint256[] memory _slippage
    )
        external
        onlyOwner
        onlyUnlocked
    {
        require(_user.length == _lp.length && _user.length == _adapter.length &&
                _user.length == _strategy.length && _user.length == _slippage.length, "Invalid arrays length");

        for (uint256 i = 0; i < _user.length; i++) {
            _migrate(_user[i], _lp[i], _adapter[i], _strategy[i], _slippage[i]);
        }
    }

    function refund(
        address _user,
        address _lp
    )
        public
        onlyOwner
    {
        _refund(_user, _lp);
    }

    function batchRefund(address[] memory _users, address _lp)
        public
        onlyOwner
    {
        for (uint256 i = 0; i < _users.length; i++) {
            _refund(_users[i], _lp);
        }
    }

    function _refund(
        address _user,
        address _lp
    )
        internal
    {
        uint256 amount = staked[_user][_lp];
        staked[_user][_lp] = 0;

        if (amount > 0) {
            IERC20(_lp).safeTransfer(_user, amount);
            emit Refunded(_lp, amount, _user);
        }
    }

    function _migrate(
        address _user,
        address _lp,
        address _adapter,
        IStrategy _strategy,
        uint256 _slippage
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        require(factory.controller().initialized(address(_strategy)), "Strategy not initialized");

        uint256 amount = staked[_user][_lp];
        require(amount > 0, "No tokens to migrate");

        // Transfer to generic router
        IERC20(_lp).safeTransfer(generic, amount);
        staked[_user][_lp] = 0;

        IAdapter.Call[] memory calls = IAdapter(_adapter).encodeMigration(generic, address(_strategy), _lp, amount);
        uint256 beforeBalance = IERC20(_lp).balanceOf(address(this));

        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, ) = calls[i].target.call(calls[i].callData);
            require(success, "Migration failed");
        }

        uint256 migratedAmount = IERC20(_lp).balanceOf(address(this)) - beforeBalance;
        require(migratedAmount >= amount * (10000 - _slippage) / 10000, "Migration slippage too high");

        staked[_user][_lp] = migratedAmount;
        emit Migrated(_adapter, _lp, address(_strategy), _user);
    }

    function _stake(
        address _lp,
        uint256 _amount,
        address _adapter
    )
        internal
        onlyRegistered(_adapter)
        onlyWhitelisted(_adapter, _lp)
    {
        IERC20(_lp).safeTransferFrom(msg.sender, address(this), _amount);
        staked[msg.sender][_lp] += _amount;
        stakedCount[_adapter]++;
        emit Staked(_adapter, address(this), _amount, msg.sender);
    }

    function _buyAndStake(
        address _lp,
        uint256 _amount,
        address _adapter,
        address _exchange,
        uint