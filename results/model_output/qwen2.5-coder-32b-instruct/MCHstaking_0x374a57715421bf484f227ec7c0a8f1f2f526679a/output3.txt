Below is the completed `MCHstaking` smart contract with all the functionalities defined according to your specifications:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

interface IERC20{
  function balanceOf(address account) external view returns (uint256);
  function transfer(address recipient, uint256 amount) external returns (bool);
  function allowance(address _owner, address spender) external view returns (uint256);
  function approve(address spender, uint256 amount) external returns (bool);
  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
}

interface contract2 {
    function claimRewards(address user) external returns(bool);
}

interface MCHstakingInterface {
    function stakingStats(address user) external view returns(uint256 amount, uint256 stakingBlock);
    function totalStaked() external view returns(uint256);
    function showBlackUser(address user) external view returns(bool);
    function allowance(address user) external view returns(bool);
    function transferOwnership(address to) external;
    function giveAllowence(address user) external;
    function removeAllowence(address user) external;
    function addToBlackList(address user) external;
    function removeFromBlackList(address user) external;
    function stakeMCH(uint256 amount) external;
    function unstake(address user, uint256 amount) external;
    function refreshBlock(address user) external;
    function setData(address user, uint256 staked, uint256 stakingBlock, uint256 stakedMCH) external;
    function transferMCH(address to, uint256 amount) external;
    function emergencyWithdraw(uint256 amount) external;
    event Stake(address indexed staker, uint256 indexed amount);
}

contract MCHstaking is MCHstakingInterface {
    address private _owner;
    mapping (address => bool) private _allowance;
    IERC20 public immutable MCH;
    contract2 public MCF;
    
    mapping (address => uint256) private _staking;
    mapping (address => uint256) private _block;
    uint256 private _totalStaked;
    mapping (address => bool) private _blackListed;

    modifier onlyOwner() {
        require(msg.sender == _owner, "Not the owner");
        _;
    }

    modifier onlyAllowed() {
        require(_allowance[msg.sender], "Not allowed");
        _;
    }

    constructor(address MCHtoken) {
        require(MCHtoken != address(0), "Invalid MCH token address");
        MCH = IERC20(MCHtoken);
        _owner = msg.sender;
        _allowance[msg.sender] = true;
    }
    
    function setMCFcontract(address contractAddress) external onlyOwner {
        require(contractAddress != address(0), "Invalid contract address");
        MCF = contract2(contractAddress);
    }
    
    function stakingStats(address user) external view override returns(uint256 amount, uint256 stakingBlock) {
        return (_staking[user], _block[user]);
    }
    
    function totalStaked() external view override returns(uint256) {
        return _totalStaked;
    }
    
    function showBlackUser(address user) external view override onlyAllowed returns(bool) {
        return _blackListed[user];
    }
    
    function allowance(address user) external view override onlyAllowed returns(bool) {
        return _allowance[user];
    }
    
    function transferOwnership(address to) external override onlyOwner {
        require(to != address(0), "Invalid address");
        _owner = to;
        emit OwnershipTransferred(_owner, to);
    }

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function giveAllowence(address user) external override onlyOwner {
        require(user != address(0), "Invalid user address");
        _allowance[user] = true;
    }
    
    function removeAllowence(address user) external override onlyOwner {
        require(user != address(0), "Invalid user address");
        _allowance[user] = false;
    }  
    
    function addToBlackList(address user) external override onlyOwner {
        require(user != address(0), "Invalid user address");
        _blackListed[user] = true;
    }

    function removeFromBlackList(address user) external override onlyOwner {
        require(user != address(0), "Invalid user address");
        _blackListed[user] = false;
    }    

    function stakeMCH(uint256 amount) external override {
        require(amount > 0, "Amount should be greater than zero");
        require(MCH.balanceOf(msg.sender) >= amount, "Insufficient balance");
        require(MCH.allowance(msg.sender, address(this)) >= amount, "Check the token allowance");
        require(!_blackListed[msg.sender], "User is blacklisted");

        bool success = MCH.transferFrom(msg.sender, address(this), amount);
        require(success, "Token transfer failed");

        _staking[msg.sender] += amount;
        _block[msg.sender] = block.number;
        _totalStaked += amount;
        
        emit Stake(msg.sender, amount);
    }
    
    function unstake(address user, uint256 amount) external override onlyAllowed {
        require(user != address(0), "Invalid user address");
        require(amount > 0, "Amount should be greater than zero");
        require(_staking[user] >= amount, "Insufficient staked amount");

        _staking[user] -= amount;
        _totalStaked -= amount;
        bool success = MCH.transfer(user, amount);
        require(success, "Token transfer failed");
    }
    
    function refreshBlock(address user) external override onlyAllowed {
        require(user != address(0), "Invalid user address");
        _block[user] = block.number;
    }

    function setData(address user, uint256 staked, uint256 stakingBlock, uint256 stakedMCH) external override onlyAllowed {
        require(user != address(0), "Invalid user address");
        _staking[user] = staked;
        _block[user] = stakingBlock;
        _totalStaked = stakedMCH;
    }

    function transferMCH(address to, uint256 amount) external override onlyAllowed {
        require(to != address(0), "Invalid destination address");
        require(amount > 0, "Amount should be greater than zero");
        require(MCH.balanceOf(address(this)) >= amount, "Insufficient contract balance");

        bool success = MCH.transfer(to, amount);
        require(success, "Token transfer failed");
    }
    
    function emergencyWithdraw(uint256 amount) external override onlyOwner {
        require(amount > 0, "Amount should be greater than zero");
        require(MCH.balanceOf(address(this)) >= amount, "Insufficient contract balance");

        bool success = MCH.transfer(_owner, amount);
        require(success, "Token transfer failed");
    }
}
```

### Notes:
- Added necessary checks to ensure valid parameters and states.
- Implemented modifier `onlyOwner` to restrict certain functions to the contract owner.
- Implemented modifier `onlyAllowed` to restrict certain functions to users with allowance.
- Included `OwnershipTransferred` event to log ownership changes.
- Used `emit Stake(msg.sender, amount);` to log staking events.