Below is the completed `Registry` smart contract based on the provided context and requirements. The contract has been implemented using Solidity version 0.5.17:

```solidity
pragma solidity ^0.5.17;

/**
 *Submitted for verification at Etherscan.io on 2021-04-28
*/

// File: @axie/contract-library/contracts/access/HasAdmin.sol

contract HasAdmin {
  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);
  event AdminRemoved(address indexed _oldAdmin);

  address public admin;

  modifier onlyAdmin {
    require(msg.sender == admin);
    _;
  }

  constructor() internal {
    admin = msg.sender;
    emit AdminChanged(address(0), admin);
  }

  function changeAdmin(address _newAdmin) external onlyAdmin {
    require(_newAdmin != address(0));
    emit AdminChanged(admin, _newAdmin);
    admin = _newAdmin;
  }

  function removeAdmin() external onlyAdmin {
    emit AdminRemoved(admin);
    admin = address(0);
  }
}

/**
 * @notice This contract serves as a registry for managing and mapping token addresses between mainchain and sidechain, 
 * as well as storing and updating addresses of key contracts such as the gateway, WETH token, validator, and acknowledgement.
 * @dev The contract uses mappings to store the addresses of the contracts and token mappings. It also emits events for updates.
 */
contract Registry is HasAdmin {

  event ContractAddressUpdated(
    string indexed _name,
    bytes32 indexed _code,
    address indexed _newAddress
  );

  event TokenMapped(
    address indexed _mainchainToken,
    address indexed _sidechainToken,
    uint32 _standard
  );

  string public constant GATEWAY = "GATEWAY";
  string public constant WETH_TOKEN = "WETH_TOKEN";
  string public constant VALIDATOR = "VALIDATOR";
  string public constant ACKNOWLEDGEMENT = "ACKNOWLEDGEMENT";

  struct TokenMapping {
    address mainchainToken;
    address sidechainToken;
    uint32 standard; // 20, 721 or any other standards
  }

  mapping(bytes32 => address) public contractAddresses;
  mapping(address => TokenMapping) public mainchainMap;
  mapping(address => TokenMapping) public sidechainMap;

  function getContract(string calldata _name)
    external
    view
    returns (address _address)
  {
    bytes32 code = getCode(_name);
    _address = contractAddresses[code];
    require(_address != address(0), "Contract address is not set");
  }

  function isTokenMapped(address _token, uint32 _standard, bool _isMainchain)
    external
    view
    returns (bool)
  {
    TokenMapping memory mappingEntry = _getTokenMapping(_token, _isMainchain);
    return mappingEntry.mainchainToken != address(0) && mappingEntry.standard == _standard;
  }

  function updateContract(string calldata _name, address _newAddress)
    external
    onlyAdmin
  {
    bytes32 code = getCode(_name);
    contractAddresses[code] = _newAddress;
    emit ContractAddressUpdated(_name, code, _newAddress);
  }

  function mapToken(address _mainchainToken, address _sidechainToken, uint32 _standard)
    external
    onlyAdmin
  {
    TokenMapping memory newMapping = TokenMapping({
      mainchainToken: _mainchainToken,
      sidechainToken: _sidechainToken,
      standard: _standard
    });
    
    mainchainMap[_mainchainToken] = newMapping;
    sidechainMap[_sidechainToken] = newMapping;
    emit TokenMapped(_mainchainToken, _sidechainToken, _standard);
  }

  function clearMapToken(address _mainchainToken, address _sidechainToken)
    external
    onlyAdmin
  {
    _clearMapEntry(mainchainMap[_mainchainToken]);
    _clearMapEntry(sidechainMap[_sidechainToken]);
  }

  function getMappedToken(
    address _token,
    bool _isMainchain
  )
    external
    view
    returns (
      address _mainchainToken,
      address _sidechainToken,
      uint32 _standard
    )
  {
    TokenMapping memory mappingEntry = _getTokenMapping(_token, _isMainchain);
    _mainchainToken = mappingEntry.mainchainToken;
    _sidechainToken = mappingEntry.sidechainToken;
    _standard = mappingEntry.standard;
  }

  function getCode(string memory _name)
    public
    pure
    returns (bytes32)
  {
    return keccak256(abi.encodePacked(_name));
  }

  function _getTokenMapping(
    address _token,
    bool isMainchain
  )
    internal
    view
    returns (TokenMapping memory _mapping)
  {
    if (isMainchain) {
      _mapping = mainchainMap[_token];
    } else {
      _mapping = sidechainMap[_token];
    }
  }

  function _clearMapEntry(TokenMapping storage _entry)
    internal
  {
    _entry.mainchainToken = address(0);
    _entry.sidechainToken = address(0);
    _entry.standard = 0;
  }
}
```

This contract provides the necessary functionality to manage and map token addresses between a mainchain and sidechain, as well as to store and update addresses of key contracts. It includes all the functions described in your comments, ensuring they are fully implemented as per the requirements.