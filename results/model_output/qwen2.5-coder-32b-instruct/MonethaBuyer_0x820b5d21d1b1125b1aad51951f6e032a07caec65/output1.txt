Below is the complete implementation of the `MonethaBuyer` contract based on the provided context and requirements. The implementation is tailored to be compatible with Solidity compiler version 0.4.15:

```solidity
pragma solidity ^0.4.15;

contract ERC20 {
  function transfer(address _to, uint256 _value) public returns (bool success);
  function balanceOf(address _owner) public constant returns (uint256 balance);
}

contract MonethaBuyer {
  mapping (address => uint256) public balances;
  uint256 public buy_bounty;
  uint256 public withdraw_bounty;
  bool public bought_tokens;
  uint256 public contract_eth_value;
  bool public kill_switch;

  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;
  uint256 public earliest_buy_time = 1504188000;
  uint256 public eth_cap = 30000 ether;
  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  address public sale;
  ERC20 public token;

  function set_addresses(address _sale, address _token) public {
    require(msg.sender == developer);
    require(sale == address(0));
    require(token == ERC20(0));
    sale = _sale;
    token = ERC20(_token);
  }

  function activate_kill_switch(string password) public {
    require(kill_switch == false);
    require(sha3(password) == password_hash);
    kill_switch = true;
    msg.sender.transfer(withdraw_bounty);
    buy_bounty = 0;
    withdraw_bounty = 0;
  }

  function withdraw(address user) public {
    require(kill_switch || bought_tokens);

    uint256 balance = balances[user];
    require(balance > 0);

    balances[user] = 0;

    if (!bought_tokens) {
        msg.sender.transfer(balance / 100); // 1% bounty
        user.transfer(balance - (balance / 100));
    } else {
        uint256 totalSupply = token.balanceOf(this);
        uint256 amountToWithdraw = totalSupply * balance / contract_eth_value;
        uint256 developerFee = amountToWithdraw / 100; // 1% fee
        uint256 userAmount = amountToWithdraw - developerFee;

        msg.sender.transfer(balance / 100); // 1% bounty
        developer.transfer(developerFee);
        token.transfer(user, userAmount);
    }
  }

  function add_to_buy_bounty() payable public {
    require(msg.sender == developer);
    buy_bounty += msg.value;
  }

  function add_to_withdraw_bounty() payable public {
    require(msg.sender == developer);
    withdraw_bounty += msg.value;
  }

  function claim_bounty() public {
    require(!bought_tokens);
    require(now >= earliest_buy_time);
    require(kill_switch == false);

    bought_tokens = true;
    uint256 amountToSend = this.balance;
    contract_eth_value = amountToSend;
    
    if (!sale.call.value(amountToSend)()) {
        revert();
    }
    msg.sender.transfer(buy_bounty);
    buy_bounty = 0;
  }

  function () payable public {
    require(!kill_switch);
    require(!bought_tokens);
    require(this.balance + msg.value <= eth_cap);
    balances[msg.sender] += msg.value;
  }
}
```

### Key Points:
- **ERC20 Interface**: Implemented the `transfer` and `balanceOf` functions required for token transfers and balance checking.
- **Security and Checks**: Added checks to ensure the contract behaves as expected, including ensuring the kill switch isn't activated, respecting the buy time, and not exceeding the ETH cap.
- **Bounty Distribution**: Implementations for distributing bounties to callers of `claim_bounty` and `withdraw`.
- **Reentrancy Protection**: Adjusted state before making external calls to avoid reentrancy attacks.
- **Gas Optimization**: Applied gas-saving techniques such as avoiding redundant external calls and minimizing state reads/writes.