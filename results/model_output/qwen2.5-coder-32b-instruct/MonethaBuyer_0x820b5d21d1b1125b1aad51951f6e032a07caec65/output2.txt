Certainly! Below is the completed `MonethaBuyer` contract according to your specifications. The functions have been implemented based on the provided context and description:

```solidity
pragma solidity 0.4.15;

// ERC20 Interface: https://github.com/ethereum/EIPs/issues/20
contract ERC20 {
  function transfer(address _to, uint256 _value) public returns (bool success);
  function balanceOf(address _owner) public constant returns (uint256 balance);
}

/**
 * @title MonethaBuyer
 * @notice A smart contract for managing ETH deposits, purchasing tokens in a crowdsale, and handling withdrawals.
 * @dev This contract includes features like bounties for executing buy and withdrawal actions, an emergency kill switch,
 *      and the ability to set the crowdsale and token addresses. It ensures that funds are only used for their intended purpose
 *      and provides mechanisms for users to withdraw their ETH or tokens.
 */
contract MonethaBuyer {
  // Store the amount of ETH deposited by each account.
  mapping (address => uint256) public balances;
  // Bounty for executing buy.
  uint256 public buy_bounty;
  // Bounty for executing withdrawals.
  uint256 public withdraw_bounty;
  // Track whether the contract has bought the tokens yet.
  bool public bought_tokens;
  // Record ETH value of tokens currently held by contract.
  uint256 public contract_eth_value;
  // Emergency kill switch in case a critical bug is found.
  bool public kill_switch;
  
  // SHA3 hash of kill switch password.
  bytes32 password_hash = 0x8223cba4d8b54dc1e03c41c059667f6adb1a642a0a07bef5a9d11c18c4f14612;
  // Earliest time contract is allowed to buy into the crowdsale.
  uint256 public earliest_buy_time = 1504188000;
  // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure.
  uint256 public eth_cap = 30000 ether;
  // The developer address.
  address public developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9;
  // The crowdsale address.  Settable by the developer.
  address public sale;
  // The token address.  Settable by the developer.
  ERC20 public token;

  /**
   * @notice Allows the developer to set the crowdsale and token addresses.
   * @dev Only the developer can set the addresses, and it can only be done once.
   * @param _sale The address of the crowdsale.
   * @param _token The address of the token.
   */
  function set_addresses(address _sale, address _token) public {
    require(msg.sender == developer && sale == address(0));
    sale = _sale;
    token = ERC20(_token);
  }

  /**
   * @notice Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. Send the caller their bounty for activating the kill switch.
   * @dev Activates the kill switch, which prevents further buys and sets the bounty to zero.
   * @param password The password to activate the kill switch.
   */
  function activate_kill_switch(string password) public {
    require(bytes(password).length > 0 && !kill_switch);
    bytes32 password_hash_test = sha3(password);
    require(password_hash_test == password_hash);
    kill_switch = true;
    buy_bounty = 0;
  }

  /**
    * @dev Allows the caller to withdraw all ETH or tokens deposited by a specified user, 
    *      with appropriate reward distribution and safety checks.
    * This function handles two scenarios:
    * 1. If tokens haven't been purchased yet (or purchase window hasn't passed), 
    *    it refunds the user's deposited ETH.
    * 2. If tokens have been successfully purchased, it distributes the user's proportional 
    *    share of tokens with a 1% developer fee and updates contract state.
    * The caller receives a 1% bounty for initiating the withdrawal on behalf of the user.
    * @param user The address of the user whose funds/tokens are being withdrawn.
    * @notice The function includes gas optimization techniques:
    *         - Early return if user has no balance
    *         - State updates before external calls to prevent reentrancy
    *         - Temporary variables for intermediate calculations
    */
  function withdraw(address user) public {
    require(balances[user] > 0);
    uint256 user_balance = balances[user];
    balances[user] = 0;
    
    if (!bought_tokens || now < earliest_buy_time) {
        user.transfer(user_balance);
    } else {
        uint256 total_tokens = token.balanceOf(this);
        uint256 user_tokens = (total_tokens * user_balance) / contract_eth_value;
        uint256 developer_fee = user_tokens / 100;
        uint256 bounty = user_tokens / 100;
        uint256 final_user_tokens = user_tokens - developer_fee - bounty;
        
        token.transfer(developer, developer_fee);
        token.transfer(msg.sender, bounty);
        token.transfer(user, final_user_tokens);
    }
  }

  /**
   * @notice Allows the developer to add ETH to the buy execution bounty.
   * @dev Only the developer can contribute to the buy bounty.
   */
  function add_to_buy_bounty() payable public {
    require(msg.sender == developer);
    buy_bounty += msg.value;
  }

  /**
   * @notice Allows the developer to add ETH to the withdraw execution bounty.
   * @dev Only the developer can contribute to the withdraw bounty.
   */
  function add_to_withdraw_bounty() payable public {
    require(msg.sender == developer);
    withdraw_bounty += msg.value;
  }

  /**
    * @dev Claims the contract's token purchase bounty by executing the initial token  purchase.
    * This function:
    * 1. Verifies preconditions (tokens not yet purchased, time window valid, kill switch  inactive)
    * 2. Sets the purchase flag
    * 3. Transfers ETH to the crowdsale contract
    * 4. Distributes the claimed bounty to the caller
    * 
    * @notice Includes gas optimizations through early returns and state updates before    external calls.
    */
  function claim_bounty() public {
    require(!kill_switch && now >= earliest_buy_time && !bought_tokens);
    require(this.balance > 0);

    bought_tokens = true;
    contract_eth_value = this.balance;

    // Send ETH to the crowdsale contract
    if (!sale.call.value(contract_eth_value)()) {
        revert();
    }
    
    // Transfer bounty to caller
    msg.sender.transfer(buy_bounty);
    buy_bounty = 0;
  }

  /**
   * @notice Default function. Called when a user sends ETH to the contract.
   * @dev Ensures the contract has not already purchased the tokens and that the ETH cap is not exceeded.
   */
  function () payable public {
    require(!kill_switch);
    require(!bought_tokens);
    require(this.balance + msg.value <= eth_cap);
    balances[msg.sender] += msg.value;
  }
}
```

This contract includes all necessary functions and adheres to the provided requirements. It handles deposits, token purchases, withdrawals, and includes mechanisms for setting the crowdsale and token addresses, as well as an emergency kill switch.