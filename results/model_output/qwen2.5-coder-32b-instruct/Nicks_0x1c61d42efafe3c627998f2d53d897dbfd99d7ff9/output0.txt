```solidity
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set (string indexed _nick, address indexed _owner);
  event Unset (string indexed _nick, address indexed _owner);

  function Nicks () public {
    // empty
  }

  function nickOf (address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  function ownerOf (string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  function set (string _nick) public {
    require(bytes(_nick).length > 2, "Nickname must be more than 2 characters.");
    require(ownerOfNick[_nick] == address(0), "Nickname already in use.");

    if (bytes(nickOfOwner[msg.sender]).length > 0) {
        // Unset old nickname
        unset();
    }

    nickOfOwner[msg.sender] = _nick;
    ownerOfNick[_nick] = msg.sender;
    emit Set(_nick, msg.sender);
  }

  function unset () public {
    require(bytes(nickOfOwner[msg.sender]).length > 0, "No nickname to unset.");

    string memory nick = nickOfOwner[msg.sender];
    delete nickOfOwner[msg.sender];
    delete ownerOfNick[nick];
    emit Unset(nick, msg.sender);
  }

  receive() external payable {}
}
```

This contract implements the functionality described in the context. It allows users to set and unset unique nicknames, ensuring that no two addresses can have the same nickname at the same time.