Certainly! Below is the complete `Nicks` smart contract implemented according to your specifications and without any additional features:

```solidity
pragma solidity ^0.4.20;

/**
 * @title Nicks
 * @notice A contract that allows users to set and unset unique nicknames. Each nickname is linked to a single Ethereum address.
 * @dev The contract ensures that each nickname is unique and can only be owned by one address at a time.
 */
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set (string indexed _nick, address indexed _owner);
  event Unset (string indexed _nick, address indexed _owner);

  /**
   * @notice Initializes the contract.
   * @dev The constructor does not perform any specific initialization in this contract.
   */
  function Nicks () public {
    // empty
  }

  /**
   * @notice Retrieves the nickname associated with a given address.
   * @param _owner The Ethereum address of the user.
   * @return _nick The nickname associated with the address.
   * @dev If the address has no nickname, an empty string will be returned.
   */
  function nickOf (address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  /**
   * @notice Retrieves the address associated with a given nickname.
   * @param _nick The nickname to look up.
   * @return _owner The Ethereum address associated with the nickname.
   * @dev If the nickname is not set, the zero address will be returned.
   */
  function ownerOf (string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  /**
   * @notice Sets a new nickname for the sender's address.
   * @param _nick The new nickname to set.
   * @dev The nickname must be more than 2 characters long and must not already be in use.
   *      If the sender already has a nickname, it will be unset before setting the new one.
   *      Emits a `Set` event on successful nickname assignment.
   */
  function set (string _nick) public {
    require(bytes(_nick).length > 2, "Nickname must be more than 2 characters long.");
    require(ownerOfNick[_nick] == 0x0, "Nickname already in use.");

    address sender = msg.sender;
    if (bytes(nickOfOwner[sender]).length > 0) {
        // Unset the old nickname
        unset();
    }

    nickOfOwner[sender] = _nick;
    ownerOfNick[_nick] = sender;
    
    emit Set(_nick, sender);
  }

  /**
   * @notice Unsets the current nickname for the sender's address.
   * @dev The sender must have a nickname set to call this function.
   *      Emits an `Unset` event on successful unsetting of the nickname.
   */
  function unset () public {
    address sender = msg.sender;
    string memory oldNick = nickOfOwner[sender];
    require(bytes(oldNick).length > 0, "Sender does not have a nickname set.");

    delete nickOfOwner[sender];
    delete ownerOfNick[oldNick];

    emit Unset(oldNick, sender);
  }

  /**
   * @notice Fallback function to handle receiving Ether.
   * @dev This function is left empty as the contract does not handle Ether.
   */
  function() external payable {}
}
```

This contract meets all the requirements you've described, including handling nickname uniqueness, setting and unsetting nicknames, and emitting the appropriate events. It uses Solidity 0.4.20 as specified.