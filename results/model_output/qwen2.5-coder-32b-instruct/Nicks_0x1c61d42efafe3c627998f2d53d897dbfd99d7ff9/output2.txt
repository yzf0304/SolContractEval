```solidity
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set (string indexed _nick, address indexed _owner);
  event Unset (string indexed _nick, address indexed _owner);

  function Nicks () public {
    // empty
  }

  function nickOf (address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  function ownerOf (string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  function set (string _nick) public {
    require(bytes(_nick).length > 2, "Nickname must be more than 2 characters.");
    require(ownerOfNick[_nick] == address(0), "Nickname is already in use.");

    address currentOwner = ownerOfNick[_nick];
    if (bytes(nickOfOwner[msg.sender]).length > 0) {
        unset();
    }

    nickOfOwner[msg.sender] = _nick;
    ownerOfNick[_nick] = msg.sender;

    emit Set(_nick, msg.sender);
  }

  function unset () public {
    string memory currentNick = nickOfOwner[msg.sender];
    require(bytes(currentNick).length > 0, "Sender does not have a nickname set.");

    delete ownerOfNick[currentNick];
    delete nickOfOwner[msg.sender];

    emit Unset(currentNick, msg.sender);
  }

  receive() external payable {}
}
```

This contract implements the functionality described: setting and unsetting unique nicknames for Ethereum addresses while emitting corresponding events. It also includes validation checks to ensure nicknames meet the requirements and prevent overwriting existing nicknames unless explicitly unset.