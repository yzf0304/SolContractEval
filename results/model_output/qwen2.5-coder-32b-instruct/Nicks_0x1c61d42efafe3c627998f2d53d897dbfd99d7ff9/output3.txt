Here is the complete and functional `Nicks` smart contract according to the provided specifications and context:

```solidity
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set (string indexed _nick, address indexed _owner);
  event Unset (string indexed _nick, address indexed _owner);

  function Nicks () public {
    // empty
  }

  function nickOf (address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  function ownerOf (string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  function set (string _nick) public {
    require(bytes(_nick).length > 2, "Nickname must be more than 2 characters long.");
    require(ownerOfNick[_nick] == 0x0, "Nickname already in use.");

    address currentOwner = ownerOfNick[_nick];
    if (bytes(nickOfOwner[msg.sender]).length > 0) {
        unset();
    }

    nickOfOwner[msg.sender] = _nick;
    ownerOfNick[_nick] = msg.sender;
    
    emit Set(_nick, msg.sender);
  }

  function unset () public {
    string memory nick = nickOfOwner[msg.sender];
    require(bytes(nick).length > 0, "Sender does not have a nickname set.");

    delete nickOfOwner[msg.sender];
    delete ownerOfNick[nick];
    
    emit Unset(nick, msg.sender);
  }

  receive() external payable {}
}
```

This contract ensures that each nickname is unique and linked to a single address. It also includes functions to set and unset nicknames, along with appropriate validation checks and events.