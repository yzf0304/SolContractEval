```solidity
contract Nicks {

  mapping (address => string) private nickOfOwner;
  mapping (string => address) private ownerOfNick;

  event Set(string indexed _nick, address indexed _owner);
  event Unset(string indexed _nick, address indexed _owner);

  function Nicks() public {
    // empty
  }

  function nickOf(address _owner) public view returns (string _nick) {
    return nickOfOwner[_owner];
  }

  function ownerOf(string _nick) public view returns (address _owner) {
    return ownerOfNick[_nick];
  }

  function set(string _nick) public {
    require(bytes(_nick).length > 2, "Nickname must be more than 2 characters.");
    address currentOwner = ownerOfNick[_nick];
    require(currentOwner == 0x0, "Nickname already in use.");

    string memory oldNick = nickOfOwner[msg.sender];
    if (bytes(oldNick).length > 0) {
        unset();
    }

    nickOfOwner[msg.sender] = _nick;
    ownerOfNick[_nick] = msg.sender;

    emit Set(_nick, msg.sender);
  }

  function unset() public {
    string memory oldNick = nickOfOwner[msg.sender];
    require(bytes(oldNick).length > 0, "No nickname to unset.");

    delete nickOfOwner[msg.sender];
    delete ownerOfNick[oldNick];

    emit Unset(oldNick, msg.sender);
  }

  receive() external payable {}
}
```

This contract implements the functionalities described in the context:
- It checks for nickname uniqueness and length before setting a nickname.
- It allows users to unset their current nickname.
- It handles events for both setting and unsetting nicknames.
- It includes fallback functionality to receive Ether, although it is not used in this contract.