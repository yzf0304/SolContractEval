Certainly! Below is the completed `OdinToken` contract implementing all the necessary functionality as per the provided description and restrictions. The contract is written in Solidity 0.4.21.

```solidity
/**
 * @notice OdinToken is an ERC20 token with additional features such as airdrop restrictions and owner-controlled whitelisting.
 * @dev This contract extends the ERC20Interface and Owned contracts, providing basic token functionality along with specific rules for airdropped tokens and whitelisting.
 */
contract OdinToken is ERC20Interface, Owned {
  using SafeMath for uint256;

  string public symbol;
  string public name;
  uint8 public decimals;
  uint private _totalSupply;
  bool private _whitelistAll;

  struct balanceData {  
     bool locked;
     uint balance;
     uint airDropQty;
  }

  mapping(address => balanceData) balances;
  mapping(address => mapping(address => uint)) allowed;

  /**
  * @dev Constructor for Odin creation
  * @dev Initially assigns the totalSupply to the contract creator
  */
  function OdinToken() public {
    // owner of this contract
    owner = msg.sender;
    symbol = "ODIN";
    name = "ODIN Token";
    decimals = 18;
    _whitelistAll = false;
    _totalSupply = 100000000000000000000000; // 100 million tokens
    balances[owner].balance = _totalSupply;
    balances[owner].airDropQty = 0; // Owner does not have airdrop tokens

    emit Transfer(address(0), msg.sender, _totalSupply);
  }

  /**
  * @notice Returns the total supply of the token.
  * @return The total supply of the token.
  * @dev This function returns the total number of tokens in circulation.
  */
  function totalSupply() constant public returns (uint256 totalSupply) {
      return _totalSupply;
  }

  /**
  * @notice Whitelist an address to allow it to receive airdrops.
  * @param to The address to whitelist.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the airdrop quantity for the specified address to 0, effectively whitelisting it.
  */
  function whitelistAddress(address to) onlyOwner public returns (bool) {
      balances[to].airDropQty = 0;
      return true;
  }

  /**
  * @notice Whitelist all addresses early.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function sets the `_whitelistAll` flag to true, allowing all addresses to be whitelisted.
  */
  function whitelistAllAddresses() onlyOwner public returns (bool) {
      _whitelistAll = true;
      return true;
  }

  /**
  * @notice Gets the balance of the specified address.
  * @param tokenOwner The address to query the balance of.
  * @return The amount owned by the passed address.
  * @dev This function returns the balance of the specified address.
  */
  function balanceOf(address tokenOwner) public constant returns (uint balance) {
      return balances[tokenOwner].balance;
  }

  /**
  * @dev Transfers tokens from sender to recipient with transfer restrictions.
  * 
  * Restrictions:
  * - Cannot send to self or address(0)
  * - Sender must have sufficient balance
  * - Air-dropped tokens have time-based transfer limits (if whitelistAll=false):
  *   - Before Sep 1 2018: Cannot transfer any air-dropped tokens
  *   - Sep 1-Sep 30 2018: Max 10% transfer of air-dropped tokens
  *   - Oct 1-Dec 31 2018: Max 25% transfer of air-dropped tokens
  *   - Jan 1-Mar 31 2019: Max 50% transfer of air-dropped tokens
  *   - Apr 1-Jun 30 2019: Max 75% transfer of air-dropped tokens
  *   - After Jun 30 2019: No restrictions
  * 
  * @param to Recipient address (cannot be zero address)
  * @param tokens Amount to transfer (must be â‰¤ sender's balance)
  * @return success Always returns true if transfer succeeds
  * 
  * @notice Emits Transfer event
  * @dev AirDropQty tracks air-dropped tokens for each account
  *      Owner transfers bypass air-drop restrictions
  */
  function transfer(address to, uint tokens) public returns (bool success) {
      require(to != address(0));
      require(tokens <= balances[msg.sender].balance);
      
      uint maxAirDropTransfer;
      if (!_whitelistAll && msg.sender != owner) {
          uint airDropQty = balances[msg.sender].airDropQty;
          uint currentTime = now;
          if (currentTime < 1535760000) { // Before Sep 1 2018
              maxAirDropTransfer = 0;
          } else if (currentTime < 1538352000) { // Sep 1-Sep 30 2018
              maxAirDropTransfer = airDropQty * 10 / 100;
          } else if (currentTime < 1546291200) { // Oct 1-Dec 31 2018
              maxAirDropTransfer = airDropQty * 25 / 100;
          } else if (currentTime < 1551369600) { // Jan 1-Mar 31 2019
              maxAirDropTransfer = airDropQty * 50 / 100;
          } else if (currentTime < 1561910400) { // Apr 1-Jun 30 2019
              maxAirDropTransfer = airDropQty * 75 / 100;
          } else { // After Jun 30 2019
              maxAirDropTransfer = airDropQty;
          }
          
          uint tokensToTransfer = airDropQty > maxAirDropTransfer ? maxAirDropTransfer : airDropQty;
          if (tokens > tokensToTransfer) {
              tokens = tokensToTransfer;
          }
      }

      balances[msg.sender].balance = balances[msg.sender].balance.sub(tokens);
      balances[to].balance = balances[to].balance.add(tokens);

      emit Transfer(msg.sender, to, tokens);
      return true;
  }

  /**
  * @notice Burn a specified amount of tokens from the owner's balance.
  * @param tokens The amount of tokens to burn.
  * @return A boolean indicating whether the operation was successful.
  * @dev This function burns a specified amount of tokens from the owner's balance, reducing the total supply.
  */
  function burn(uint256 tokens) onlyOwner public returns (bool) {
      require(tokens <= balances[owner].balance);
      
      _totalSupply = _totalSupply.sub(tokens);
      balances[owner].balance = balances[owner].balance.sub(tokens);
      
      emit Burn(tokens);
      return true;
  }

  function () public payable {
      revert(); // Prevent sending Ether to the contract
  }
}
```

This contract includes all required functionalities, including:

- Basic token functions such as `transfer`, `balanceOf`, `totalSupply`.
- Whitelisting functionalities to manage airdrop tokens.
- Transfer restrictions based on the airdrop quantity and time.
- A burn function for the owner to reduce the total supply.

Note: The `approve`, `transferFrom`, `allowance`, and `approveAndCall` methods are intentionally left unimplemented as per your instructions. Also, the fallback function has been modified to `revert()` instead of `throw`, which is deprecated in Solidity 0.4.21.