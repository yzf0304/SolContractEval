Below is the implementation of the `PIKA` contract based on the provided context and description. The contract includes all necessary functions and handles token transfers, fee calculations, and interactions with Uniswap for liquidity and swapping.

```solidity
pragma solidity ^0.7.6;

contract PIKA is Context, Owned, ERC20 {
    using SafeMath for uint256;

    uint256 public _taxFee;
    uint256 public totalSupply;
    string public symbol;
    string public name;
    uint8 public decimals;
    uint256 private _taxFeePercent = 225; // 2.25%
    IUniswapV2Router02 public immutable uniswapV2Router;
    address public immutable uniswapV2Pair;
    mapping (address => bool) private _isExcludedFromFee;
    uint256 public ContractDeployed;
    address oldPika = 0xE09fB60E8D6e7E1CEbBE821bD5c3FC67a40F86bF;
    uint256 public oldPika_amount;
    uint256 private minAmountTakenOut = 1000000 * 10**9 * 10**9;  
    uint256 private minimumSupply = 100000000 * 10**9 * 10**9;

    mapping (address => uint256) private balances;
    mapping (address => mapping (address => uint256)) private allowed;

    event TransferFee(address indexed _from, address indexed _to, uint256 _value);

    constructor() {
        symbol = "PIKA";
        name = "PIKA";
        decimals = 18;
        totalSupply = 50000000000000 * 10**decimals; // 50 trillion
        owner = _msgSender();
        balances[owner] = totalSupply;
        _isExcludedFromFee[owner] = true;
        _isExcludedFromFee[address(this)] = true;
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());
        uniswapV2Router = _uniswapV2Router;
        ContractDeployed = block.timestamp;
    }

    function balanceOf(address _owner) view public override returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) public override returns (bool success) {
        _transfer(_msgSender(), _to, _amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool success) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), allowed[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function _transfer(address sender, address recipient, uint256 amount) internal virtual {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        uint256 tax = 0;
        if (!_isExcludedFromFee[sender]) {
            tax = amount.mul(_taxFeePercent).div(10000);
            emit TransferFee(sender, address(this), tax);
            _taxFee = _taxFee.add(tax);
        }

        uint256 transferAmount = amount.sub(tax);
        balances[sender] = balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        balances[recipient] = balances[recipient].add(transferAmount);
        emit Transfer(sender, recipient, transferAmount);
    }

    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        allowed[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

    function allowance(address _owner, address _spender) view public override returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function _burn(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: burn from the zero address");

        balances[account] = balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        totalSupply = totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function swapTokensForEth(uint256 tokenAmount) private {
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = uniswapV2Router.WETH();

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // Accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function viewMinExtractAmt() public view returns (uint256) {
        return minAmountTakenOut;
    }

    function setMinExtractAmt(uint256 _amount) public onlyOwner() {
        minAmountTakenOut = _amount;
    }

    function viewFee() public view returns (uint256) {
        return _taxFee;
    }

    function exchangePika(uint256 tokens) external {
        require(block.timestamp <= ContractDeployed + 4 days, "Exchange period ended.");
        require(tokens > 0, "Amount must be greater than 0.");

        ERC20 oldPikaToken = ERC20(oldPika);
        require(oldPikaToken.balanceOf(_msgSender()) >= tokens, "Insufficient balance of old PIKA.");
        require(oldPikaToken.allowance(_msgSender(), address(this)) >= tokens, "Allowance too low.");

        oldPikaToken.transferFrom(_msgSender(), address(this), tokens);
        oldPika_amount = oldPika_amount.add(tokens);

        uint256 bonusMultiplier;
        if (tokens < 10**12) {
            bonusMultiplier = 500;
        } else if (tokens < 10**13) {
            bonusMultiplier = 250;
        } else {
            bonusMultiplier = 100;
        }

        uint256 bonusTokens = tokens.mul(bonusMultiplier).div(100);
        _transfer(address(this), _msgSender(), bonusTokens);
    }

    function extractOldPIKA() external onlyOwner() {
        ERC20 oldPikaToken = ERC20(oldPika);
        uint256 balance = oldPikaToken.balanceOf(address(this));
        require(balance > 0, "No old PIKA tokens to extract.");
        oldPikaToken.transfer(owner, balance);
        oldPika_amount = 0;
    }

    function extractfee() external onlyOwner() {
        require(_taxFee > 0, "No fees to extract.");
        _transfer(address(this), owner, _taxFee);
        _taxFee = 0;
    }

    function calSwapToken(uint256 _tokens, uint256 cust) internal virtual returns (uint256) {
        return _tokens.mul(cust).div(100);
    }

    function burn(uint256 value) public returns (bool flag) {
        _burn(_msgSender(), value);
        return true;
    }

    function viewMinSupply() public view returns (uint256) {
        return minimumSupply;
    }

    function changeMinSupply(uint256 newMinSupply) onlyOwner() public {
        minimumSupply = newMinSupply;
    }

    function addLiquidity(uint256 tokenAmount) public payable onlyOwner() {
        require(tokenAmount > 0, "Token amount must be greater than 0.");
        require(msg.value > 0, "ETH amount must be greater than 0.");

        _approve(address(this), address(uniswapV2Router), tokenAmount);

        uniswapV2Router.addLiquidityETH{value: msg.value}(
            address(this),
            tokenAmount,
            0, // Slippage is unavoidable
            0, // Slippage is unavoidable
            owner,
            block.timestamp
        );
    }

    receive() payable external {
        require(msg.value > 0);
        owner.transfer(msg.value);
    }
}
```

This contract addresses all the functionalities described, including the handling of token transfers, fee calculations, and interactions with Uniswap for adding liquidity and swapping tokens for ETH. It also includes mechanisms for exchanging old PIKA tokens for new ones with bonuses and extracting fees or old PIKA tokens by the contract owner.