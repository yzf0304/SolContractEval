Below is the implementation of the PSP token contract as per the provided requirements and structure. The contract adheres to the ERC-20 standard and includes additional functionalities like minting, delegation, and voting. It utilizes the `SafeMath` library conceptually, with specific functions tailored for `uint96` and `uint32` to handle the bit-width constraints of mappings and variables.

```solidity
pragma solidity 0.5.17;

contract PSP {
    using SafeMath for uint;
    using SafeMath96 for uint96;
    using SafeMath32 for uint32;

    string public constant name = "ParaSwap";
    string public constant symbol = "PSP";
    uint8 public constant decimals = 18;
    uint public totalSupply = 2_000_000_000e18;
    address public minter;
    uint public mintingAllowedAfter;
    uint32 public constant minimumTimeBetweenMints = 1 days * 365;
    uint8 public constant mintCap = 2;
    mapping (address => mapping (address => uint96)) internal allowances;
    mapping (address => uint96) internal balances;
    mapping (address => address) public delegates;
    struct Checkpoint {
        uint32 fromBlock;
        uint96 votes;
    }
    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;
    mapping (address => uint32) public numCheckpoints;

    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");
    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");
    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    mapping (address => uint) public nonces;

    event MinterChanged(address minter, address newMinter);
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    constructor(address account, address minter_, uint mintingAllowedAfter_) public {
        require(mintingAllowedAfter_ >= block.timestamp, "PSP::constructor: minting can only begin after deployment");

        balances[account] = uint96(totalSupply);
        emit Transfer(address(0), account, totalSupply);
        minter = minter_;
        emit MinterChanged(address(0), minter);
        mintingAllowedAfter = mintingAllowedAfter_;
    }

    function setMinter(address minter_) external {
        require(msg.sender == minter, "PSP::setMinter: only the minter can change the minter");
        emit MinterChanged(minter, minter_);
        minter = minter_;
    }

    function mint(address dst, uint rawAmount) external {
        require(msg.sender == minter, "PSP::mint: only the minter can mint");
        require(block.timestamp >= mintingAllowedAfter, "PSP::mint: minting not allowed yet");
        require(dst != address(0), "PSP::mint: cannot mint to the zero address");

        uint96 amount = safe96(rawAmount, "PSP::mint: amount exceeds 96 bits");

        uint maxMintable = totalSupply.mul(mintCap).div(100);
        require(rawAmount <= maxMintable, "PSP::mint: exceeded mint cap");

        totalSupply = totalSupply.add(rawAmount, "PSP::mint: total supply overflow");
        balances[dst] = balances[dst].add(amount, "PSP::mint: balance overflow");
        emit Transfer(address(0), dst, rawAmount);

        mintingAllowedAfter = block.timestamp.add(minimumTimeBetweenMints);
        _moveDelegates(address(0), delegates[dst], amount);
    }

    function allowance(address account, address spender) external view returns (uint) {
        return allowances[account][spender];
    }

    function approve(address spender, uint rawAmount) external returns (bool) {
        uint96 amount;
        if (rawAmount == uint(-1)) {
            amount = uint96(-1);
        } else {
            amount = safe96(rawAmount, "PSP::approve: amount exceeds 96 bits");
        }

        allowances[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, rawAmount);
        return true;
    }

    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {
        require(block.timestamp <= deadline, "PSP::permit: signature expired");

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(
            abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline)
        );
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0) && recoveredAddress == owner, "PSP::permit: invalid signature");

        uint96 amount;
        if (rawAmount == uint(-1)) {
            amount = uint96(-1);
        } else {
            amount = safe96(rawAmount, "PSP::permit: amount exceeds 96 bits");
        }

        allowances[owner][spender] = amount;
        emit Approval(owner, spender, rawAmount);
    }

    function balanceOf(address account) external view returns (uint) {
        return balances[account];
    }

    function transfer(address dst, uint rawAmount) external returns (bool) {
        uint96 amount = safe96(rawAmount, "PSP::transfer: amount exceeds 96 bits");
        _transferTokens(msg.sender, dst, amount);
        return true;
    }

    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {
        uint96 amount = safe96(rawAmount, "PSP::transferFrom: amount exceeds 96 bits");
        require(amount <= allowances[src][msg.sender], "PSP::transferFrom: transfer amount exceeds allowance");

        allowances[src][msg.sender] = allowances[src][msg.sender].sub(amount, "PSP::transferFrom: insufficient allowance");
        _transferTokens(src, dst, amount);
        return true;
    }

    function delegate(address delegatee) public {
        return _delegate(msg.sender, delegatee);
    }

    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {
        require(block.timestamp <= expiry, "PSP::delegateBySig: signature expired");

        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));
        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        address signer = ecrecover(digest, v, r, s);
        require(signer != address(0), "PSP::delegateBySig: invalid signature");
        require(nonce == nonces[signer]++, "PSP::delegateBySig: invalid nonce");
        _delegate(signer, delegatee);
    }

    function getCurrentVotes(address account) external view returns (uint96) {
        uint32 nCheckpoints = numCheckpoints[account];
        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints.sub(1, "PSP::getCurrentVotes: no checkpoints")] : 0;
    }

    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {
        require(blockNumber < block.number, "PSP::getPriorVotes: not yet determined");

        uint32 nCheckpoints = numCheckpoints[account];
        if (nCheckpoints == 0) {
            return 0;
        }

        // First check most recent balance
        if (checkpoints[account][nCheckpoints.sub(1, "PSP::getPriorVotes: no checkpoints")].fromBlock <= blockNumber) {
            return checkpoints[account][nCheckpoints.sub(1, "PSP::getPriorVotes: no checkpoints")].votes;
        }

        // Next check implicit zero balance
        if (checkpoints[account][0].fromBlock > blockNumber) {
            return 0;
        }

        uint32 lower = 0;
        uint32 upper = nCheckpoints.sub(1, "PSP::getPriorVotes: no checkpoints");
        while (upper > lower) {
            uint32 center = upper.sub(lower, "PSP::getPriorVotes: lower too high").div(2).add(lower, "PSP::getPriorVotes: low overflow");
            Checkpoint memory cp = checkpoints[account][center];
            if (cp.fromBlock == blockNumber) {
                return cp.votes;
            } else if (cp.fromBlock < blockNumber) {
                lower = center.add(1, "PSP::getPriorVotes: low overflow");
            } else {
                upper = center;
            }
        }
        return checkpoints[account][lower].votes;
    }

    function _delegate(address delegator, address delegatee) internal {
        address currentDelegate = delegates[delegator];
        uint96 delegatorBalance = balances[delegator];
        delegates[delegator] = delegatee;

        emit DelegateChanged(delegator, currentDelegate, delegatee);

        _moveDelegates(currentDelegate, delegatee, delegatorBalance);
    }

    function _transferTokens(address src, address dst, uint96 amount) internal {
        require(src != address(0), "PSP::_transferTokens: cannot transfer from the zero address");
        require(dst != address(0), "PSP::_transferTokens: cannot transfer to the zero address");

        balances[src] = balances[src].sub(amount, "PSP::_transferTokens: transfer amount exceeds balance");
        balances[dst] = balances[dst].add(amount, "PSP::_transferTokens: transfer amount causes overflow");
        emit Transfer(src, dst, amount);

        _moveDelegates(delegates[src], delegates[dst], amount);
    }

    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {
        if (srcRep != dstRep && amount > 0) {
            if (srcRep != address(0)) {
                uint32 srcRepNum = numCheckpoints[srcRep];
                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum.sub(1, "PSP::_moveDelegates: no checkpoints")].votes : 0;
                uint96 srcRepNew = srcRepOld.sub(amount, "PSP::_moveDelegates: vote amount underflows");
                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);
            }

            if (dstRep != address(0)) {
                uint32 dstRepNum = numCheckpoints[dstRep];
                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum.sub(1, "PSP::_moveDelegates: no checkpoints")].votes : 0;
                uint96 dstRepNew = dstRepOld.add(amount, "PSP::_moveDelegates: vote amount overflows");
                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {
       uint32 blockNumber = safe32(block.number, "PSP::_writeCheckpoint: block number exceeds 32 bits");
        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints.sub(1, "PSP::_writeCheckpoint: no checkpoints")].fromBlock == blockNumber) {
            checkpoints[delegatee][nCheckpoints.sub(1, "PSP::_writeCheckpoint: no checkpoints")] = Checkpoint(blockNumber, newVotes);
        } else {
            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);
            numCheckpoints[delegatee] = nCheckpoints.add(1, "PSP::_writeCheckpoint: numCheckpoints exceeds 32 bits");
        }

        emit DelegateVotesChanged(delegatee, uint(oldVotes), uint(newVotes));
    }

    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {
        require(n < 2**96, errorMessage);
        return uint96(n);
    }

    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }

    function getChainId() internal pure returns (uint) {
        uint256 chainId;
        /* solium-disable-next-line security/no-inline-assembly */
        assembly { chainId := chainid() }
        return chainId;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    function sub(uint a, uint b) internal pure returns (uint) {
        require(b <= a, "SafeMath: subtraction underflow");
        return a - b;
    }

    function mul(uint a, uint b) internal pure returns (uint) {
        if (a == 0) return 0;
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        return c;
    }

    function div(uint a, uint b) internal pure returns (uint) {
        require(b > 0, "SafeMath: division by zero");
        return a / b;
    }
}

library SafeMath96 {
    function add(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        uint96 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {
        require(b <= a, errorMessage);
        return a - b;
    }
}

library SafeMath32 {
    function add(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
        uint32 c = a + b;
        require(c >= a, errorMessage);
        return c;
    }

    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {
        require(b <= a, errorMessage);
        return a - b;
    }
}
```

This code includes all the necessary functions and logic to fulfill the specified requirements and functionalities, including minting, transferring, approving, delegating, and querying token information. It handles the conversion between different data types carefully to avoid potential overflow and underflow issues.