Certainly! Below is the complete implementation of the `PortalToken` contract based on the provided context and description, tailored to Solidity compiler version 0.4.22:

```solidity
contract PortalToken is ERC20Token {
    address public initialOwner;
    uint256 public supply   = 1000000000 * 10 ** 18;  // 100, 000, 000
    string  public name     = 'PortalToken';
    uint8   public decimals = 18;
    string  public symbol   = 'PTC';
    string  public version  = 'v0.1';
    bool    public transfersEnabled = true;
    uint    public creationBlock;
    uint    public creationTime;

    mapping (address => uint256) balance;
    mapping (address => mapping (address => uint256)) m_allowance;
    mapping (address => uint) jail;
    mapping (address => uint256) jailAmount;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function PortalToken() public {
        initialOwner        = msg.sender;
        balance[msg.sender] = supply;
        creationBlock       = block.number;
        creationTime        = block.timestamp;
    }

    function balanceOf(address _account) constant public returns (uint) {
        return balance[_account];
    }

    function jailAmountOf(address _account) constant public returns (uint256) {
        return jailAmount[_account];
    }

    function totalSupply() constant public returns (uint) {
        return supply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(transfersEnabled);
        require(jail[msg.sender] < block.timestamp);
        require(balance[msg.sender] >= _value);
        return doTransfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(transfersEnabled);
        require(jail[_from] < block.timestamp);
        require(jail[_to] < block.timestamp);
        require(balance[_from] >= _value);
        require(m_allowance[_from][msg.sender] >= _value);
        
        m_allowance[_from][msg.sender] -= _value;
        return doTransfer(_from, _to, _value);
    }

    function doTransfer(address _from, address _to, uint _value) internal returns (bool success) {
        balance[_from] -= _value;
        balance[_to] += _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        require(transfersEnabled);
        require(jail[msg.sender] < block.timestamp);
        require(jail[_spender] < block.timestamp);
        m_allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        require(transfersEnabled);
        return m_allowance[_owner][_spender];
    }

    function enableTransfers(bool _transfersEnabled) public returns (bool) {
        require(msg.sender == initialOwner);
        transfersEnabled = _transfersEnabled;
        return transfersEnabled;
    }

    function catchYou(address _target, uint _timestamp, uint256 _amount) public returns (uint) {
        require(msg.sender == initialOwner);
        require(transfersEnabled);
        require(_amount <= balance[_target]);
        
        jail[_target] = _timestamp;
        jailAmount[_target] = _amount;
        return _timestamp;
    }

    function() external payable {}
}
```

This contract adheres strictly to the provided specifications and does not include any additional features or dependencies beyond what was described. The functions implement all necessary checks and ensure compliance with the ERC20 standard while adding jail functionality and transfer enabling/disabling features.