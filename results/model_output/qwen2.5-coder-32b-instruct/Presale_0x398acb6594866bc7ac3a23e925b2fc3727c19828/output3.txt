Certainly! Below is the complete and functional `Presale` contract implementing all the required functionalities based on the provided context and description. The contract includes detailed implementations for all public and private methods, as well as necessary modifiers and storage variables.

```solidity
/**
 * @title Presale
 * @notice This contract facilitates a token presale with tiered discounts, purchase limits, and authorization for participants.
 * @dev The contract is pausable and claimable, inheriting from Pausable and Claimable contracts. It manages the sale of tokens,
 *      setting rates, adding tiers, authorizing participants, and handling purchases and withdrawals.
 */
contract Presale is Claimable, Pausable {

  using Discounts for Discounts.Collection;
  using Limits for Limits.Window;

  /**
   * @notice Struct to store participant information.
   * @dev Contains whether the participant is authorized and their minimum tier.
   */
  struct Participant {
    bool authorized;
    uint256 minimumTier;
  }

  /**************************************************************************
   * STORAGE / EVENTS
   *************************************************************************/

  SeeToken public token;
  Discounts.Collection discounts;
  Limits.Window cap;
  mapping (address => Participant) participants;

  /**
   * @notice Emitted when a new tier is added.
   * @param discount The discount in basis points.
   * @param available The available supply at the tier.
   */
  event TierAdded(uint256 discount, uint256 available);

  /**
   * @notice Emitted when a purchase is made.
   * @param buyer The address that bought tokens.
   * @param amount The amount of tokens purchased.
   * @param cost The cost in wei for the purchase.
   */
  event TokensPurchased(address indexed buyer, uint256 amount, uint256 cost);

  /**
   * @notice Emitted when a rate is set.
   * @param rate The number of tokens per wei.
   */
  event RateSet(uint256 rate);

  /**
   * @notice Emitted when purchasing limits are set.
   * @param amount The limit of tokens.
   * @param duration The duration in blocks.
   */
  event PurchaseLimitSet(uint256 amount, uint256 duration);

  /**
   * @notice Emitted when a participant is authorized for a tier.
   * @param participant The authorized participant.
   * @param minimumTier The minimum tier.
   */
  event ParticipantAuthorized(address participant, uint256 minimumTier);

  /**************************************************************************
   * CONSTRUCTOR / LIFECYCLE
   *************************************************************************/

  function Presale(address _token)
    public
  {
    token = SeeToken(_token);
    paused = true;
  }

  /**
   * @notice Claims ownership of the token contract.
   * @dev This function should be called as part of the migration process.
   */
  function claimToken() public {
    token.claimOwnership();
    token.transferOwnership(this);
  }

  /**
   * @notice Unpauses the contract, allowing purchases.
   * @dev Can only be called by the owner, and the contract must be paused, have a set rate, be capped, and own the token.
   */
  function unpause()
    onlyOwner
    whenPaused
    whenRateSet
    whenCapped
    whenOwnsToken
    public
  {
    super.unpause();
  }

  /**************************************************************************
   * ADMIN INTERFACE
   *************************************************************************/

  /**
   * @notice Sets the base purchase rate for the token.
   * @param _purchaseRate The number of tokens granted per wei.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function setRate(uint256 _purchaseRate)
    onlyOwner
    whenPaused
    public
  {
    discounts.baseRate = _purchaseRate;
    RateSet(_purchaseRate);
  }

  /**
   * @notice Specifies purchasing limits for a single account.
   * @param _amount The limit of tokens that a participant may purchase.
   * @param _duration The duration in blocks over which the limit applies.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function limitPurchasing(uint256 _amount, uint256 _duration)
    onlyOwner
    whenPaused
    public
  {
    cap.amount = _amount;
    cap.duration = _duration;
    PurchaseLimitSet(_amount, _duration);
  }

  /**
   * @notice Adds a new tier with a given discount and available supply.
   * @param _discount The discount in basis points.
   * @param _available The available supply at the tier.
   * @dev Can only be called by the owner and while the contract is paused.
   */
  function addTier(uint256 _discount, uint256 _available)
    onlyOwner
    whenPaused
    public
  {
    discounts.addTier(_discount, _available);
    TierAdded(_discount, _available);
  }

  /**
   * @notice Authorizes a group of participants for a specific tier.
   * @param _minimumTier The minimum tier for the list of participants.
   * @param _authorized An array of addresses to be authorized.
   * @dev Can only be called by the owner.
   */
  function authorizeForTier(uint256 _minimumTier, address[] _authorized)
    onlyOwner
    public
  {
    for (uint256 i = 0; i < _authorized.length; i++) {
      participants[_authorized[i]] = Participant({
        authorized: true,
        minimumTier: _minimumTier
      });
      ParticipantAuthorized(_authorized[i], _minimumTier);
    }
  }

  /**
   * @notice Withdraws the balance from the presale contract.
   * @dev Can only be called by the owner.
   */
  function withdraw()
    onlyOwner
    public
  {
    owner.transfer(this.balance);
  }

  /**************************************************************************
   * PURCHASE INTERFACE
   *************************************************************************/

  /**
   * @notice Fallback function that forwards to `purchaseTokens()`.
   * @dev Accepts Ether and calls `purchaseTokens()`.
   */
  function ()
    public
    payable
  {
    purchaseTokens();
  }

  /**
   * @notice Public purchase interface for authorized participants.
   * @dev Purchases tokens starting from the authorized minimum tier.
   * Can only be called by an authorized participant and while the contract is not paused.
   */
  function purchaseTokens()
    onlyAuthorized
    whenNotPaused
    public
    payable
  {
    require(msg.value > 0);

    address buyer = msg.sender;
    uint256 minTier = participants[buyer].minimumTier;

    // Calculate available limit based on window and past purchases
    uint256 availableLimit = cap.getLimit(buyer);

    // Attempt to purchase tokens, up to the available limit or funds
    var (purchased, remaining) = discounts.purchaseTokens(
      availableLimit, 
      msg.value, 
      minTier
    );

    // Check if the participant could purchase any tokens
    require(purchased > 0);

    // Issue tokens to the buyer
    token.issue(buyer, purchased);

    // Update participant purchase record
    cap.recordPurchase(buyer, purchased);

    // Refund any remaining funds if they were sent
    if (remaining > 0) {
      buyer.transfer(remaining);
    }

    // Emit purchase event
    TokensPurchased(buyer, purchased, msg.value.sub(remaining));
  }

  /**************************************************************************
   * PRICING / AVAILABILITY - VIEW INTERFACE
   *************************************************************************/

  /**
   * @notice Gets the terms for the purchasing limit window.
   * @return _amount The number of tokens allowed.
   * @return _duration The duration in blocks.
   */
  function getPurchaseLimit()
    public
    view
    returns (uint256 _amount, uint256 _duration)
  {
    return (cap.amount, cap.duration);
  }

  /**
   * @notice Gets the tiers currently set up, with discounts and available supplies.
   * @return An array of tuples (discount, available).
   */
  function getTiers()
    public
    view
    returns (uint256[][2] tiers)
  {
    uint256 len = discounts.tiers.length;
    uint256[][2] memory result = new uint256[][2](len);

    for (uint256 i = 0; i < len; i++) {
      result[i][0] = discounts.tiers[i].discount;
      result[i][1] = discounts.tiers[i].available;
    }

    return result;
  }

  /**
   * @notice Gets the available supply for each tier for a given participant.
   * @param _participant The address of the participant.
   * @return An array of available supplies by tier index, zeroes for non-authorized participants.
   */
  function getAvailability(address _participant)
    public
    view
    returns (uint256[])
  {
    uint256 len = discounts.tiers.length;
    uint256[] memory result = new uint256[](len);
    
    if (!participants[_participant].authorized) {
      return result;
    }

    for (uint256 i = 0; i < len; i++) {
      result[i] = discounts.tiers[i].available;
    }

    return result;
  }

  /**************************************************************************
   * MODIFIERS
   *************************************************************************/

  /**
   * @dev Requires the participant to be whitelist-authorized.
   */
  modifier onlyAuthorized() {
    require(participants[msg.sender].authorized);
    _;
  }

  /**
   * @dev Ensures the base rate is set (not zero).
   */
  modifier whenRateSet() {
    require(discounts.baseRate != 0);
    _;
  }

  /**
   * @dev Ensures the contract is capped (cap amount is not zero).
   */
  modifier whenCapped() {
    require(cap.amount != 0);
    _;
  }

  /**
   * @dev Ensures the contract owns the token.
   */
  modifier whenOwnsToken() {
    require(token.owner() == address(this));
    _;
  }
}
```

This contract implements all necessary functionalities including adding tiers, setting a base rate, limiting purchases, authorizing participants, handling purchases, and withdrawing funds, all while adhering to the specified constraints such as contract ownership and pausing mechanisms.