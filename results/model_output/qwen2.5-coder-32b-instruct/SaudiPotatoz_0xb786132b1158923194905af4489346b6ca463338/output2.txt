Below is the completed `SaudiPotatoz` contract implementing all the functionalities as described in the comments:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "./@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./@openzeppelin/contracts/utils/Context.sol";
import "./@openzeppelin/contracts/access/Ownable.sol";
import "./contracts/ERC721A.sol";

contract SaudiPotatoz is ERC721A, Ownable, ReentrancyGuard {

    string public baseURI;
    uint public price = 0 ether;
    uint public maxPerTx = 1;
    uint public maxPerWallet = 1;
    uint public totalFree = 0;
    uint public maxSupply = 5000;
    uint public nextOwnerToExplicitlySet;
    bool public mintEnabled;

    constructor() ERC721A("SaudiPotatoz", "SaudiPotatoz"){}

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }

    function freeMint(uint256 amt) external callerIsUser nonReentrant {
        require(mintEnabled, "Minting is not enabled");
        require(currentIndex + amt <= totalFree, "Exceeds free mint supply");
        require(amt <= maxPerTx, "Amount exceeds max per transaction");
        require(numberMinted(msg.sender) + amt <= maxPerWallet, "Amount exceeds max per wallet");

        _safeMint(msg.sender, amt);
    }

    function mint(uint256 amt) external payable callerIsUser nonReentrant {
        require(mintEnabled, "Minting is not enabled");
        require(currentIndex + amt <= maxSupply, "Exceeds max supply");
        require(amt <= maxPerTx, "Amount exceeds max per transaction");
        require(numberMinted(msg.sender) + amt <= maxPerWallet, "Amount exceeds max per wallet");
        require(msg.value >= price * amt, "Insufficient ETH sent");

        _safeMint(msg.sender, amt);
    }

    function ownerBatchMint(uint256 amt) external onlyOwner nonReentrant {
        require(currentIndex + amt <= maxSupply, "Exceeds max supply");

        _safeMint(msg.sender, amt);
    }

    function toggleMinting() external onlyOwner {
        mintEnabled = !mintEnabled;
    }

    function numberMinted(address owner) public view returns (uint256) {
        return _numberMinted(owner);
    }

    function setBaseURI(string calldata baseURI_) external onlyOwner {
        baseURI = baseURI_;
    }

    function setPrice(uint256 price_) external onlyOwner {
        price = price_;
    }

    function setTotalFree(uint256 totalFree_) external onlyOwner {
        totalFree = totalFree_;
    }

    function setMaxPerTx(uint256 maxPerTx_) external onlyOwner {
        maxPerTx = maxPerTx_;
    }

    function setMaxPerWallet(uint256 maxPerWallet_) external onlyOwner {
        maxPerWallet = maxPerWallet_;
    }

    function setmaxSupply(uint256 maxSupply_) external onlyOwner {
        maxSupply = maxSupply_;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseURI;
    }

    function withdraw() external onlyOwner nonReentrant {
        Address.sendValue(payable(owner()), address(this).balance);
    }

    function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
        _setOwnersExplicit(quantity);
    }

    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
        return ownershipOf(tokenId);
    }

    function _setOwnersExplicit(uint256 quantity) internal {
        require(quantity > 0, "Quantity must be greater than 0");
        require(currentIndex > 0, "No tokens minted yet");

        uint256 _nextOwnerToExplicitlySet = nextOwnerToExplicitlySet;
        require(_nextOwnerToExplicitlySet < currentIndex, "All ownerships already set");

        uint256 endIndex = _nextOwnerToExplicitlySet + quantity;

        if (endIndex > currentIndex) {
            endIndex = currentIndex;
        }

        unchecked {
            for (uint256 i = _nextOwnerToExplicitlySet; i < endIndex; i++) {
                if (_ownerships[i].addr == address(0)) {
                    TokenOwnership memory ownership = ownershipOf(i);
                    _ownerships[i].addr = ownership.addr;
                    _ownerships[i].startTimestamp = ownership.startTimestamp;
                }
            }
        }

        nextOwnerToExplicitlySet = endIndex;
    }
}
```

This contract fully implements the required functionalities and ensures adherence to the described specifications, including proper error handling and security measures such as reentrancy protection. It also includes necessary internal functions to handle token ownership and metadata efficiently.