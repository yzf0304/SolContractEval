Below is the complete and functional implementation of the `SaudiPotatoz` smart contract based on the provided description and context:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./ERC721A.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SaudiPotatoz is ERC721A, Ownable, ReentrancyGuard {
  string public baseURI;
  uint public price = 0 ether;
  uint public maxPerTx = 1;
  uint public maxPerWallet = 1;
  uint public totalFree = 0;
  uint public maxSupply = 5000;
  uint public nextOwnerToExplicitlySet;
  bool public mintEnabled;

  constructor() ERC721A("SaudiPotatoz", "SaudiPotatoz") {}

  modifier callerIsUser() {
    require(tx.origin == msg.sender, "The caller is another contract");
    _;
  }

  function freeMint(uint256 amt) external callerIsUser {
    require(mintEnabled, "Minting is not enabled");
    require(totalSupply() + amt <= totalFree, "Exceeds free supply");
    require(numberMinted(msg.sender) + amt <= maxPerWallet, "Exceeds max per wallet");
    require(amt <= maxPerTx, "Exceeds max per tx");
    _safeMint(msg.sender, amt, "", true);
  }

  function mint(uint256 amt) external payable {
    require(mintEnabled, "Minting is not enabled");
    require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
    require(numberMinted(msg.sender) + amt <= maxPerWallet, "Exceeds max per wallet");
    require(amt <= maxPerTx, "Exceeds max per tx");
    require(msg.value >= price * amt, "Insufficient payment");
    _safeMint(msg.sender, amt, "", true);
  }

  function ownerBatchMint(uint256 amt) external onlyOwner {
    require(totalSupply() + amt <= maxSupply, "Exceeds max supply");
    _safeMint(msg.sender, amt, "", true);
  }

  function toggleMinting() external onlyOwner {
    mintEnabled = !mintEnabled;
  }

  function numberMinted(address owner) public view returns (uint256) {
    return _numberMinted(owner);
  }

  function setBaseURI(string calldata baseURI_) external onlyOwner {
    baseURI = baseURI_;
  }

  function setPrice(uint256 price_) external onlyOwner {
    price = price_;
  }

  function setTotalFree(uint256 totalFree_) external onlyOwner {
    totalFree = totalFree_;
  }

  function setMaxPerTx(uint256 maxPerTx_) external onlyOwner {
    maxPerTx = maxPerTx_;
  }

  function setMaxPerWallet(uint256 maxPerWallet_) external onlyOwner {
    maxPerWallet = maxPerWallet_;
  }

  function setmaxSupply(uint256 maxSupply_) external onlyOwner {
    maxSupply = maxSupply_;
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return baseURI;
  }

  function withdraw() external onlyOwner nonReentrant {
    (bool success, ) = payable(owner()).call{value: address(this).balance}("");
    require(success, "Withdrawal failed");
  }

  function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {
    _setOwnersExplicit(quantity);
  }

  function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory) {
    return ownershipOf(tokenId);
  }

  function _setOwnersExplicit(uint256 quantity) internal {
    require(quantity > 0, "Quantity must be greater than 0");
    require(totalSupply() > 0, "No tokens have been minted");

    uint256 _nextOwnerToExplicitlySet = nextOwnerToExplicitlySet;
    require(_nextOwnerToExplicitlySet < currentIndex, "All ownerships already set");

    uint256 endIndex = _nextOwnerToExplicitlySet + quantity;

    if (endIndex > currentIndex) {
      endIndex = currentIndex;
    }

    for (uint256 i = _nextOwnerToExplicitlySet; i < endIndex; i++) {
      if (_ownerships[i].addr == address(0)) {
        TokenOwnership memory ownership = ownershipOf(i);
        _ownerships[i].addr = ownership.addr;
        _ownerships[i].startTimestamp = ownership.startTimestamp;
      }
    }

    nextOwnerToExplicitlySet = endIndex;
  }
}
```

### Key Features Implemented:
1. **Free Mint Functionality**: Users can mint tokens for free within the limits specified by `totalFree` and `maxPerWallet`.
2. **Paid Mint Functionality**: Users can mint tokens by paying a specified price within the limits specified by `maxSupply`, `maxPerWallet`, and `maxPerTx`.
3. **Owner Batch Mint**: Allows the owner to mint tokens without paying, within the limits specified by `maxSupply`.
4. **Toggle Minting**: Enables the owner to enable or disable minting.
5. **Base URI Management**: Allows the owner to set the base URI for token metadata.
6. **Various Setters**: The owner can adjust parameters such as `price`, `totalFree`, `maxPerTx`, `maxPerWallet`, and `maxSupply`.
7. **Withdraw Functionality**: Allows the owner to withdraw funds from the contract.
8. **Ownership Data Management**: Optimizes future `ownerOf` calls by pre-setting ownership data for tokens. 

This implementation ensures security, efficiency, and adheres to best practices in Solidity smart contract development.