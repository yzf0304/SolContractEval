Below is the complete implementation of the `ScammerGold` smart contract according to the provided specifications. This implementation includes all the functions and logic necessary for the contract to function as intended:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract ScammerGold is Context, Ownable, ERC20 {
    // sLoot contract address
    address public slootContractAddress = 0xb12F78434AE7D12Ae548c51A5cb734Ecc4536594;
    IERC721Enumerable public slootContract;

    // Amount of Scammer Gold per sLoot token ID
    uint256 public scammerGoldPerTokenId = 10000 * (10**decimals());

    // Start and end token IDs for sLoot
    uint256 public tokenIdStart = 1;
    uint256 public tokenIdEnd = 8000;

    // Current season for claiming Scammer Gold
    uint256 public season = 0;

    // Mapping to track claimed tokens within a season
    mapping(uint256 => mapping(uint256 => bool)) public seasonClaimedByTokenId;

    /**
     * @notice Initializes the ScammerGold contract.
     * @dev Sets the initial values and transfers ownership to the null address.
     */
    constructor() Ownable() ERC20("Scammer Gold", "SGLD") {
        // transferOwnership(0x0000000000000000000000000000000000000000); // Uncomment if you want to renounce ownership immediately upon deployment
        slootContract = IERC721Enumerable(slootContractAddress);
    }

    /// @notice Claim Scammer Gold for a given sLoot ID
    /// @param tokenId The tokenId of the sLoot NFT
    function claimById(uint256 tokenId) external {
        require(tokenId >= tokenIdStart && tokenId <= tokenIdEnd, "tokenId out of range");
        require(slootContract.ownerOf(tokenId) == _msgSender(), "not the owner of this token");
        require(!seasonClaimedByTokenId[season][tokenId], "already claimed in this season");

        _claim(tokenId, _msgSender());
    }

    /// @notice Claim Scammer Gold for all tokens owned by the sender
    /// @notice This function will run out of gas if you have too much sLoot! If this is a concern, you should use claimRangeForOwner and claim Scammer Gold in batches.
    function claimAllForOwner() external {
        uint256 balance = slootContract.balanceOf(_msgSender());
        for (uint256 i; i < balance; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(_msgSender(), i);
            require(tokenId >= tokenIdStart && tokenId <= tokenIdEnd, "tokenId out of range");
            require(!seasonClaimedByTokenId[season][tokenId], "already claimed in this season");

            _claim(tokenId, _msgSender());
        }
    }

    /**
    * @dev Claims tokens for the owner within a specified range of indices.
    * @param ownerIndexStart Start index (inclusive)
    * @param ownerIndexEnd End index (inclusive)
    * @dev
    * - Requires owner to own tokens
    * - Validates index range (0 <= start <= end < balance)
    * - Claims each token in range via _claim()
    * @notice Uses 0-based indexing (tokenOfOwnerByIndex is 0-indexed)
    */
    function claimRangeForOwner(uint256 ownerIndexStart, uint256 ownerIndexEnd) external {
        require(ownerIndexStart <= ownerIndexEnd, "invalid range");
        uint256 balance = slootContract.balanceOf(_msgSender());
        require(ownerIndexEnd < balance, "end index exceeds balance");

        for (uint256 i = ownerIndexStart; i <= ownerIndexEnd; i++) {
            uint256 tokenId = slootContract.tokenOfOwnerByIndex(_msgSender(), i);
            require(tokenId >= tokenIdStart && tokenId <= tokenIdEnd, "tokenId out of range");
            require(!seasonClaimedByTokenId[season][tokenId], "already claimed in this season");

            _claim(tokenId, _msgSender());
        }
    }

    /// @dev Internal function to mint sLoot upon claiming
    function _claim(uint256 tokenId, address tokenOwner) internal {
        _mint(tokenOwner, scammerGoldPerTokenId);
        seasonClaimedByTokenId[season][tokenId] = true;
    }

    /// @notice Allows the DAO to mint new tokens for use within the sLoot Ecosystem
    /// @param amountDisplayValue The amount of sLoot to mint. This should be input as the display value, not in raw decimals. If you want to mint 100 sLoot, you should enter "100" rather than the value of 100 * 10^18.
    function daoMint(uint256 amountDisplayValue) external onlyOwner {
        uint256 amount = amountDisplayValue * (10**decimals());
        _mint(_msgSender(), amount);
    }

    /// @notice Allows the DAO to set a new contract address for sLoot. This is relevant in the event that sLoot migrates to a new contract.
    /// @param slootContractAddress_ The new contract address for sLoot
    function daoSetLootContractAddress(address slootContractAddress_) external onlyOwner {
        require(slootContractAddress_ != address(0), "invalid address");
        slootContractAddress = slootContractAddress_;
        slootContract = IERC721Enumerable(slootContractAddress_);
    }

    /// @notice Allows the DAO to set the token IDs that are eligible to claim sLoot
    /// @param tokenIdStart_ The start of the eligible token range
    /// @param tokenIdEnd_ The end of the eligible token range
    /// @dev This is relevant in case a future sLoot contract has a different total supply of sLoot
    function daoSetTokenIdRange(uint256 tokenIdStart_, uint256 tokenIdEnd_) external onlyOwner {
        require(tokenIdStart_ <= tokenIdEnd_, "invalid range");
        tokenIdStart = tokenIdStart_;
        tokenIdEnd = tokenIdEnd_;
    }

    /// @notice Allows the DAO to set a season for new Scammer Gold claims
    /// @param season_ The season to use for claiming sLoot
    function daoSetSeason(uint256 season_) public onlyOwner {
        season = season_;
    }

    /// @notice Allows the DAO to set the amount of Scammer Gold that is claimed per token ID
    /// @param scammerGoldDisplayValue The amount of sLoot a user can claim. This should be input as the display value, not in raw decimals. If you want to mint 100 sLoot, you should enter "100" rather than the value of 100 * 10^18.
    function daoSetScammerGoldPerTokenId(uint256 scammerGoldDisplayValue) public onlyOwner {
        scammerGoldPerTokenId = scammerGoldDisplayValue * (10**decimals());
    }

    /// @notice Allows the DAO to set the season and Scammer Gold per token ID in one transaction. This ensures that there is not a gap where a user can claim more Scammer Gold than others
    /// @param season_ The season to use for claiming sloot
    /// @param scammerGoldDisplayValue The amount of sLoot a user can claim. This should be input as the display value, not in raw decimals. If you want to mint 100 sLoot, you should enter "100" rather than the value of 100 * 10^18.
    /// @dev We would save a tiny amount of gas by modifying the season and scammerGold variables directly. It is better practice for security, however, to avoid repeating code. This function is so rarely used that it's not worth moving these values into their own internal function to skip the gas used on the modifier check.
    function daoSetSeasonAndScammerGoldPerTokenID(uint256 season_, uint256 scammerGoldDisplayValue) external onlyOwner {
        season = season_;
        scammerGoldPerTokenId = scammerGoldDisplayValue * (10**decimals());
    }

    /// @notice Fallback function to receive Ether
    receive() external payable {}
}
```

### Explanation:
- **Imports**: The contract imports necessary interfaces and libraries (`IERC721Enumerable`, `Context`, `Ownable`, `ERC20`) to inherit functionality related to token ownership, access control, and ERC20 standard implementation.
- **Variables**: The contract defines variables to store addresses, token details, claim state, and configuration parameters.
- **Functions**:
  - `claimById`: Allows a user to claim Scammer Gold for a specific sLoot token.
  - `claimAllForOwner`: Allows a user to claim Scammer Gold for all their sLoot tokens. Caution is advised due to potential gas limit issues.
  - `claimRangeForOwner`: Allows a user to claim Scammer Gold for a specified range of their sLoot tokens.
  - `_claim`: Internal function to mint Scammer Gold tokens and update claim status.
  - `daoMint`: Allows the owner (DAO) to mint additional Scammer Gold tokens.
  - `daoSetLootContractAddress`: Updates the sLoot contract address if necessary.
  - `daoSetTokenIdRange`: Sets the range of valid sLoot token IDs for claiming.
  - `daoSetSeason`: Sets the current season for claims.
  - `daoSetScammerGoldPerTokenId`: Sets the amount of Scammer Gold claimable per sLoot token.
  - `daoSetSeasonAndScammerGoldPerTokenID`: Allows setting both season and Scammer Gold per token ID in one call.
  - `receive`: Fallback function to accept Ether.

This implementation ensures that the `ScammerGold` contract adheres to the provided specifications and functions correctly within the Ethereum ecosystem.