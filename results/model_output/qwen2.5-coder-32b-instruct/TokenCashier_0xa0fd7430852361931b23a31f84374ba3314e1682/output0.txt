Certainly! Below is the completed `TokenCashier` contract based on the provided context and requirements. It includes all the necessary functions and logic as described:

```solidity
pragma solidity ^0.5.12;

contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

contract Pausable is Ownable {
    event Pause();
    event Unpause();

    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    modifier whenPaused() {
        require(paused);
        _;
    }

    function pause() onlyOwner whenNotPaused public {
        paused = true;
        emit Pause();
    }

    function unpause() onlyOwner whenPaused public {
        paused = false;
        emit Unpause();
    }
}

interface ITokenList {
    function isAllowed(address) external returns (bool);
    function maxAmount(address) external returns (uint256);
    function minAmount(address) external returns (uint256);
}

interface IWrappedCoin {
    function deposit() external payable;
}

contract TokenCashier is Pausable {
    event Receipt(address indexed token, uint256 indexed id, address sender, address recipient, uint256 amount, uint256 fee);

    ITokenList[] public tokenLists;
    address[] public tokenSafes;
    mapping(address => uint256) public counts;
    uint256 public depositFee;
    IWrappedCoin public wrappedCoin;

    constructor(IWrappedCoin _wrappedCoin, ITokenList[] memory _tokenLists, address[] memory _tokenSafes) public {
        require(_tokenLists.length == _tokenSafes.length, "# of token lists is not equal to # of safes");
        wrappedCoin = _wrappedCoin;
        tokenLists = _tokenLists;
        tokenSafes = _tokenSafes;
    }

    function() external {
        revert();
    }

    function count(address _token) public view returns (uint256) {
        return counts[_token];
    }

    function setDepositFee(uint256 _fee) public onlyOwner {
        depositFee = _fee;
    }

    function depositTo(address _token, address _to, uint256 _amount) public whenNotPaused payable {
        require(_to != address(0), "Invalid recipient address");
        uint256 fee = depositFee;
        uint256 totalAmount = _amount + fee;
        
        if (_token == address(0)) {
            require(msg.value == totalAmount, "Insufficient ETH sent");
            wrappedCoin.deposit.value(_amount)();
        } else {
            require(safeTransferFrom(_token, msg.sender, address(this), totalAmount), "Token transfer failed");
        }

        bool isAllowed = false;
        address safeAddress = address(0);
        for (uint i = 0; i < tokenLists.length; i++) {
            ITokenList tokenList = tokenLists[i];
            if (tokenList.isAllowed(_token)) {
                isAllowed = true;
                safeAddress = tokenSafes[i];
                uint256 minAmount = tokenList.minAmount(_token);
                uint256 maxAmount = tokenList.maxAmount(_token);
                require(_amount >= minAmount && _amount <= maxAmount, "Amount out of allowed range");
                break;
            }
        }
        require(isAllowed, "Token not whitelisted");

        if (safeAddress != address(0)) {
            if (!safeTransfer(_token, safeAddress, _amount)) {
                revert("Failed to transfer tokens to safe");
            }
        } else {
            // Attempt to burn the token if no safe is configured
            (bool success, ) = _token.call(abi.encodeWithSelector(0x42966c68, _amount));
            require(success, "Failed to burn tokens");
        }

        counts[_token] += 1;
        emit Receipt(_token, counts[_token], msg.sender, _to, _amount, fee);
    }

    function deposit(address _token, uint256 _amount) public payable {
        depositTo(_token, msg.sender, _amount);
    }

    function withdraw() external onlyOwner {
        msg.sender.transfer(address(this).balance);
    }

    function withdrawToken(address _token) public onlyOwner {
        (bool success, bytes memory data) = _token.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));
        require(success && data.length > 0, "Failed to get balance");
        uint256 balance = abi.decode(data, (uint256));
        if (balance > 0) {
            require(safeTransfer(_token, owner, balance), "Failed to transfer token");
        }
    }

    function safeTransferFrom(address _token, address _from, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0x23b872dd, _from, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }

    function safeTransfer(address _token, address _to, uint256 _amount) internal returns (bool) {
        (bool success, bytes memory data) = _token.call(abi.encodeWithSelector(0xa9059cbb, _to, _amount));
        return success && (data.length == 0 || abi.decode(data, (bool)));
    }
}
```

This contract adheres to the Solidity version 0.5.12 and includes all the specified functionalities, ensuring proper handling of token deposits, withdrawals, and fee calculations while being compliant with the provided interfaces and base contracts.