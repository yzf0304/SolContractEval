```solidity
contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    function register(string memory name, string memory pubKey) public {
        require(bytes(name).length >= 3 && bytes(name).length <= 16, "Name must be between 3 and 16 characters long");
        require(bytes(pubKey).length >= 50 && bytes(pubKey).length <= 64, "Public key must be between 50 and 64 characters long");

        bytes memory b = bytes(name);
        require((b[0] >= 0x30 && b[0] <= 0x39) || (b[0] >= 0x61 && b[0] <= 0x7A), "Name must start with a lowercase letter or digit");

        for(uint i = 1; i < b.length; i++){
            byte char = b[i];
            require((char >= 0x30 && char <= 0x39) || (char >= 0x61 && char <= 0x7A) || char == 0x2D || char == 0x2E, "Name can only contain lowercase letters, digits, hyphens, or periods");
        }

        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address is already registered");
        require(bytes(_accountToPubKey[name]).length == 0, "Name is already taken");

        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;

        emit AccountRegister(msg.sender, name, pubKey);
    }

    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    function keys(address addr) public view returns (string memory) {
        return _accountToPubKey[_ethToSphtx[addr]];
    }

    function nameAvailable(string memory name) public view returns (bool) {
        if(bytes(name).length < 3 || bytes(name).length > 16) return false;

        bytes memory b = bytes(name);
        if(!((b[0] >= 0x30 && b[0] <= 0x39) || (b[0] >= 0x61 && b[0] <= 0x7A))) return false;

        for(uint i = 1; i < b.length; i++){
            byte char = b[i];
            if(!((char >= 0x30 && char <= 0x39) || (char >= 0x61 && char <= 0x7A) || char == 0x2D || char == 0x2E)) return false;
        }

        return bytes(_accountToPubKey[name]).length == 0;
    }
}
```

This contract adheres to the specified requirements, including validation rules for SPHTX names and public keys, ensuring uniqueness and proper formatting. It utilizes mappings to store associations between Ethereum addresses, SPHTX names, and public keys, and provides functionality to register, retrieve, and check the availability of SPHTX names.