Below is the completed `TokenReclaim` contract implementing the functionalities as described in your context:

```solidity
pragma solidity ^0.4.23;

contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    function register(string memory name, string memory pubKey) public {
        bytes memory b = bytes(name);
        require(b.length >= 3 && b.length <= 16, "Name must be between 3 and 16 characters.");
        require((b[0] >= 97 && b[0] <= 122) || (b[0] >= 48 && b[0] <= 57), "Name must start with a lowercase letter or digit.");
        
        for(uint i=1; i<b.length; i++) {
            bytes1 c = b[i];
            require((c >= 97 && c <= 122) || (c >= 48 && c <= 57) || c == 45 || c == 46, "Name contains invalid characters.");
        }

        bytes memory pkBytes = bytes(pubKey);
        require(pkBytes.length >= 50 && pkBytes.length <= 64, "Public key must be between 50 and 64 characters.");

        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address is already registered.");
        require(bytes(_accountToPubKey[name]).length == 0, "Name is already registered.");

        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;
        emit AccountRegister(msg.sender, name, pubKey);
    }

    function account(address addr) public view returns (string memory) {
        return _ethToSphtx[addr];
    }

    function keys(address addr) public view returns (string memory) {
        return _accountToPubKey[_ethToSphtx[addr]];
    }

    function nameAvailable(string memory name) public view returns (bool) {
        bytes memory b = bytes(name);
        if(b.length < 3 || b.length > 16) {
            return false;
        }
        if(!((b[0] >= 97 && b[0] <= 122) || (b[0] >= 48 && b[0] <= 57))) {
            return false;
        }

        for(uint i=1; i<b.length; i++) {
            bytes1 c = b[i];
            if(!((c >= 97 && c <= 122) || (c >= 48 && c <= 57) || c == 45 || c == 46)) {
                return false;
            }
        }

        return bytes(_accountToPubKey[name]).length == 0;
    }
}
```

This contract adheres to the specified requirements and includes validation checks for name and public key formats and lengths. It also ensures that each Ethereum address and SPHTX name are unique within the system.