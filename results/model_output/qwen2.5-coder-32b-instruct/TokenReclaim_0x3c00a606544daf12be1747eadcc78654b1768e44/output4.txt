Here is the completed `TokenReclaim` smart contract based on the provided context and description, using Solidity compiler version 0.4.23:

```solidity
pragma solidity ^0.4.23;

contract TokenReclaim {
    mapping (address => string) internal _ethToSphtx;
    mapping (string => string) internal _accountToPubKey;

    event AccountRegister(address ethAccount, string sphtxAccount, string pubKey);

    function register(string name, string pubKey) public {
        require(bytes(name).length >= 3 && bytes(name).length <= 16, "Name must be between 3 and 16 characters");
        require(bytes(pubKey).length >= 50 && bytes(pubKey).length <= 64, "Public key must be between 50 and 64 characters");

        // Check if the name format is correct
        bytes memory nameBytes = bytes(name);
        require((nameBytes[0] >= 97 && nameBytes[0] <= 122) || (nameBytes[0] >= 48 && nameBytes[0] <= 57), "Name must start with a lowercase letter or digit");
        for(uint i = 1; i < nameBytes.length; i++) {
            require(
                (nameBytes[i] >= 97 && nameBytes[i] <= 122) ||
                (nameBytes[i] >= 48 && nameBytes[i] <= 57) ||
                nameBytes[i] == 45 || nameBytes[i] == 46,
                "Name can only contain lowercase letters, digits, hyphens and periods"
            );
        }

        require(bytes(_ethToSphtx[msg.sender]).length == 0, "Address is already registered");
        require(bytes(_accountToPubKey[name]).length == 0, "Name is already in use");

        _ethToSphtx[msg.sender] = name;
        _accountToPubKey[name] = pubKey;

        emit AccountRegister(msg.sender, name, pubKey);
    }

    function account(address addr) public view returns (string) {
        return _ethToSphtx[addr];
    }

    function keys(address addr) public view returns (string) {
        string memory name = _ethToSphtx[addr];
        return _accountToPubKey[name];
    }

    function nameAvailable(string name) public view returns (bool) {
        if(bytes(name).length < 3 || bytes(name).length > 16) {
            return false;
        }
        
        bytes memory nameBytes = bytes(name);
        if(!((nameBytes[0] >= 97 && nameBytes[0] <= 122) || (nameBytes[0] >= 48 && nameBytes[0] <= 57))) {
            return false;
        }
        for(uint i = 1; i < nameBytes.length; i++) {
            if (!((nameBytes[i] >= 97 && nameBytes[i] <= 122) ||
                  (nameBytes[i] >= 48 && nameBytes[i] <= 57) ||
                  nameBytes[i] == 45 || nameBytes[i] == 46)) {
                return false;
            }
        }
        
        return bytes(_accountToPubKey[name]).length == 0;
    }
}
```

This contract implements all specified functions and follows the given requirements for name and public key validation, along with ensuring the uniqueness of names and addresses. It also emits an event upon successful registration of an account.