Below is the completed `TronToken` smart contract according to the provided context and requirements. This implementation includes the missing functions and ensures compatibility with Solidity compiler version 0.4.18.

```solidity
contract TronToken {

    string   public name;            //  token name
    string   public symbol;          //  token symbol
    uint256  public decimals;        //  token digit

    mapping (address => uint256) public balanceOf;

    uint256 public totalSupply = 0;
    bool public stopped = false;      //  stopflag: true is stopped, false is not stopped

    uint256 constant valueFounder = 500000000000000000;
    address owner = 0x0;

    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }

    modifier isRunning {
        assert (!stopped);
        _;
    }

    modifier validAddress {
        assert(0x0 != msg.sender);
        _;
    }

    function TronToken(address _addressFounder, uint256 _initialSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public {
        owner = msg.sender;
        if (_addressFounder == 0x0)
            _addressFounder = msg.sender;
        if (_initialSupply == 0) 
            _initialSupply = valueFounder;
        totalSupply = _initialSupply;   // Set the totalSupply 
        name = _tokenName;              // Set the name for display 
        symbol = _tokenSymbol;          // Set the symbol for display 
        decimals = _decimalUnits;       // Amount of decimals for display purposes
        balanceOf[_addressFounder] = totalSupply;
        Transfer(0x0, _addressFounder, totalSupply);
    }

    function transfer(address _to, uint256 _value) public isRunning validAddress returns (bool success) {
        require(_to != address(0));
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to].add(_value) > balanceOf[_to]); // Prevent overflow

        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);

        Transfer(msg.sender, _to, _value);
        return true;
    }

    function stop() public isOwner {
        stopped = true;
    }

    function start() public isOwner {
        stopped = false;
    }

    function setName(string _name) public isOwner {
        name = _name;
    }

    function setOwner(address _owner) public isOwner {
        require(_owner != address(0));
        owner = _owner;
    }

    function burn(uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function () public payable {}
}

library SafeMath {
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}
```

**Note:** 
- The `SafeMath` library is included at the end for safe arithmetic operations. However, since it is defined as a separate library and not imported, ensure that this code is correctly placed in your contract file or integrated into your build system.
- The `assert()` statements were used as per the provided code template, though `require()` might be more appropriate in some cases for providing more specific error messages and avoiding wasting gas in case of failure. In the context of this exercise and the requirement to follow the given structure, `assert()` has been retained.
- The constructor parameters use `uint256` for `_initialSupply`, but `_decimalUnits` is `uint8` as per typical ERC20 standard.