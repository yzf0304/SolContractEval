Certainly! Below is the completed `UniqlyPresale4` contract with all the necessary functions implemented according to the provided context and description:

```solidity
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.2;

abstract contract IERC20 {
    function balanceOf(address _owner)
        external
        virtual
        returns (uint256 balance);

    function transfer(address _to, uint256 _value) external virtual;
}

contract UniqlyPresale4 {
    uint256 public immutable presaleLimit;
    uint256 public immutable minPerUser;
    uint256 public immutable maxPerUser;
    uint256 public immutable presaleEnd;
    uint256 constant failSafeTime = 2 weeks;
    address public owner;
    bool presaleEnded;
    bool presaleFailed;
    bool presaleStarted;
    mapping(address => uint256) private balances;

    constructor(uint256 _presaleLimit, uint256 _minPerUser, uint256 _maxPerUser, uint256 _presaleEnd, address _owner) {
        presaleLimit = _presaleLimit;
        minPerUser = _minPerUser;
        maxPerUser = _maxPerUser;
        presaleEnd = _presaleEnd;
        owner = _owner;
    }

    receive() external payable {
        require(presaleStarted, "Presale not started");
        require(!presaleEnded, "Presale ended");
        require(block.timestamp < presaleEnd, "Presale time's up");

        uint256 amount = msg.value + balances[msg.sender];
        require(amount >= minPerUser, "Below buy-in");
        require(amount <= maxPerUser, "Over buy-in");
        balances[msg.sender] = amount;

        if (collected() >= presaleLimit) {
            presaleEnded = true;
        }
    }

    function start() external {
        require(msg.sender == owner, "Not owner");
        require(!presaleStarted, "Presale already started");
        presaleStarted = true;
    }

    function balanceOf(address user) external view returns (uint256) {
        return balances[user];
    }

    function balanceOf() external view returns (uint256) {
        return balances[msg.sender];
    }

    function collected() public view returns (uint256) {
        return address(this).balance;
    }

    function withdraw() external returns (bool) {
        if (!presaleEnded && block.timestamp > presaleEnd + failSafeTime) {
            presaleFailed = true;
        }

        if (presaleFailed) {
            uint256 balance = balances[msg.sender];
            balances[msg.sender] = 0;
            send(msg.sender, balance);
            return true;
        } else if (presaleEnded) {
            require(msg.sender == owner, "Not owner");
            send(owner, collected());
            return true;
        }

        return false;
    }

    function send(address user, uint256 amount) private {
        bool success;
        assembly {
            success := call(gas(), user, amount, 0, 0, 0, 0)
        }
        require(success, "Transfer failed");
    }

    function withdrawAnyERC20(IERC20 token) external {
        require(msg.sender == owner, "Not owner");
        uint256 balance = token.balanceOf(address(this));
        token.transfer(owner, balance);
    }

    address public newOwner;

    function giveOwnership(address _newOwner) external {
        require(msg.sender == owner, "Not owner");
        newOwner = _newOwner;
    }

    function acceptOwnership() external {
        require(msg.sender == newOwner, "Not new owner");
        owner = newOwner;
        delete newOwner;
    }
}
```

This contract now includes all required functionalities such as starting the presale, tracking user balances, collecting funds, and handling withdrawals based on the presale's state. It also includes mechanisms for failing the presale if it doesn't end within the allotted time and recovering any accidental ERC20 token transfers. Additionally, it supports transferring ownership of the contract in a secure manner.