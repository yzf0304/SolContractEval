Certainly! Below is the complete `Pausable` smart contract based on your provided specifications. I've implemented the logic for pausing and unpausing, as well as changing the pauser role. This contract uses the `Context` and `Ownable` contracts as specified.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.0;

contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691
        return msg.data;
    }
}

contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    function owner() public view virtual returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Pausable is Context, Ownable {
    event Pause();
    event Unpause();
    event PauserChanged(address indexed newAddress);

    address public pauser;
    bool public paused = false;

    modifier whenNotPaused() {
        require(!paused, "Network paused by administrator");
        _;
    }

    modifier onlyPauser() {
        require(msg.sender == pauser, "Caller is not the pause administrator");
        _;
    }

    constructor() {
        pauser = _msgSender();
        emit PauserChanged(pauser);
    }

    function pause() external onlyPauser whenNotPaused {
        paused = true;
        emit Pause();
    }

    function unpause() external onlyPauser whenPaused {
        paused = false;
        emit Unpause();
    }

    function updatePauser(address _newPauser) external onlyOwner {
        require(_newPauser != address(0), "Ownable: new pauser is the zero address");
        pauser = _newPauser;
        emit PauserChanged(_newPauser);
    }

    modifier whenPaused() {
        require(paused, "Network is not paused");
        _;
    }
}
```

### Key Points:
- **Constructor**: The `Pausable` contract's constructor sets the initial pauser to the contract deployer.
- **Modifiers**:
  - `whenNotPaused`: Ensures that certain functions can only be called when the contract is not paused.
  - `onlyPauser`: Ensures that certain functions can only be called by the designated pauser.
  - `whenPaused`: Additional modifier to ensure a function can only be called when the contract is paused (useful for `unpause` method).
- **Events**: Emitted on various actions for transparency and off-chain event listening.
- **Methods**:
  - `pause()`: Changes the `paused` state to `true`.
  - `unpause()`: Changes the `paused` state to `false`.
  - `updatePauser(address _newPauser)`: Updates the pauser role to a new address.