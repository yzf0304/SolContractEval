Below is the complete implementation of the `Wagmipet` smart contract based on the provided context and description:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

contract Wagmipet {
    address _owner;
    bool _birthed;
    
    event CaretakerLoved(address indexed caretaker, uint256 indexed amount);
    
    uint256 lastFeedBlock;
    uint256 lastCleanBlock;
    uint256 lastPlayBlock;
    uint256 lastSleepBlock;
    
    uint8 internal hunger;
    uint8 internal uncleanliness;
    uint8 internal boredom;
    uint8 internal sleepiness;
    
    mapping (address => uint256) public love;
    
    modifier onlyOwner() {
        require(msg.sender == _owner);
        _;
    }
    
    constructor() {
        _owner = msg.sender;
        lastFeedBlock = block.number;
        lastCleanBlock = block.number;
        lastPlayBlock = block.number;
        lastSleepBlock = block.number;
        
        hunger = 0;
        uncleanliness = 0;
        boredom = 0;
        sleepiness = 0;
    }
    
    function addLove(address caretaker, uint256 amount) internal {
        love[caretaker] += amount;
        emit CaretakerLoved(caretaker, amount);
    }
    
    function feed() public {
        require(getAlive(), "Pet is no longer with us");
        require(boredom < 50, "Too bored to eat");
        require(uncleanliness < 50, "Too dirty to eat");

        hunger = 0;
        boredom += 10;
        uncleanliness += 3;
        addLove(msg.sender, 1);
    }
    
    function clean() public {
        require(getAlive(), "Pet is no longer with us");
        require(uncleanliness > 0, "Already clean");

        uncleanliness = 0;
        addLove(msg.sender, 1);
    }
    
    function play() public {
        require(getAlive(), "Pet is no longer with us");
        require(hunger < 50, "Too hungry to play");
        require(sleepiness < 50, "Too sleepy to play");
        require(uncleanliness < 50, "Too dirty to play");

        boredom = 0;
        hunger += 10;
        sleepiness += 10;
        uncleanliness += 5;
        addLove(msg.sender, 1);
    }
    
    function sleep() public {
        require(getAlive(), "Pet is no longer with us");
        require(uncleanliness < 80, "Too dirty to sleep");
        require(sleepiness > 0, "Not sleepy");

        lastSleepBlock = block.number;
        sleepiness = 0;
        uncleanliness += 5;
        addLove(msg.sender, 1);
    }
    
    function getStatus() public view returns (string memory) {
        if (!getAlive()) return "no longer with us";
        
        if (sleepiness > 50) return "very sleepy";
        if (boredom > 50) return "very bored";
        if (uncleanliness > 50) return "very dirty";
        if (hunger > 50) return "very hungry";
        
        string[4] memory statuses = ["gm", "im feeling great", "all good", "i love u"];
        uint256 index = block.number % 4;
        return statuses[index];
    }
    
    function getAlive() public view returns (bool) {
        return hunger < 101 && uncleanliness < 101 && boredom < 101 && sleepiness < 101;
    }
    
    function getHunger() public view returns (uint256) {
        return hunger + uint8(block.number - lastFeedBlock) / 10;
    }
    
    function getUncleanliness() public view returns (uint256) {
        return uncleanliness + uint8(block.number - lastCleanBlock) / 10;
    }
    
    function getBoredom() public view returns (uint256) {
        return boredom + uint8(block.number - lastPlayBlock) / 10;
    }
    
    function getSleepiness() public view returns (uint256) {
        return sleepiness + uint8(block.number - lastSleepBlock) / 10;
    }
}
```

This contract implements all specified functionalities and logic, ensuring that the pet's conditions degrade over time and can be managed by specific actions. The `getStatus` function provides feedback on the pet's condition, and each action (`feed`, `clean`, `play`, `sleep`) modifies the pet's conditions accordingly.