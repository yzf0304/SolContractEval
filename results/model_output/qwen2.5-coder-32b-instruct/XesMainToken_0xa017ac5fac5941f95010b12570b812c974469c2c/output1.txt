Here is the complete `StandardToken` contract implemented as per your specifications, using Solidity compiler version 0.4.19. It incorporates the `ERC20` interface and utilizes the `SafeMath` contract for safe arithmetic operations.

```solidity
/**
 * @title StandardToken
 * @dev Implementation of the basic standard token with ERC20 and SafeMath.
 * @notice This contract provides a standard implementation of an ERC20 token, including transfer, transferFrom, approve, and allowance functions.
 */
contract StandardToken is ERC20, SafeMath {

    mapping (address => uint) balances;

    mapping (address => mapping (address => uint)) allowed;

    /**
     * @notice Transfers `_value` amount of tokens from the message sender to `_to`.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to be transferred.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits a Transfer event and uses SafeMath for arithmetic operations.
     */
    function transfer(address _to, uint _value) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], _value);
        balances[_to] = safeAdd(balances[_to], _value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    /**
     * @notice Transfers `_value` amount of tokens from `_from` to `_to`, using the allowance mechanism.
     * @param _from The address from which the tokens will be transferred.
     * @param _to The address to which the tokens will be transferred.
     * @param _value The amount of tokens to be transferred.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits a Transfer event, updates the allowance, and uses SafeMath for arithmetic operations.
     */
    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
        uint _allowance = allowed[_from][msg.sender];
        require(_value <= _allowance); // Ensure sufficient allowance

        balances[_to] = safeAdd(balances[_to], _value);
        balances[_from] = safeSub(balances[_from], _value);
        allowed[_from][msg.sender] = safeSub(_allowance, _value);
        Transfer(_from, _to, _value);
        return true;
    }

    /**
     * @notice Returns the balance of the `_owner` address.
     * @param _owner The address whose balance is to be queried.
     * @return The balance of the `_owner` address.
     * @dev This function is constant and does not modify the state.
     */
    function balanceOf(address _owner) public constant returns (uint balance) {
        return balances[_owner];
    }

    /**
     * @notice Approves `_spender` to spend up to `_value` amount of tokens on behalf of the message sender.
     * @param _spender The address that is being approved to spend the tokens.
     * @param _value The maximum amount of tokens that can be spent.
     * @return A boolean value indicating whether the operation succeeded.
     * @dev Emits an Approval event. Be aware of the risks associated with setting the allowance to 0 before calling this function.
     */
    function approve(address _spender, uint _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    /**
     * @notice Returns the remaining amount of tokens that `_spender` is allowed to spend on behalf of `_owner`.
     * @param _owner The address that owns the tokens.
     * @param _spender The address that is allowed to spend the tokens.
     * @return The remaining amount of tokens that `_spender` is allowed to spend.
     * @dev This function is constant and does not modify the state.
     */
    function allowance(address _owner, address _spender) public constant returns (uint remaining) {
        return allowed[_owner][_spender];
    }
}
```

### Notes:
- The `require` statement has been added in `transferFrom` to ensure that the transfer amount does not exceed the allowance. This is a good practice to avoid underflow issues.
- The contract uses the `constant` keyword for functions that do not modify the state of the blockchain. In Solidity 0.5.0 and later, `constant` was replaced by `view`.
- The events `Transfer` and `Approval` are emitted according to the ERC20 standard to provide transparency regarding token transfers and approvals.