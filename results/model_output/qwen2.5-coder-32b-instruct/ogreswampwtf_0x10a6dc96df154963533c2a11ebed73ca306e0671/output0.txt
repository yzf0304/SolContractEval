Below is the completed `ogreswampwtf` smart contract implementing all the specified functionalities:

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;

import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/utils/introspection/IERC165.sol";
import "@openzeppelin/contracts/utils/introspection/ERC165.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract ogreswampwtf is ERC721, Ownable {
  using Counters for Counters.Counter; 
  using Strings for uint256;

  Counters.Counter private _tokenSupply;
  string public ogreURI;
  string public ogreExtension = ".json"; 
  uint256 public cost = 0 ether; 
  uint256 public maxSupply = 3333; 
  uint256 public freeMints = 3333; 
  uint256 public maxMintAmount = 3; 
  bool public paused = false;
  bool public revealed = false;
  string public SwampUri;
  mapping(address => bool) public whitelisted;
  mapping(address => uint256) private freeMintsWallet;

  constructor(
    string memory _name,
    string memory _symbol,
    string memory _initOgreURI,
    string memory _initSwampUri
  ) ERC721(_name, _symbol) {
    setOgreURI(_initOgreURI);
    setSwampURI(_initSwampUri);
  }

  function totalSupply() public view returns (uint256) {
    return _tokenSupply.current();
  }

  function _ogreURI() internal view virtual override returns (string memory) {
    return ogreURI;
  }

  function mint(address _to, uint256 _mintAmount) public payable {
    require(!paused, "The contract is paused!");
    require(_mintAmount > 0, "Need to mint at least 1 NFT");
    require(_mintAmount <= maxMintAmount, "Max mint amount per transaction exceeded");
    require(totalSupply() + _mintAmount <= maxSupply, "Max supply exceeded");
    
    if (_tokenSupply.current() < freeMints) {
      require(whitelisted[msg.sender], "Not whitelisted for free mint");
      require(freeMintsWallet[msg.sender] + _mintAmount <= 20, "Exceeded free mint limit per wallet");
      freeMintsWallet[msg.sender] += _mintAmount;
    } else {
      require(msg.value >= cost * _mintAmount, "Insufficient funds");
    }

    for(uint256 i = 1; i <= _mintAmount; i++) {
      _safeMint(_to, _tokenSupply.current() + 1);
      _tokenSupply.increment();
    }
  }

  function tokenURI(uint256 tokenId)
    public
    view
    virtual
    override
    returns (string memory)
  {
    require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

    if (!revealed) {
      return SwampUri;
    }

    string memory currentBaseURI = _baseURI();
    return bytes(currentBaseURI).length > 0
        ? string(abi.encodePacked(currentBaseURI, tokenId.toString(), ogreExtension))
        : "";
  }

  function reveal() public onlyOwner {
    revealed = true;
  }

  function setCost(uint256 _newCost) public onlyOwner {
    cost = _newCost;
  }

  function setmaxMintAmount(uint256 _newmaxMintAmount) public onlyOwner {
    maxMintAmount = _newmaxMintAmount;
  }

  function setSwampURI(string memory _SwampURI) public onlyOwner {
    SwampUri = _SwampURI;
  }

  function setOgreURI(string memory _newOgreURI) public onlyOwner {
    ogreURI = _newOgreURI;
  }

  function setOgreExtension(string memory _newOgreExtension) public onlyOwner {
    ogreExtension = _newOgreExtension;
  }

  function pause(bool _state) public onlyOwner {
    paused = _state;
  }

  function whitelistUser(address _user) public onlyOwner {
    whitelisted[_user] = true;
  }

  function removeWhitelistUser(address _user) public onlyOwner {
    whitelisted[_user] = false;
  }

  function withdraw() public payable onlyOwner {
    require(payable(msg.sender).send(address(this).balance));
  }
}
```

### Summary
This contract implements the basic functionalities required for an NFT collection including minting, revealing, and administrative functionalities. It uses OpenZeppelin's libraries to simplify implementation and ensure security. The contract allows for:
- Minting of tokens with free or paid options.
- Revealing the NFTs by changing their URI.
- Administrative functions to control various parameters like cost, supply, and minting rules.
- A whitelist system to allow certain addresses to mint NFTs for free.
- Contract pausing functionality.
- Withdrawal of funds by the owner.