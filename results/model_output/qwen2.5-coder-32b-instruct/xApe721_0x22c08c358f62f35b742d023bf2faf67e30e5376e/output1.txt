Certainly! Below is the completed `xApe721` contract implementing all the specified functionalities according to the provided documentation and requirements:

```solidity
// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.10;

import "./Ownable.sol";
import "./ERC721.sol";
import "./IERC721.sol";
import "./Strings.sol";

/**
 * @title xApe721
 * @notice This contract is an ERC721 token contract that allows for minting, claiming, and managing a collection of 10,000 unique tokens.
 * @dev The contract includes functionalities to claim tokens from an old contract, mint new tokens, and manage the minting process.
 */
contract xApe721 is Ownable, ERC721 {
  using Strings for uint256;

  uint256 public constant TOTAL_SUPPLY = 10_000;
  uint256 public constant PRICE_PER_MINT = 0.05 ether;
  uint256 public constant MAX_MINT_PER_TX = 20;

  bool public mintActive;
  uint256 public totalSupply;
  uint256 internal nextMintableId = 10038; // IDs start at 10038
  string public baseURI;
  IERC721 public oldContract;
  address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;

  constructor(
    string memory name,
    string memory symbol,
    string memory _baseURI,
    address _oldContract,
    address[] memory recipients,
    uint256[] memory tokens
  ) payable ERC721(name, symbol) {
    require(recipients.length == tokens.length, "Airdrop lengths");
    baseURI = _baseURI;

    if (_oldContract != address(0)) {
      oldContract = IERC721(_oldContract);
    }

    uint256 length = tokens.length;

    for (uint i; i < length; ++i) {
      _mint(recipients[i], tokens[i]);
      totalSupply++;
    }
  }

  modifier onlyTeamWallet() {
    require(msg.sender == teamWallet, "Not callable except by team wallet");
    _;
  }

  function mint(uint16 amount) external payable {
    require(mintActive, "Minting not active");
    require(amount > 0 && amount <= MAX_MINT_PER_TX, "Invalid mint amount");
    require(totalSupply + amount <= TOTAL_SUPPLY, "Exceeds total supply");
    require(msg.value >= amount * PRICE_PER_MINT, "Insufficient ETH sent");

    for (uint i; i < amount; ++i) {
      _mint(msg.sender, nextMintableId);
      nextMintableId++;
      totalSupply++;
    }
  }

  function claim(uint256 tokenId) external payable {
    require(!_ownsOldToken(msg.sender, tokenId), "Already claimed");
    require(oldContract.ownerOf(tokenId) == msg.sender, "Not owner of old token");

    _mint(msg.sender, _getNextUnusedID());
    totalSupply++;
  }

  function claimAll() external payable {
    uint256[] memory phunks = oldContract.getPhunksBelongingToOwner(msg.sender);
    require(phunks.length > 0, "No tokens to claim");

    for (uint256 i; i < phunks.length; ++i) {
      uint256 tokenId = phunks[i];
      if (!_ownsOldToken(msg.sender, tokenId)) {
        _mint(msg.sender, _getNextUnusedID());
        totalSupply++;
      }
    }
  }

  function _ownsOldToken(address account, uint256 tokenId) internal view returns(bool) {
    try oldContract.ownerOf(tokenId) returns (address owner) {
      return owner == account;
    } catch {
      return false;
    }
  }

  function _getNextUnusedID() internal returns (uint256) {
    while (nextMintableId <= TOTAL_SUPPLY && ownerOf[nextMintableId] != address(0)) {
      nextMintableId++;
    }
    require(nextMintableId <= TOTAL_SUPPLY, "No more IDs available");
    return nextMintableId;
  }

  function tokenURI(uint256 id) public view override returns (string memory) {
    require(ownerOf[id] != address(0), "Nonexistent token");
    return string(abi.encodePacked(baseURI, id.toString()));
  }

  function withdraw() external onlyTeamWallet() {
    SafeTransferLib.safeTransferETH(teamWallet, address(this).balance);
  }

  function pauseMint() external onlyOwner {
    mintActive = false;
  }

  function startMint() external onlyOwner {
    mintActive = true;
  }

  function setBaseURI(string memory _baseURI) external onlyOwner {
    baseURI = _baseURI;
  }

  function supportsInterface(bytes4 interfaceId)
    public
    pure
    override
    returns (bool)
  {
    return
      interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165
      interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
      interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
  }

  function onERC721Received(
      address operator,
      address from,
      uint256 tokenId,
      bytes calldata data
  ) external returns (bytes4) {
      return ERC721TokenReceiver.onERC721Received.selector;
  }
}
```

This implementation adheres closely to the specifications you provided, including minting functionality, claim functionalities from an old contract, and various management functions such as pausing and resuming minting, setting the base URI, and withdrawing funds.