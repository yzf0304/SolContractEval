Below is the completed `xApe721` contract based on the provided context and description. This contract implements all the necessary functions and modifiers as specified:

```solidity
/**
 * @title xApe721
 * @notice This contract is an ERC721 token contract that allows for minting, claiming, and managing a collection of 10,000 unique tokens.
 * @dev The contract includes functionalities to claim tokens from an old contract, mint new tokens, and manage the minting process.
 */
contract xApe721 is Ownable, ERC721 {
  using Strings for uint256;

  uint256 public constant TOTAL_SUPPLY = 10_000;
  uint256 public constant PRICE_PER_MINT = 0.05 ether;
  uint256 public constant MAX_MINT_PER_TX = 20;

  bool public mintActive;
  uint256 public totalSupply;
  uint256 internal nextMintableId = 10038; // IDs start at 10038

  string public baseURI;
  IERC721 public oldContract = IERC721(0x090b1DE324fEA5f0A0B4226101Db645819102629);
  address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;

  constructor(
    string memory name,
    string memory symbol,
    string memory _baseURI,
    address _oldContract,
    address[] memory recipients,
    uint256[] memory tokens
  ) payable ERC721(name, symbol) {
    require(recipients.length == tokens.length, "Airdrop lengths");
    baseURI = _baseURI;

    if (_oldContract != address(0)) {
      oldContract = IERC721(_oldContract);
    }

    uint256 length = tokens.length;
    for (uint i; i < length; ++i) {
      _mint(recipients[i], tokens[i]);
      totalSupply++;
    }
  }

  modifier onlyTeamWallet() {
    require(msg.sender == teamWallet, "Not callable except by team wallet");
    _;
  }

  function mint(uint16 amount) external payable {
    require(mintActive, "Minting is not active");
    require(amount > 0 && amount <= MAX_MINT_PER_TX, "Invalid mint amount");
    require(totalSupply + amount <= TOTAL_SUPPLY, "Exceeds total supply");
    require(msg.value >= amount * PRICE_PER_MINT, "Insufficient funds");

    for (uint16 i = 0; i < amount; i++) {
      uint256 tokenId = _getNextUnusedID();
      _mint(msg.sender, tokenId);
      totalSupply++;
    }
  }

  function claim(uint256 tokenId) external payable {
    require(oldContract.ownerOf(tokenId) == msg.sender, "Not the owner of old token");
    require(ownerOf[tokenId] == address(0), "Token already claimed");
    
    _mint(msg.sender, tokenId);
    totalSupply++;
  }

  function claimAll() external payable {
    uint256[] memory oldTokens = oldContract.getPhunksBelongingToOwner(msg.sender);
    require(oldTokens.length > 0, "No tokens to claim");

    for (uint256 i = 0; i < oldTokens.length; i++) {
      if (ownerOf[oldTokens[i]] == address(0)) {
        _mint(msg.sender, oldTokens[i]);
        totalSupply++;
      }
    }
  }

  function _ownsOldToken(address account, uint256 tokenId) internal view returns (bool) {
    try oldContract.ownerOf(tokenId) returns (address owner) {
      return owner == account;
    } catch {
      return false;
    }
  }

  function _getNextUnusedID() internal returns (uint256) {
    while (nextMintableId <= TOTAL_SUPPLY && (ownerOf[nextMintableId] != address(0) || _ownsOldToken(address(this), nextMintableId))) {
      nextMintableId++;
    }
    require(nextMintableId <= TOTAL_SUPPLY, "No more tokens available");
    return nextMintableId;
  }

  function tokenURI(uint256 id) public view override returns (string memory) {
    require(ownerOf[id] != address(0), "Token does not exist");
    return string(abi.encodePacked(baseURI, id.toString()));
  }

  function withdraw() external onlyTeamWallet {
    SafeTransferLib.safeTransferETH(teamWallet, address(this).balance);
  }

  function pauseMint() external onlyOwner {
    mintActive = false;
  }

  function startMint() external onlyOwner {
    mintActive = true;
  }

  function setBaseURI(string memory _baseURI) external onlyOwner {
    baseURI = _baseURI;
  }

  function supportsInterface(bytes4 interfaceId)
    public
    pure
    override
    returns (bool)
  {
    return
      interfaceId == type(IERC721).interfaceId ||
      super.supportsInterface(interfaceId);
  }

  function onERC721Received(
    address operator,
    address from,
    uint256 tokenId,
    bytes calldata data
  ) external returns (bytes4) {
    emit Transfer(from, operator, tokenId);
    return this.onERC721Received.selector;
  }
}
```

This contract includes functions to mint new tokens, claim tokens from an old contract, and manage the contract settings like minting status, base URI, and team wallet. It also includes the necessary checks and balances to ensure the contract operates correctly.