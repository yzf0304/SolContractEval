{
    "name": "AtomicSwap",
    "address": "0xac5881d77db9340c94f53300736a9cf9e61fa25e",
    "Compiler Version": "v0.5.16+commit.9c3226ce",
    "Optimization Enabled": "No with 0 runs",
    "abi": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Added\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_participant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refundTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_countdown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payoff\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"Initiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_participant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refundTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payoff\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"swaps\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"secret\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"refundTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countdown\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoff\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"enum AtomicSwap.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
    "constructor_argument": "",
    "Contract Source Code": "pragma solidity ^0.5.0;\r\n\r\n// From file: openzeppelin-contracts/contracts/math/SafeMath.sol \r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n}\r\n\r\n// From file: openzeppelin-contracts/contracts/utils/Address.sol \r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-contracts/contracts/token/ERC20/SafeERC20.sol \r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol \r\ncontract ReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    constructor () internal {\r\n        _notEntered = true;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n        _notEntered = false;\r\n        _;\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\ncontract AtomicSwap is ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    enum State { Empty, Initiated, Redeemed, Refunded }\r\n\r\n    struct Swap {\r\n        bytes32 hashedSecret;\r\n        bytes32 secret;\r\n        address contractAddr;\r\n        address participant;\r\n        address payable initiator;\r\n        uint refundTimestamp;\r\n        uint countdown;\r\n        uint value;\r\n        uint payoff;\r\n        bool active;\r\n        State state;\r\n    }\r\n    \r\n    event Initiated(\r\n        bytes32 indexed _hashedSecret,\r\n        address indexed _contract,\r\n        address indexed _participant,\r\n        address _initiator,\r\n        uint _refundTimestamp,\r\n        uint _countdown,\r\n        uint _value,\r\n        uint _payoff,\r\n        bool _active\r\n    );\r\n    event Added(\r\n        bytes32 indexed _hashedSecret,\r\n        address _sender,\r\n        uint _value  \r\n    );\r\n    event Activated(\r\n        bytes32 indexed _hashedSecret\r\n    );\r\n    event Redeemed(\r\n        bytes32 indexed _hashedSecret,\r\n        bytes32 _secret\r\n    );\r\n    event Refunded(\r\n        bytes32 indexed _hashedSecret\r\n    );\r\n\r\n    mapping(bytes32 => Swap) public swaps;\r\n\r\n    modifier onlyByInitiator(bytes32 _hashedSecret) {\r\n        require(msg.sender == swaps[_hashedSecret].initiator, \"sender is not the initiator\");\r\n        _;\r\n    }\r\n\r\n    modifier isInitiatable(bytes32 _hashedSecret, address _participant, uint _refundTimestamp, uint _countdown) {\r\n        require(_participant != address(0), \"invalid participant address\");\r\n        require(swaps[_hashedSecret].state == State.Empty, \"swap for this hash is initiated\");\r\n        require(block.timestamp <= _refundTimestamp, \"invalid refundTimestamp\");\r\n        require(_countdown < _refundTimestamp, \"invalid countdown\");\r\n        _;\r\n    }\r\n    \r\n    modifier isInitiated(bytes32 _hashedSecret) {\r\n        require(swaps[_hashedSecret].state == State.Initiated, \"swap for this hash is empty or spent\");\r\n        _;\r\n    }\r\n\r\n    modifier isAddable(bytes32 _hashedSecret) {\r\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\r\n        _;\r\n    }\r\n        \r\n    modifier isActivated(bytes32 _hashedSecret) {\r\n        require(swaps[_hashedSecret].active, \"swap is not active\");\r\n        _;\r\n    }    \r\n    \r\n    modifier isNotActivated(bytes32 _hashedSecret) {\r\n        require(!swaps[_hashedSecret].active, \"swap is active\");\r\n        _;\r\n    }\r\n\r\n    modifier isRedeemable(bytes32 _hashedSecret, bytes32 _secret) {\r\n        require(block.timestamp <= swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has come\");\r\n        require(sha256(abi.encodePacked(sha256(abi.encodePacked(_secret)))) == _hashedSecret, \"secret is not correct\");\r\n        _;\r\n    }\r\n\r\n    modifier isRefundable(bytes32 _hashedSecret) {\r\n        require(block.timestamp > swaps[_hashedSecret].refundTimestamp, \"refundTimestamp has not come\");\r\n        _;\r\n    }\r\n\r\n    function initiate (bytes32 _hashedSecret, address _contract, address _participant, uint _refundTimestamp, uint _countdown, uint _value, uint _payoff, bool _active)\r\n        public nonReentrant isInitiatable(_hashedSecret, _participant, _refundTimestamp, _countdown)\r\n    {\r\n        IERC20(_contract).safeTransferFrom(msg.sender, address(this), _value);\r\n\r\n        swaps[_hashedSecret].value = _value.sub(_payoff);\r\n        swaps[_hashedSecret].hashedSecret = _hashedSecret;\r\n        swaps[_hashedSecret].contractAddr = _contract;\r\n        swaps[_hashedSecret].participant = _participant;\r\n        swaps[_hashedSecret].initiator = msg.sender;\r\n        swaps[_hashedSecret].refundTimestamp = _refundTimestamp;\r\n        swaps[_hashedSecret].countdown = _countdown;\r\n        swaps[_hashedSecret].payoff = _payoff;\r\n        swaps[_hashedSecret].active = _active;\r\n        swaps[_hashedSecret].state = State.Initiated;\r\n\r\n        emit Initiated(\r\n            _hashedSecret,\r\n            _contract,\r\n            _participant,\r\n            msg.sender,\r\n            _refundTimestamp,\r\n            _countdown,\r\n            _value.sub(_payoff),\r\n            _payoff,\r\n            _active\r\n        );\r\n    }\r\n    \r\n    function add (bytes32 _hashedSecret, uint _value)\r\n        public nonReentrant isInitiated(_hashedSecret) isAddable(_hashedSecret)    \r\n    {\r\n        IERC20(swaps[_hashedSecret].contractAddr).safeTransferFrom(msg.sender, address(this), _value);\r\n        \r\n        swaps[_hashedSecret].value = swaps[_hashedSecret].value.add(_value);\r\n\r\n        emit Added(\r\n            _hashedSecret,\r\n            msg.sender,\r\n            swaps[_hashedSecret].value\r\n        );\r\n    }\r\n    \r\n    function activate (bytes32 _hashedSecret)\r\n        public nonReentrant isInitiated(_hashedSecret) isNotActivated(_hashedSecret) onlyByInitiator(_hashedSecret)\r\n    {\r\n        swaps[_hashedSecret].active = true;\r\n\r\n        emit Activated(\r\n            _hashedSecret\r\n        );\r\n    }\r\n\r\n    function redeem(bytes32 _hashedSecret, bytes32 _secret) \r\n        public nonReentrant isInitiated(_hashedSecret) isActivated(_hashedSecret) isRedeemable(_hashedSecret, _secret) \r\n    {\r\n        swaps[_hashedSecret].secret = _secret;\r\n        swaps[_hashedSecret].state = State.Redeemed;\r\n\r\n        if (block.timestamp > swaps[_hashedSecret].refundTimestamp.sub(swaps[_hashedSecret].countdown)) {\r\n            \r\n            IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value);\r\n            \r\n            if(swaps[_hashedSecret].payoff > 0) {\r\n                IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(msg.sender, swaps[_hashedSecret].payoff);\r\n            }\r\n        }\r\n        else {\r\n            IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].participant, swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\r\n        }\r\n        \r\n        emit Redeemed(\r\n            _hashedSecret,\r\n            _secret\r\n        );\r\n        \r\n        delete swaps[_hashedSecret];\r\n    }\r\n\r\n    function refund(bytes32 _hashedSecret)\r\n        public nonReentrant isInitiated(_hashedSecret) isRefundable(_hashedSecret) \r\n    {\r\n        swaps[_hashedSecret].state = State.Refunded;\r\n\r\n        IERC20(swaps[_hashedSecret].contractAddr).safeTransfer(swaps[_hashedSecret].initiator, swaps[_hashedSecret].value.add(swaps[_hashedSecret].payoff));\r\n\r\n        emit Refunded(\r\n            _hashedSecret\r\n        );\r\n        \r\n        delete swaps[_hashedSecret];\r\n    }\r\n}",
    "id": "AtomicSwap_0xac5881d77db9340c94f53300736a9cf9e61fa25e",
    "file": "./Contract_source_Code/AtomicSwap_0xac5881d77db9340c94f53300736a9cf9e61fa25e.sol"
}